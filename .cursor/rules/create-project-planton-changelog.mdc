---
description: Action rule to create a well-structured changelog document capturing meaningful engineering work in Project Planton CLI, sized proportionally to the feature's impact and complexity.
globs: []
alwaysApply: false
---

# Rule: Create Project Planton Changelog (action)

Purpose: When invoked, create a comprehensive changelog document in the `_changelog/` directory that captures the essence, context, and impact of recent engineering work on the Project Planton CLI. The changelog should be meaningful, well-structured, and appropriately sized based on the scope and impact of the change.

Usage: Invoke explicitly as `@create-project-planton-changelog` after completing meaningful work in a conversation.

References: `@understand-cursor-rules`, existing changelogs in `_changelog/`

## ⚠️ CRITICAL: Explicit Invocation Only

**DO NOT** create a changelog automatically or proactively. Changelogs must ONLY be created when the user explicitly invokes this rule with `@create-project-planton-changelog`.

Never:
- ❌ Suggest creating a changelog without being asked
- ❌ Create a changelog at the end of a conversation automatically
- ❌ Assume the user wants a changelog created
- ❌ Create a changelog "to be helpful" without explicit request

Always:
- ✅ Wait for explicit `@create-project-planton-changelog` invocation
- ✅ Confirm the request before creating the file
- ✅ Let the user decide when/if a changelog is needed

**This is a user-controlled action, not an automatic process.**

## When to Create a Changelog

Create a changelog when:
- ✅ You've completed a meaningful feature, refactoring, or improvement
- ✅ The work involved multiple files or system components
- ✅ The change introduces new patterns or architectural decisions
- ✅ The work took significant time/effort (typically 1+ hours)
- ✅ The change has notable impact on CLI users, developers, or workflows
- ✅ You want to preserve the context and rationale for future reference
- ✅ New CLI commands, flags, or options were added
- ✅ Provider implementations were enhanced or added
- ✅ Pulumi integration or IAC execution was improved
- ✅ API changes affecting infrastructure resources

**Skip changelogs for**:
- ✋ Trivial bug fixes or typo corrections
- ✋ Minor configuration tweaks
- ✋ Work-in-progress or incomplete changes
- ✋ Changes already well-documented in PR descriptions

## Sizing Guidance: Use Your Judgment

**Critical principle**: The changelog length should be **proportional to the feature's complexity and impact**, not artificially constrained or inflated.

### Small Changes (150-300 lines)
- Single CLI command updates
- Focused bug fixes with clear before/after
- Minor flag additions
- Configuration improvements
- Single provider enhancements

**Example**: CLI error reporting enhancement - straightforward problem, clear solution, limited scope

### Medium Changes (300-600 lines)
- Multi-command refactorings
- New CLI patterns or frameworks
- Provider integration work
- Pulumi integration enhancements
- Changes across 2-3 packages

**Example**: Pulumi interactive output - TTY detection fix, new flags, improved UX

### Large Changes (600-1000+ lines)
- Major architectural shifts
- Framework migrations
- Comprehensive feature rollouts across many providers
- System-wide refactorings with broad impact
- New IAC execution patterns

**Example**: Generic resource operations (multiple providers), Complete CLI restructuring, Provider framework overhaul

**Golden rule**: If you're unsure, start shorter and add detail only where it adds real value. Quality over quantity.

## Changelog Structure

### File Naming
```
YYYY-MM-DD-HHMMSS-brief-descriptive-slug.md
```

Examples:
- `2025-10-18-153045-pulumi-interactive-output-with-diff-support.md`
- `2025-10-18-091230-proto-field-defaults-support.md`
- `2025-10-17-164500-temporal-namespace-initialization-bug-fix.md`

**IMPORTANT**: Get the actual current timestamp by running the command `date +"%Y-%m-%d-%H%M%S"` and use that exact output as the prefix for the filename. Do NOT make up or guess the timestamp. Follow with a clear, kebab-case slug describing the change. The timestamp (HHMMSS) ensures automatic chronological sorting when multiple changelogs are created on the same day.

### Required Metadata

Every changelog should start with metadata in this format:

```markdown
# [Clear, Descriptive Title]

**Date**: [Month Day, Year]
**Type**: [Enhancement | Bug Fix | Feature | Refactoring | Breaking Change]
**Components**: [Component1, Component2, Component3]

## Summary

[2-4 sentence overview of what was accomplished and why it matters]
```

**Common Components**:
- Pulumi CLI Integration
- CLI Flags
- Kubernetes Provider
- IAC Stack Runner
- Command Handlers
- Provider Framework
- API Definitions
- Manifest Processing
- Resource Management
- Build System
- Error Handling
- User Experience

### Required Sections

Every changelog should include:

```markdown
# [Clear, Descriptive Title]

**Date**: [Month Day, Year]
**Type**: [Type]
**Components**: [Components]

## Summary

[2-4 sentence overview of what was accomplished and why it matters]

## Problem Statement / Motivation

[Describe the problem or need that motivated this work]

### Pain Points

[Bullet list of specific issues being addressed]

## Solution / What's New

[High-level description of the approach taken]

### [Key Features/Components]

[Visual diagrams using Mermaid, component descriptions as needed]

## Implementation Details

[Technical specifics - code changes, new patterns, key decisions]
[Include Mermaid diagrams to visualize architecture, workflows, or data flows]

## Benefits

[Concrete improvements - metrics, time savings, developer experience]

## Impact

[Who/what is affected and how]

## Related Work

[Connect to other changelogs, features, or initiatives]

---

**Status**: ✅ [Production Ready | In Progress | Experimental]
**Timeline**: [Duration if relevant]
```

**Note**: Include Mermaid diagrams throughout the changelog wherever they make information easier to consume. See "Mermaid Diagrams" section below for guidance.

### Optional Sections (Include When Valuable)

Add these sections only when they provide meaningful value:

- **Breaking Changes**: When APIs, commands, or flags change incompatibly
- **Migration Guide**: When users need to adapt their workflows
- **Testing Strategy**: For complex features requiring verification
- **Performance Characteristics**: When performance is a key concern
- **Known Limitations**: For incomplete implementations
- **Future Enhancements**: For planned follow-up work
- **Usage Examples**: When it helps understanding (CLI commands, YAML manifests)
- **Code Metrics**: Statistics that tell a story (files changed, reduction %, etc.)
- **Design Decisions**: When trade-offs were significant
- **Architecture**: When system design changed
- **Backward Compatibility**: When compatibility considerations are important
- **Troubleshooting**: For complex features that may have issues

## Writing Guidelines

### Do:
- ✅ **Start with context**: Why did this work happen?
- ✅ **Focus on value**: What problem does this solve for CLI users?
- ✅ **Use concrete examples**: Show before/after CLI commands, YAML manifests, outputs
- ✅ **Include Mermaid diagrams**: Visualize workflows, architecture, and interactions for better readability
- ✅ **Include numbers**: Metrics, timelines, file counts (when meaningful)
- ✅ **Explain decisions**: Why this approach vs alternatives?
- ✅ **Write for future you**: Capture the thinking, not just the what
- ✅ **Link to related work**: Connect the dots with other changes
- ✅ **Use formatting**: Code blocks, tables, bullet lists for readability
- ✅ **Show actual output**: Terminal output, diffs, error messages

### Don't:
- ❌ **Over-explain the obvious**: Assume the reader is technical
- ❌ **Include every detail**: Focus on what matters
- ❌ **Write generic summaries**: Be specific to Project Planton
- ❌ **Skip the "why"**: Context is critical for future understanding
- ❌ **Ignore trade-offs**: Document decisions and their rationale
- ❌ **Use jargon without context**: Define terms that may be unclear

## Mermaid Diagrams: Make It Visual

**⚠️ CRITICAL**: Include Mermaid diagrams wherever appropriate. Diagrams dramatically improve readability and make changelogs far more consumable for future readers.

### When to Use Mermaid Diagrams

Use Mermaid diagrams to visualize:
- **Workflows and processes** - Show CLI flows, deployment steps, execution sequences
- **Before/after architecture** - Illustrate system changes side by side
- **Component relationships** - Show how modules, providers, or services interact
- **Sequence diagrams** - Demonstrate interactions between CLI, Pulumi, and cloud providers
- **State transitions** - Depict resource lifecycle or status changes
- **Data flows** - Trace how manifests, configurations, or data move through the system

### Common Diagram Types for Changelogs

#### Flowcharts - For CLI flows and processes
```mermaid
flowchart TB
    A[CLI Command] --> B{Parse Manifest}
    B -->|Valid| C[Execute Pulumi]
    B -->|Invalid| D[Error]
    C --> E[Deploy Resources]
    E --> F[Generate Outputs]
```

#### Sequence Diagrams - For component interactions
```mermaid
sequenceDiagram
    participant User
    participant CLI
    participant Pulumi
    participant Provider
    User->>CLI: Run command
    CLI->>Pulumi: Initialize stack
    Pulumi->>Provider: Deploy resources
    Provider-->>Pulumi: Success
    Pulumi-->>CLI: Stack outputs
    CLI-->>User: Display results
```

#### State Diagrams - For resource lifecycle
```mermaid
stateDiagram-v2
    [*] --> Pending
    Pending --> Provisioning
    Provisioning --> Running
    Running --> Updating
    Updating --> Running
    Running --> Deleting
    Deleting --> [*]
```

#### Git Graphs - For workflow changes
```mermaid
gitGraph
    commit id: "Before: Manual steps"
    branch feature
    checkout feature
    commit id: "Add automation"
    commit id: "Add validation"
    checkout main
    merge feature
    commit id: "After: Automated workflow"
```

### Examples of Effective Diagram Usage

**Before/After Comparisons:**
```markdown
## Previous Workflow

```mermaid
flowchart LR
    A[User] --> B[Manual Config]
    B --> C[Run Pulumi]
    C --> D[Fix Errors]
    D --> C
```

## New Workflow

```mermaid
flowchart LR
    A[User] --> B[CLI Validates]
    B --> C[Auto-run Pulumi]
    C --> D[Success]
```
```

**Architecture Changes:**
```markdown
## Architecture Evolution

### Before
```mermaid
graph TB
    CLI --> Pulumi
    Pulumi --> AWS
    Pulumi --> GCP
```

### After
```mermaid
graph TB
    CLI --> Framework[Provider Framework]
    Framework --> Pulumi
    Pulumi --> AWS
    Pulumi --> GCP
    Pulumi --> Azure
```
```

### Best Practices for Mermaid in Changelogs

- ✅ **Include diagrams early** - In "Solution" or "Implementation" sections
- ✅ **Use before/after pairs** - Show the impact of changes visually
- ✅ **Keep diagrams focused** - One concept per diagram
- ✅ **Add brief text context** - Explain what the diagram shows
- ✅ **Use consistent styling** - Similar colors/shapes for similar elements
- ✅ **Label clearly** - Descriptive node names, not abbreviations
- ✅ **Show decision points** - Highlight conditional logic and branching

### When Diagrams Add Maximum Value

**High-value scenarios:**
- Architectural refactorings showing old vs new structure
- CLI workflow improvements with decision trees
- Provider integration patterns and interactions
- Multi-step deployment processes
- Error handling and retry logic flows
- Resource lifecycle and state transitions

**Lower-value scenarios (use sparingly):**
- Simple linear flows without decisions
- Trivial bug fixes with no workflow impact
- Single-file changes with no system interaction

### Size and Complexity

Match diagram complexity to change scope:

- **Small changes**: 1 simple flowchart or sequence diagram
- **Medium changes**: 2-3 diagrams showing key interactions or before/after
- **Large changes**: Multiple diagrams covering architecture, workflows, and data flows

**Remember**: A well-placed Mermaid diagram can replace paragraphs of explanation and make your changelog memorable and scannable.

## Tone and Style

- **Informative, not promotional**: Focus on facts and impact
- **Technical but accessible**: Balance depth with clarity
- **Professional but human**: You can say "we struggled with X" or "this was tricky"
- **Present tense for descriptions**: "The CLI now does X"
- **Past tense for actions**: "We implemented Y"

## Quality Checklist

Before finalizing a changelog:

- [ ] Title clearly describes the change
- [ ] Metadata includes Date, Type, and Components
- [ ] Summary captures essence in 2-4 sentences
- [ ] Problem statement explains why work was needed
- [ ] Solution section describes the approach
- [ ] Implementation details are technical but focused
- [ ] Benefits are concrete and measurable
- [ ] Code examples (if any) are actual code, not pseudocode
- [ ] CLI commands and outputs are copy-pasteable
- [ ] **Mermaid diagrams included where they add clarity** (workflows, architecture, interactions)
- [ ] Related work connects this to other changes
- [ ] Length is proportional to scope and impact
- [ ] No sensitive information (credentials, private URLs, etc.)
- [ ] File paths reference actual project-planton structure

## Proportionality Examples

### ✅ Good: Appropriately Sized

**Small feature** (200 lines): 
- Problem: 1 paragraph
- Solution: 1-2 paragraphs + key code snippet or CLI example
- Benefits: 3-5 bullets
- Impact: 1 paragraph

**Medium feature** (500 lines):
- Problem: 2-3 paragraphs with pain points
- Solution: Component descriptions with examples
- Implementation: 3-4 key changes with code snippets
- Benefits: Categorized list with metrics
- Impact: User experience + developer improvements

**Large feature** (900 lines):
- Problem: Comprehensive context with examples
- Solution: Full architecture with diagrams and phases
- Implementation: Detailed technical sections per component
- Benefits: Quantitative and qualitative analysis
- Testing: Strategy and verification steps
- Impact: Multi-dimensional (users, developers, operations)

### ❌ Anti-patterns

- **Over-detailed small change**: 800-line changelog for a 50-line fix
- **Under-documented major change**: 150-line changelog for major refactor
- **Kitchen sink**: Including every file touched, every line changed
- **Too abstract**: Generic descriptions without concrete CLI examples

## Project Planton Specific Guidelines

### File Path Examples

When referencing code, use actual project-planton paths:

```markdown
**File**: `cmd/project-planton/root/pulumi/preview.go`
**File**: `pkg/iac/pulumi/pulumistack/run.go`
**File**: `internal/cli/flag/flag.go`
**File**: `pkg/kubernetes/workload/postgres/provider.go`
**File**: `apis/project/planton/provider/kubernetes/workload/postgreskubernetes/v1/api.proto`
```

### CLI Command Examples

Always show actual commands users can run:

```bash
# Preview infrastructure
project-planton pulumi preview --manifest postgres.yaml --module-dir ${MODULE}

# Apply with auto-approval
project-planton pulumi up --manifest postgres.yaml --yes

# Generate stack outputs
project-planton stack-outputs --manifest postgres.yaml
```

### Component Categories

Use these component categories consistently:

**CLI Layer**:
- CLI Commands, CLI Flags, Command Handlers, User Experience

**IAC Execution**:
- Pulumi CLI Integration, IAC Stack Runner, Stack Management

**Providers**:
- Kubernetes Provider, AWS Provider, GCP Provider, Azure Provider

**Core Libraries**:
- Provider Framework, Manifest Processing, Resource Management

**API Layer**:
- API Definitions, Protobuf Schemas, Code Generation

**Build & Tools**:
- Build System, Bazel Integration, Testing Framework

**Infrastructure**:
- Error Handling, Logging, Configuration Management

## Automation Notes

When creating the changelog:
1. **Get current timestamp**: Run `date +"%Y-%m-%d-%H%M%S"` to get the actual current date and time for the filename
2. **Analyze the conversation**: Extract key decisions, changes, outcomes
3. **Assess scope**: Count files, commands, providers affected
4. **Determine components**: Map changes to component categories
5. **Choose type**: Enhancement, Bug Fix, Feature, Refactoring, Breaking Change
6. **Size appropriately**: Match detail level to impact
7. **Write the file**: Create in `_changelog/YYYY-MM/` (year-month directory) with proper naming using the timestamp from step 1
8. **Confirm creation**: Provide file path and next steps

## Example Invocations

```
"We just completed the Pulumi interactive output enhancement. @create-project-planton-changelog"

"I've finished implementing the generic find operation across multiple providers. 
@create-project-planton-changelog - this was a major change"

"The CLI flag system refactoring is done. @create-project-planton-changelog - 
include the backward compatibility notes"
```

## Remember

**Changelogs are living documentation** that helps future developers (including you) understand:
- What changed in the CLI
- Why it changed
- How it was implemented
- What the impact was on users

Write for the person who will debug this at 2am in six months. Give them the context they need - no more, no less.

**When in doubt**: Start with the required sections, keep it focused, and add detail only where it truly helps understanding. A clear, concise 300-line changelog is better than a rambling 1000-line document.

---

*"Documentation is a love letter to your future self."* - Damian Conway
