---
alwaysApply: false
---

# Fix: Targeted Improvements with Cascading Updates

## Purpose

This rule makes targeted fixes to deployment components and automatically propagates changes to all related artifacts (examples, documentation, tests, IaC modules) to ensure complete consistency. **Source code is the ultimate source of truth** - all documentation must accurately reflect the actual implementation.

## Role

You are the Project Planton Code Partner. This rule orchestrates targeted fixes with intelligent propagation to maintain consistency across proto definitions, IaC modules, documentation, examples, and tests.

## Philosophy: Source Code is Truth

**Core Principle:** Documentation describes code, code doesn't describe documentation.

**Consistency Chain:**
```
Source Code (Proto, IaC Modules)
        ‚Üì (describes)
    Documentation
        ‚Üì (demonstrates)
      Examples
        ‚Üì (validates)
       Tests
```

When fixing a component:
1. Make the fix in source code first (proto, Pulumi, Terraform)
2. Update documentation to match the new source code
3. Update examples to demonstrate the new behavior
4. Update tests to validate the new logic
5. Verify everything is consistent

**Never:** Write docs first and make code match - that's backwards!

## When to Use Fix

Use fix when you need to:
- ‚úÖ **Fix a specific bug** in proto schema, IaC modules, or validation logic
- ‚úÖ **Correct incorrect behavior** and update all related documentation
- ‚úÖ **Add a missing field** to proto and propagate to Terraform, examples, docs
- ‚úÖ **Fix failing tests** and ensure validation rules are correct
- ‚úÖ **Update examples** that no longer match current API
- ‚úÖ **Synchronize artifacts** when they've drifted out of sync

**Don't use fix when:**
- ‚ùå Component doesn't exist (use **forge**)
- ‚ùå Want to fill missing files (use **complete** or **update --fill-gaps**)
- ‚ùå Want general improvements (use **update** with specific scenario)
- ‚ùå Just checking status (use **audit**)
- ‚ùå Want to remove component (use **delete**)

## Usage

```
@fix-project-planton-component <ComponentName> --explain "<detailed description of fix needed>"
```

### Examples

**Fix validation logic:**
```bash
@fix-project-planton-component GcpCertManagerCert --explain "primaryDomainName validation is too strict, should allow wildcards like *.example.com"
```

**Fix IaC implementation:**
```bash
@fix-project-planton-component AwsRdsInstance --explain "Pulumi module doesn't set backup_retention_period correctly, should use spec value instead of hardcoded 7 days"
```

**Fix documentation sync:**
```bash
@fix-project-planton-component PostgresKubernetes --explain "examples.md shows old field 'database_name' but current spec uses 'db_identifier', update all examples to match"
```

**Fix missing field:**
```bash
@fix-project-planton-component MongodbAtlas --explain "spec.proto is missing 'region' field which is essential for multi-region deployments"
```

**Fix test failures:**
```bash
@fix-project-planton-component GcpCloudSql --explain "spec_test.go is failing because validation test expects error for empty project_id but validation rule is missing"
```

## Workflow

### Step 1: Understand the Fix

1. **Parse the explanation** - Understand what needs fixing
2. **Locate component** - Find in cloud_resource_kind.proto and file system
3. **Read source code** - Understand current implementation:
   - Read spec.proto to see current schema
   - Read Pulumi module to see current deployment logic
   - Read Terraform module to see current TF implementation
   - Read spec_test.go to see current test logic
4. **Read documentation context** - Consult v1/docs/README.md for design philosophy
5. **Identify affected artifacts** - Determine what needs updating:
   - Proto files?
   - IaC modules?
   - Documentation?
   - Examples?
   - Tests?

### Step 2: Make the Fix in Source Code

**Priority Order (Source Code First):**

1. **Fix Proto Schema** (if proto change needed)
   - Update spec.proto with the fix
   - Add/modify buf.validate rules
   - Regenerate stubs: `make protos`

2. **Fix IaC Modules** (if deployment logic change needed)
   - Update Pulumi module (main.go, locals.go, resource files)
   - Update Terraform module to maintain feature parity
   - Ensure both implement the same behavior

3. **Fix Tests** (if test logic change needed)
   - Update spec_test.go to validate new behavior
   - Add tests for the fix
   - Run component tests: `go test ./apis/.../v1/`

**Validation After Source Code Fix:**
```bash
# Verify proto compiles
make protos

# Verify Go code compiles  
make build

# Verify tests pass
go test ./apis/org/project_planton/provider/<provider>/<component>/v1/
make test
```

### Step 3: Propagate to Documentation (Match Source)

**Critical:** Documentation must accurately reflect the fixed source code.

**Update in Priority Order:**

1. **Update examples.md** (must match current API)
   - Review all examples
   - Update field names if proto changed
   - Update values if validations changed
   - Add new examples if new fields added
   - **Validate** each example against current schema:
     ```bash
     project-planton validate --manifest example.yaml
     ```

2. **Update README.md** (user-facing)
   - Update example usage if API changed
   - Update field descriptions if schema changed
   - Update "Key Features" if capabilities changed
   - Ensure example code matches examples.md

3. **Update docs/README.md** (research document)
   - Update if fix changes deployment approach
   - Update if fix changes best practices
   - Update if fix affects 80/20 scoping decisions
   - Generally more stable (only update if architectural change)

4. **Update IaC READMEs** (Pulumi/Terraform)
   - Update if module behavior changed
   - Update if new configuration options added
   - Update if usage patterns changed

5. **Update iac/pulumi/overview.md** (if architecture changed)
   - Update resource relationships if changed
   - Update data flow if changed
   - Update design decisions if changed

### Step 4: Validate Consistency

**Consistency Checks:**

1. **Proto ‚Üî Terraform Variables**
   - Every field in spec.proto has matching variable in variables.tf
   - Variable types match proto field types
   - Required fields match in both
   - Defaults match in both

2. **Proto ‚Üî Examples**
   - Examples only use fields that exist in spec.proto
   - Examples use current field names (not deprecated)
   - Examples meet all validation rules
   - Examples actually work (can be validated)

3. **Pulumi ‚Üî Terraform**
   - Both modules create same resources
   - Both use same fields from spec
   - Both produce same outputs (stack_outputs)
   - Feature parity maintained

4. **Tests ‚Üî Validations**
   - Every validation rule in spec.proto has test in spec_test.go
   - Tests validate both positive and negative cases
   - Tests use realistic values from examples

5. **Docs ‚Üî Implementation**
   - README describes actual behavior
   - Examples demonstrate actual API
   - Research docs explain actual approach
   - No outdated information

### Step 5: Run Comprehensive Validation

**Execute in order:**

```bash
# 1. Component-specific tests (validates buf.validate rules)
go test ./apis/org/project_planton/provider/<provider>/<component>/v1/
# Must pass - validates validation logic is correct

# 2. Build validation (validates Go compiles)
make build
# Must pass - validates no syntax/import errors

# 3. Full test suite (validates all tests)
make test
# Must pass - validates no regressions anywhere
```

**If any validation fails:**
- Fix the issue
- Retry up to 3 times
- If still failing after 3 attempts, report error with fix suggestions

### Step 6: Generate Fix Report

**Show what was fixed and propagated:**

```
‚úÖ Fix Complete: GcpCertManagerCert

Fix Applied:
  "primaryDomainName validation now allows wildcards"

Changes Made:

Source Code:
  ‚úÖ spec.proto
     - Updated pattern validation: ^(\*\.)?[a-z0-9-]+\.[a-z]{2,}$
     - Now accepts *.example.com format
     
  ‚úÖ spec_test.go
     - Added test: wildcard domain validation
     - Added test: non-wildcard validation still works
     
  ‚úÖ iac/pulumi/module/cert_manager_cert.go
     - No changes needed (uses spec field directly)
     
  ‚úÖ iac/tf/main.tf
     - No changes needed (uses variable directly)

Documentation Updates:
  ‚úÖ v1/examples.md
     - Added example: Wildcard certificate (*.example.com)
     - Updated existing examples to show both formats
     
  ‚úÖ v1/README.md
     - Updated "Multi-Domain Support" section
     - Added wildcard support to key features
     - Updated example usage to show wildcard
     
  ‚úÖ v1/docs/README.md
     - Updated comparison table (wildcard support)
     - Updated best practices section
     - No architectural changes (just capability)

Consistency Verified:
  ‚úÖ Proto ‚Üî Terraform variables (variables.tf matches spec.proto)
  ‚úÖ Proto ‚Üî Examples (all examples validate against schema)
  ‚úÖ Pulumi ‚Üî Terraform (feature parity maintained)
  ‚úÖ Tests ‚Üî Validations (all validation rules tested)
  ‚úÖ Docs ‚Üî Implementation (docs describe actual behavior)

Validation Results:
  ‚úÖ Component tests passed (go test ./apis/.../v1/)
  ‚úÖ Build passed (make build)
  ‚úÖ Full test suite passed (make test)

Files Modified: 5
Documentation Updated: 3
Tests Added: 2
Duration: 8 minutes

Next Steps:
  1. Review changes (git diff)
  2. Test with real manifest
  3. Commit:
     git add -A
     git commit -m "fix(gcp-cert): allow wildcard domains in primaryDomainName validation"
```

## Fix Scenarios

### Scenario 1: Proto Schema Fix

**Trigger:** Validation rule is wrong, field is missing, type is incorrect

**Example:**
```bash
@fix-project-planton-component GcpCloudSql --explain "spec.proto has 'disk_size' as int32 but should be int64 to support >2TB disks"
```

**Actions:**
1. Update spec.proto (int32 ‚Üí int64)
2. Regenerate stubs (make protos)
3. Update spec_test.go (test with large values)
4. Update Terraform variables.tf (int ‚Üí number)
5. Update examples.md (show large disk example)
6. Update README.md (mention TB-scale support)
7. Validate consistency and run tests

### Scenario 2: IaC Implementation Fix

**Trigger:** Deployment logic is incorrect, resources not created properly

**Example:**
```bash
@fix-project-planton-component AwsRdsInstance --explain "Pulumi module creates instance without backup_retention_period from spec, always uses default 7 days instead"
```

**Actions:**
1. Update Pulumi module/main.go (use spec.BackupRetentionPeriod)
2. Update Terraform main.tf (ensure same logic)
3. Update spec_test.go (test backup retention values)
4. Update examples.md (show backup retention usage)
5. Update iac/pulumi/overview.md (document backup behavior)
6. Run E2E tests to verify fix works
7. Validate consistency and run tests

### Scenario 3: Documentation Out of Sync

**Trigger:** Examples, README, or docs don't match actual code

**Example:**
```bash
@fix-project-planton-component PostgresKubernetes --explain "examples.md uses deprecated field 'database_name' but spec.proto now uses 'db_identifier'"
```

**Actions:**
1. **Don't change code** (code is correct, docs are wrong)
2. Read current spec.proto to understand actual fields
3. Update examples.md (use db_identifier everywhere)
4. Update README.md (fix any references to old field)
5. Update docs/README.md (note the field name if discussed)
6. Validate examples against schema
7. No test changes needed (code unchanged)

**Key:** Documentation updated to match reality, not the other way around.

### Scenario 4: Test Logic Fix

**Trigger:** Tests are failing or not testing correctly

**Example:**
```bash
@fix-project-planton-component MongodbAtlas --explain "spec_test.go validation test expects error when cluster_tier is empty but validation rule doesn't exist in spec.proto"
```

**Actions:**
1. Read spec.proto to see if validation rule exists
2. **Decision point:**
   - If validation SHOULD exist: Add to spec.proto, fix test
   - If validation SHOULDN'T exist: Fix test to not expect error
3. Regenerate stubs if proto changed
4. Run component tests to verify
5. Update examples if validation behavior changed
6. Update README if validation rules mentioned

### Scenario 5: Feature Parity Fix

**Trigger:** Pulumi and Terraform modules behave differently

**Example:**
```bash
@fix-project-planton-component GcpGkeCluster --explain "Terraform module doesn't create node pool autoscaling like Pulumi does"
```

**Actions:**
1. Read Pulumi module to understand correct behavior
2. Update Terraform module to match
3. Update tests to verify both work the same
4. Update examples to show autoscaling
5. Update Terraform README to document autoscaling
6. Run both E2E tests to verify parity
7. Validate consistency

### Scenario 6: Validation Rule Fix

**Trigger:** buf.validate rule is incorrect

**Example:**
```bash
@fix-project-planton-component AwsVpc --explain "CIDR block validation rejects 10.0.0.0/8 (valid private range) due to overly strict regex"
```

**Actions:**
1. Update spec.proto (fix regex pattern)
2. Regenerate stubs (make protos)
3. Update spec_test.go (test 10.0.0.0/8 is now valid)
4. Update examples.md (show 10.0.0.0/8 example)
5. Update docs/README.md (document valid CIDR ranges)
6. Run component tests to verify
7. Validate consistency

## Consistency Enforcement

Fix automatically checks and enforces consistency:

### Check 1: Proto ‚Üî Terraform Variables

**After any proto change:**
```bash
# Compare spec.proto fields with variables.tf
# Ensure every field has matching variable
# Ensure types match (string ‚Üí string, int32 ‚Üí number, etc.)
# Ensure required fields match
```

**If mismatch found:**
```
‚ö†Ô∏è  Inconsistency: Proto ‚Üî Terraform

spec.proto has:
  int64 disk_size_gb = 5 [(buf.validate.field).int64.gte = 10];

variables.tf has:
  variable "disk_size_gb" {
    type = number  # ‚úì Correct
    # Missing: validation (should have >= 10)
  }

Action: Updating variables.tf to match proto validation...
```

### Check 2: Proto ‚Üî Examples

**After any proto change:**
```bash
# Parse all examples in examples.md
# Validate each against current spec.proto schema
# Check field names are current (not deprecated)
# Check values meet validation rules
```

**If mismatch found:**
```
‚ö†Ô∏è  Inconsistency: Examples ‚Üî Proto

examples.md line 42:
  database_name: mydb  # ‚ùå Field doesn't exist in spec.proto
  
Current spec.proto uses:
  db_identifier: mydb  # ‚úì Correct field name

Action: Updating examples.md to use current field names...
```

### Check 3: Pulumi ‚Üî Terraform

**After any IaC change:**
```bash
# Compare resources created by both modules
# Compare field usage (do both use same spec fields?)
# Compare outputs (do both return same outputs?)
```

**If mismatch found:**
```
‚ö†Ô∏è  Feature Parity Issue: Pulumi ‚Üî Terraform

Pulumi creates:
  - Cluster (‚úì)
  - Node Pool with autoscaling (‚úì)
  - Monitoring dashboard (‚úì)

Terraform creates:
  - Cluster (‚úì)
  - Node Pool (‚úì)
  - Monitoring dashboard (‚ùå Missing)

Action: Adding monitoring dashboard to Terraform module...
```

### Check 4: Validations ‚Üî Tests

**After any validation change:**
```bash
# For each validation rule in spec.proto
# Verify spec_test.go has test for that rule
# Verify test validates both positive and negative cases
```

**If mismatch found:**
```
‚ö†Ô∏è  Missing Test: Validation not tested

spec.proto line 15:
  string region = 3 [(buf.validate.field).string = {
    in: ["us-east-1", "us-west-2", "eu-west-1"]
  }];

spec_test.go:
  # No test found for region validation

Action: Adding test for region validation rule...
```

### Check 5: Documentation ‚Üî Implementation

**After any code change:**
```bash
# Check README describes actual behavior
# Check examples demonstrate actual capabilities
# Check docs/README.md explains actual approach
```

**If mismatch found:**
```
‚ö†Ô∏è  Documentation Outdated

README.md states:
  "Supports PostgreSQL 11, 12, and 13"

spec.proto actually supports:
  enum Version {
    V11 = 1;
    V12 = 2;
    V13 = 3;
    V14 = 4;  # ‚Üê Missing from docs
    V15 = 5;  # ‚Üê Missing from docs
  }

Action: Updating README to reflect current supported versions...
```

## Execution Steps

### Step 1: Analyze Fix Request

```
üìã Analyzing fix request...

Component: GcpCertManagerCert
Fix: "primaryDomainName validation should allow wildcards"

Understanding current state:
  ‚úì Reading spec.proto (current validation pattern)
  ‚úì Reading Pulumi module (how field is used)
  ‚úì Reading Terraform module (how field is used)
  ‚úì Reading spec_test.go (current test coverage)
  ‚úì Reading examples.md (current examples)
  ‚úì Reading v1/docs/README.md (design context)

Current behavior:
  - Pattern: ^[a-z0-9-]+\.[a-z]{2,}$ (no wildcards)
  - Rejects: *.example.com
  - Tests: Only test non-wildcard domains

Fix needed:
  1. Update validation pattern in spec.proto
  2. Add tests for wildcard validation
  3. Add wildcard examples
  4. Update docs to mention wildcard support
```

### Step 2: Apply Fix to Source Code

```
üîß Applying fix to source code...

[1/5] ‚úÖ Updated spec.proto
  - Modified validation pattern: ^(\*\.)?[a-z0-9-]+\.[a-z]{2,}$
  - Now accepts both example.com and *.example.com
  
[2/5] ‚úÖ Regenerated proto stubs
  - Command: make protos
  - Status: Success
  
[3/5] ‚úÖ Updated spec_test.go
  - Added: TestWildcardDomainValidation (positive)
  - Added: TestWildcardDomainFormat (edge cases)
  - Updated: TestDomainValidation (ensure non-wildcard still works)
  
[4/5] ‚úÖ Verified Pulumi module
  - No changes needed (uses spec field directly)
  
[5/5] ‚úÖ Verified Terraform module
  - No changes needed (uses variable directly)
  - variables.tf already compatible

Source code fix complete!
```

### Step 3: Propagate to Documentation

```
üìù Propagating to documentation...

[1/4] ‚úÖ Updated v1/examples.md
  - Added: Wildcard Domain Example (*.example.com)
  - Added: Multi-Domain Wildcard Example
  - Verified all examples against schema: ‚úì Valid
  
[2/4] ‚úÖ Updated v1/README.md
  - Added wildcard support to "Multi-Domain Support" section
  - Updated example usage to show wildcard
  - Added to "Key Features" list
  
[3/4] ‚úÖ Updated v1/docs/README.md
  - Updated comparison table (wildcard column)
  - Updated "The Project Planton Choice" section
  - Added wildcard to best practices
  
[4/4] ‚úÖ Updated iac/pulumi/README.md
  - Added wildcard example to usage section

Documentation sync complete!
```

### Step 4: Validate Consistency

```
üîç Validating consistency...

Consistency Checks:
  ‚úÖ Proto ‚Üî Terraform variables
     spec.proto fields match variables.tf (17/17 fields)
     
  ‚úÖ Proto ‚Üî Examples
     All 7 examples validate against schema
     No deprecated field names found
     
  ‚úÖ Pulumi ‚Üî Terraform
     Both create same resources (Certificate, DNS Auth, DNS Record)
     Feature parity maintained
     
  ‚úÖ Validations ‚Üî Tests
     All 12 validation rules have tests
     Coverage: 100%
     
  ‚úÖ Documentation ‚Üî Implementation
     README describes actual behavior ‚úì
     Examples demonstrate actual API ‚úì
     No outdated information found ‚úì

All consistency checks passed!
```

### Step 5: Execute Validation

```
üß™ Running validation...

Component Tests:
  Command: go test ./apis/org/project_planton/provider/gcp/gcpcertmanagercert/v1/
  Result: ‚úÖ PASS
  Tests run: 18
  Tests passed: 18
  Duration: 1.2s

Build Validation:
  Command: make build
  Result: ‚úÖ Success
  Duration: 2m 15s

Full Test Suite:
  Command: make test
  Result: ‚úÖ All tests passed
  Tests run: 156
  Tests passed: 156
  Duration: 3m 45s

All validation passed!
```

### Step 6: Generate Summary

```
‚úÖ Fix Complete: GcpCertManagerCert

Fix Applied:
  "Allow wildcard domains in primaryDomainName validation"

Impact Analysis:

Source Code Changes:
  üìù spec.proto (1 line changed)
     - Validation pattern updated
  üìù spec_test.go (2 tests added, 15 lines)
     - Wildcard validation tests
  ‚ÑπÔ∏è  IaC modules (no changes needed)

Documentation Updates:
  üìù examples.md (+45 lines)
     - Added 2 wildcard examples
  üìù README.md (+12 lines)
     - Updated feature list
  üìù docs/README.md (+25 lines)
     - Updated comparison and best practices

Validation:
  ‚úÖ Component tests: 18/18 passed
  ‚úÖ Build: Success
  ‚úÖ Full test suite: 156/156 passed

Files Modified: 5
Lines Changed: +97, -1
Duration: 8 minutes

Ready to commit!

Git command:
  git add -A
  git commit -m "fix(gcp-cert): allow wildcard domains in primaryDomainName validation"
```

## Source Code Truth Principles

### Principle 1: Code Defines Behavior

**Right:** 
1. Fix the code (spec.proto, IaC module)
2. Update docs to describe the new code

**Wrong:**
1. Update docs to describe desired behavior
2. Make code match docs

**Why:** Code is executable truth, docs are descriptive.

### Principle 2: Examples Must Validate

**Right:**
1. Update spec.proto with new validation
2. Update examples.md to meet new validation
3. Validate examples: `project-planton validate --manifest example.yaml`

**Wrong:**
1. Update examples.md with desired usage
2. Hope spec.proto eventually matches

**Why:** Examples that don't validate are worse than no examples.

### Principle 3: Tests Validate Reality

**Right:**
1. Update validation rule in spec.proto
2. Update spec_test.go to test the new rule
3. Run tests to verify rule works: `go test ./apis/.../v1/`

**Wrong:**
1. Update test to expect desired behavior
2. Hope proto eventually matches

**Why:** Tests that don't match code are misleading.

### Principle 4: Feature Parity is Non-Negotiable

**Right:**
1. Fix Pulumi module implementation
2. Update Terraform module to match
3. Verify both create same resources

**Wrong:**
1. Fix Pulumi only
2. Leave Terraform different

**Why:** Users expect same behavior regardless of IaC choice.

### Principle 5: Documentation Trails Code

**Right:**
1. Code changes first (proto, IaC)
2. Documentation updated to describe new code
3. Examples demonstrate new capabilities

**Wrong:**
1. Documentation written based on plans
2. Code eventually updated to match
3. Misalignment until code catches up

**Why:** Documentation leads to broken promises.

## Error Handling

### Fix Causes Build Failure

```
‚ùå Build failed after applying fix

Error: undefined: spec.NewFieldAdded
File: iac/pulumi/module/main.go:45

Root Cause:
  - spec.proto was updated with new field
  - Proto stubs not regenerated
  - Pulumi code references field before regeneration

Auto-Fix:
  1. Run: make protos (regenerate stubs)
  2. Retry build
  
‚úÖ Build now passes
```

### Fix Causes Test Failure

```
‚ùå Component tests failed after fix

Failed: TestDomainValidation
Error: Expected validation error for "invalid.domain" but got none

Root Cause:
  - Validation pattern was relaxed
  - Test expects strict validation
  - Test needs updating for new behavior

Auto-Fix:
  1. Analyze new validation pattern
  2. Update test to expect new behavior
  3. Retry tests
  
‚úÖ Tests now pass (18/18)
```

### Examples Don't Validate

```
‚ùå Examples validation failed

Example line 42: Validation error
  Field 'disk_size_gb' must be >= 10 (got: 5)

Root Cause:
  - spec.proto validation was tightened (min: 10)
  - Example uses old minimum (5)
  
Auto-Fix:
  1. Update example value: 5 ‚Üí 20
  2. Validate: ‚úì
  
‚úÖ All examples now validate
```

### Documentation Out of Sync

```
‚ö†Ô∏è  Documentation inconsistency detected

README.md states:
  "Supports CPU values from 100m to 1000m"

spec.proto actually allows:
  [(buf.validate.field).string.pattern = "^[0-9]+m$"]
  # No upper limit!

Action: Updating README to match actual validation...

‚úÖ README now accurate
```

## Best Practices

### Before Fix

1. ‚úÖ **Understand the issue** - Read current code thoroughly
2. ‚úÖ **Consult research docs** - Read v1/docs/README.md for context
3. ‚úÖ **Check related components** - See how similar components handle it
4. ‚úÖ **Plan the fix** - Know what needs changing
5. ‚úÖ **Commit current state** - Clean git state before fix

### During Fix

1. ‚úÖ **Fix code first** - Source code is truth
2. ‚úÖ **Validate incrementally** - Test after each change
3. ‚úÖ **Maintain parity** - Keep Pulumi and Terraform aligned
4. ‚úÖ **Watch for cascading** - One fix might require multiple updates
5. ‚úÖ **Trust automation** - Let fix handle propagation

### After Fix

1. ‚úÖ **Review all changes** - Check git diff
2. ‚úÖ **Test manually** - Deploy with hack manifest
3. ‚úÖ **Run audit** - Verify score didn't decrease
4. ‚úÖ **Commit meaningfully** - Good commit message
5. ‚úÖ **Update changelog** - Document significant fixes

## Safety Features

### Automatic Backup

Fix creates automatic backup before changes:
```
üíæ Backup created: <component>-fix-backup-2025-11-13-094800/
```

### Validation Before Completion

Won't complete if:
- ‚ùå Component tests fail
- ‚ùå Build fails
- ‚ùå Full test suite fails
- ‚ùå Examples don't validate
- ‚ùå Inconsistencies detected

### Rollback on Failure

If fix fails partway:
```bash
# Restore from backup
cp -r <component>-fix-backup-2025-11-13-094800/* .

# Or use git
git restore .
```

## Examples

### Example 1: Fix Proto Validation

```bash
@fix-project-planton-component GcpCertManagerCert --explain "primaryDomainName should allow wildcards *.example.com"

# Fix executes:
# 1. Update spec.proto pattern
# 2. Regenerate stubs
# 3. Add tests for wildcards
# 4. Add wildcard examples
# 5. Update README/docs
# 6. Validate everything

# Result:
# - Proto: Validation updated ‚úì
# - Tests: Pass with wildcard tests ‚úì
# - Examples: Show wildcard usage ‚úì
# - Docs: Mention wildcard support ‚úì
# - Consistency: 100% ‚úì
```

### Example 2: Fix IaC Implementation

```bash
@fix-project-planton-component AwsRdsInstance --explain "backup_retention_period is hardcoded to 7, should use spec value"

# Fix executes:
# 1. Update Pulumi: use spec.BackupRetentionPeriod
# 2. Update Terraform: use var.backup_retention_period
# 3. Update tests: test different retention values
# 4. Update examples: show various retention periods
# 5. Update overview: document backup behavior
# 6. Run E2E tests

# Result:
# - Pulumi: Uses spec field ‚úì
# - Terraform: Feature parity ‚úì
# - Tests: Validate behavior ‚úì
# - Examples: Show usage ‚úì
# - Consistency: 100% ‚úì
```

### Example 3: Fix Documentation Drift

```bash
@fix-project-planton-component PostgresKubernetes --explain "examples use 'database_name' field but spec uses 'db_identifier'"

# Fix executes:
# 1. Read spec.proto (confirm db_identifier is correct)
# 2. Update ALL examples (database_name ‚Üí db_identifier)
# 3. Update README (fix any mentions)
# 4. Validate examples against schema
# 5. No code changes needed (code is correct)

# Result:
# - Code: Unchanged (already correct) ‚úì
# - Examples: Match current schema ‚úì
# - Docs: Accurate ‚úì
# - Validation: All examples pass ‚úì
```

### Example 4: Fix Test Failures

```bash
@fix-project-planton-component MongodbAtlas --explain "spec_test.go expects validation error for empty cluster_tier but validation rule is missing"

# Fix executes:
# 1. Read spec.proto (check if validation exists)
# 2. Decision: Add validation rule (cluster_tier required)
# 3. Update spec.proto (add required validation)
# 4. Regenerate stubs
# 5. Update examples (ensure cluster_tier present)
# 6. Run tests (should pass now)

# Result:
# - Proto: Validation added ‚úì
# - Tests: Pass (validation works) ‚úì
# - Examples: Include required field ‚úì
# - Consistency: 100% ‚úì
```

### Example 5: Fix Feature Parity

```bash
@fix-project-planton-component GcpGkeCluster --explain "Terraform doesn't create autoscaling config like Pulumi does"

# Fix executes:
# 1. Read Pulumi module (understand autoscaling logic)
# 2. Update Terraform main.tf (add autoscaling block)
# 3. Ensure both use same spec fields
# 4. Update tests (verify autoscaling works)
# 5. Update examples (show autoscaling config)
# 6. Run both E2E tests

# Result:
# - Pulumi: Autoscaling ‚úì
# - Terraform: Autoscaling ‚úì (NOW)
# - Feature parity: Restored ‚úì
# - Tests: Validate both ‚úì
```

## Integration with Other Rules

### After Audit

```bash
# Audit reveals specific issue
@audit-project-planton-component MyComponent
# Report: "examples.md uses deprecated fields"

# Fix the issue
@fix-project-planton-component MyComponent --explain "update examples.md to use current field names from spec.proto"
```

### Before Complete

```bash
# Fix specific issue first
@fix-project-planton-component MyComponent --explain "critical bug in validation logic"

# Then complete any remaining gaps
@complete-project-planton-component MyComponent
```

### During Update

```bash
# Update identified an inconsistency
@update-project-planton-component MyComponent --scenario proto-changed
# Warning: "Examples don't match new proto"

# Fix the inconsistency
@fix-project-planton-component MyComponent --explain "examples need updating after proto change"
```

## Success Criteria

After fix completes:

‚úÖ Fix applied to source code (proto, IaC, tests)
‚úÖ All related artifacts updated (examples, docs)
‚úÖ Consistency verified (proto ‚Üî TF, Pulumi ‚Üî TF, etc.)
‚úÖ Component tests pass (`go test ./apis/.../v1/`)
‚úÖ Build passes (`make build`)
‚úÖ Full test suite passes (`make test`)
‚úÖ Examples validate against schema
‚úÖ Documentation describes actual behavior
‚úÖ No regressions introduced
‚úÖ Ready to commit

## Reference

- **Ideal State:** `architecture/deployment-component.md`
- **Update Rule:** `.cursor/rules/deployment-component/update/update-project-planton-component.mdc`
- **Audit Rule:** `.cursor/rules/deployment-component/audit/audit-project-planton-component.mdc`
- **Fix README:** `.cursor/rules/deployment-component/fix/README.md`

---

**Ready to fix?** Run `@fix-project-planton-component <ComponentName> --explain "<what needs fixing>"` to apply targeted fixes with automatic propagation!
