syntax = "proto3";

package project.planton.provider.civo.civoloadbalancer.v1;

import "buf/validate/validate.proto";
import "project/planton/provider/civo/region.proto";
import "project/planton/shared/cloudresourcekind/cloud_resource_kind.proto";
import "project/planton/shared/foreignkey/v1/foreign_key.proto";

// CivoLoadBalancerSpec defines the specification for creating a Civo Load Balancer.
// It focuses on essential parameters following the 80/20 principle, including region, network placement,
// target instances (by IDs or tag), forwarding rules for traffic, and health checks for backend instance health.
// Note: Either `instance_ids` or `instance_tag` may be provided (mutually exclusive).
// The load balancer must be associated with a network, and can optionally use a reserved IP for its public endpoint.
message CivoLoadBalancerSpec {
  // The name of the Load Balancer. Must be unique per account.
  // Constraints: 1-64 characters, lowercase alphanumeric and hyphens.
  string load_balancer_name = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[a-z0-9-]+$"
  ];

  // The Civo region where the Load Balancer will be created.
  // Determines the geographical location of the load balancer.
  CivoRegion region = 2 [(buf.validate.field).required = true];

  // Reference to the Civo Network in which to create the Load Balancer.
  // This should be a foreign key reference to an existing CivoNetwork resource.
  project.planton.shared.foreignkey.v1.StringValueOrRef network = 3 [
    (buf.validate.field).required = true,
    (project.planton.shared.foreignkey.v1.default_kind) = CivoVpc,
    (project.planton.shared.foreignkey.v1.default_kind_field_path) = "status.outputs.network_id"
  ];

  // A list of forwarding rules that define how traffic is routed from the load balancer to backend instances.
  // Each forwarding rule specifies an incoming port/protocol and a corresponding target port/protocol on the instances.
  repeated CivoLoadBalancerForwardingRule forwarding_rules = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).repeated.min_items = 1
  ];

  // Health check configuration for the load balancer’s backend instances.
  // Defines how the load balancer will probe the instances to check their health.
  CivoLoadBalancerHealthCheck health_check = 5;

  // A list of specific instance IDs to attach to the Load Balancer.
  // Mutually exclusive with `instance_tag`. These can be literal IDs or references to CivoInstance resources.
  repeated project.planton.shared.foreignkey.v1.StringValueOrRef instance_ids = 6 [
    (project.planton.shared.foreignkey.v1.default_kind) = CivoComputeInstance,
    (project.planton.shared.foreignkey.v1.default_kind_field_path) = "status.outputs.instance_id"
  ];

  // A tag name for instances. All instances with this tag in the specified network will be attached to the Load Balancer.
  // Mutually exclusive with `instance_ids`.
  string instance_tag = 7 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 255
  ];

  // A reserved IP to assign to the Load Balancer (for a static public IP address).
  // If provided, the Load Balancer will use this reserved IP instead of allocating a new one.
  project.planton.shared.foreignkey.v1.StringValueOrRef reserved_ip_id = 8 [
    (project.planton.shared.foreignkey.v1.default_kind) = CivoIpAddress,
    (project.planton.shared.foreignkey.v1.default_kind_field_path) = "status.outputs.reserved_ip_id"
  ];

  // Enables sticky sessions if true (disabled by default).
  // When enabled, the load balancer will attempt to direct repeated requests from the same client to the same instance.
  bool enable_sticky_sessions = 9;
}

// CivoLoadBalancerProtocol enumerates the supported protocols for load balancer forwarding rules and health checks.
enum CivoLoadBalancerProtocol {
  civo_load_balancer_protocol_unspecified = 0; // Default value, should not be used.
  http = 1;
  https = 2;
  tcp = 3;
}

// ForwardingRule represents a single rule for routing traffic from the load balancer to the backend instances.
message CivoLoadBalancerForwardingRule {
  // Port on the load balancer that will listen for incoming traffic.
  uint32 entry_port = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).uint32.gte = 1,
    (buf.validate.field).uint32.lte = 65535
  ];

  // Protocol for incoming traffic on the load balancer’s entry port (e.g., HTTP, HTTPS, TCP).
  CivoLoadBalancerProtocol entry_protocol = 2 [(buf.validate.field).required = true];

  // Port on the backend instances that will receive forwarded traffic.
  uint32 target_port = 3 [
    (buf.validate.field).required = true,
    (buf.validate.field).uint32.gte = 1,
    (buf.validate.field).uint32.lte = 65535
  ];

  // Protocol for traffic between the load balancer and the backend instances (e.g., HTTP, HTTPS, TCP).
  CivoLoadBalancerProtocol target_protocol = 4 [(buf.validate.field).required = true];
}

// HealthCheck defines how the load balancer checks the health of attached instances.
message CivoLoadBalancerHealthCheck {
  // The port on the instance to which the health check will be performed.
  uint32 port = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).uint32.gte = 1,
    (buf.validate.field).uint32.lte = 65535
  ];

  // Protocol to use for health checking (HTTP, HTTPS, or TCP).
  CivoLoadBalancerProtocol protocol = 2 [(buf.validate.field).required = true];

  // If using HTTP/HTTPS for health checks, the request path to probe (e.g., "/health").
  // Ignored for TCP health checks.
  string path = 3;
}
