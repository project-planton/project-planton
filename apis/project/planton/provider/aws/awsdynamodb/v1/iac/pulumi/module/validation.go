// Code generated by Project Planton; DO NOT EDIT.
//
// Extra runtime validation helpers for the AwsDynamodb resource. These
// checks complement (but do not replace) the protobuf-level validation
// rules expressed through buf.build/validate options and CEL expressions.
//
// The intent is to catch configuration mistakes that are either
// impossible or hard to express in protobuf validation (e.g. cross-field
// or cross-collection relationships) and to provide early, deterministic
// feedback before a request ever reaches AWS.
//
// All functions in this file are side-effect free and safe to invoke in
// the CRUD handlers of the Pulumi provider.
package awsdynamodb

import (
    "fmt"
    "sort"
    "strings"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
)

// ValidateSpec performs best-effort validation of an AwsDynamodbSpec. It
// returns an error that aggregates every problem found so callers can
// display the full list of issues to the user in one shot.
func ValidateSpec(spec *awsdynamodbpb.AwsDynamodbSpec) error {
    if spec == nil {
        return fmt.Errorf("spec must be provided")
    }

    var errs []string

    // --------------------------------------------------------------------------------
    // 1. Attribute definitions — uniqueness and lookup map construction.
    // --------------------------------------------------------------------------------
    attrTypes := make(map[string]awsdynamodbpb.AttributeType, len(spec.AttributeDefinitions))
    for i, ad := range spec.AttributeDefinitions {
        name := strings.TrimSpace(ad.GetAttributeName())
        if name == "" {
            errs = appendErr(errs, "attribute_definitions[%d] has an empty attribute_name", i)
            continue
        }
        if _, exists := attrTypes[name]; exists {
            errs = appendErr(errs, "duplicate attribute definition for %q", name)
            continue
        }
        attrTypes[name] = ad.GetAttributeType()
    }

    // Helper that ensures an attribute referenced somewhere is present in
    // the definitions.
    ensureAttrDefined := func(attr, context string) {
        if _, ok := attrTypes[attr]; !ok {
            errs = appendErr(errs, "%s references attribute %q that is not defined in attribute_definitions", context, attr)
        }
    }

    // --------------------------------------------------------------------------------
    // 2. Table key schema — exactly one HASH key, optional RANGE, unique names.
    // --------------------------------------------------------------------------------
    tableHashKey, tableRangeKey := "", ""
    hashCnt := 0
    keyNames := make(map[string]bool, len(spec.KeySchema))
    for i, ks := range spec.KeySchema {
        name := ks.GetAttributeName()
        ensureAttrDefined(name, fmt.Sprintf("key_schema[%d]", i))

        if keyNames[name] {
            errs = appendErr(errs, "key_schema has duplicate attribute %q", name)
        }
        keyNames[name] = true

        switch ks.GetKeyType() {
        case awsdynamodbpb.KeyType_HASH:
            hashCnt++
            tableHashKey = name
        case awsdynamodbpb.KeyType_RANGE:
            tableRangeKey = name
        default:
            // Should never happen thanks to proto validation, but be defensive.
            errs = appendErr(errs, "key_schema[%d] has invalid key_type %d", i, ks.GetKeyType())
        }
    }
    if hashCnt != 1 {
        errs = appendErr(errs, "table must have exactly one HASH (partition) key, found %d", hashCnt)
    }

    // --------------------------------------------------------------------------------
    // 3. Secondary indexes (GSI & LSI).
    // --------------------------------------------------------------------------------
    // Keep track of index names to guarantee uniqueness across GSIs and LSIs.
    indexNames := make(map[string]string) // name -> kind (GSI/LSI)

    // 3.a Global Secondary Indexes (GSIs).
    if len(spec.GlobalSecondaryIndexes) > 20 {
        errs = appendErr(errs, "a table can define at most 20 global secondary indexes, found %d", len(spec.GlobalSecondaryIndexes))
    }

    for i, gsi := range spec.GlobalSecondaryIndexes {
        idxCtx := fmt.Sprintf("global_secondary_indexes[%d]", i)
        name := gsi.GetIndexName()
        if prevKind, exists := indexNames[name]; exists {
            errs = appendErr(errs, "%s duplicates %s with name %q", idxCtx, prevKind, name)
        } else {
            indexNames[name] = "GSI"
        }

        // Key schema validation for the GSI.
        gsiHashCnt := 0
        keyAttrNames := make(map[string]bool, len(gsi.KeySchema))
        if len(gsi.KeySchema) == 0 {
            errs = appendErr(errs, "%s must have at least one key_schema element", idxCtx)
        }
        for j, ks := range gsi.KeySchema {
            attr := ks.GetAttributeName()
            ensureAttrDefined(attr, fmt.Sprintf("%s.key_schema[%d]", idxCtx, j))

            if keyAttrNames[attr] {
                errs = appendErr(errs, "%s.key_schema has duplicate attribute %q", idxCtx, attr)
            }
            keyAttrNames[attr] = true

            if ks.GetKeyType() == awsdynamodbpb.KeyType_HASH {
                gsiHashCnt++
            }
        }
        if gsiHashCnt != 1 {
            errs = appendErr(errs, "%s must define exactly one HASH (partition) key, found %d", idxCtx, gsiHashCnt)
        }

        // Provisioned throughput alignment with billing mode. The top-level
        // CEL expression already checks this, but we double-check to ensure
        // we do not rely on it being evaluated here.
        if spec.GetBillingMode() == awsdynamodbpb.BillingMode_PROVISIONED && gsi.GetProvisionedThroughput() == nil {
            errs = appendErr(errs, "%s must set provisioned_throughput when billing_mode is PROVISIONED", idxCtx)
        }
        if spec.GetBillingMode() == awsdynamodbpb.BillingMode_PAY_PER_REQUEST && gsi.GetProvisionedThroughput() != nil {
            errs = appendErr(errs, "%s must not set provisioned_throughput when billing_mode is PAY_PER_REQUEST", idxCtx)
        }
    }

    // 3.b Local Secondary Indexes (LSIs).
    if len(spec.LocalSecondaryIndexes) > 5 {
        errs = appendErr(errs, "a table can define at most 5 local secondary indexes, found %d", len(spec.LocalSecondaryIndexes))
    }

    for i, lsi := range spec.LocalSecondaryIndexes {
        idxCtx := fmt.Sprintf("local_secondary_indexes[%d]", i)
        name := lsi.GetIndexName()
        if prevKind, exists := indexNames[name]; exists {
            errs = appendErr(errs, "%s duplicates %s with name %q", idxCtx, prevKind, name)
        } else {
            indexNames[name] = "LSI"
        }

        // LSI key schema must contain exactly two elements (HASH & RANGE) and
        // share the table HASH key.
        if len(lsi.KeySchema) != 2 {
            // Proto validation enforces this, but keep for clarity.
            errs = appendErr(errs, "%s must have exactly two key_schema elements", idxCtx)
        }

        lsiHashCnt := 0
        var lsiRangeAttr string
        for j, ks := range lsi.KeySchema {
            attr := ks.GetAttributeName()
            ensureAttrDefined(attr, fmt.Sprintf("%s.key_schema[%d]", idxCtx, j))

            if ks.GetKeyType() == awsdynamodbpb.KeyType_HASH {
                lsiHashCnt++
                if attr != tableHashKey {
                    errs = appendErr(errs, "%s HASH key (%q) must match the table HASH key (%q)", idxCtx, attr, tableHashKey)
                }
            } else if ks.GetKeyType() == awsdynamodbpb.KeyType_RANGE {
                lsiRangeAttr = attr
            }
        }
        if lsiHashCnt != 1 {
            errs = appendErr(errs, "%s must define exactly one HASH (partition) key, found %d", idxCtx, lsiHashCnt)
        }
        if lsiRangeAttr == tableRangeKey && tableRangeKey != "" {
            errs = appendErr(errs, "%s RANGE key (%q) must differ from the table RANGE key", idxCtx, lsiRangeAttr)
        }
    }

    // --------------------------------------------------------------------------------
    // 4. TTL attribute (if enabled).
    // --------------------------------------------------------------------------------
    if ttl := spec.GetTtlSpecification(); ttl != nil && ttl.GetTtlEnabled() {
        ttlAttr := ttl.GetAttributeName()
        ensureAttrDefined(ttlAttr, "ttl_specification")
    }

    // --------------------------------------------------------------------------------
    // 5. Validate tag keys uniqueness (proto guarantees valid strings).
    // --------------------------------------------------------------------------------
    // Map field already enforces uniqueness, nothing to do.

    // --------------------------------------------------------------------------------
    // 6. Surface the aggregated result.
    // --------------------------------------------------------------------------------
    if len(errs) > 0 {
        // Deterministic order for stable error messages.
        sort.Strings(errs)
        return fmt.Errorf("spec validation failed:\n  - %s", strings.Join(errs, "\n  - "))
    }
    return nil
}

// appendErr is a tiny helper that formats and appends an error message to the
// slice. It returns the slice for fluent usage.
func appendErr(errs []string, format string, a ...interface{}) []string {
    return append(errs, fmt.Sprintf(format, a...))
}
