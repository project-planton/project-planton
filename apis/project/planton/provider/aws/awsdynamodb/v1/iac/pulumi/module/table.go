// Code generated by project-planton. DO NOT EDIT.

package main

import (
    "fmt"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"

    "github.com/pulumi/pulumi-aws/sdk/v6/go/aws/dynamodb"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// buildTable provisions an Amazon DynamoDB table based on the supplied spec and
// returns the StackOutputs message populated with the identifiers that become
// available at deploy-time.
func buildTable(
    ctx *pulumi.Context,
    name string,
    spec *awsdynamodbpb.AwsDynamodbSpec,
    opts ...pulumi.ResourceOption,
) (*awsdynamodbpb.AwsDynamodbStackOutputs, error) {
    if spec == nil {
        return nil, fmt.Errorf("spec must not be nil")
    }

    // ---------------------------------------------------------------------
    //  Attribute definitions
    // ---------------------------------------------------------------------
    var attributes dynamodb.TableAttributeArray
    for _, ad := range spec.AttributeDefinitions {
        attributes = append(attributes, dynamodb.TableAttributeArgs{
            Name: pulumi.String(ad.AttributeName),
            Type: pulumi.String(convertAttributeType(ad.AttributeType)),
        })
    }

    // ---------------------------------------------------------------------
    //  Primary key schema (hash / range)
    // ---------------------------------------------------------------------
    var hashKey, rangeKey string
    for _, ks := range spec.KeySchema {
        switch ks.KeyType {
        case awsdynamodbpb.KeyType_HASH:
            hashKey = ks.AttributeName
        case awsdynamodbpb.KeyType_RANGE:
            rangeKey = ks.AttributeName
        }
    }
    if hashKey == "" {
        return nil, fmt.Errorf("table must have a HASH key defined")
    }

    // ---------------------------------------------------------------------
    //  Global secondary indexes
    // ---------------------------------------------------------------------
    var gsis dynamodb.TableGlobalSecondaryIndexArray
    for _, g := range spec.GlobalSecondaryIndexes {
        gsiArgs := dynamodb.TableGlobalSecondaryIndexArgs{
            Name: pulumi.String(g.IndexName),
        }

        // key schema for the GSI
        for _, ks := range g.KeySchema {
            if ks.KeyType == awsdynamodbpb.KeyType_HASH {
                gsiArgs.HashKey = pulumi.String(ks.AttributeName)
            } else if ks.KeyType == awsdynamodbpb.KeyType_RANGE {
                gsiArgs.RangeKey = pulumi.StringPtr(ks.AttributeName)
            }
        }

        // projection
        gsiArgs.ProjectionType = pulumi.String(convertProjectionType(g.Projection.ProjectionType))
        if len(g.Projection.NonKeyAttributes) > 0 {
            var attrs pulumi.StringArray
            for _, a := range g.Projection.NonKeyAttributes {
                attrs = append(attrs, pulumi.String(a))
            }
            gsiArgs.NonKeyAttributes = attrs
        }

        // capacity (only allowed / required for PROVISIONED mode)
        if spec.BillingMode == awsdynamodbpb.BillingMode_PROVISIONED {
            if g.ProvisionedThroughput != nil {
                gsiArgs.ReadCapacity  = pulumi.IntPtr(int(g.ProvisionedThroughput.ReadCapacityUnits))
                gsiArgs.WriteCapacity = pulumi.IntPtr(int(g.ProvisionedThroughput.WriteCapacityUnits))
            }
        }

        gsis = append(gsis, gsiArgs)
    }

    // ---------------------------------------------------------------------
    //  Local secondary indexes
    // ---------------------------------------------------------------------
    var lsis dynamodb.TableLocalSecondaryIndexArray
    for _, l := range spec.LocalSecondaryIndexes {
        lsiArgs := dynamodb.TableLocalSecondaryIndexArgs{
            Name: pulumi.String(l.IndexName),
        }

        // LSIs must share HASH key with the table, only RANGE differs.
        for _, ks := range l.KeySchema {
            if ks.KeyType == awsdynamodbpb.KeyType_RANGE {
                lsiArgs.RangeKey = pulumi.String(ks.AttributeName)
            }
        }

        // projection
        lsiArgs.ProjectionType = pulumi.String(convertProjectionType(l.Projection.ProjectionType))
        if len(l.Projection.NonKeyAttributes) > 0 {
            var attrs pulumi.StringArray
            for _, a := range l.Projection.NonKeyAttributes {
                attrs = append(attrs, pulumi.String(a))
            }
            lsiArgs.NonKeyAttributes = attrs
        }

        lsis = append(lsis, lsiArgs)
    }

    // ---------------------------------------------------------------------
    //  TTL configuration
    // ---------------------------------------------------------------------
    var ttl dynamodb.TableTtlPtrInput
    if spec.TtlSpecification != nil && spec.TtlSpecification.TtlEnabled {
        ttl = dynamodb.TableTtlArgs{
            Enabled:       pulumi.Bool(true),
            AttributeName: pulumi.String(spec.TtlSpecification.AttributeName),
        }
    }

    // ---------------------------------------------------------------------
    //  Server-side encryption
    // ---------------------------------------------------------------------
    var sse dynamodb.TableServerSideEncryptionPtrInput
    if spec.SseSpecification != nil && spec.SseSpecification.Enabled {
        sseArgs := &dynamodb.TableServerSideEncryptionArgs{
            Enabled: pulumi.Bool(true),
        }
        if spec.SseSpecification.SseType == awsdynamodbpb.SSEType_KMS {
            sseArgs.KmsKeyArn = pulumi.String(spec.SseSpecification.KmsMasterKeyId)
        }
        sse = sseArgs
    }

    // ---------------------------------------------------------------------
    //  Point-in-time recovery
    // ---------------------------------------------------------------------
    var pitr dynamodb.TablePointInTimeRecoveryPtrInput
    if spec.PointInTimeRecoveryEnabled {
        pitr = dynamodb.TablePointInTimeRecoveryArgs{
            Enabled: pulumi.Bool(true),
        }
    }

    // ---------------------------------------------------------------------
    //  Streams
    // ---------------------------------------------------------------------
    var streamEnabled pulumi.BoolPtrInput
    var streamViewType pulumi.StringPtrInput
    if spec.StreamSpecification != nil && spec.StreamSpecification.StreamEnabled {
        streamEnabled  = pulumi.Bool(true)
        streamViewType = pulumi.String(convertStreamViewType(spec.StreamSpecification.StreamViewType))
    }

    // ---------------------------------------------------------------------
    //  Tags
    // ---------------------------------------------------------------------
    tags := make(pulumi.StringMap, len(spec.Tags))
    for k, v := range spec.Tags {
        tags[k] = pulumi.String(v)
    }

    // ---------------------------------------------------------------------
    //  Billing mode & capacity
    // ---------------------------------------------------------------------
    var billingMode pulumi.StringPtrInput
    var readCap, writeCap pulumi.IntPtrInput

    switch spec.BillingMode {
    case awsdynamodbpb.BillingMode_PAY_PER_REQUEST:
        billingMode = pulumi.String("PAY_PER_REQUEST")
    case awsdynamodbpb.BillingMode_PROVISIONED:
        billingMode = pulumi.String("PROVISIONED")
        readCap  = pulumi.IntPtr(int(spec.ProvisionedThroughput.ReadCapacityUnits))
        writeCap = pulumi.IntPtr(int(spec.ProvisionedThroughput.WriteCapacityUnits))
    default:
        return nil, fmt.Errorf("unsupported billing mode")
    }

    // ---------------------------------------------------------------------
    //  Create the table
    // ---------------------------------------------------------------------
    table, err := dynamodb.NewTable(ctx, name, &dynamodb.TableArgs{
        Name:                    pulumi.StringPtr(spec.TableName),
        Attributes:              attributes,
        HashKey:                 pulumi.String(hashKey),
        RangeKey:                pulumi.StringPtr(rangeKey),
        BillingMode:             billingMode,
        ReadCapacity:            readCap,
        WriteCapacity:           writeCap,
        GlobalSecondaryIndexes:  gsis,
        LocalSecondaryIndexes:   lsis,
        StreamEnabled:           streamEnabled,
        StreamViewType:          streamViewType,
        Ttl:                     ttl,
        ServerSideEncryption:    sse,
        PointInTimeRecovery:     pitr,
        Tags:                    tags,
    }, opts...)
    if err != nil {
        return nil, err
    }

    // ---------------------------------------------------------------------
    //  Prepare stack outputs. We populate them via ApplyT so the caller can
    //  consume them immediately after buildTable returns (the values will be
    //  resolved by Pulumi during the engine run).
    // ---------------------------------------------------------------------
    outputs := &awsdynamodbpb.AwsDynamodbStackOutputs{
        GlobalSecondaryIndexNames: make([]string, 0, len(spec.GlobalSecondaryIndexes)),
        LocalSecondaryIndexNames:  make([]string, 0, len(spec.LocalSecondaryIndexes)),
    }

    // copy index names from the spec (these are deterministic)
    for _, g := range spec.GlobalSecondaryIndexes {
        outputs.GlobalSecondaryIndexNames = append(outputs.GlobalSecondaryIndexNames, g.IndexName)
    }
    for _, l := range spec.LocalSecondaryIndexes {
        outputs.LocalSecondaryIndexNames = append(outputs.LocalSecondaryIndexNames, l.IndexName)
    }

    // table identifiers
    pulumi.All(table.Arn, table.Name, table.ID()).ApplyT(func(all []interface{}) error {
        outputs.TableArn  = all[0].(string)
        outputs.TableName = all[1].(string)
        outputs.TableId   = all[2].(string)
        return nil
    })

    // stream identifiers (if enabled)
    if spec.StreamSpecification != nil && spec.StreamSpecification.StreamEnabled {
        pulumi.All(table.LatestStreamArn, table.LatestStreamLabel).ApplyT(func(all []interface{}) error {
            outputs.Stream = &awsdynamodbpb.Stream{
                StreamArn:   all[0].(string),
                StreamLabel: all[1].(string),
            }
            return nil
        })
    }

    // KMS CMK ARN (only present when SSE uses CMK)
    if spec.SseSpecification != nil && spec.SseSpecification.Enabled && spec.SseSpecification.SseType == awsdynamodbpb.SSEType_KMS {
        outputs.KmsKeyArn = spec.SseSpecification.KmsMasterKeyId
    }

    return outputs, nil
}

// convertAttributeType converts the protobuf enum to the AWS string literal
// expected by the Pulumi provider.
func convertAttributeType(t awsdynamodbpb.AttributeType) string {
    switch t {
    case awsdynamodbpb.AttributeType_STRING:
        return "S"
    case awsdynamodbpb.AttributeType_NUMBER:
        return "N"
    case awsdynamodbpb.AttributeType_BINARY:
        return "B"
    default:
        return "S"
    }
}

// convertProjectionType maps protobuf ProjectionType to AWS string values.
func convertProjectionType(p awsdynamodbpb.ProjectionType) string {
    switch p {
    case awsdynamodbpb.ProjectionType_ALL:
        return "ALL"
    case awsdynamodbpb.ProjectionType_KEYS_ONLY:
        return "KEYS_ONLY"
    case awsdynamodbpb.ProjectionType_INCLUDE:
        return "INCLUDE"
    default:
        return "ALL"
    }
}

// convertStreamViewType maps protobuf StreamViewType to AWS literal strings.
func convertStreamViewType(v awsdynamodbpb.StreamViewType) string {
    switch v {
    case awsdynamodbpb.StreamViewType_NEW_IMAGE:
        return "NEW_IMAGE"
    case awsdynamodbpb.StreamViewType_OLD_IMAGE:
        return "OLD_IMAGE"
    case awsdynamodbpb.StreamViewType_NEW_AND_OLD_IMAGES:
        return "NEW_AND_OLD_IMAGES"
    case awsdynamodbpb.StreamViewType_STREAM_KEYS_ONLY:
        return "KEYS_ONLY"
    default:
        return "NEW_AND_OLD_IMAGES"
    }
}
