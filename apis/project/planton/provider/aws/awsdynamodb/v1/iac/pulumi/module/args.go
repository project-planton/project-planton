// Code generated by project-planton ‑ DO NOT EDIT.
//
// This file provides helpers that translate the high-level protobuf
// AwsDynamodbSpec into Pulumi-native aws.dynamodb.TableArgs
// so that a caller can provision a table with idiomatic Pulumi code.
//
// The conversion is intentionally kept in its own file so that business
// logic can stay entirely within Go and unit-tests can work without the
// Pulumi engine.  No resources are created in this file – it only builds
// *dynamodb.TableArgs* values.

package awsdynamodb

import (
    "fmt"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ConvertSpecToTableArgs converts a high level AwsDynamodbSpec into Pulumi
// aws.dynamodb.TableArgs. The returned arguments can directly be supplied to
// dynamodb.NewTable().
func ConvertSpecToTableArgs(ctx *pulumi.Context, spec *awsdynamodbpb.AwsDynamodbSpec) (*dynamodb.TableArgs, error) {
    if spec == nil {
        return nil, fmt.Errorf("spec must not be nil")
    }

    // ---------------------------------------------------------------------
    // 1.  Attribute definitions
    // ---------------------------------------------------------------------
    var attributes dynamodb.TableAttributeArray
    for _, a := range spec.GetAttributeDefinitions() {
        typ, err := attributeTypeToAWS(a.GetAttributeType())
        if err != nil {
            return nil, err
        }
        attributes = append(attributes, dynamodb.TableAttributeArgs{
            Name: pulumi.String(a.GetAttributeName()),
            Type: pulumi.String(typ),
        })
    }

    // ---------------------------------------------------------------------
    // 2.  Table key schema: HASH (mandatory) and optional RANGE
    // ---------------------------------------------------------------------
    var hashKey, rangeKey string
    for _, ks := range spec.GetKeySchema() {
        switch ks.GetKeyType() {
        case awsdynamodbpb.KeyType_HASH:
            hashKey = ks.GetAttributeName()
        case awsdynamodbpb.KeyType_RANGE:
            rangeKey = ks.GetAttributeName()
        default:
            return nil, fmt.Errorf("unsupported key_type %v in table key schema", ks.GetKeyType())
        }
    }
    if hashKey == "" {
        return nil, fmt.Errorf("table key schema must define exactly one HASH key")
    }

    // ---------------------------------------------------------------------
    // 3.  Billing mode and (table-level) provisioned capacity
    // ---------------------------------------------------------------------
    var (
        billingMode      *pulumi.String
        readCapacityPtr  pulumi.IntPtrInput
        writeCapacityPtr pulumi.IntPtrInput
    )
    switch spec.GetBillingMode() {
    case awsdynamodbpb.BillingMode_PROVISIONED:
        billingMode = pulumi.StringPtr("PROVISIONED")
        if spec.ProvisionedThroughput == nil {
            return nil, fmt.Errorf("provisioned_throughput must be provided when billing_mode == PROVISIONED")
        }
        readCapacityPtr = pulumi.IntPtr(int(spec.ProvisionedThroughput.GetReadCapacityUnits()))
        writeCapacityPtr = pulumi.IntPtr(int(spec.ProvisionedThroughput.GetWriteCapacityUnits()))
    case awsdynamodbpb.BillingMode_PAY_PER_REQUEST:
        billingMode = pulumi.StringPtr("PAY_PER_REQUEST")
    default:
        return nil, fmt.Errorf("unexpected billing_mode %v", spec.GetBillingMode())
    }

    // ---------------------------------------------------------------------
    // 4.  Global Secondary Indexes (GSI)
    // ---------------------------------------------------------------------
    var gsis dynamodb.TableGlobalSecondaryIndexArray
    for _, g := range spec.GetGlobalSecondaryIndexes() {
        gsiHash, gsiRange, err := resolveKeySchema(g.GetKeySchema())
        if err != nil {
            return nil, fmt.Errorf("GSI %q: %w", g.GetIndexName(), err)
        }

        projectionType, err := projectionTypeToAWS(g.GetProjection().GetProjectionType())
        if err != nil {
            return nil, fmt.Errorf("GSI %q: %w", g.GetIndexName(), err)
        }

        gsiArgs := dynamodb.TableGlobalSecondaryIndexArgs{
            Name:           pulumi.String(g.GetIndexName()),
            HashKey:        pulumi.String(gsiHash),
            ProjectionType: pulumi.String(projectionType),
        }
        if gsiRange != "" {
            gsiArgs.RangeKey = pulumi.StringPtr(gsiRange)
        }
        // Non-key attributes only when INCLUDE is requested.
        if len(g.GetProjection().GetNonKeyAttributes()) > 0 {
            var nka pulumi.StringArray
            for _, attr := range g.GetProjection().GetNonKeyAttributes() {
                nka = append(nka, pulumi.String(attr))
            }
            gsiArgs.NonKeyAttributes = nka
        }

        // Provisioned capacity is only valid when table is provisioned.
        if g.ProvisionedThroughput != nil {
            gsiArgs.ReadCapacity  = pulumi.IntPtr(int(g.ProvisionedThroughput.GetReadCapacityUnits()))
            gsiArgs.WriteCapacity = pulumi.IntPtr(int(g.ProvisionedThroughput.GetWriteCapacityUnits()))
        }
        gsis = append(gsis, gsiArgs)
    }

    // ---------------------------------------------------------------------
    // 5.  Local Secondary Indexes (LSI)
    // ---------------------------------------------------------------------
    var lsis dynamodb.TableLocalSecondaryIndexArray
    for _, l := range spec.GetLocalSecondaryIndexes() {
        _, lsiRange, err := resolveKeySchema(l.GetKeySchema())
        if err != nil {
            return nil, fmt.Errorf("LSI %q: %w", l.GetIndexName(), err)
        }
        if lsiRange == "" {
            return nil, fmt.Errorf("LSI %q must define a RANGE key", l.GetIndexName())
        }
        projectionType, err := projectionTypeToAWS(l.GetProjection().GetProjectionType())
        if err != nil {
            return nil, fmt.Errorf("LSI %q: %w", l.GetIndexName(), err)
        }
        lsiArgs := dynamodb.TableLocalSecondaryIndexArgs{
            Name:           pulumi.String(l.GetIndexName()),
            RangeKey:       pulumi.String(lsiRange),
            ProjectionType: pulumi.String(projectionType),
        }
        if len(l.GetProjection().GetNonKeyAttributes()) > 0 {
            var nka pulumi.StringArray
            for _, attr := range l.GetProjection().GetNonKeyAttributes() {
                nka = append(nka, pulumi.String(attr))
            }
            lsiArgs.NonKeyAttributes = nka
        }
        lsis = append(lsis, lsiArgs)
    }

    // ---------------------------------------------------------------------
    // 6.  Streams configuration
    // ---------------------------------------------------------------------
    var streamEnabled pulumi.BoolPtrInput
    var streamViewType pulumi.StringPtrInput
    if spec.StreamSpecification != nil {
        streamEnabled = pulumi.BoolPtr(spec.StreamSpecification.GetStreamEnabled())
        if spec.StreamSpecification.GetStreamEnabled() {
            svt, err := streamViewTypeToAWS(spec.StreamSpecification.GetStreamViewType())
            if err != nil {
                return nil, err
            }
            streamViewType = pulumi.StringPtr(svt)
        }
    }

    // ---------------------------------------------------------------------
    // 7.  TTL configuration
    // ---------------------------------------------------------------------
    var ttlArg *dynamodb.TableTtlArgs
    if spec.TtlSpecification != nil && spec.TtlSpecification.GetTtlEnabled() {
        ttlArg = &dynamodb.TableTtlArgs{
            Enabled:       pulumi.Bool(true),
            AttributeName: pulumi.String(spec.TtlSpecification.GetAttributeName()),
        }
    }

    // ---------------------------------------------------------------------
    // 8.  Server-side encryption
    // ---------------------------------------------------------------------
    var sseArg *dynamodb.TableServerSideEncryptionArgs
    if spec.SseSpecification != nil && spec.SseSpecification.GetEnabled() {
        sseArg = &dynamodb.TableServerSideEncryptionArgs{
            Enabled: pulumi.BoolPtr(true),
        }
        if spec.SseSpecification.GetSseType() == awsdynamodbpb.SSEType_KMS {
            sseArg.KmsKeyArn = pulumi.StringPtr(spec.SseSpecification.GetKmsMasterKeyId())
        }
    }

    // ---------------------------------------------------------------------
    // 9.  Tags
    // ---------------------------------------------------------------------
    tags := pulumi.StringMap{}
    for k, v := range spec.GetTags() {
        tags[k] = pulumi.String(v)
    }

    // ---------------------------------------------------------------------
    // 10.  Compose final TableArgs
    // ---------------------------------------------------------------------
    args := &dynamodb.TableArgs{
        Attributes:              attributes,
        BillingMode:             billingMode,
        HashKey:                 pulumi.String(hashKey),
        Name:                    pulumi.StringPtr(spec.GetTableName()),
        PointInTimeRecovery:     pulumi.BoolPtr(spec.GetPointInTimeRecoveryEnabled()),
        ReadCapacity:            readCapacityPtr,
        WriteCapacity:           writeCapacityPtr,
        GlobalSecondaryIndexes:  gsis,
        LocalSecondaryIndexes:   lsis,
        RangeKey:                stringPtrOrNil(rangeKey),
        StreamEnabled:           streamEnabled,
        StreamViewType:          streamViewType,
        Tags:                    tags,
        Ttl:                     ttlArg,
        ServerSideEncryption:    sseArg,
    }

    return args, nil
}

// ---------------------------------------------------------------------------
// Helper functions
// ---------------------------------------------------------------------------

// attributeTypeToAWS returns the AWS single-character attribute type ("S", "N", "B")
// expected by the Pulumi provider.
func attributeTypeToAWS(t awsdynamodbpb.AttributeType) (string, error) {
    switch t {
    case awsdynamodbpb.AttributeType_STRING:
        return "S", nil
    case awsdynamodbpb.AttributeType_NUMBER:
        return "N", nil
    case awsdynamodbpb.AttributeType_BINARY:
        return "B", nil
    default:
        return "", fmt.Errorf("unsupported attribute_type %v", t)
    }
}

func projectionTypeToAWS(p awsdynamodbpb.ProjectionType) (string, error) {
    switch p {
    case awsdynamodbpb.ProjectionType_ALL:
        return "ALL", nil
    case awsdynamodbpb.ProjectionType_KEYS_ONLY:
        return "KEYS_ONLY", nil
    case awsdynamodbpb.ProjectionType_INCLUDE:
        return "INCLUDE", nil
    default:
        return "", fmt.Errorf("unsupported projection_type %v", p)
    }
}

func streamViewTypeToAWS(s awsdynamodbpb.StreamViewType) (string, error) {
    switch s {
    case awsdynamodbpb.StreamViewType_NEW_IMAGE:
        return "NEW_IMAGE", nil
    case awsdynamodbpb.StreamViewType_OLD_IMAGE:
        return "OLD_IMAGE", nil
    case awsdynamodbpb.StreamViewType_NEW_AND_OLD_IMAGES:
        return "NEW_AND_OLD_IMAGES", nil
    case awsdynamodbpb.StreamViewType_STREAM_KEYS_ONLY:
        return "KEYS_ONLY", nil
    default:
        return "", fmt.Errorf("unsupported stream_view_type %v", s)
    }
}

// resolveKeySchema extracts HASH and RANGE key attribute names from a repeated
// KeySchemaElement list and validates that at most one of each exists.
func resolveKeySchema(schema []*awsdynamodbpb.KeySchemaElement) (hash string, rng string, err error) {
    for _, ks := range schema {
        switch ks.GetKeyType() {
        case awsdynamodbpb.KeyType_HASH:
            if hash != "" {
                return "", "", fmt.Errorf("multiple HASH keys defined")
            }
            hash = ks.GetAttributeName()
        case awsdynamodbpb.KeyType_RANGE:
            if rng != "" {
                return "", "", fmt.Errorf("multiple RANGE keys defined")
            }
            rng = ks.GetAttributeName()
        default:
            return "", "", fmt.Errorf("unsupported key_type %v", ks.GetKeyType())
        }
    }
    if hash == "" {
        return "", "", fmt.Errorf("HASH key not defined")
    }
    return hash, rng, nil
}

// stringPtrOrNil returns a pulumi.StringPtrInput when s is not empty; otherwise nil.
func stringPtrOrNil(s string) pulumi.StringPtrInput {
    if s == "" {
        return nil
    }
    return pulumi.StringPtr(s)
}
