// Code generated by Project Planton – DO NOT EDIT.
//
// This file wires an AwsDynamodbSpec (protobuf) to Pulumi's
// aws.dynamodb.TableArgs structure so that the state described by the
// declarative spec can be materialised via Pulumi.
//
// The mapping is largely mechanical – every field that is present in the
// protobuf is (where possible) mapped to its counterpart in the Pulumi
// provider.  The conversion deliberately avoids any business-logic-type
// validation because the protobuf itself already carries CEL/Buf-validate
// rules.  The only extra checks we perform are the ones required to build a
// valid Pulumi model (e.g. we make sure the HASH key is present, translate
// enums, etc.).
package awsdynamodb

import (
	"fmt"

	awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/dynamodb"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ToTableArgs converts an AwsDynamodbSpec protobuf message into the
// corresponding Pulumi dynamodb.TableArgs structure.
func ToTableArgs(spec *awsdynamodbpb.AwsDynamodbSpec) (*dynamodb.TableArgs, error) {
	if spec == nil {
		return nil, fmt.Errorf("spec must not be nil")
	}

	// ---------------------------------------------------------------------
	// Attributes (schema) --------------------------------------------------
	// ---------------------------------------------------------------------
	var attributes dynamodb.TableAttributeArray
	for _, attr := range spec.GetAttributeDefinitions() {
		attributes = append(attributes, &dynamodb.TableAttributeArgs{
			Name: pulumi.String(attr.GetAttributeName()),
			Type: pulumi.String(attributeTypeToTerraform(attr.GetAttributeType())),
		})
	}

	// ---------------------------------------------------------------------
	// Primary key (HASH / RANGE) ------------------------------------------
	// ---------------------------------------------------------------------
	var (
		hashKey  string
		rangeKey *string
	)
	for _, ks := range spec.GetKeySchema() {
		if ks.GetKeyType() == awsdynamodbpb.KeyType_HASH {
			hashKey = ks.GetAttributeName()
		} else if ks.GetKeyType() == awsdynamodbpb.KeyType_RANGE {
			v := ks.GetAttributeName()
			rangeKey = &v
		}
	}
	if hashKey == "" {
		return nil, fmt.Errorf("primary HASH key not found in key_schema")
	}

	// ---------------------------------------------------------------------
	// Billing / capacity ---------------------------------------------------
	// ---------------------------------------------------------------------
	billingModeStr := billingModeToTerraform(spec.GetBillingMode())
	var (
		readCapacity  *int
		writeCapacity *int
	)
	if spec.GetBillingMode() == awsdynamodbpb.BillingMode_PROVISIONED {
		if pt := spec.GetProvisionedThroughput(); pt != nil {
			rcu := int(pt.GetReadCapacityUnits())
			wcu := int(pt.GetWriteCapacityUnits())
			readCapacity = &rcu
			writeCapacity = &wcu
		}
	}

	// ---------------------------------------------------------------------
	// Global secondary indexes --------------------------------------------
	// ---------------------------------------------------------------------
	var gsis dynamodb.TableGlobalSecondaryIndexArray
	for _, g := range spec.GetGlobalSecondaryIndexes() {
		gHashKey, gRangeKey, err := extractIndexKeys(g.GetKeySchema())
		if err != nil {
			return nil, fmt.Errorf("GSI '%s': %w", g.GetIndexName(), err)
		}

		var gReadCap, gWriteCap pulumi.IntPtrInput
		if spec.GetBillingMode() == awsdynamodbpb.BillingMode_PROVISIONED {
			if throughPut := g.GetProvisionedThroughput(); throughPut != nil {
				gReadCap = pulumi.IntPtr(int(throughPut.GetReadCapacityUnits()))
				gWriteCap = pulumi.IntPtr(int(throughPut.GetWriteCapacityUnits()))
			}
		}

		gsis = append(gsis, &dynamodb.TableGlobalSecondaryIndexArgs{
			Name:            pulumi.String(g.GetIndexName()),
			HashKey:         pulumi.String(gHashKey),
			RangeKey:        stringPtrInput(gRangeKey),
			ProjectionType:  pulumi.String(projectionTypeToTerraform(g.GetProjection().GetProjectionType())),
			NonKeyAttributes: pulumi.ToStringArray(g.GetProjection().GetNonKeyAttributes()),
			ReadCapacity:    gReadCap,
			WriteCapacity:   gWriteCap,
		})
	}

	// ---------------------------------------------------------------------
	// Local secondary indexes ---------------------------------------------
	// ---------------------------------------------------------------------
	var lsis dynamodb.TableLocalSecondaryIndexArray
	for _, l := range spec.GetLocalSecondaryIndexes() {
		_, lRangeKey, err := extractIndexKeys(l.GetKeySchema())
		if err != nil {
			return nil, fmt.Errorf("LSI '%s': %w", l.GetIndexName(), err)
		}

		lsis = append(lsis, &dynamodb.TableLocalSecondaryIndexArgs{
			Name:            pulumi.String(l.GetIndexName()),
			RangeKey:        pulumi.String(*lRangeKey),
			ProjectionType:  pulumi.String(projectionTypeToTerraform(l.GetProjection().GetProjectionType())),
			NonKeyAttributes: pulumi.ToStringArray(l.GetProjection().GetNonKeyAttributes()),
		})
	}

	// ---------------------------------------------------------------------
	// Streams --------------------------------------------------------------
	// ---------------------------------------------------------------------
	var streamEnabled pulumi.BoolPtrInput
	var streamViewType pulumi.StringPtrInput
	if s := spec.GetStreamSpecification(); s != nil && s.GetStreamEnabled() {
		streamEnabled = pulumi.BoolPtr(true)
		streamViewType = pulumi.StringPtr(streamViewTypeToTerraform(s.GetStreamViewType()))
	}

	// ---------------------------------------------------------------------
	// TTL / Point-in-time recovery ----------------------------------------
	// ---------------------------------------------------------------------
	var ttlArg *dynamodb.TableTtlArgs
	if ttl := spec.GetTtlSpecification(); ttl != nil && ttl.GetTtlEnabled() {
		ttlArg = &dynamodb.TableTtlArgs{
			AttributeName: pulumi.String(ttl.GetAttributeName()),
			Enabled:       pulumi.Bool(true),
		}
	}

	var pitrArg *dynamodb.TablePointInTimeRecoveryArgs
	if spec.GetPointInTimeRecoveryEnabled() {
		pitrArg = &dynamodb.TablePointInTimeRecoveryArgs{Enabled: pulumi.Bool(true)}
	}

	// ---------------------------------------------------------------------
	// Server-side encryption ----------------------------------------------
	// ---------------------------------------------------------------------
	var sseArg *dynamodb.TableServerSideEncryptionArgs
	if sse := spec.GetSseSpecification(); sse != nil {
		// Only include the block when enabled or when the user explicitly sets it.
		sseArg = &dynamodb.TableServerSideEncryptionArgs{
			Enabled: pulumi.Bool(sse.GetEnabled()),
		}
		if sse.GetEnabled() && sse.GetSseType() == awsdynamodbpb.SSEType_KMS {
			sseArg.KmsKeyArn = pulumi.StringPtr(sse.GetKmsMasterKeyId())
		}
	}

	// ---------------------------------------------------------------------
	// Tags ----------------------------------------------------------------
	// ---------------------------------------------------------------------
	tags := make(pulumi.StringMap)
	for k, v := range spec.GetTags() {
		tags[k] = pulumi.String(v)
	}

	// ---------------------------------------------------------------------
	// Assemble the TableArgs ----------------------------------------------
	// ---------------------------------------------------------------------
	args := &dynamodb.TableArgs{
		Name:                   pulumi.StringPtr(spec.GetTableName()),
		Attributes:             attributes,
		HashKey:                pulumi.String(hashKey),
		RangeKey:               stringPtrInput(rangeKey),
		BillingMode:            pulumi.StringPtr(billingModeStr),
		ReadCapacity:           intPtrInput(readCapacity),
		WriteCapacity:          intPtrInput(writeCapacity),
		GlobalSecondaryIndexes: gsis,
		LocalSecondaryIndexes:  lsis,
		StreamEnabled:          streamEnabled,
		StreamViewType:         streamViewType,
		Ttl:                    ttlArg,
		PointInTimeRecovery:    pitrArg,
		ServerSideEncryption:   sseArg,
		Tags:                   tags,
	}

	return args, nil
}

// attributeTypeToTerraform maps the protobuf enum to the single-character
// DynamoDB type understood by Terraform/Pulumi.
func attributeTypeToTerraform(t awsdynamodbpb.AttributeType) string {
	switch t {
	case awsdynamodbpb.AttributeType_STRING:
		return "S"
	case awsdynamodbpb.AttributeType_NUMBER:
		return "N"
	case awsdynamodbpb.AttributeType_BINARY:
		return "B"
	default:
		return "S" // fall-back – protobuf validation guarantees non-zero
	}
}

func billingModeToTerraform(b awsdynamodbpb.BillingMode) string {
	switch b {
	case awsdynamodbpb.BillingMode_PROVISIONED:
		return "PROVISIONED"
	case awsdynamodbpb.BillingMode_PAY_PER_REQUEST:
		return "PAY_PER_REQUEST"
	default:
		return "PROVISIONED"
	}
}

func projectionTypeToTerraform(p awsdynamodbpb.ProjectionType) string {
	switch p {
	case awsdynamodbpb.ProjectionType_ALL:
		return "ALL"
	case awsdynamodbpb.ProjectionType_KEYS_ONLY:
		return "KEYS_ONLY"
	case awsdynamodbpb.ProjectionType_INCLUDE:
		return "INCLUDE"
	default:
		return "ALL"
	}
}

func streamViewTypeToTerraform(s awsdynamodbpb.StreamViewType) string {
	switch s {
	case awsdynamodbpb.StreamViewType_NEW_IMAGE:
		return "NEW_IMAGE"
	case awsdynamodbpb.StreamViewType_OLD_IMAGE:
		return "OLD_IMAGE"
	case awsdynamodbpb.StreamViewType_NEW_AND_OLD_IMAGES:
		return "NEW_AND_OLD_IMAGES"
	case awsdynamodbpb.StreamViewType_STREAM_KEYS_ONLY:
		return "KEYS_ONLY"
	default:
		return "NEW_AND_OLD_IMAGES"
	}
}

// extractIndexKeys pulls out the HASH and RANGE keys from an index key schema.
// Returns: hashKey (required), rangeKey (optional, may be nil), error
func extractIndexKeys(schema []*awsdynamodbpb.KeySchemaElement) (string, *string, error) {
	var hashKey string
	var rangeKey *string
	for _, k := range schema {
		if k.GetKeyType() == awsdynamodbpb.KeyType_HASH {
			hashKey = k.GetAttributeName()
		} else if k.GetKeyType() == awsdynamodbpb.KeyType_RANGE {
			v := k.GetAttributeName()
			rangeKey = &v
		}
	}
	if hashKey == "" {
		return "", nil, fmt.Errorf("HASH key not found in index key_schema")
	}
	return hashKey, rangeKey, nil
}

// Helpers to deal with optional pointer conversions ----------------------------------
func stringPtrInput(s *string) pulumi.StringPtrInput {
	if s == nil {
		return nil
	}
	return pulumi.StringPtr(*s)
}

func intPtrInput(i *int) pulumi.IntPtrInput {
	if i == nil {
		return nil
	}
	return pulumi.IntPtr(*i)
}
