// Code generated by project-planton. DO NOT EDIT.
//
// This file contains helper utilities that translate the
// project.planton.provider.aws.awsdynamodb.v1.SSESpecification proto message
// into the Pulumi AWS DynamoDB encryption (SSE) configuration.  When KMS is
// requested we either import the user-supplied CMK or create a fresh one and
// return its ARN so the caller can expose it through the stack outputs.

package awsdynamodb

import (
    "fmt"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"

    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/kms"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// EncryptionResult groups the Pulumi inputs/outputs produced when translating
// an SSESpecification.
//
//   • SseSpec     – value that can be assigned to dynamodb.TableArgs.SseSpecification.
//   • KmsKeyArn   – (optional) ARN of the CMK used when "KMS" was requested. The
//                   output is nil when SSE is disabled or when AES256 is used.
//
// The struct makes it simple for the calling code to both wire the encryption
// settings into the DynamoDB table and export the KMS ARN from the stack when
// applicable.
//
// NOTE: Pulumi uses pointer-to-struct inputs (…PtrInput) to express optional
// nested blocks. We expose the same so callers can write e.g.
//
//   table, err := dynamodb.NewTable(ctx, name, &dynamodb.TableArgs{
//       …
//       SseSpecification: enc.SseSpec,
//   })
//
// and later, if desired:
//
//   if enc.KmsKeyArn != nil {
//       ctx.Export("kms_key_arn", enc.KmsKeyArn)
//   }
//
// without having to know the internals of how we built the SSE configuration.
//
type EncryptionResult struct {
    SseSpec   dynamodb.TableSseSpecificationPtrInput
    KmsKeyArn pulumi.StringPtrOutput
}

// ConfigureEncryption converts the protobuf-level SSESpecification into the
// Pulumi representation understood by aws.dynamodb.Table.  The function is a
// no-op when the proto message is nil or the feature is disabled.
//
// Parameters
//   ctx   – Pulumi context.
//   name  – Resource-name prefix used if the function needs to create a KMS key.
//   spec  – Protobuf specification coming from user input (may be nil).
//   opts  – Any additional resource options (e.g. parent) that should be
//           applied to managed child resources (currently only to a CMK when
//           created).
//
// Returns
//   • EncryptionResult with both the SseSpec for the table and (optionally)
//     the KMS key ARN.
//   • error when the input was invalid or when Pulumi failed creating or
//     importing a resource.
//
// The caller should treat a nil result as "SSE disabled".
//
func ConfigureEncryption(ctx *pulumi.Context, name string, spec *awsdynamodbpb.SSESpecification, opts ...pulumi.ResourceOption) (*EncryptionResult, error) {
    // Nothing to do when the user omitted the block or explicitly disabled SSE.
    if spec == nil || !spec.Enabled {
        return nil, nil
    }

    // Translate the protobuf enum into the string expected by AWS.
    sseType, err := translateSSEType(spec.SseType)
    if err != nil {
        return nil, err
    }

    // Start building the Pulumi args structure.
    args := &dynamodb.TableSseSpecificationArgs{
        Enabled: pulumi.BoolPtr(true),
        SseType: pulumi.StringPtr(sseType),
    }

    var kmsArn pulumi.StringPtrOutput // remains nil unless KMS is used

    if sseType == "KMS" {
        // When the user supplied a CMK ARN we simply use it; otherwise we create
        // a new key under our control.
        if k := spec.GetKmsMasterKeyId(); k != "" {
            args.KmsMasterKeyId = pulumi.StringPtr(k)
            kmsArn = pulumi.String(k).ToStringOutput().ApplyT(func(s string) *string { return &s }).(pulumi.StringPtrOutput)
        } else {
            // Create a fresh CMK with a 30-day deletion window – a common sane default.
            // The resource will be parented (and otherwise influenced) by the optional
            // opts supplied by the caller.
            kmsKey, err := kms.NewKey(ctx, fmt.Sprintf("%s-kms", name), &kms.KeyArgs{
                DeletionWindowInDays: pulumi.Int(30),
                Description:          pulumi.String(fmt.Sprintf("CMK for DynamoDB table %s", name)),
            }, opts...)
            if err != nil {
                return nil, err
            }

            // The DynamoDB SSE spec expects the key ID (ARN is accepted).
            args.KmsMasterKeyId = kmsKey.Arn().ToStringPtrOutput()
            // Expose the ARN to callers so they may export it from the stack.
            kmsArn = kmsKey.Arn().ToStringOutput().ApplyT(func(s string) *string { return &s }).(pulumi.StringPtrOutput)
        }
    }

    return &EncryptionResult{
        SseSpec:   args.ToTableSseSpecificationPtrOutput(),
        KmsKeyArn: kmsArn,
    }, nil
}

// translateSSEType converts the protobuf enum into the literal string accepted
// by aws.dynamodb.Table.SseSpecification.SseType.
func translateSSEType(t awsdynamodbpb.SSEType) (string, error) {
    switch t {
    case awsdynamodbpb.SSEType_AES256:
        return "AES256", nil
    case awsdynamodbpb.SSEType_KMS:
        return "KMS", nil
    default:
        return "", fmt.Errorf("unsupported SSEType: %v", t)
    }
}
