// Code generated by Project Planton; DO NOT EDIT.
//
// tags.go centralises all tag-handling logic for the DynamoDB component.  It is
// responsible for
//   * converting the user-supplied tags from the protobuf spec into Pulumi
//     inputs;
//   * applying normalisation rules (currently trimming surrounding white-space
//     and dropping empty keys / values);
//   * layering the different tag sources (default/internal → stack-level →
//     resource-level), making sure that the most specific source wins;
//   * guaranteeing that every resource receives a set of “standard” tags that
//     Project Planton relies on (e.g. `ManagedBy: project-planton`).
//
// Having a single file for this logic prevents subtle inconsistencies from
// creeping in when we add new sub-resources (GSIs, streams, etc.) to the
// DynamoDB component.
package awsdynamodb

import (
    "strings"

    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Standard tag keys – these are always present on every AWS resource we create.
const (
    // TagManagedBy indicates the tool that created / manages the resource.
    TagManagedBy      = "ManagedBy"
    TagManagedByValue = "project-planton"
)

// ToPulumiStringMap converts an ordinary Go map into a Pulumi StringMap.  Nil
// input maps are tolerated and yield an empty StringMap (not nil) so callers
// can chain methods safely.
func ToPulumiStringMap(m map[string]string) pulumi.StringMap {
    sm := pulumi.StringMap{}
    for k, v := range m {
        sm[k] = pulumi.String(v)
    }
    return sm
}

// normaliseTag trims white-space around the key and value.  The function
// returns the normalised key/value pair and a boolean that indicates whether
// the tag should be kept.  Tags with an empty key or value are silently
// dropped, because AWS rejects them anyway.
func normaliseTag(k, v string) (string, string, bool) {
    key := strings.TrimSpace(k)
    val := strings.TrimSpace(v)

    if key == "" || val == "" {
        return "", "", false
    }
    return key, val, true
}

// NormaliseRawTags converts the raw map that comes from the protobuf spec into
// a Pulumi StringMap after applying the normalisation rules defined in
// normaliseTag.
func NormaliseRawTags(raw map[string]string) pulumi.StringMap {
    if raw == nil {
        return pulumi.StringMap{}
    }

    out := pulumi.StringMap{}
    for k, v := range raw {
        nk, nv, ok := normaliseTag(k, v)
        if !ok {
            continue
        }
        out[nk] = pulumi.String(nv)
    }
    return out
}

// mergeStringMaps is an internal helper that performs the actual merge.  The
// maps are processed from left to right; later maps override keys that appeared
// in earlier maps.
func mergeStringMaps(maps ...pulumi.StringMap) pulumi.StringMap {
    merged := pulumi.StringMap{}
    for _, m := range maps {
        for k, v := range m {
            merged[k] = v
        }
    }
    return merged
}

// MergeTags merges an arbitrary number of StringMaps together, automatically
// injecting the standard Project Planton tags.  Later arguments override
// earlier ones.  The function guarantees that the returned map is never nil.
//
// Example (in a component resource):
//   finalTags := MergeTags(
//       NormaliseRawTags(spec.Tags), // from protobuf
//       stackTags,                   // from StackInput
//   )
func MergeTags(tagSets ...pulumi.StringMap) pulumi.StringMap {
    // Ensure the default tags are always applied first so that user-supplied
    // tags can overwrite them if necessary (should rarely be the case, but we
    // do not want to prevent it outright).
    defaultTags := pulumi.StringMap{
        TagManagedBy: pulumi.String(TagManagedByValue),
    }

    all := append([]pulumi.StringMap{defaultTags}, tagSets...)
    return mergeStringMaps(all...)
}
