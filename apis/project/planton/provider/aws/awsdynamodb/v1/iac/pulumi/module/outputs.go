// Code generated by project-planton – DO NOT EDIT.
//
// This file defines the list of stack-output keys produced by the
// aws_dynamodb component and a small helper that converts a generic
// map[string]any (e.g. the result of Pulumi Automation API's
// stack.Outputs(ctx)) into the strongly-typed protobuf message
// AwsDynamodbStackOutputs.
//
// Having the translation logic in a single place makes it very easy to:
//   • keep the wiring between infrastructure code (where ctx.Export is
//     used) and the rest of the application consistent;
//   • evolve the protobuf definition without hunting for string literals
//     across the codebase; and
//   • write unit-tests without having to spin up real stacks.
package awsdynamodb

import (
    "fmt"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
)

// Stack-output keys that the aws_dynamodb component exports.  Keeping the
// keys in constants avoids typos and makes code-completion work in IDEs.
const (
    // Flat (top-level) outputs.
    OutputTableArn                 = "table_arn"
    OutputTableName                = "table_name"
    OutputTableID                  = "table_id"
    OutputKMSKeyArn               = "kms_key_arn"
    OutputGlobalSecondaryIndexNames = "global_secondary_index_names"
    OutputLocalSecondaryIndexNames  = "local_secondary_index_names"

    // The nested "stream" object.
    OutputStream                   = "stream"          // map[string]any
    OutputStreamArn               = "stream_arn"      // string – inside map referenced by OutputStream
    OutputStreamLabel             = "stream_label"    // string – inside map referenced by OutputStream
)

// MapToAwsDynamodbStackOutputs converts the loosely-typed map returned by
// the Pulumi engine / Automation API into an AwsDynamodbStackOutputs
// protobuf.  The function performs best-effort type assertions and returns
// an error if a mandatory field has an unexpected type.
func MapToAwsDynamodbStackOutputs(outputs map[string]any) (*awsdynamodbpb.AwsDynamodbStackOutputs, error) {
    if outputs == nil {
        return nil, fmt.Errorf("nil outputs map passed to MapToAwsDynamodbStackOutputs")
    }

    res := &awsdynamodbpb.AwsDynamodbStackOutputs{}

    // Helper closures -----------------------------------------------------
    getString := func(key string) (string, error) {
        v, ok := outputs[key]
        if !ok {
            return "", nil // not present is fine for optional fields
        }
        s, ok := v.(string)
        if !ok {
            return "", fmt.Errorf("output %q is not a string (got %T)", key, v)
        }
        return s, nil
    }

    getStringSlice := func(key string) ([]string, error) {
        v, ok := outputs[key]
        if !ok {
            return nil, nil // treat as unset
        }
        switch vv := v.(type) {
        case []any:
            out := make([]string, 0, len(vv))
            for i, iv := range vv {
                str, ok := iv.(string)
                if !ok {
                    return nil, fmt.Errorf("output %q[%d] is not a string (got %T)", key, i, iv)
                }
                out = append(out, str)
            }
            return out, nil
        case []string:
            return vv, nil
        default:
            return nil, fmt.Errorf("output %q is not a list of strings (got %T)", key, v)
        }
    }

    // --------------------------------------------------------------------
    var err error

    if res.TableArn, err = getString(OutputTableArn); err != nil {
        return nil, err
    }
    if res.TableName, err = getString(OutputTableName); err != nil {
        return nil, err
    }
    if res.TableId, err = getString(OutputTableID); err != nil {
        return nil, err
    }
    if res.KmsKeyArn, err = getString(OutputKMSKeyArn); err != nil {
        return nil, err
    }
    if res.GlobalSecondaryIndexNames, err = getStringSlice(OutputGlobalSecondaryIndexNames); err != nil {
        return nil, err
    }
    if res.LocalSecondaryIndexNames, err = getStringSlice(OutputLocalSecondaryIndexNames); err != nil {
        return nil, err
    }

    // Stream (nested object) ---------------------------------------------
    if raw, ok := outputs[OutputStream]; ok {
        m, ok := raw.(map[string]any)
        if !ok {
            return nil, fmt.Errorf("output %q is not an object (got %T)", OutputStream, raw)
        }

        stream := &awsdynamodbpb.Stream{}

        if stream.StreamArn, err = func() (string, error) {
            v, ok := m[OutputStreamArn]
            if !ok {
                return "", nil
            }
            s, ok := v.(string)
            if !ok {
                return "", fmt.Errorf("stream.%s is not a string (got %T)", OutputStreamArn, v)
            }
            return s, nil
        }(); err != nil {
            return nil, err
        }

        if stream.StreamLabel, err = func() (string, error) {
            v, ok := m[OutputStreamLabel]
            if !ok {
                return "", nil
            }
            s, ok := v.(string)
            if !ok {
                return "", fmt.Errorf("stream.%s is not a string (got %T)", OutputStreamLabel, v)
            }
            return s, nil
        }(); err != nil {
            return nil, err
        }

        res.Stream = stream
    }

    return res, nil
}
