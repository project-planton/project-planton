// Code generated by project-planton scaffolder. DO NOT EDIT.
//
// File: outputs.go
// Purpose: Defines stack-output key constants and a collectOutputs helper that
// marshals Pulumi resource attributes into the AwsDynamodbStackOutputs protobuf
// message and registers them as stack outputs.

package awsdynamodb

import (
    "reflect"

    dynamodb "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
    "google.golang.org/protobuf/encoding/protojson"
)

// Well-known stack-output keys. They match the field names of
// AwsDynamodbStackOutputs in snake_case so downstream code can rely on stable
// identifiers irrespective of the Pulumi code structure.
const (
    KeyTableARN                    = "table_arn"
    KeyTableName                   = "table_name"
    KeyTableID                     = "table_id"
    KeyStream                      = "stream"
    KeyKmsKeyArn                   = "kms_key_arn"
    KeyGlobalSecondaryIndexNames   = "global_secondary_index_names"
    KeyLocalSecondaryIndexNames    = "local_secondary_index_names"

    // KeyAwsDynamodbJSON is a convenience export that contains the complete
    // AwsDynamodbStackOutputs protobuf message (JSON-encoded).
    KeyAwsDynamodbJSON = "aws_dynamodb"
)

// collectOutputs gathers interesting attributes from the provisioned DynamoDB
// table and registers them as Pulumi stack outputs. Besides individual fields,
// the function also exports the full AwsDynamodbStackOutputs message encoded as
// JSON for machine-friendly consumption by CI/CD tooling.
func collectOutputs(ctx *pulumi.Context, table *dynamodb.Table) error { // nolint:funlen
    // Helper that converts the (provider-specific) index representation returned
    // by the AWS provider into a slice of index names.
    extractIndexNames := func(idx interface{}) []string {
        names := make([]string, 0)
        if idx == nil {
            return names
        }

        // The underlying type varies depending on the path taken by the provider
        // during diff/apply. Handle the handful of formats we observe.
        switch v := idx.(type) {
        case []interface{}:
            for _, raw := range v {
                switch i := raw.(type) {
                case map[string]interface{}:
                    if n, ok := i["name"].(string); ok {
                        names = append(names, n)
                    }
                case string: // Some provider versions already collapse to string.
                    names = append(names, i)
                }
            }
        case []dynamodb.TableGlobalSecondaryIndex: // When the AWS SDK keeps type info.
            for _, g := range v {
                names = append(names, g.Name)
            }
        case []dynamodb.TableLocalSecondaryIndex:
            // TableLocalSecondaryIndex has the same shape (Name field).
            rv := reflect.ValueOf(v)
            for i := 0; i < rv.Len(); i++ {
                field := rv.Index(i).FieldByName("Name")
                if field.IsValid() && field.Kind() == reflect.String {
                    names = append(names, field.String())
                }
            }
        }
        return names
    }

    // Aggregate all interesting outputs in one shot so we can create the proto
    // message from strongly-typed Go values.
    protoOutput := pulumi.All(
        table.Arn,                         // 0
        table.Name,                        // 1
        table.ID().ToStringOutput(),       // 2
        table.StreamArn,                   // 3
        table.StreamLabel,                 // 4
        table.KmsKeyArn,                   // 5
        table.GlobalSecondaryIndexes,      // 6
        table.LocalSecondaryIndexes,       // 7
    ).ApplyT(func(args []interface{}) (*awsdynamodbpb.AwsDynamodbStackOutputs, error) {
        out := &awsdynamodbpb.AwsDynamodbStackOutputs{
            TableArn: args[0].(string),
            TableName: args[1].(string),
            TableId: args[2].(string),
            GlobalSecondaryIndexNames: extractIndexNames(args[6]),
            LocalSecondaryIndexNames:  extractIndexNames(args[7]),
        }

        // Optional fields â€“ add them only when the provider returned values.
        if v := args[5]; v != nil {
            switch data := v.(type) {
            case *string:
                if data != nil {
                    out.KmsKeyArn = *data
                }
            case string:
                out.KmsKeyArn = data
            }
        }

        // Stream (only when enabled).
        if arnRaw := args[3]; arnRaw != nil {
            var arn, label string
            switch a := arnRaw.(type) {
            case *string:
                if a != nil {
                    arn = *a
                }
            case string:
                arn = a
            }
            if arn != "" {
                // stream_label may legitimately be empty.
                switch l := args[4].(type) {
                case *string:
                    if l != nil {
                        label = *l
                    }
                case string:
                    label = l
                }
                out.Stream = &awsdynamodbpb.Stream{
                    StreamArn:  arn,
                    StreamLabel: label,
                }
            }
        }

        return out, nil
    }).(*pulumi.OutputState)

    // Export the JSON-encoded protobuf message for machine consumption.
    ctx.Export(KeyAwsDynamodbJSON, protoOutput.ApplyT(func(o *awsdynamodbpb.AwsDynamodbStackOutputs) (string, error) {
        if o == nil {
            return "", nil
        }
        b, err := protojson.Marshal(o)
        if err != nil {
            return "", err
        }
        return string(b), nil
    }).(pulumi.StringOutput))

    // Export individual convenience fields to the stack.
    ctx.Export(KeyTableARN, table.Arn)
    ctx.Export(KeyTableName, table.Name)
    ctx.Export(KeyTableID, table.ID().ToStringOutput())
    ctx.Export(KeyKmsKeyArn, table.KmsKeyArn)

    // Export the list of index names.
    ctx.Export(KeyGlobalSecondaryIndexNames, protoOutput.ApplyT(func(o *awsdynamodbpb.AwsDynamodbStackOutputs) []string {
        if o == nil {
            return nil
        }
        return o.GlobalSecondaryIndexNames
    }).(pulumi.StringArrayOutput))

    ctx.Export(KeyLocalSecondaryIndexNames, protoOutput.ApplyT(func(o *awsdynamodbpb.AwsDynamodbStackOutputs) []string {
        if o == nil {
            return nil
        }
        return o.LocalSecondaryIndexNames
    }).(pulumi.StringArrayOutput))

    // Export stream map if present.
    ctx.Export(KeyStream, protoOutput.ApplyT(func(o *awsdynamodbpb.AwsDynamodbStackOutputs) map[string]string {
        if o == nil || o.Stream == nil {
            return nil
        }
        return map[string]string{
            "stream_arn":  o.Stream.StreamArn,
            "stream_label": o.Stream.StreamLabel,
        }
    }).(pulumi.MapOutput))

    return nil
}
