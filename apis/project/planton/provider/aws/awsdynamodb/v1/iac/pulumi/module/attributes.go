// Code generated by project-planton. DO NOT EDIT.

package awsdynamodb

import (
    "fmt"

    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
)

// BuildTableAttributes converts the AttributeDefinitions and KeySchema contained in the
// AwsDynamodbSpec into their Pulumi equivalents that are required when instantiating
// an aws.dynamodb.Table resource.
//
// The function returns:
//   1. A slice of TableAttributeInput objects (the full set of attribute definitions).
//   2. A pulumi.StringInput holding the HASH (partition) key name.
//   3. A pulumi.StringPtrInput holding the RANGE (sort) key name, if one exists.  It
//      will be nil when the table schema does not declare a sort key.
//
// Any semantic inconsistencies – such as missing attribute definitions referenced
// in the key schema, multiple HASH/RANGE keys or the use of an unsupported scalar
// attribute type – are surfaced as errors so they can be handled by the caller
// during plan-time validation.
func BuildTableAttributes(
    spec *awsdynamodbpb.AwsDynamodbSpec,
) (dynamodb.TableAttributeArray, pulumi.StringInput, pulumi.StringPtrInput, error) {
    if spec == nil {
        return nil, nil, nil, fmt.Errorf("BuildTableAttributes: spec must not be nil")
    }

    // -------------------------------------------------------------------------
    // 1. Build a map of attribute_name -> AttributeDefinition for quick look-up
    // -------------------------------------------------------------------------
    attrMap := make(map[string]*awsdynamodbpb.AttributeDefinition, len(spec.AttributeDefinitions))
    for _, ad := range spec.AttributeDefinitions {
        if _, exists := attrMap[ad.GetAttributeName()]; exists {
            return nil, nil, nil, fmt.Errorf("duplicate attribute definition for %q", ad.GetAttributeName())
        }
        // Enforce that the attribute has a supported scalar type while we are here.
        if _, err := toPulumiAttributeType(ad.GetAttributeType()); err != nil {
            return nil, nil, nil, fmt.Errorf("attribute %q: %w", ad.GetAttributeName(), err)
        }
        attrMap[ad.GetAttributeName()] = ad
    }

    // -------------------------------------------------------------
    // 2. Determine the HASH and (optional) RANGE key from KeySchema
    // -------------------------------------------------------------
    var (
        hashKeyName  string
        rangeKeyName *string
    )

    for _, el := range spec.KeySchema {
        switch el.GetKeyType() {
        case awsdynamodbpb.KeyType_HASH:
            if hashKeyName != "" {
                return nil, nil, nil, fmt.Errorf("multiple HASH keys defined (%q and %q)", hashKeyName, el.GetAttributeName())
            }
            hashKeyName = el.GetAttributeName()
        case awsdynamodbpb.KeyType_RANGE:
            if rangeKeyName != nil {
                return nil, nil, nil, fmt.Errorf("multiple RANGE keys defined (%q and %q)", *rangeKeyName, el.GetAttributeName())
            }
            n := el.GetAttributeName()
            rangeKeyName = &n
        default:
            return nil, nil, nil, fmt.Errorf("key schema element %q has unsupported key type %v", el.GetAttributeName(), el.GetKeyType())
        }

        // Make sure every key attribute has a corresponding AttributeDefinition.
        if _, ok := attrMap[el.GetAttributeName()]; !ok {
            return nil, nil, nil, fmt.Errorf("key schema refers to undefined attribute %q", el.GetAttributeName())
        }
    }

    if hashKeyName == "" {
        return nil, nil, nil, fmt.Errorf("exactly one HASH key must be specified in key_schema")
    }

    // ---------------------------------------------------------
    // 3. Translate proto AttributeDefinitions into Pulumi type
    // ---------------------------------------------------------
    pulumiAttrs := make(dynamodb.TableAttributeArray, 0, len(spec.AttributeDefinitions))
    for _, ad := range spec.AttributeDefinitions {
        scalarType, _ := toPulumiAttributeType(ad.GetAttributeType())

        pulumiAttrs = append(pulumiAttrs, dynamodb.TableAttributeArgs{
            Name: pulumi.String(ad.GetAttributeName()),
            Type: pulumi.String(scalarType),
        })
    }

    // ---------------------------------------------------------
    // 4. Return the fully-materialised Pulumi structures
    // ---------------------------------------------------------
    var rk pulumi.StringPtrInput
    if rangeKeyName != nil {
        rk = pulumi.StringPtr(*rangeKeyName)
    }

    return pulumiAttrs, pulumi.String(hashKeyName), rk, nil
}

// toPulumiAttributeType converts the proto-level AttributeType enum into the scalar
// types understood by the AWS provider ("S", "N" or "B").
func toPulumiAttributeType(t awsdynamodbpb.AttributeType) (string, error) {
    switch t {
    case awsdynamodbpb.AttributeType_STRING:
        return "S", nil
    case awsdynamodbpb.AttributeType_NUMBER:
        return "N", nil
    case awsdynamodbpb.AttributeType_BINARY:
        return "B", nil
    default:
        return "", fmt.Errorf("unsupported attribute_type %v", t)
    }
}
