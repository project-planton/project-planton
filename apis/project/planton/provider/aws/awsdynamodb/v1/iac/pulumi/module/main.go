// Code generated by Project Planton – DO NOT EDIT.
// This Pulumi program materialises an Amazon DynamoDB table based on the
// AwsDynamodbSpec Stack Input and exports the identifiers defined by
// AwsDynamodbStackOutputs.
package main

import (
    "encoding/json"
    "fmt"
    "strings"

    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

/* --------------------------------------------------------------------------
Helpers – small conversions between the protobuf-shaped StackInput payload and
what the AWS provider expects. They are intentionally kept small and local to
this file so that the program remains completely self-contained.
-------------------------------------------------------------------------- */

func toAttributeType(t string) (string, error) {
    switch strings.ToUpper(t) {
    case "S", "STRING":
        return "S", nil
    case "N", "NUMBER":
        return "N", nil
    case "B", "BINARY":
        return "B", nil
    default:
        return "", fmt.Errorf("unsupported DynamoDB attribute type %q", t)
    }
}

func toKeyType(t string) (string, error) {
    switch strings.ToUpper(t) {
    case "HASH":
        return "HASH", nil
    case "RANGE":
        return "RANGE", nil
    default:
        return "", fmt.Errorf("unsupported key type %q", t)
    }
}

func toProjectionType(t string) (string, error) {
    switch strings.ToUpper(t) {
    case "ALL":
        return "ALL", nil
    case "KEYS_ONLY":
        return "KEYS_ONLY", nil
    case "INCLUDE":
        return "INCLUDE", nil
    default:
        return "", fmt.Errorf("unsupported projection type %q", t)
    }
}

/* --------------------------------------------------------------------------
StackInput – a Go representation of AwsDynamodbSpec. Only the fields that this
program needs are modelled; the protobuf definition is far more exhaustive, but
the omitted fields are irrelevant for resource creation.
-------------------------------------------------------------------------- */

// AttributeDefinition mirrors AwsDynamodbSpec.AttributeDefinition (subset).
type AttributeDefinition struct {
    AttributeName string `json:"attributeName"`
    AttributeType string `json:"attributeType"`
}

// KeySchemaElement mirrors AwsDynamodbSpec.KeySchemaElement (subset).
type KeySchemaElement struct {
    AttributeName string `json:"attributeName"`
    KeyType       string `json:"keyType"`
}

type ProvisionedThroughput struct {
    ReadCapacityUnits  int `json:"readCapacityUnits"`
    WriteCapacityUnits int `json:"writeCapacityUnits"`
}

// Projection model (subset).
type Projection struct {
    ProjectionType   string   `json:"projectionType"`
    NonKeyAttributes []string `json:"nonKeyAttributes,omitempty"`
}

// GlobalSecondaryIndex mirrors AwsDynamodbSpec.GlobalSecondaryIndex (subset).
type GlobalSecondaryIndex struct {
    IndexName            string                 `json:"indexName"`
    KeySchema            []KeySchemaElement     `json:"keySchema"`
    Projection           Projection             `json:"projection"`
    ProvisionedThroughput *ProvisionedThroughput `json:"provisionedThroughput,omitempty"`
}

// LocalSecondaryIndex mirrors AwsDynamodbSpec.LocalSecondaryIndex (subset).
type LocalSecondaryIndex struct {
    IndexName  string             `json:"indexName"`
    KeySchema  []KeySchemaElement `json:"keySchema"`
    Projection Projection         `json:"projection"`
}

type StreamSpecification struct {
    StreamEnabled  bool   `json:"streamEnabled"`
    StreamViewType string `json:"streamViewType"`
}

type TimeToLiveSpecification struct {
    TtlEnabled    bool   `json:"ttlEnabled"`
    AttributeName string `json:"attributeName"`
}

type SSESpecification struct {
    Enabled        bool   `json:"enabled"`
    SseType        string `json:"sseType"`
    KmsMasterKeyId string `json:"kmsMasterKeyId"`
}

// StackInput is the root message (AwsDynamodbSpec).
type StackInput struct {
    TableName                   string                     `json:"tableName"`
    AttributeDefinitions        []AttributeDefinition      `json:"attributeDefinitions"`
    KeySchema                   []KeySchemaElement         `json:"keySchema"`
    BillingMode                 string                     `json:"billingMode"`
    ProvisionedThroughput       *ProvisionedThroughput     `json:"provisionedThroughput,omitempty"`
    GlobalSecondaryIndexes      []GlobalSecondaryIndex     `json:"globalSecondaryIndexes,omitempty"`
    LocalSecondaryIndexes       []LocalSecondaryIndex      `json:"localSecondaryIndexes,omitempty"`
    StreamSpecification         *StreamSpecification       `json:"streamSpecification,omitempty"`
    TtlSpecification            *TimeToLiveSpecification   `json:"ttlSpecification,omitempty"`
    SseSpecification            *SSESpecification          `json:"sseSpecification,omitempty"`
    PointInTimeRecoveryEnabled  bool                       `json:"pointInTimeRecoveryEnabled"`
    Tags                        map[string]string          `json:"tags,omitempty"`
}

/* --------------------------------------------------------------------------
main – Pulumi entry-point.
-------------------------------------------------------------------------- */

func main() {
    pulumi.Run(func(ctx *pulumi.Context) error {
        // ---------------------------------------------------------------------
        // 1. Read and decode the StackInput (AwsDynamodbSpec) from Pulumi
        //    configuration.  The configuration key is "spec" at the root level
        //    of the current Pulumi stack configuration.
        // ---------------------------------------------------------------------
        cfg := pulumi.NewConfig(ctx)
        specJSON := cfg.Require("spec")

        var in StackInput
        if err := json.Unmarshal([]byte(specJSON), &in); err != nil {
            return fmt.Errorf("unable to parse stack input: %w", err)
        }

        // ---------------------------------------------------------------------
        // 2. Translate StackInput → AWS provider arguments.
        // ---------------------------------------------------------------------

        // 2.1  Table attributes.
        attrs := make(dynamodb.TableAttributeArray, 0, len(in.AttributeDefinitions))
        for _, ad := range in.AttributeDefinitions {
            t, err := toAttributeType(ad.AttributeType)
            if err != nil {
                return err
            }
            attrs = append(attrs, dynamodb.TableAttributeArgs{
                Name: pulumi.String(ad.AttributeName),
                Type: pulumi.String(t),
            })
        }

        // 2.2  Hash & range key for the table.
        var hashKey, rangeKey *string
        for _, ks := range in.KeySchema {
            kt, err := toKeyType(ks.KeyType)
            if err != nil {
                return err
            }
            switch kt {
            case "HASH":
                hashKey = pulumi.StringPtr(ks.AttributeName)
            case "RANGE":
                rangeKey = pulumi.StringPtr(ks.AttributeName)
            }
        }
        if hashKey == nil {
            return fmt.Errorf("key_schema must contain a HASH key")
        }

        // 2.3  Global Secondary Indexes (GSIs).
        gsiArgs := make(dynamodb.TableGlobalSecondaryIndexArray, 0, len(in.GlobalSecondaryIndexes))
        for _, gsi := range in.GlobalSecondaryIndexes {
            var gHash, gRange *string
            for _, ks := range gsi.KeySchema {
                kt, err := toKeyType(ks.KeyType)
                if err != nil {
                    return err
                }
                switch kt {
                case "HASH":
                    gHash = pulumi.StringPtr(ks.AttributeName)
                case "RANGE":
                    gRange = pulumi.StringPtr(ks.AttributeName)
                }
            }
            if gHash == nil {
                return fmt.Errorf("GSI %q lacks a HASH key", gsi.IndexName)
            }

            projType, err := toProjectionType(gsi.Projection.ProjectionType)
            if err != nil {
                return err
            }

            var nonKey pulumi.StringArray
            for _, n := range gsi.Projection.NonKeyAttributes {
                nonKey = append(nonKey, pulumi.String(n))
            }

            gsiArgs = append(gsiArgs, dynamodb.TableGlobalSecondaryIndexArgs{
                Name:             pulumi.String(gsi.IndexName),
                HashKey:          pulumi.StringPtrInput(pulumi.StringPtr(*gHash)),
                RangeKey:         pulumi.StringPtrInput(pulumi.StringPtr(gRangeToPtr(gRange))),
                ProjectionType:   pulumi.String(projType),
                NonKeyAttributes: nonKey,
            })

            // Provisioned capacity per-GSI (only when PROVISIONED billing).
            if in.BillingMode == "PROVISIONED" && gsi.ProvisionedThroughput != nil {
                gsiArgs[len(gsiArgs)-1].ReadCapacity = pulumi.Int(gsi.ProvisionedThroughput.ReadCapacityUnits)
                gsiArgs[len(gsiArgs)-1].WriteCapacity = pulumi.Int(gsi.ProvisionedThroughput.WriteCapacityUnits)
            }
        }

        // 2.4  Local Secondary Indexes (LSIs).
        lsiArgs := make(dynamodb.TableLocalSecondaryIndexArray, 0, len(in.LocalSecondaryIndexes))
        for _, lsi := range in.LocalSecondaryIndexes {
            var lHash, lRange *string
            for _, ks := range lsi.KeySchema {
                kt, err := toKeyType(ks.KeyType)
                if err != nil {
                    return err
                }
                switch kt {
                case "HASH":
                    lHash = pulumi.StringPtr(ks.AttributeName)
                case "RANGE":
                    lRange = pulumi.StringPtr(ks.AttributeName)
                }
            }
            if lHash == nil || lRange == nil {
                return fmt.Errorf("LSI %q must include both HASH and RANGE keys", lsi.IndexName)
            }

            projType, err := toProjectionType(lsi.Projection.ProjectionType)
            if err != nil {
                return err
            }

            var nonKey pulumi.StringArray
            for _, n := range lsi.Projection.NonKeyAttributes {
                nonKey = append(nonKey, pulumi.String(n))
            }

            lsiArgs = append(lsiArgs, dynamodb.TableLocalSecondaryIndexArgs{
                Name:             pulumi.String(lsi.IndexName),
                RangeKey:         pulumi.StringPtrInput(pulumi.StringPtr(*lRange)),
                ProjectionType:   pulumi.String(projType),
                NonKeyAttributes: nonKey,
            })
        }

        // 2.5  Construct TableArgs.
        tableArgs := &dynamodb.TableArgs{
            Name:        pulumi.StringPtr(in.TableName),
            Attributes:  attrs,
            HashKey:     pulumi.StringPtrInput(pulumi.StringPtr(*hashKey)),
            GlobalSecondaryIndexes: gsiArgs,
            LocalSecondaryIndexes:  lsiArgs,
            Tags:                  pulumi.ToStringMap(in.Tags),
        }

        if rangeKey != nil {
            tableArgs.RangeKey = pulumi.StringPtrInput(pulumi.StringPtr(*rangeKey))
        }

        // Billing mode / capacity.
        switch strings.ToUpper(in.BillingMode) {
        case "PAY_PER_REQUEST":
            tableArgs.BillingMode = pulumi.String("PAY_PER_REQUEST")
        case "PROVISIONED":
            tableArgs.BillingMode = pulumi.String("PROVISIONED")
            if in.ProvisionedThroughput == nil {
                return fmt.Errorf("billing_mode is PROVISIONED but provisioned_throughput is missing")
            }
            tableArgs.ReadCapacity = pulumi.Int(in.ProvisionedThroughput.ReadCapacityUnits)
            tableArgs.WriteCapacity = pulumi.Int(in.ProvisionedThroughput.WriteCapacityUnits)
        default:
            return fmt.Errorf("unsupported billing mode %q", in.BillingMode)
        }

        // Streams.
        if in.StreamSpecification != nil && in.StreamSpecification.StreamEnabled {
            tableArgs.StreamEnabled = pulumi.Bool(true)
            tableArgs.StreamViewType = pulumi.String(in.StreamSpecification.StreamViewType)
        }

        // TTL.
        if in.TtlSpecification != nil && in.TtlSpecification.TtlEnabled {
            tableArgs.Ttl = &dynamodb.TableTtlArgs{
                Enabled:       pulumi.Bool(true),
                AttributeName: pulumi.String(in.TtlSpecification.AttributeName),
            }
        }

        // Server-side encryption.
        if in.SseSpecification != nil && in.SseSpecification.Enabled {
            tableArgs.ServerSideEncryption = &dynamodb.TableServerSideEncryptionArgs{
                Enabled: pulumi.Bool(true),
            }
            if strings.ToUpper(in.SseSpecification.SseType) == "KMS" && in.SseSpecification.KmsMasterKeyId != "" {
                tableArgs.ServerSideEncryption.KmsKeyArn = pulumi.String(in.SseSpecification.KmsMasterKeyId)
            }
        }

        // Point-in-time recovery.
        if in.PointInTimeRecoveryEnabled {
            tableArgs.PointInTimeRecovery = &dynamodb.TablePointInTimeRecoveryArgs{
                Enabled: pulumi.Bool(true),
            }
        }

        // ---------------------------------------------------------------------
        // 3. Create the DynamoDB table.
        // ---------------------------------------------------------------------
        table, err := dynamodb.NewTable(ctx, in.TableName, tableArgs)
        if err != nil {
            return err
        }

        // ---------------------------------------------------------------------
        // 4. Export stack outputs (AwsDynamodbStackOutputs).
        // ---------------------------------------------------------------------
        ctx.Export("table_arn", table.Arn)
        ctx.Export("table_name", table.Name)
        ctx.Export("table_id", table.ID().ToStringOutput())

        // Streams (only when enabled).
        if in.StreamSpecification != nil && in.StreamSpecification.StreamEnabled {
            ctx.Export("stream_arn", table.StreamArn)
            ctx.Export("stream_label", table.StreamLabel)
        }

        // KMS CMK ARN (when applicable).
        if in.SseSpecification != nil && in.SseSpecification.Enabled &&
            strings.ToUpper(in.SseSpecification.SseType) == "KMS" &&
            in.SseSpecification.KmsMasterKeyId != "" {
            ctx.Export("kms_key_arn", pulumi.String(in.SseSpecification.KmsMasterKeyId))
        }

        // Index names.
        var gsiNames, lsiNames pulumi.StringArray
        for _, g := range in.GlobalSecondaryIndexes {
            gsiNames = append(gsiNames, pulumi.String(g.IndexName))
        }
        for _, l := range in.LocalSecondaryIndexes {
            lsiNames = append(lsiNames, pulumi.String(l.IndexName))
        }
        if len(gsiNames) > 0 {
            ctx.Export("global_secondary_index_names", gsiNames)
        }
        if len(lsiNames) > 0 {
            ctx.Export("local_secondary_index_names", lsiNames)
        }

        return nil
    })
}

/* --------------------------------------------------------------------------
small util – nil-safe helper for pointer dereference.
-------------------------------------------------------------------------- */

func gRangeToPtr(p *string) string {
    if p == nil {
        return ""
    }
    return *p
}
