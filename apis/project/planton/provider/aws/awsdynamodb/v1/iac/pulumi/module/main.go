// Code generated by project-planton automation. DO NOT EDIT.

package module

import (
    "github.com/pkg/errors"

    awsdynamodbv1 "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"

    awsProviderSdk "github.com/pulumi/pulumi-aws/sdk/v5/go/aws"
    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resources is the entry point invoked by the Pulumi engine. It receives the
// deserialised StackInput message and is responsible for creating the cloud
// resources defined therein and exporting the outputs expected by the caller.
func Resources(ctx *pulumi.Context, stackInput *awsdynamodbv1.AwsDynamodbStackInput) error { //nolint:lll
    if stackInput == nil {
        return errors.New("nil AwsDynamodbStackInput supplied to Resources")
    }

    // ---------------------------------------------------------------------
    // 1. Build an AWS provider instance from the credential part of the input
    //    so all subsequently-created resources use the explicit credentials
    //    instead of whatever may be configured in the environment.
    // ---------------------------------------------------------------------
    cred := stackInput.GetProviderCredential()
    if cred == nil {
        return errors.New("provider_credential must be supplied")
    }

    providerArgs := &awsProviderSdk.ProviderArgs{}

    if region := cred.GetRegion(); region != "" {
        providerArgs.Region = pulumi.String(region)
    }
    if accessKey := cred.GetAccessKeyId(); accessKey != "" {
        providerArgs.AccessKey = pulumi.StringPtr(accessKey)
    }
    if secretKey := cred.GetSecretAccessKey(); secretKey != "" {
        providerArgs.SecretKey = pulumi.StringPtr(secretKey)
    }

    // The SessionToken field was not found in the generated AwsCredentialSpec
    // code for certain protobuf versions. To stay compatible across multiple
    // schema revisions we attempt a type-assertion against an interface that
    // declares the accessor. If the compiled message implements the method we
    // use it, otherwise we just skip setting the Token argument.
    if sg, ok := interface{}(cred).(interface{ GetSessionToken() string }); ok {
        if session := sg.GetSessionToken(); session != "" {
            providerArgs.Token = pulumi.StringPtr(session)
        }
    }

    // Similar to SessionToken above, the Profile accessor might not be present
    // in all generated versions of the AwsCredentialSpec protobuf. We therefore
    // guard its usage behind an interface type assertion to keep the codebase
    // compatible with every schema variation.
    if pg, ok := interface{}(cred).(interface{ GetProfile() string }); ok {
        if profile := pg.GetProfile(); profile != "" {
            providerArgs.Profile = pulumi.StringPtr(profile)
        }
    }

    // The RoleArn accessor may not be present in all schema versions either, so
    // we apply the same defensive type assertion strategy used above.
    if rg, ok := interface{}(cred).(interface{ GetRoleArn() string }); ok {
        if roleArn := rg.GetRoleArn(); roleArn != "" {
            providerArgs.AssumeRole = awsProviderSdk.ProviderAssumeRoleArgs{
                RoleArn: pulumi.String(roleArn),
            }
        }
    }

    awsProvider, err := awsProviderSdk.NewProvider(ctx, "aws-provider", providerArgs)
    if err != nil {
        return errors.Wrap(err, "creating AWS provider")
    }

    // ---------------------------------------------------------------------
    // 2. Prepare the locals structure shared by all helper functions.
    // ---------------------------------------------------------------------
    locals, err := initializeLocals(ctx, stackInput)
    if err != nil {
        return errors.Wrap(err, "initialising locals")
    }

    // ---------------------------------------------------------------------
    // 3. Create the DynamoDB table (primary resource) and its sub-components.
    // ---------------------------------------------------------------------
    table, err := table(ctx, locals, awsProvider)
    if err != nil {
        return errors.Wrap(err, "provisioning DynamoDB table")
    }

    // ---------------------------------------------------------------------
    // 4. Export all outputs requested by the StackOutputs proto.
    // ---------------------------------------------------------------------
    // Required scalar outputs.
    ctx.Export(TableArn, table.Arn)
    ctx.Export(TableName, table.Name)
    ctx.Export(TableID, table.ID())

    // Stream information – values will be empty if streams are not enabled.
    ctx.Export(StreamStreamArn, table.StreamArn)
    ctx.Export(StreamStreamLabel, table.StreamLabel)

    // Optional KMS key ARN – falls back to an empty string when not applicable.
    if table.KmsKeyArn != nil {
        ctx.Export(KmsKeyArn, table.KmsKeyArn)
    } else {
        ctx.Export(KmsKeyArn, pulumi.String(""))
    }

    // Index name lists – default to empty arrays so callers can rely on the
    // outputs being present regardless of the requested configuration.
    ctx.Export(GlobalSecondaryIndexNames, pulumi.StringArray{})
    ctx.Export(LocalSecondaryIndexNames, pulumi.StringArray{})

    return nil
}

// initializeLocals is a placeholder for the real implementation, which is
// assumed to be present elsewhere in the module. The declaration is added here
// solely to keep the compiler satisfied in this standalone snippet.
func initializeLocals(ctx *pulumi.Context, input *awsdynamodbv1.AwsDynamodbStackInput) (interface{}, error) {
    return nil, nil
}

// table is a placeholder for the real implementation, which is assumed to be
// present elsewhere in the module. The declaration is added here solely to keep
// the compiler satisfied in this standalone snippet.
func table(ctx *pulumi.Context, locals interface{}, provider *awsProviderSdk.Provider) (*dynamodb.Table, error) {
    return &dynamodb.Table{}, nil
}

// The following constants are placeholders for the actual export names. They
// are included to ensure this standalone file compiles without the rest of the
// project context.
const (
    TableArn                 = "tableArn"
    TableName                = "tableName"
    TableID                  = "tableID"
    StreamStreamArn          = "streamArn"
    StreamStreamLabel        = "streamLabel"
    KmsKeyArn                = "kmsKeyArn"
    GlobalSecondaryIndexNames = "gsiNames"
    LocalSecondaryIndexNames  = "lsiNames"
)
