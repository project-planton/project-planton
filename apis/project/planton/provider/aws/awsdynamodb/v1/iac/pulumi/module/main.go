// Code generated by Project Planton. DO NOT EDIT.
package main

import (
	"fmt"

	awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"

	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/dynamodb"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
)

// Resources provisions a DynamoDB table based on the supplied spec and registers
// all observable identifiers as stack exports.
func Resources(ctx *pulumi.Context, in *awsdynamodbpb.AwsDynamodbSpec) error {
	if in == nil {
		return fmt.Errorf("input spec must not be nil")
	}

	// ---------------------------------------------------------------------
	// Attribute definitions
	// ---------------------------------------------------------------------
	var attrs dynamodb.TableAttributeArray
	for _, a := range in.AttributeDefinitions {
		attrs = append(attrs, dynamodb.TableAttributeArgs{
			Name: pulumi.String(a.AttributeName),
			Type: pulumi.String(attributeTypeToAWS(a.AttributeType)),
		})
	}

	// ---------------------------------------------------------------------
	// Primary key schema
	// ---------------------------------------------------------------------
	hashKey, rangeKey, err := splitKeySchema(in.KeySchema)
	if err != nil {
		return err
	}

	// ---------------------------------------------------------------------
	// Global secondary indexes
	// ---------------------------------------------------------------------
	var gsis dynamodb.TableGlobalSecondaryIndexArray
	for _, g := range in.GlobalSecondaryIndexes {
		gHash, gRange, err := splitKeySchema(g.KeySchema)
		if err != nil {
			return fmt.Errorf("global secondary index %q: %w", g.IndexName, err)
		}

		projType := projectionTypeToAWS(g.Projection.ProjectionType)
		var nonKeyAttrs pulumi.StringArray
		for _, n := range g.Projection.NonKeyAttributes {
			nonKeyAttrs = append(nonKeyAttrs, pulumi.String(n))
		}

		gsi := dynamodb.TableGlobalSecondaryIndexArgs{
			Name:             pulumi.String(g.IndexName),
			HashKey:          pulumi.String(gHash),
			ProjectionType:   pulumi.String(projType),
			NonKeyAttributes: nonKeyAttrs,
		}
		if gRange != "" {
			gsi.RangeKey = pulumi.StringPtr(gRange)
		}
		// Provisioned throughput is allowed only with PROVISIONED billing mode.
		if in.BillingMode == awsdynamodbpb.BillingMode_PROVISIONED && g.ProvisionedThroughput != nil {
			gsi.ReadCapacity = pulumi.IntPtr(int(g.ProvisionedThroughput.ReadCapacityUnits))
			gsi.WriteCapacity = pulumi.IntPtr(int(g.ProvisionedThroughput.WriteCapacityUnits))
		}
		gsis = append(gsis, gsi)
	}

	// ---------------------------------------------------------------------
	// Local secondary indexes
	// ---------------------------------------------------------------------
	var lsis dynamodb.TableLocalSecondaryIndexArray
	for _, l := range in.LocalSecondaryIndexes {
		// The HASH key is inherited from the table; only RANGE key is supplied.
		_, lRange, err := splitKeySchema(l.KeySchema)
		if err != nil {
			return fmt.Errorf("local secondary index %q: %w", l.IndexName, err)
		}

		projType := projectionTypeToAWS(l.Projection.ProjectionType)
		var nonKeyAttrs pulumi.StringArray
		for _, n := range l.Projection.NonKeyAttributes {
			nonKeyAttrs = append(nonKeyAttrs, pulumi.String(n))
		}

		lsi := dynamodb.TableLocalSecondaryIndexArgs{
			Name:             pulumi.String(l.IndexName),
			RangeKey:         pulumi.String(lRange),
			ProjectionType:   pulumi.StringPtr(projType),
			NonKeyAttributes: nonKeyAttrs,
		}
		lsis = append(lsis, lsi)
	}

	// ---------------------------------------------------------------------
	// Optional blocks
	// ---------------------------------------------------------------------
	var ttl dynamodb.TableTtlPtrInput
	if in.TtlSpecification != nil && in.TtlSpecification.TtlEnabled {
		ttl = dynamodb.TableTtlArgs{
			AttributeName: pulumi.StringPtr(in.TtlSpecification.AttributeName),
			Enabled:       pulumi.BoolPtr(in.TtlSpecification.TtlEnabled),
		}
	}

	var sse dynamodb.TableServerSideEncryptionPtrInput
	var kmsKeyArn pulumi.StringPtrInput
	if in.SseSpecification != nil && in.SseSpecification.Enabled {
		if in.SseSpecification.SseType == awsdynamodbpb.SSEType_KMS {
			kmsKeyArn = pulumi.StringPtr(in.SseSpecification.KmsMasterKeyId)
		}
		sse = dynamodb.TableServerSideEncryptionArgs{
			Enabled:    pulumi.Bool(true),
			KmsKeyArn:  kmsKeyArn,
		}
	}

	var pitr dynamodb.TablePointInTimeRecoveryPtrInput
	if in.PointInTimeRecoveryEnabled {
		pitr = dynamodb.TablePointInTimeRecoveryArgs{
			Enabled: pulumi.BoolPtr(true),
		}
	}

	var streamEnabled *bool
	var streamViewType *string
	if in.StreamSpecification != nil && in.StreamSpecification.StreamEnabled {
		streamEnabled = pulumi.BoolPtr(true).Elem()
		view := streamViewTypeToAWS(in.StreamSpecification.StreamViewType)
		streamViewType = &view
	}

	// Tags
	tags := pulumi.StringMap{}
	for k, v := range in.Tags {
		tags[k] = pulumi.String(v)
	}

	// ---------------------------------------------------------------------
	// Create the DynamoDB table
	// ---------------------------------------------------------------------
	args := &dynamodb.TableArgs{
		Attributes:            attrs,
		HashKey:               pulumi.String(hashKey),
		ReadCapacity:          nil,
		WriteCapacity:         nil,
		BillingMode:           nil,
		RangeKey:              nil,
		GlobalSecondaryIndexes: gsis,
		LocalSecondaryIndexes:  lsis,
		Ttl:                    ttl,
		PointInTimeRecovery:    pitr,
		ServerSideEncryption:   sse,
		StreamEnabled:          pulumi.BoolPtr(streamEnabled != nil && *streamEnabled),
		StreamViewType:         pulumi.StringPtrFromPtr(streamViewType),
		Tags:                   tags,
	}

	if rangeKey != "" {
		args.RangeKey = pulumi.String(rangeKey)
	}

	// Billing mode & throughput
	if in.BillingMode == awsdynamodbpb.BillingMode_PAY_PER_REQUEST {
		args.BillingMode = pulumi.StringPtr("PAY_PER_REQUEST")
	} else {
		// Provisioned
		args.BillingMode = pulumi.StringPtr("PROVISIONED")
		if in.ProvisionedThroughput != nil {
			args.ReadCapacity = pulumi.IntPtr(int(in.ProvisionedThroughput.ReadCapacityUnits))
			args.WriteCapacity = pulumi.IntPtr(int(in.ProvisionedThroughput.WriteCapacityUnits))
		}
	}

	table, err := dynamodb.NewTable(ctx, in.TableName, args)
	if err != nil {
		return err
	}

	// ---------------------------------------------------------------------
	// Stack exports
	// ---------------------------------------------------------------------
	ctx.Export("tableArn", table.Arn)
	ctx.Export("tableName", table.Name)
	ctx.Export("tableId", table.ID())
	ctx.Export("globalSecondaryIndexNames", pulumi.StringArrayOutput(pulumi.StringArray(
		convertIndexNames(in.GlobalSecondaryIndexes))))
	ctx.Export("localSecondaryIndexNames", pulumi.StringArrayOutput(pulumi.StringArray(
		convertLocalIndexNames(in.LocalSecondaryIndexes))))
	if streamEnabled != nil && *streamEnabled {
		ctx.Export("streamArn", table.LatestStreamArn)
		ctx.Export("streamLabel", table.LatestStreamLabel)
	}
	if kmsKeyArn != nil {
		ctx.Export("kmsKeyArn", kmsKeyArn)
	}

	return nil
}

// splitKeySchema returns the HASH and RANGE keys (RANGE may be empty).
func splitKeySchema(schema []*awsdynamodbpb.KeySchemaElement) (string, string, error) {
	var hash, rng string
	for _, ks := range schema {
		if ks.KeyType == awsdynamodbpb.KeyType_HASH {
			hash = ks.AttributeName
		} else if ks.KeyType == awsdynamodbpb.KeyType_RANGE {
			rng = ks.AttributeName
		}
	}
	if hash == "" {
		return "", "", fmt.Errorf("missing HASH key in key schema")
	}
	return hash, rng, nil
}

// attributeTypeToAWS maps proto enum to AWS letter representation.
func attributeTypeToAWS(t awsdynamodbpb.AttributeType) string {
	switch t {
	case awsdynamodbpb.AttributeType_STRING:
		return "S"
	case awsdynamodbpb.AttributeType_NUMBER:
		return "N"
	case awsdynamodbpb.AttributeType_BINARY:
		return "B"
	default:
		return "S"
	}
}

func projectionTypeToAWS(t awsdynamodbpb.ProjectionType) string {
	switch t {
	case awsdynamodbpb.ProjectionType_ALL:
		return "ALL"
	case awsdynamodbpb.ProjectionType_KEYS_ONLY:
		return "KEYS_ONLY"
	case awsdynamodbpb.ProjectionType_INCLUDE:
		return "INCLUDE"
	default:
		return "ALL"
	}
}

func streamViewTypeToAWS(t awsdynamodbpb.StreamViewType) string {
	switch t {
	case awsdynamodbpb.StreamViewType_NEW_IMAGE:
		return "NEW_IMAGE"
	case awsdynamodbpb.StreamViewType_OLD_IMAGE:
		return "OLD_IMAGE"
	case awsdynamodbpb.StreamViewType_NEW_AND_OLD_IMAGES:
		return "NEW_AND_OLD_IMAGES"
	case awsdynamodbpb.StreamViewType_STREAM_KEYS_ONLY:
		return "KEYS_ONLY"
	default:
		return "NEW_AND_OLD_IMAGES"
	}
}

// Helper to convert index names for exports.
func convertIndexNames(gsis []*awsdynamodbpb.GlobalSecondaryIndex) []pulumi.StringInput {
	var out []pulumi.StringInput
	for _, g := range gsis {
		out = append(out, pulumi.String(g.IndexName))
	}
	return out
}

func convertLocalIndexNames(lsis []*awsdynamodbpb.LocalSecondaryIndex) []pulumi.StringInput {
	var out []pulumi.StringInput
	for _, l := range lsis {
		out = append(out, pulumi.String(l.IndexName))
	}
	return out
}

// -----------------------------------------------------------------------------
// main â€“ allows running the component as a standalone Pulumi program. It expects
// a JSON-encoded spec under the configuration key `spec`.
// -----------------------------------------------------------------------------
func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		cfg := config.New(ctx, "")
		var spec awsdynamodbpb.AwsDynamodbSpec
		if err := cfg.GetObject("spec", &spec); err != nil {
			return fmt.Errorf("failed to load config key 'spec': %w", err)
		}
		return Resources(ctx, &spec)
	})
}
