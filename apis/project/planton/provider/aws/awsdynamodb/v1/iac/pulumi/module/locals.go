// Code generated by Project Planton. DO NOT EDIT.
//
// The locals.go helper centralises a handful of cross-cutting utilities that are
// frequently needed when provisioning DynamoDB tables – consistent resource
// names, common tags and deterministic ARNs.  Keeping that logic in one place
// makes the actual stack definitions considerably more readable.

package awsdynamodb

import (
    "fmt"

    "github.com/pulumi/pulumi-aws/sdk/v5/go/aws"
    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Locals bundles together commonly-used bits of runtime information obtained
// from the Pulumi context as well as helper functions that rely on that
// information.
//
// A single Locals instance is expected to be created per Pulumi program (stack)
// and then passed around wherever it is needed.
//
//     func main() {
//         pulumi.Run(func(ctx *pulumi.Context) error {
//             locals := awsdynamodb.NewLocals(ctx)
//             // … use locals.FmtName(), locals.CommonTags(), locals.TableArn(), …
//             return nil
//         })
//     }
//
// Nothing in Locals holds on to live pulumi.Resource values, therefore it is
// safe to retain it for the lifetime of the program.
//
// All fields are exported on purpose: in the rare scenarios where stack code
// needs direct access (for instance, to include the AWS account ID in a bucket
// policy), it can do so without additional helper functions.
//
type Locals struct {
    Ctx       *pulumi.Context // Pulumi execution context (never nil).
    Project   string          // Pulumi project name (e.g. "inventory-service").
    Stack     string          // Pulumi stack name   (e.g. "prod-us-east-1").
    Region    string          // AWS region          (e.g. "us-east-1").
    AccountID string          // AWS account ID      (12-digit string).
}

// NewLocals instantiates a Locals structure by querying the surrounding Pulumi
// environment as well as the AWS provider for region and caller identity.
// The helper panics only if the AWS provider cannot furnish the required
// information – a condition that would make any further provisioning
// impossible anyway.
func NewLocals(ctx *pulumi.Context) *Locals {
    if ctx == nil {
        panic("locals.NewLocals called with a nil context")
    }

    // Look-up region and account information once so that the values can be
    // re-used throughout the program without additional provider calls.
    region, err := aws.GetRegion(ctx, nil, nil)
    if err != nil {
        panic(fmt.Errorf("unable to determine current AWS region: %w", err))
    }

    ident, err := aws.GetCallerIdentity(ctx, nil, nil)
    if err != nil {
        panic(fmt.Errorf("unable to determine AWS account ID: %w", err))
    }

    return &Locals{
        Ctx:       ctx,
        Project:   ctx.Project(),
        Stack:     ctx.Stack(),
        Region:    region.Name,
        AccountID: ident.AccountId,
    }
}

// ---------------------------------------------------------------------------
// Tag helpers
// ---------------------------------------------------------------------------

// CommonTags returns a pulumi.StringMap that carries the conventional tags
// applied to every AWS resource created by stacks in this repository:
//   • project – Pulumi project name
//   • stack   – Pulumi stack name
//   • managed – Always "pulumi", signalling the provisioning engine
//
// Additional tags passed in via the extra parameter take precedence and can be
// used to augment or overwrite the defaults.
func (l *Locals) CommonTags(extra pulumi.StringMap) pulumi.StringMap {
    // NOTE: A pulumi.StringMap is just map[string]pulumi.StringInput – we copy
    //       the values to avoid mutating the caller-provided map.
    out := pulumi.StringMap{
        "project": pulumi.String(l.Project),
        "stack":   pulumi.String(l.Stack),
        "managed": pulumi.String("pulumi"),
    }
    for k, v := range extra {
        out[k] = v
    }
    return out
}

// ---------------------------------------------------------------------------
// Naming helpers
// ---------------------------------------------------------------------------

// FmtName creates a deterministic, kebab-cased resource name consisting of the
// Pulumi project, stack and any additional parts supplied via the variadic
// argument list.  A call such as
//
//     locals.FmtName("orders", "gsi")
//
// would yield something similar to:
//
//     inventory-service-prod-us-east-1-orders-gsi
//
// The helper is intentionally simple – it does not attempt to enforce length
// limits or validate characters beyond what is needed for DynamoDB table/index
// names (min 3, max 255, alphanumeric plus dash and dot).  Individual stacks
// remain responsible for ensuring compliance when passing the resulting value
// to AWS APIs.
func (l *Locals) FmtName(parts ...string) string {
    // Pre-allocate with len(parts)+2 (project+stack).
    all := make([]string, 0, len(parts)+2)
    all = append(all, l.Project, l.Stack)
    all = append(all, parts...)
    return joinKebab(all...)
}

// joinKebab joins arbitrary strings using a dash as separator while skipping
// empty elements.
func joinKebab(parts ...string) string {
    filtered := make([]string, 0, len(parts))
    for _, p := range parts {
        if p != "" {
            filtered = append(filtered, p)
        }
    }
    return fmt.Sprintf("%s", stringJoin("-", filtered...))
}

// stringJoin mirrors strings.Join but is re-implemented here to avoid importing
// the entire strings package for a single call.
func stringJoin(sep string, elems ...string) string {
    switch len(elems) {
    case 0:
        return ""
    case 1:
        return elems[0]
    }

    n := len(sep) * (len(elems) - 1)
    for i := 0; i < len(elems); i++ {
        n += len(elems[i])
    }

    b := make([]byte, n)
    bp := copy(b, elems[0])
    for _, s := range elems[1:] {
        bp += copy(b[bp:], sep)
        bp += copy(b[bp:], s)
    }
    return string(b)
}

// ---------------------------------------------------------------------------
// ARN helpers
// ---------------------------------------------------------------------------

// TableArn produces the ARN for a DynamoDB table with the given name in the
// current AWS account and region.  The tableName parameter can be either a
// plain string or any Pulumi StringInput (e.g. a Table.Name output).
func (l *Locals) TableArn(tableName pulumi.StringInput) pulumi.StringOutput {
    // Because the account ID and region are static strings (known at planning
    // time), they can be formatted directly.  The actual table name might be
    // an output that resolves only at apply-time, therefore we rely on
    // pulumi.Sprintf to create the final output value.
    arnPrefix := fmt.Sprintf("arn:aws:dynamodb:%s:%s:table/", l.Region, l.AccountID)
    return pulumi.Sprintf("%s%s", arnPrefix, tableName)
}

// StreamArn produces the ARN for the DynamoDB Stream associated with the given
// table.  The streamLabel is optional – when omitted the helper returns the
// well-known table-level stream ARN, otherwise it constructs the full stream
// ARN containing the label.
func (l *Locals) StreamArn(tableName pulumi.StringInput, streamLabel pulumi.StringPtrInput) pulumi.StringOutput {
    base := pulumi.Sprintf("%s/stream/", l.TableArn(tableName))
    return pulumi.All(base, streamLabel).ApplyT(func(args []interface{}) string {
        b := args[0].(string)
        labelPtr := args[1].(*string)
        if labelPtr == nil || *labelPtr == "" {
            return b
        }
        return b + *labelPtr
    }).(pulumi.StringOutput)
}

