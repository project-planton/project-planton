// Code generated by Project Planton. DO NOT EDIT.
//
// locals.go groups together helper values that are derived once from the
// user-supplied AwsDynamodbSpec and then reused across all resources in the
// stack.  In particular it is in charge of building the canonical set of AWS
// resource tags that must be applied uniformly.

package awsdynamodb

import (
    "fmt"

    "github.com/pulumi/pulumi/sdk/v3/go/pulumi"

    awsdynamodbpb "github.com/project-planton/project-planton/apis/project/planton/provider/aws/awsdynamodb/v1"
)

// Locals holds values that are calculated once and shared by all resources
// created by the stack.
//
// Keeping such data in a dedicated structure avoids repeating the same logic
// in every component and makes unit-testing easier.
//
// All fields are intentionally exported so that higher-level components can
// consume them without using getter methods.
type Locals struct {
    // Spec is the validated table specification that drives the entire stack.
    Spec *awsdynamodbpb.AwsDynamodbSpec

    // Tags is the full set of tags that must be attached to every AWS
    // resource created by this stack.  It is built by merging project/stack
    // tags with the user-provided tags defined in AwsDynamodbSpec.Tags.
    Tags pulumi.StringMap
}

// NewLocals initialises a Locals instance from the provided AwsDynamodbSpec.
//
// The function returns an error when the specification is nil so that callers
// can fail fast before trying to provision any resource.
func NewLocals(ctx *pulumi.Context, spec *awsdynamodbpb.AwsDynamodbSpec) (*Locals, error) {
    if spec == nil {
        return nil, fmt.Errorf("awsdynamodb: nil AwsDynamodbSpec provided")
    }

    // Base tags that should always be present.
    baseTags := map[string]string{
        "ManagedBy": "Pulumi", // Signals that the resource is managed by IaC.
    }

    // Add contextual information so that resources can be traced back to the
    // Pulumi project/stack that owns them.
    if p := ctx.Project(); p != "" {
        baseTags["Project"] = p
    }
    if s := ctx.Stack(); s != "" {
        baseTags["Stack"] = s
    }

    // Merge with the user-defined tags from the specification.  User tags have
    // precedence over the automatically-generated ones so that they can
    // override defaults when necessary.
    mergedTags := mergeTags(baseTags, spec.Tags)

    // Convert to Pulumi's native type so that the map can be passed directly
    // to AWS resources.
    pulumiTags := make(pulumi.StringMap, len(mergedTags))
    for k, v := range mergedTags {
        pulumiTags[k] = pulumi.String(v)
    }

    return &Locals{
        Spec: spec,
        Tags: pulumiTags,
    }, nil
}

// mergeTags combines two maps in a non-destructive way.  Conflicts are solved
// by giving priority to values coming from b.
func mergeTags(a, b map[string]string) map[string]string {
    out := make(map[string]string, len(a)+len(b))
    for k, v := range a {
        out[k] = v
    }
    for k, v := range b {
        out[k] = v
    }
    return out
}
