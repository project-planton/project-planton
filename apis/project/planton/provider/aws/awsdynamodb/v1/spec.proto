syntax = "proto3";

package project.planton.provider.aws.awsdynamodb.v1;

import "buf/validate/validate.proto";

/************************************************************
 * AwsDynamodbSpec
 ***********************************************************/
message AwsDynamodbSpec {
  // Name of the DynamoDB table. Must be unique within the AWS account & region.
  string table_name = 1 [
    (buf.validate.field).string = {
      min_len: 3,
      max_len: 255,
      pattern: "^[a-zA-Z0-9_.-]+$"
    }
  ];

  // How you want to pay for database capacity.
  BillingMode billing_mode = 2 [
    (buf.validate.field).enum = { not_in: [0] }
  ];

  // Provisioned read/write capacity settings (used when billing_mode = PROVISIONED).
  ProvisionedThroughput provisioned_throughput = 3;

  // List of attribute definitions that describe the key and index attributes for the table.
  repeated AttributeDefinition attribute_definitions = 4 [
    (buf.validate.field).repeated = { min_items: 1 }
  ];

  // Primary key schema for the table (partition key and optional sort key).
  KeySchema key_schema = 5 [
    (buf.validate.field).required = true
  ];

  // Configuration for global secondary indexes (GSIs).
  repeated GlobalSecondaryIndex global_secondary_indexes = 6;

  // Configuration for local secondary indexes (LSIs).
  repeated LocalSecondaryIndex local_secondary_indexes = 7;

  // Enables DynamoDB Streams and specifies the information written to the stream.
  StreamSpecification stream_specification = 8;

  // Server-side encryption settings.
  SSESpecification sse_specification = 9;

  // Enables point-in-time recovery (PITR) for continuous backups.
  bool point_in_time_recovery_enabled = 10;

  // Time-to-live settings for automatic item expiration.
  TTLSpecification ttl_specification = 11;

  // Enables Contributor Insights to analyze traffic patterns.
  bool contributor_insights_enabled = 12;

  // Prevents accidental deletion of the table when set to true.
  bool deletion_protection_enabled = 13;

  // Storage class used for the table.
  TableClass table_class = 14 [
    (buf.validate.field).enum = { not_in: [0] }
  ];

  // Tags to attach to the table for cost allocation and organization.
  map<string, string> tags = 15 [
    (buf.validate.field).map = {
      keys:   { string: { min_len: 1, max_len: 128 } },
      values: { string: {          max_len: 256 } }
    }
  ];

  //---------------- CEL rules ----------------
  option (buf.validate.message).cel = {
    id: "billing_mode_capacity_rule",
    message: "When billing_mode == PROVISIONED, provisioned_throughput must be set with positive RCU/WCU; when PAY_PER_REQUEST it must be unset or set to 0",
    expression: "this.billing_mode == 1 ? (has(this.provisioned_throughput) && this.provisioned_throughput.read_capacity_units > 0 && this.provisioned_throughput.write_capacity_units > 0) : (this.billing_mode == 2 ? (!has(this.provisioned_throughput) || (this.provisioned_throughput.read_capacity_units == 0 && this.provisioned_throughput.write_capacity_units == 0)) : true)"
  };
}

/************ Supporting Types ************/

//==== Billing & Capacity ====
enum BillingMode {
  BILLING_MODE_UNSPECIFIED = 0;
  // You specify the read/write capacity units.
  PROVISIONED = 1;
  // DynamoDB charges for the actual read/write requests (a.k.a. "on-demand").
  PAY_PER_REQUEST = 2;
}

// Provisioned throughput settings (RCU/WCU).
message ProvisionedThroughput {
  // Maximum number of strongly consistent reads per second.
  int64 read_capacity_units = 1 [
    (buf.validate.field).int64 = { gte: 0 }
  ];
  // Maximum number of writes per second.
  int64 write_capacity_units = 2 [
    (buf.validate.field).int64 = { gte: 0 }
  ];
}

//==== Attributes & Keys ====
enum AttributeType {
  ATTRIBUTE_TYPE_UNSPECIFIED = 0;
  STRING = 1;  // "S"
  NUMBER = 2;  // "N"
  BINARY = 3;  // "B"
}

// Describes an attribute and its scalar type.
message AttributeDefinition {
  string attribute_name = 1 [
    (buf.validate.field).string = { min_len: 1, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];
  AttributeType attribute_type = 2 [
    (buf.validate.field).enum = { not_in: [0] }
  ];
}

// Primary or secondary key schema.
message KeySchema {
  string partition_key = 1 [
    (buf.validate.field).string = { min_len: 1, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];
  string sort_key = 2 [
    (buf.validate.field).string = { max_len: 255, pattern: "^[a-zA-Z0-9_.-]*$" }
  ];
}

//==== Indexes ====
enum ProjectionType {
  PROJECTION_TYPE_UNSPECIFIED = 0;
  KEYS_ONLY = 1;
  INCLUDE = 2;
  ALL = 3;
}

// Attributes that are copied into an index.
message Projection {
  ProjectionType projection_type = 1 [
    (buf.validate.field).enum = { not_in: [0] }
  ];
  repeated string non_key_attributes = 2 [
    (buf.validate.field).repeated.items.string = { min_len: 1, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];

  option (buf.validate.message).cel = {
    id: "projection_include_rule",
    message: "When projection_type == INCLUDE, non_key_attributes must be non-empty; otherwise it must be empty",
    expression: "this.projection_type == 2 ? size(this.non_key_attributes) > 0 : size(this.non_key_attributes) == 0"
  };
}

// Global secondary index configuration.
message GlobalSecondaryIndex {
  string index_name = 1 [
    (buf.validate.field).string = { min_len: 3, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];
  KeySchema key_schema = 2 [
    (buf.validate.field).required = true
  ];
  Projection projection = 3 [
    (buf.validate.field).required = true
  ];
  BillingMode billing_mode = 4 [
    (buf.validate.field).enum = { not_in: [0] }
  ];
  ProvisionedThroughput provisioned_throughput = 5;

  option (buf.validate.message).cel = {
    id: "gsi_capacity_rule",
    message: "For a GSI, when billing_mode == PROVISIONED, provisioned_throughput must be set with positive RCU/WCU; when PAY_PER_REQUEST it must be unset or zero",
    expression: "this.billing_mode == 1 ? (has(this.provisioned_throughput) && this.provisioned_throughput.read_capacity_units > 0 && this.provisioned_throughput.write_capacity_units > 0) : (this.billing_mode == 2 ? (!has(this.provisioned_throughput) || (this.provisioned_throughput.read_capacity_units == 0 && this.provisioned_throughput.write_capacity_units == 0)) : true)"
  };
}

// Local secondary index configuration.
message LocalSecondaryIndex {
  string index_name = 1 [
    (buf.validate.field).string = { min_len: 3, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];
  string sort_key = 2 [
    (buf.validate.field).string = { min_len: 1, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];
  Projection projection = 3 [
    (buf.validate.field).required = true
  ];
}

//==== Streams ====
enum StreamViewType {
  STREAM_VIEW_TYPE_UNSPECIFIED = 0;
  KEYS_ONLY_STREAM = 1; // Renamed to avoid collision with ProjectionType.KEYS_ONLY.
  NEW_IMAGE = 2;
  OLD_IMAGE = 3;
  NEW_AND_OLD_IMAGES = 4;
}

// Stream settings.
message StreamSpecification {
  bool enabled = 1;
  StreamViewType view_type = 2;

  option (buf.validate.message).cel = {
    id: "stream_enabled_rule",
    message: "When streams are enabled view_type must be set; when disabled it must be UNSPECIFIED",
    expression: "this.enabled ? this.view_type != 0 : this.view_type == 0"
  };
}

//==== Encryption ====
enum SSEType {
  SSE_TYPE_UNSPECIFIED = 0;
  AWS_MANAGED = 1; // AWS owned CMK.
  KMS = 2;         // Customer managed KMS key.
}

// Server-side encryption settings.
message SSESpecification {
  bool enabled = 1;
  SSEType sse_type = 2;
  string kms_key_arn = 3 [
    (buf.validate.field).string = { pattern: "^arn:[A-Za-z0-9:/-]+$" }
  ];

  option (buf.validate.message).cel = {
    id: "sse_enabled_rule",
    message: "When SSE is enabled sse_type must be set and, if type == KMS, kms_key_arn must be provided; when disabled type must be UNSPECIFIED",
    expression: "this.enabled ? (this.sse_type != 0 && (this.sse_type == 2 ? size(this.kms_key_arn) > 0 : true)) : this.sse_type == 0"
  };
}

//==== TTL ====
message TTLSpecification {
  bool enabled = 1;            // Enables/disables TTL.
  string attribute_name = 2 [
    (buf.validate.field).string = { min_len: 1, max_len: 255, pattern: "^[a-zA-Z0-9_.-]+$" }
  ];

  option (buf.validate.message).cel = {
    id: "ttl_enabled_rule",
    message: "attribute_name must be set when TTL is enabled; it must be empty when TTL is disabled",
    expression: "this.enabled ? size(this.attribute_name) > 0 : size(this.attribute_name) == 0"
  };
}

//==== Table class ====
enum TableClass {
  TABLE_CLASS_UNSPECIFIED = 0;
  STANDARD = 1;
  STANDARD_INFREQUENT_ACCESS = 2;
}