syntax = "proto3";

package project.planton.provider.aws.awsdynamodb.v1;

import "buf/validate/validate.proto";

// Desired state of an Amazon DynamoDB table.
message AwsDynamodbSpec {
  // Name of the DynamoDB table (unique per region/account).
  string table_name = 1 [
    (buf.validate.field) = {
      required: true
      string: {
        min_len: 3
        max_len: 255
        pattern: "^[A-Za-z0-9_.-]+$"
      }
    }
  ];

  // Definitions of all attributes referenced by keys and indexes.
  repeated AttributeDefinition attribute_definitions = 2 [
    (buf.validate.field).repeated = {
      min_items: 1
      max_items: 100
    }
  ];

  // Primary key schema consisting of a partition key and optional sort key.
  repeated KeySchemaElement key_schema = 3 [
    (buf.validate.field).repeated = {
      min_items: 1   // partition key required
      max_items: 2   // at most HASH + RANGE
    }
  ];

  // Billing mode: on-demand (PAY_PER_REQUEST) or provisioned capacity.
  BillingMode billing_mode = 4 [
    (buf.validate.field).enum = {
      defined_only: true
      not_in: [0]   // must not be BILLING_MODE_UNSPECIFIED
    }
  ];

  // Capacity settings used when billing_mode = PROVISIONED.
  ProvisionedThroughput provisioned_throughput = 5;

  // Global secondary indexes to be created for the table.
  repeated GlobalSecondaryIndex global_secondary_indexes = 6 [
    (buf.validate.field).repeated = { max_items: 20 }
  ];

  // Local secondary indexes to be created for the table.
  repeated LocalSecondaryIndex local_secondary_indexes = 7 [
    (buf.validate.field).repeated = { max_items: 5 }
  ];

  // Key-value tags to assign to the table.
  map<string, string> tags = 8 [
    (buf.validate.field).map = {
      max_pairs: 50
      keys: {
        string: {
          min_len: 1
          max_len: 128
        }
      }
      values: {
        string: {
          max_len: 256
        }
      }
    }
  ];

  // Stream configuration for change data capture.
  StreamSpecification stream_specification = 9;

  // Time-to-live configuration for automatic item expiration.
  TTLSpecification ttl_specification = 10;

  // Server-side encryption configuration.
  ServerSideEncryptionSpecification sse_specification = 11;

  // Table class (STANDARD or STANDARD_INFREQUENT_ACCESS).
  TableClass table_class = 12 [
    (buf.validate.field).enum = { defined_only: true }
  ];

  // Protect table from accidental deletion when true.
  bool deletion_protection_enabled = 13;

  // Enables point-in-time recovery for continuous backups.
  PointInTimeRecoverySpecification point_in_time_recovery = 14;

  // ---------- CEL Cross-field Rules ----------
  option (buf.validate.message).cel = {
    id: "aws_dynamodb_spec_provisioned_thr_required"
    expression: "billing_mode != project.planton.provider.aws.awsdynamodb.v1.BillingMode.PROVISIONED || has(provisioned_throughput)"
    message: "provisioned_throughput must be set when billing_mode = PROVISIONED"
  };

  option (buf.validate.message).cel = {
    id: "aws_dynamodb_spec_provisioned_units_positive"
    expression: "billing_mode != project.planton.provider.aws.awsdynamodb.v1.BillingMode.PROVISIONED || (provisioned_throughput.read_capacity_units > 0 && provisioned_throughput.write_capacity_units > 0)"
    message: "read_capacity_units and write_capacity_units must be greater than zero when billing_mode = PROVISIONED"
  };

  option (buf.validate.message).cel = {
    id: "aws_dynamodb_spec_ppr_throughput_unset"
    expression: "billing_mode != project.planton.provider.aws.awsdynamodb.v1.BillingMode.PAY_PER_REQUEST || (!has(provisioned_throughput) || (provisioned_throughput.read_capacity_units == 0 && provisioned_throughput.write_capacity_units == 0))"
    message: "provisioned_throughput must be unset or zero when billing_mode = PAY_PER_REQUEST"
  };
}

// ---------------- Supporting Types ----------------

// Describes a single attribute and its data type.
message AttributeDefinition {
  // Attribute name.
  string attribute_name = 1 [
    (buf.validate.field) = {
      required: true
      string: {
        min_len: 1
        max_len: 255
        pattern: "^[A-Za-z0-9_.-]+$"
      }
    }
  ];

  // Attribute data type: S (String), N (Number) or B (Binary).
  AttributeType attribute_type = 2 [
    (buf.validate.field).enum = {
      defined_only: true
      not_in: [0]
    }
  ];
}

enum AttributeType {
  ATTRIBUTE_TYPE_UNSPECIFIED = 0;
  STRING = 1;  // S
  NUMBER = 2;  // N
  BINARY = 3;  // B
}

// Defines a key element in the key schema.
message KeySchemaElement {
  // Attribute name for this key element.
  string attribute_name = 1 [
    (buf.validate.field) = {
      required: true
      string: {
        min_len: 1
        max_len: 255
        pattern: "^[A-Za-z0-9_.-]+$"
      }
    }
  ];

  // HASH for partition key, RANGE for sort key.
  KeyType key_type = 2 [
    (buf.validate.field).enum = {
      defined_only: true
      not_in: [0]
    }
  ];
}

enum KeyType {
  KEY_TYPE_UNSPECIFIED = 0;
  HASH = 1;   // Partition key
  RANGE = 2;  // Sort key
}

enum BillingMode {
  BILLING_MODE_UNSPECIFIED = 0;
  PAY_PER_REQUEST = 1;
  PROVISIONED = 2;
}

// Provisioned capacity settings.
message ProvisionedThroughput {
  // Maximum strongly-consistent reads per second.
  int64 read_capacity_units = 1 [
    (buf.validate.field).int64 = { gte: 0 }
  ];

  // Maximum writes per second.
  int64 write_capacity_units = 2 [
    (buf.validate.field).int64 = { gte: 0 }
  ];
}

// Global secondary index (GSI) configuration.
message GlobalSecondaryIndex {
  // Index name.
  string index_name = 1 [
    (buf.validate.field) = {
      required: true
      string: {
        min_len: 3
        max_len: 255
        pattern: "^[A-Za-z0-9_.-]+$"
      }
    }
  ];

  // Key schema for the index.
  repeated KeySchemaElement key_schema = 2 [
    (buf.validate.field).repeated = { min_items: 1, max_items: 2 }
  ];

  // Attribute projection into the index.
  Projection projection = 3 [ (buf.validate.field).required = true ];

  // Billing mode for the index (defaults to table mode).
  BillingMode billing_mode = 4 [
    (buf.validate.field).enum = { defined_only: true }
  ];

  // Provisioned throughput when billing_mode = PROVISIONED.
  ProvisionedThroughput provisioned_throughput = 5;

  option (buf.validate.message).cel = {
    id: "gsi_provisioned_thr_required"
    expression: "billing_mode != project.planton.provider.aws.awsdynamodb.v1.BillingMode.PROVISIONED || has(provisioned_throughput)"
    message: "provisioned_throughput must be set for the index when billing_mode = PROVISIONED"
  };

  option (buf.validate.message).cel = {
    id: "gsi_provisioned_units_positive"
    expression: "billing_mode != project.planton.provider.aws.awsdynamodb.v1.BillingMode.PROVISIONED || (provisioned_throughput.read_capacity_units > 0 && provisioned_throughput.write_capacity_units > 0)"
    message: "read/write capacity units must be > 0 for the index when billing_mode = PROVISIONED"
  };
}

// Local secondary index (LSI) configuration.
message LocalSecondaryIndex {
  // Index name.
  string index_name = 1 [
    (buf.validate.field) = {
      required: true
      string: {
        min_len: 3
        max_len: 255
        pattern: "^[A-Za-z0-9_.-]+$"
      }
    }
  ];

  // Key schema for the index (must share the table partition key).
  repeated KeySchemaElement key_schema = 2 [
    (buf.validate.field).repeated = { min_items: 2, max_items: 2 }
  ];

  // Attribute projection into the index.
  Projection projection = 3 [ (buf.validate.field).required = true ];
}

// Determines which table attributes are copied into an index.
message Projection {
  // Projection type.
  ProjectionType projection_type = 1 [
    (buf.validate.field).enum = {
      defined_only: true
      not_in: [0]
    }
  ];

  // Attributes to include when projection_type = INCLUDE.
  repeated string non_key_attributes = 2;

  option (buf.validate.message).cel = {
    id: "projection_include_attributes_rule"
    expression: "projection_type == project.planton.provider.aws.awsdynamodb.v1.ProjectionType.INCLUDE ? size(non_key_attributes) > 0 : size(non_key_attributes) == 0"
    message: "non_key_attributes must be set when projection_type = INCLUDE and empty otherwise"
  };
}

enum ProjectionType {
  PROJECTION_TYPE_UNSPECIFIED = 0;
  ALL = 1;
  KEYS_ONLY = 2;
  INCLUDE = 3;
}

// Stream settings for the table.
message StreamSpecification {
  // When true, DynamoDB Streams is enabled.
  bool enabled = 1;

  // Type of data written to the stream.
  StreamViewType view_type = 2 [
    (buf.validate.field).enum = { defined_only: true }
  ];

  option (buf.validate.message).cel = {
    id: "stream_view_type_required_when_enabled"
    expression: "!enabled || view_type != project.planton.provider.aws.awsdynamodb.v1.StreamViewType.STREAM_VIEW_TYPE_UNSPECIFIED"
    message: "view_type must be specified when Streams is enabled"
  };
}

enum StreamViewType {
  STREAM_VIEW_TYPE_UNSPECIFIED = 0;
  NEW_IMAGE = 1;
  OLD_IMAGE = 2;
  NEW_AND_OLD_IMAGES = 3;
  KEYS_ONLY_STREAM = 4;
}

// Time-to-live (TTL) settings.
message TTLSpecification {
  // Enables TTL when true.
  bool enabled = 1;

  // Attribute containing the epoch time when the item expires.
  string attribute_name = 2;

  option (buf.validate.message).cel = {
    id: "ttl_attribute_name_rule"
    expression: "enabled ? attribute_name != '' : attribute_name == ''"
    message: "attribute_name must be set when TTL is enabled and empty when disabled"
  };
}

// Server-side encryption (SSE) settings.
message ServerSideEncryptionSpecification {
  // Enables SSE when true.
  bool enabled = 1;

  // ARN of a customer-managed KMS key; leave empty to use AWS owned key.
  string kms_key_arn = 2 [
    (buf.validate.field).string = {
      pattern: "^arn:[^:]+:kms:[^:]+:[0-9]{12}:key/[0-9a-fA-F-]{36}$"
    }
  ];

  option (buf.validate.message).cel = {
    id: "sse_kms_key_arn_rule"
    expression: "enabled || kms_key_arn == ''"
    message: "kms_key_arn must be empty when SSE is disabled"
  };
}

enum TableClass {
  TABLE_CLASS_UNSPECIFIED = 0;
  STANDARD = 1;
  STANDARD_INFREQUENT_ACCESS = 2;
}

// Point-in-time recovery (PITR) settings.
message PointInTimeRecoverySpecification {
  // Enables continuous backups when true.
  bool enabled = 1;
}