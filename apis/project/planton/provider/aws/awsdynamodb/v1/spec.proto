syntax = "proto3";

package project.planton.provider.aws.awsdynamodb.v1;

import "buf/validate/validate.proto";

// ---------------------------------------------------------------------------
// AwsDynamodbSpec describes an Amazon DynamoDB table.
// ---------------------------------------------------------------------------
message AwsDynamodbSpec {
  // Unique name of the DynamoDB table.
  string table_name = 1 [
    (buf.validate.field).string = {
      min_len: 3,
      max_len: 255,
      pattern: "^[A-Za-z0-9][A-Za-z0-9_.-]*$"
    },
    (buf.validate.field).required = true
  ];

  // Billing strategy for read/write capacity.
  BillingMode billing_mode = 2 [
    (buf.validate.field).enum = {defined_only: true, not_in: [0]},
    (buf.validate.field).required = true
  ];

  // Provisioned read capacity units (used when billing_mode = PROVISIONED).
  int64 read_capacity_units = 3 [
    (buf.validate.field).int64 = {gte: 0}
  ];

  // Provisioned write capacity units (used when billing_mode = PROVISIONED).
  int64 write_capacity_units = 4 [
    (buf.validate.field).int64 = {gte: 0}
  ];

  // Definitions of all attributes referenced by keys or indexes.
  repeated AttributeDefinition attribute_definitions = 5 [
    (buf.validate.field).repeated.min_items = 1
  ];

  // Primary key schema for the table.
  KeySchema key_schema = 6 [
    (buf.validate.field).required = true
  ];

  // Optional global secondary indexes.
  repeated GlobalSecondaryIndex global_secondary_indexes = 7;

  // Optional local secondary indexes.
  repeated LocalSecondaryIndex local_secondary_indexes = 8;

  // DynamoDB Streams configuration.
  StreamSpecification stream_specification = 9;

  // Time-to-live (TTL) settings.
  TimeToLiveSpecification ttl_specification = 10;

  // Point-in-time recovery (continuous backup) settings.
  PointInTimeRecovery point_in_time_recovery = 11;

  // Server-side encryption configuration.
  EncryptionSpecification encryption = 12;

  // Table class (STANDARD or STANDARD_INFREQUENT_ACCESS).
  TableClass table_class = 13 [
    (buf.validate.field).enum = {defined_only: true, not_in: [0]}
  ];

  // Key-value tags applied to this table.
  map<string, string> tags = 14 [
    (buf.validate.field).map.keys.string.pattern = "^[A-Za-z0-9_.:/=+@-]{1,128}$",
    (buf.validate.field).map.keys.string.min_len = 1,
    (buf.validate.field).map.values.string.max_len = 256
  ];

  // Regions in which to replicate the table for Global Tables (V2).
  repeated string replica_regions = 15 [
    (buf.validate.field).repeated.items.string.pattern = "^[a-z]{2}-[a-z]+-\d$"
  ];

  // -------------------------------------------------------------------------
  // Message-level CEL rules for complex cross-field validation
  // -------------------------------------------------------------------------
  (buf.validate.message).cel = [
    {
      id:               "billing_mode_provisioned_capacities",
      message:          "When billing_mode is PROVISIONED, read_capacity_units and write_capacity_units must both be > 0", 
      expression:       "billing_mode != PROVISIONED || (read_capacity_units > 0 && write_capacity_units > 0)"
    },
    {
      id:               "billing_mode_pay_per_request_capacities",
      message:          "When billing_mode is PAY_PER_REQUEST, read_capacity_units and write_capacity_units must both be 0", 
      expression:       "billing_mode != PAY_PER_REQUEST || (read_capacity_units == 0 && write_capacity_units == 0)"
    },
    {
      id:               "hash_key_defined",
      message:          "hash_key must exist in attribute_definitions",
      expression:       "attribute_definitions.exists(ad, ad.attribute_name == key_schema.hash_key)"
    },
    {
      id:               "range_key_defined",
      message:          "When range_key is provided it must exist in attribute_definitions",
      expression:       "key_schema.range_key == '' || attribute_definitions.exists(ad, ad.attribute_name == key_schema.range_key)"
    },
    {
      id:         "gsi_capacity_when_provisioned",
      message:    "For each GSI, read/write capacity must be >0 when table billing_mode is PROVISIONED",
      expression: "billing_mode != PROVISIONED || global_secondary_indexes.all(i, i.read_capacity_units > 0 && i.write_capacity_units > 0)"
    },
    {
      id:         "gsi_capacity_when_on_demand",
      message:    "For each GSI, read/write capacity must be 0 when table billing_mode is PAY_PER_REQUEST",
      expression: "billing_mode != PAY_PER_REQUEST || global_secondary_indexes.all(i, i.read_capacity_units == 0 && i.write_capacity_units == 0)"
    }
  ];
}

// ---------------------------------------------------------------------------
// Supporting messages & enums with validations
// ---------------------------------------------------------------------------

// Definition of a single attribute.
message AttributeDefinition {
  // Attribute name as referenced in keys or indexes.
  string attribute_name = 1 [
    (buf.validate.field).string = {min_len: 1, max_len: 255, pattern: "^[A-Za-z0-9_.-]+$"},
    (buf.validate.field).required = true
  ];

  // Scalar attribute data type.
  ScalarAttributeType attribute_type = 2 [
    (buf.validate.field).enum = {defined_only: true, not_in: [0]},
    (buf.validate.field).required = true
  ];
}

// Primary key schema consisting of partition (hash) key and optional sort key.
message KeySchema {
  // Partition key attribute name (required).
  string hash_key = 1 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).required = true
  ];

  // Sort key attribute name (optional).
  string range_key = 2 [
    (buf.validate.field).string.min_len = 1
  ];
}

// Configuration for a global secondary index (GSI).
message GlobalSecondaryIndex {
  // Name of the GSI.
  string index_name = 1 [
    (buf.validate.field).string = {min_len: 3, max_len: 255, pattern: "^[A-Za-z0-9][A-Za-z0-9_.-]*$"},
    (buf.validate.field).required = true
  ];

  // Partition key attribute name for the index.
  string hash_key = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).required = true
  ];

  // Sort key attribute name for the index (optional).
  string range_key = 3 [
    (buf.validate.field).string.min_len = 1
  ];

  // Attributes projected into the index.
  Projection projection = 4 [
    (buf.validate.field).required = true
  ];

  // Provisioned read capacity units (used when billing_mode = PROVISIONED).
  int64 read_capacity_units = 5 [
    (buf.validate.field).int64.gte = 0
  ];

  // Provisioned write capacity units (used when billing_mode = PROVISIONED).
  int64 write_capacity_units = 6 [
    (buf.validate.field).int64.gte = 0
  ];
}

// Configuration for a local secondary index (LSI).
message LocalSecondaryIndex {
  // Name of the LSI.
  string index_name = 1 [
    (buf.validate.field).string = {min_len: 3, max_len: 255, pattern: "^[A-Za-z0-9][A-Za-z0-9_.-]*$"},
    (buf.validate.field).required = true
  ];

  // Sort key attribute name; partition key is the same as the table.
  string range_key = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).required = true
  ];

  // Attributes projected into the index.
  Projection projection = 3 [
    (buf.validate.field).required = true
  ];
}

// Projection determines which attributes are copied into an index.
message Projection {
  ProjectionType projection_type = 1 [
    (buf.validate.field).enum = {defined_only: true, not_in: [0]},
    (buf.validate.field).required = true
  ];
  // Attributes to include when projection_type = INCLUDE.
  repeated string non_key_attributes = 2 [
    (buf.validate.field).repeated.max_items = 20,
    (buf.validate.field).repeated.items.string.min_len = 1
  ];

  (buf.validate.message).cel = [
    {
      id:        "include_requires_attributes",
      message:   "non_key_attributes must be provided when projection_type is INCLUDE",
      expression:"projection_type != INCLUDE || non_key_attributes.size() > 0"
    },
    {
      id:        "non_include_must_not_have_attributes",
      message:   "non_key_attributes must be empty unless projection_type is INCLUDE",
      expression:"projection_type == INCLUDE || non_key_attributes.size() == 0"
    }
  ];
}

// Stream specification for DynamoDB Streams.
message StreamSpecification {
  // Whether streams are enabled.
  bool enabled = 1;

  // View type for the stream.
  StreamViewType view_type = 2 [
    (buf.validate.field).enum.defined_only = true
  ];

  (buf.validate.message).cel = [
    {
      id:       "stream_view_type_required_when_enabled",
      message:  "view_type must be specified when streams are enabled",
      expression:"enabled == false || view_type != STREAM_VIEW_TYPE_UNSPECIFIED"
    },
    {
      id:       "stream_view_type_empty_when_disabled",
      message:  "view_type must be UNSPECIFIED when streams are disabled",
      expression:"enabled == true || view_type == STREAM_VIEW_TYPE_UNSPECIFIED"
    }
  ];
}

// TTL specification.
message TimeToLiveSpecification {
  // Whether TTL is enabled.
  bool enabled = 1;

  // Name of the attribute storing the TTL timestamp.
  string attribute_name = 2 [
    (buf.validate.field).string.min_len = 1
  ];

  (buf.validate.message).cel = [
    {
      id:       "ttl_attribute_required_when_enabled",
      message:  "attribute_name must be set when TTL is enabled",
      expression:"enabled == false || attribute_name != ''"
    },
    {
      id:       "ttl_attribute_empty_when_disabled",
      message:  "attribute_name must be empty when TTL is disabled",
      expression:"enabled == true || attribute_name == ''"
    }
  ];
}

// Point-in-time recovery settings.
message PointInTimeRecovery {
  // Whether point-in-time recovery is enabled.
  bool enabled = 1;
}

// Server-side encryption settings.
message EncryptionSpecification {
  // Whether SSE is enabled.
  bool enabled = 1;

  // Encryption type.
  EncryptionType encryption_type = 2 [
    (buf.validate.field).enum.defined_only = true
  ];

  // Customer-managed KMS key ARN (required when encryption_type = CUSTOMER_MANAGED_KMS).
  string kms_key_arn = 3 [
    (buf.validate.field).string.pattern = "^arn:[A-Za-z0-9:/_-]+$"
  ];

  (buf.validate.message).cel = [
    {
      id:       "encryption_type_when_enabled",
      message:  "encryption_type must be specified when encryption is enabled",
      expression:"enabled == false || encryption_type != ENCRYPTION_TYPE_UNSPECIFIED"
    },
    {
      id:       "kms_key_required",
      message:  "kms_key_arn must be supplied when encryption_type is CUSTOMER_MANAGED_KMS",
      expression:"encryption_type != CUSTOMER_MANAGED_KMS || kms_key_arn != ''"
    },
    {
      id:       "kms_key_empty_when_not_customer",
      message:  "kms_key_arn must be empty unless encryption_type is CUSTOMER_MANAGED_KMS",
      expression:"encryption_type == CUSTOMER_MANAGED_KMS || kms_key_arn == ''"
    }
  ];
}

// ---------------------------------------------------------------------------
// Enums (unchanged – kept for reference in validation rules)
// ---------------------------------------------------------------------------
enum ScalarAttributeType {
  ATTRIBUTE_TYPE_UNSPECIFIED = 0;
  S = 1; // String
  N = 2; // Number
  B = 3; // Binary
}

enum ProjectionType {
  PROJECTION_TYPE_UNSPECIFIED = 0;
  ALL = 1;
  KEYS_ONLY = 2;
  INCLUDE = 3;
}

enum StreamViewType {
  STREAM_VIEW_TYPE_UNSPECIFIED = 0;
  NEW_IMAGE = 1;
  OLD_IMAGE = 2;
  NEW_AND_OLD_IMAGES = 3;
  KEYS_ONLY_VIEW = 4; // Renamed to avoid duplicate enum value names at the file scope.
}

enum EncryptionType {
  ENCRYPTION_TYPE_UNSPECIFIED = 0;
  AWS_OWNED = 1;
  AWS_MANAGED_KMS = 2;
  CUSTOMER_MANAGED_KMS = 3;
}

enum BillingMode {
  BILLING_MODE_UNSPECIFIED = 0;
  PROVISIONED = 1;
  PAY_PER_REQUEST = 2;
}

enum TableClass {
  TABLE_CLASS_UNSPECIFIED = 0;
  STANDARD = 1;
  STANDARD_INFREQUENT_ACCESS = 2;
}