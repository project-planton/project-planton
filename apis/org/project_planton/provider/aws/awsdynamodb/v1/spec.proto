syntax = "proto3";

package org.project_planton.provider.aws.awsdynamodb.v1;

import "buf/validate/validate.proto";

// AwsDynamodbSpec captures common fields for an AWS DynamoDB table.
message AwsDynamodbSpec {
  // Billing mode for the table.
  // Values match AWS API expected strings.
  enum BillingMode {
    BILLING_MODE_UNSPECIFIED = 0;
    PROVISIONED = 1; // Specify RCUs/WCUs
    PAY_PER_REQUEST = 2; // On-demand
  }

  // Attribute data types supported by DynamoDB keys and indexes.
  // Values match AWS API expected strings.
  enum AttributeType {
    ATTRIBUTE_TYPE_UNSPECIFIED = 0;
    S = 1; // String
    N = 2; // Number
    B = 3; // Binary
  }

  // Stream view type for DynamoDB Streams.
  // Values match AWS API expected strings.
  enum StreamViewType {
    STREAM_VIEW_TYPE_UNSPECIFIED = 0;
    KEYS_ONLY = 1;
    NEW_IMAGE = 2;
    OLD_IMAGE = 3;
    NEW_AND_OLD_IMAGES = 4;
  }

  // Projection type for indexes.
  // Values match AWS API expected strings.
  enum ProjectionType {
    PROJECTION_TYPE_UNSPECIFIED = 0;
    ALL = 1;
    KEYS_ONLY_PROJECTION = 2; // Note: Can't reuse KEYS_ONLY from StreamViewType
    INCLUDE = 3; // Include selected non-key attributes
  }

  // Table storage class.
  // Values match AWS API expected strings.
  enum TableClass {
    TABLE_CLASS_UNSPECIFIED = 0;
    STANDARD = 1;
    STANDARD_INFREQUENT_ACCESS = 2;
  }

  // Defines an attribute name and type.
  message AttributeDefinition {
    string name = 1 [(buf.validate.field).string.min_len = 1]; // Attribute name
    AttributeType type = 2 [(buf.validate.field).enum.defined_only = true]; // Attribute type
  }

  // Element of the key schema.
  message KeySchemaElement {
    string attribute_name = 1 [(buf.validate.field).string.min_len = 1]; // Must reference an attribute defined in attribute_definitions
    // Values match AWS API expected strings.
    enum KeyType {
      KEY_TYPE_UNSPECIFIED = 0;
      HASH = 1; // Partition key
      RANGE = 2; // Sort key
    }
    KeyType key_type = 2 [(buf.validate.field).enum.defined_only = true];
  }

  // Index projection configuration.
  message Projection {
    ProjectionType type = 1 [(buf.validate.field).enum.defined_only = true]; // ALL, KEYS_ONLY, or INCLUDE
    repeated string non_key_attributes = 2 [(buf.validate.field).repeated.unique = true]; // Used when type == INCLUDE

    option (buf.validate.message).cel = {
      id: "include_requires_attributes"
      message: "non_key_attributes must be set when projection type is INCLUDE, otherwise it must be empty"
      expression: "this.type == 3 ? this.non_key_attributes.size() > 0 : this.non_key_attributes.size() == 0"
    };
  }

  // Provisioned capacity settings.
  message ProvisionedThroughput {
    int64 read_capacity_units = 1 [(buf.validate.field).int64.gte = 0]; // RCUs
    int64 write_capacity_units = 2 [(buf.validate.field).int64.gte = 0]; // WCUs
  }

  // Global secondary index definition.
  message GlobalSecondaryIndex {
    string name = 1 [(buf.validate.field).string.min_len = 1]; // Index name
    repeated KeySchemaElement key_schema = 2 [(buf.validate.field).repeated.min_items = 1]; // HASH and optional RANGE
    Projection projection = 3; // Projection configuration
    ProvisionedThroughput provisioned_throughput = 4; // Required when billing_mode is PROVISIONED

    option (buf.validate.message).cel = {
      id: "gsi_key_schema_shape"
      message: "GSI must have exactly one HASH key and at most one RANGE key"
      expression: "this.key_schema.filter(k, k.key_type == 1).size() == 1 && this.key_schema.filter(k, k.key_type == 2).size() <= 1 && this.key_schema.size() >= 1 && this.key_schema.size() <= 2"
    };
  }

  // Local secondary index definition.
  message LocalSecondaryIndex {
    string name = 1 [(buf.validate.field).string.min_len = 1]; // Index name
    repeated KeySchemaElement key_schema = 2 [(buf.validate.field).repeated.min_items = 2]; // Same HASH as table; alternate RANGE
    Projection projection = 3; // Projection configuration

    option (buf.validate.message).cel = {
      id: "lsi_key_schema_shape"
      message: "LSI must have exactly one HASH key and one RANGE key"
      expression: "this.key_schema.size() == 2 && this.key_schema.filter(k, k.key_type == 1).size() == 1 && this.key_schema.filter(k, k.key_type == 2).size() == 1"
    };
  }

  // Server-side encryption settings.
  message ServerSideEncryption {
    bool enabled = 1; // Enable SSE
    string kms_key_arn = 2; // Optional customer-managed KMS key ARN
  }

  // Time-to-live (TTL) configuration.
  message TimeToLive {
    bool enabled = 1; // Enable TTL
    string attribute_name = 2; // Attribute storing TTL epoch time (in seconds)
  }

  // Billing configuration for the table.
  BillingMode billing_mode = 1 [(buf.validate.field).enum.defined_only = true];

  // Provisioned throughput for the table (used when billing_mode is PROVISIONED).
  ProvisionedThroughput provisioned_throughput = 2;

  // Attribute definitions referenced by the primary key and indexes.
  repeated AttributeDefinition attribute_definitions = 3 [(buf.validate.field).repeated.min_items = 1];

  // Primary key schema for the table: includes HASH and optional RANGE.
  repeated KeySchemaElement key_schema = 4 [(buf.validate.field).repeated.min_items = 1];

  // Global secondary indexes.
  repeated GlobalSecondaryIndex global_secondary_indexes = 5;

  // Local secondary indexes.
  repeated LocalSecondaryIndex local_secondary_indexes = 6;

  // Time-to-live configuration.
  TimeToLive ttl = 7;

  // DynamoDB Streams configuration.
  bool stream_enabled = 8;
  StreamViewType stream_view_type = 9 [(buf.validate.field).enum.defined_only = true];

  // Point-in-time recovery (PITR) setting.
  bool point_in_time_recovery_enabled = 10;

  // Server-side encryption settings.
  ServerSideEncryption server_side_encryption = 11;

  // Table storage class.
  TableClass table_class = 12 [(buf.validate.field).enum.defined_only = true];

  // Deletion protection setting.
  bool deletion_protection_enabled = 13;

  // Contributor Insights setting.
  bool contributor_insights_enabled = 14;

  // Message-level validations
  option (buf.validate.message).cel = {
    id: "billing_mode_set"
    message: "billing_mode must be set to PROVISIONED or PAY_PER_REQUEST"
    expression: "this.billing_mode != 0"
  };

  option (buf.validate.message).cel = {
    id: "table_key_schema_shape"
    message: "Table key_schema must have exactly one HASH key and at most one RANGE key (max 2 elements)"
    expression: "this.key_schema.filter(k, k.key_type == 1).size() == 1 && this.key_schema.filter(k, k.key_type == 2).size() <= 1 && this.key_schema.size() >= 1 && this.key_schema.size() <= 2"
  };

  option (buf.validate.message).cel = {
    id: "provisioned_requires_throughput"
    message: "When billing_mode is PROVISIONED, provisioned_throughput must be set with RCUs and WCUs > 0; for PAY_PER_REQUEST it must be unset or zero"
    expression: "this.billing_mode == 1 ? (has(this.provisioned_throughput) && this.provisioned_throughput.read_capacity_units > 0 && this.provisioned_throughput.write_capacity_units > 0) : (!has(this.provisioned_throughput) || (this.provisioned_throughput.read_capacity_units == 0 && this.provisioned_throughput.write_capacity_units == 0))"
  };

  option (buf.validate.message).cel = {
    id: "stream_view_requires_enabled"
    message: "stream_view_type must be set when stream_enabled is true, and must be UNSPECIFIED when disabled"
    expression: "this.stream_enabled ? this.stream_view_type != 0 : this.stream_view_type == 0"
  };

  option (buf.validate.message).cel = {
    id: "ttl_attribute_when_enabled"
    message: "ttl.attribute_name must be set when TTL is enabled, and must be empty when disabled"
    expression: "!has(this.ttl) || (this.ttl.enabled ? this.ttl.attribute_name != \"\" : this.ttl.attribute_name == \"\")"
  };

  option (buf.validate.message).cel = {
    id: "gsi_throughput_matches_billing"
    message: "For each GSI: when billing_mode is PROVISIONED, provisioned_throughput must be set with RCUs/WCUs > 0; for PAY_PER_REQUEST it must be unset or zero"
    expression: "this.global_secondary_indexes.all(i, this.billing_mode == 1 ? (has(i.provisioned_throughput) && i.provisioned_throughput.read_capacity_units > 0 && i.provisioned_throughput.write_capacity_units > 0) : (!has(i.provisioned_throughput) || (i.provisioned_throughput.read_capacity_units == 0 && i.provisioned_throughput.write_capacity_units == 0)))"
  };
}
