syntax = "proto3";

package org.project_planton.provider.aws.awsroute53zone.v1;

import "buf/validate/validate.proto";
import "org/project_planton/shared/networking/enums/dnsrecordtype/dns_record_type.proto";

// AwsRoute53ZoneSpec defines the specification required to create and manage a Route53 DNS Zone in AWS.
// This message encapsulates the configurations necessary for setting up DNS records within the zone,
// allowing you to specify multiple DNS records of various types, including support for Route53's
// advanced features like alias records, routing policies, health checks, and private zones.
//
// AWS Route53 is a scalable and highly available Domain Name System (DNS) web service that can be used
// to route users to internet applications by translating domain names into IP addresses.
//
// This specification helps in automating the creation and management of DNS records within a Route53 zone,
// ensuring that your domain names are correctly mapped to your resources with support for advanced
// traffic routing and high availability features.
message AwsRoute53ZoneSpec {
  // Flag to indicate if this is a private hosted zone.
  // Private zones are used for split-horizon DNS and only resolve within associated VPCs.
  // Public zones (is_private=false) resolve globally on the internet.
  // Default: false (public zone)
  bool is_private = 1;

  // VPC associations for private hosted zones.
  // Only applicable when is_private is true.
  // Each association allows the private zone to resolve DNS queries from the specified VPC.
  // You must enable enableDnsHostnames and enableDnsSupport in your VPC settings.
  repeated Route53VpcAssociation vpc_associations = 2;

  // Enable query logging for this hosted zone.
  // Query logs are sent to CloudWatch Logs and can be used for debugging,
  // security monitoring, and understanding query patterns.
  // Warning: High-traffic domains generate large log volumes.
  bool enable_query_logging = 3;

  // CloudWatch Log Group name for query logs (required if enable_query_logging is true).
  // The log group must exist before enabling query logging.
  string query_log_group_name = 4;

  // Enable DNSSEC for the hosted zone.
  // DNSSEC adds cryptographic signatures to DNS records to prevent spoofing attacks.
  // Note: Requires additional configuration at domain registrar level.
  bool enable_dnssec = 5;

  // The DNS records that are added to the zone.
  // Each record represents a DNS resource record with support for basic records (A, AAAA, CNAME, MX, TXT),
  // alias records (pointing to AWS resources), and advanced routing policies.
  // These records define how your domain or subdomains are routed to your resources.
  repeated Route53DnsRecord records = 6;
}

// Route53VpcAssociation represents a VPC association for a private hosted zone.
// Private zones can be associated with multiple VPCs, allowing DNS resolution across VPCs.
message Route53VpcAssociation {
  // The VPC ID to associate with the private hosted zone.
  // Example: "vpc-12345678"
  string vpc_id = 1 [(buf.validate.field).required = true];

  // The AWS region where the VPC is located.
  // Example: "us-east-1"
  string vpc_region = 2 [(buf.validate.field).required = true];
}

// Route53DnsRecord represents a DNS resource record in the Route53 zone.
// It supports basic DNS records, alias records (Route53's killer feature), and advanced routing policies
// for traffic management (weighted, latency-based, failover, geolocation).
//
// This message allows you to specify detailed DNS configurations for your domain,
// enabling fine-grained control over how your domain name resolves and how traffic is routed.
message Route53DnsRecord {
  // The DNS record type.
  // This specifies the type of DNS record, such as A, AAAA, CNAME, MX, TXT, etc.
  // The record type determines how the DNS query is processed and what kind of data is returned.
  org.project_planton.shared.networking.enums.dnsrecordtype.DnsRecordType record_type = 1 [(buf.validate.field).required = true];

  // The name of the DNS record, e.g., "example.com" or "dev.example.com".
  // This is the domain name or subdomain for which the DNS record applies.
  // Route53 will automatically append a trailing dot if not provided.
  // Supports wildcard records: "*.example.com" for catch-all subdomains.
  string name = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string = {pattern: "^(?:\\*\\.[A-Za-z0-9\\-\\.]+|[A-Za-z0-9\\-\\.]+\\.[A-Za-z]{2,}|[A-Za-z0-9\\-\\.]+)$"}
  ];

  // The Time To Live (TTL) for the DNS record, in seconds.
  // TTL specifies how long DNS resolvers should cache the DNS record before querying again.
  // Default: 300 seconds (5 minutes) - balances caching efficiency with change propagation speed.
  // Common values:
  //   - 60 seconds: For records you might change during incidents (faster cutover)
  //   - 300 seconds: Default for most records
  //   - 86400 seconds (1 day): For static records (MX, NS) to reduce query costs
  // Note: TTL is not applicable for alias records (ignored if alias_target is set).
  int32 ttl_seconds = 3;

  // The values for the DNS record.
  // This field contains the data associated with the DNS record type.
  // Examples:
  //   - A record: ["192.0.2.1", "192.0.2.2"]
  //   - AAAA record: ["2001:0db8::1"]
  //   - CNAME record: ["target.example.com."]
  //   - MX record: ["10 mail1.example.com.", "20 mail2.example.com."]
  //   - TXT record: ["v=spf1 include:_spf.example.com ~all"]
  // Note: This field is mutually exclusive with alias_target. Use one or the other, not both.
  repeated string values = 4;

  // Alias target configuration for Route53 alias records.
  // Alias records are Route53's killer feature - they allow you to:
  //   1. Point your zone apex (example.com) to AWS resources without CNAME restrictions
  //   2. Route traffic to CloudFront, ALB/NLB, S3 website, API Gateway, etc.
  //   3. Get free queries (no Route53 charges for alias queries to AWS resources)
  //
  // Use alias instead of CNAME for:
  //   - Zone apex records (DNS spec prohibits CNAME at zone apex)
  //   - AWS resource targets (free queries vs paid CNAME queries)
  //
  // Note: This field is mutually exclusive with values. Use one or the other, not both.
  // Note: TTL is not applicable for alias records (Route53 uses the target resource's TTL).
  Route53AliasTarget alias_target = 5;

  // Routing policy configuration.
  // Route53 supports multiple routing policies for advanced traffic management:
  //   - Simple: Default single-value response
  //   - Weighted: Split traffic across multiple resources (blue/green, canary deployments)
  //   - Latency: Route users to the lowest-latency endpoint (global applications)
  //   - Failover: Automatic failover to secondary resource with health checks
  //   - Geolocation: Route based on user's geographic location (GDPR compliance, localized content)
  //
  // If not specified, simple routing is used (standard DNS behavior).
  Route53RoutingPolicy routing_policy = 6;

  // Health check ID for failover routing.
  // Attach a Route53 health check to monitor endpoint availability.
  // When the primary resource fails the health check, Route53 automatically returns the failover record.
  //
  // Health checks monitor:
  //   - HTTP/HTTPS endpoints (status code, response body)
  //   - TCP connections
  //   - CloudWatch alarms (for application-level health)
  //
  // Cost: ~$0.50/month per health check for AWS endpoints (first 50 free)
  //
  // Note: Only used with failover routing policy.
  string health_check_id = 7;

  // Set identifier for routing policies.
  // Required for weighted, latency, failover, and geolocation routing.
  // Must be unique among records with the same name and type.
  // Example: "primary", "secondary", "us-east-1", "weight-70"
  string set_identifier = 8;
}

// Route53AliasTarget defines an alias record target.
// Alias records are a Route53-specific extension to DNS that allows you to route traffic
// to AWS resources without the limitations of CNAME records.
//
// Key benefits:
//   - Works at zone apex (example.com) where CNAME is not allowed
//   - No query charges for alias queries to AWS resources
//   - Automatic updates when target resource's IP changes
//
// Common use cases:
//   - Point apex domain to CloudFront distribution
//   - Point domain to Application/Network Load Balancer
//   - Point domain to S3 website endpoint
//   - Point domain to API Gateway
//   - Point domain to another Route53 record in same zone
message Route53AliasTarget {
  // The DNS name of the target resource.
  // Examples:
  //   - CloudFront: "d1234abcd.cloudfront.net"
  //   - ALB: "my-alb-1234567890.us-east-1.elb.amazonaws.com"
  //   - S3 website: "my-bucket.s3-website-us-east-1.amazonaws.com"
  //   - API Gateway: "abc123.execute-api.us-east-1.amazonaws.com"
  string dns_name = 1 [(buf.validate.field).required = true];

  // The hosted zone ID of the target resource.
  // Each AWS service has a specific hosted zone ID per region.
  // Common hosted zone IDs:
  //   - CloudFront: "Z2FDTNDATAQYW2" (global)
  //   - ALB (us-east-1): "Z35SXDOTRQ7X7K"
  //   - S3 website (us-east-1): "Z3AQBSTGFYJSTF"
  //
  // Note: This is NOT your Route53 zone ID - it's the AWS service's zone ID.
  // The Pulumi/Terraform provider typically handles this automatically.
  string hosted_zone_id = 2 [(buf.validate.field).required = true];

  // Evaluate target health.
  // If true, Route53 checks the health of the target resource before responding to queries.
  // Useful for automatic failover when combined with health checks.
  // Default: false
  bool evaluate_target_health = 3;
}

// Route53RoutingPolicy defines traffic routing policies for DNS records.
// Route53 supports multiple routing strategies beyond simple DNS resolution,
// enabling advanced traffic management, high availability, and performance optimization.
message Route53RoutingPolicy {
  oneof policy {
    // Weighted routing policy.
    // Distributes traffic across multiple resources based on assigned weights.
    // Use cases:
    //   - Blue/green deployments (90% old, 10% new)
    //   - A/B testing
    //   - Load distribution across regions
    Route53WeightedRoutingPolicy weighted = 1;

    // Latency-based routing policy.
    // Routes users to the resource with the lowest network latency.
    // Use cases:
    //   - Global applications serving users from multiple regions
    //   - Automatic selection of nearest endpoint
    Route53LatencyRoutingPolicy latency = 2;

    // Failover routing policy.
    // Routes to primary resource, automatically fails over to secondary when health check fails.
    // Use cases:
    //   - Active-passive disaster recovery
    //   - Automatic failover during incidents
    Route53FailoverRoutingPolicy failover = 3;

    // Geolocation routing policy.
    // Routes traffic based on the geographic location of the user.
    // Use cases:
    //   - GDPR compliance (EU users to EU endpoints)
    //   - Localized content
    //   - Geographic restrictions
    Route53GeolocationRoutingPolicy geolocation = 4;
  }
}

// Route53WeightedRoutingPolicy enables traffic splitting across multiple resources.
// Weights are relative - Route53 calculates the percentage based on the sum of all weights.
// Example: Records with weights 70 and 30 get 70% and 30% of traffic respectively.
message Route53WeightedRoutingPolicy {
  // Weight value (0-255).
  // Higher weight means more traffic.
  // Weight of 0 stops traffic to this record (useful for quick traffic draining).
  int32 weight = 1 [
    (buf.validate.field).int32.gte = 0,
    (buf.validate.field).int32.lte = 255
  ];
}

// Route53LatencyRoutingPolicy routes users to the resource with the lowest latency.
// Route53 measures latency from different AWS regions and automatically routes users
// to the endpoint that provides the best performance.
message Route53LatencyRoutingPolicy {
  // The AWS region where this resource is located.
  // Route53 uses this to measure latency from user locations.
  // Example: "us-east-1", "eu-west-1", "ap-southeast-1"
  string region = 1 [(buf.validate.field).required = true];
}

// Route53FailoverRoutingPolicy enables active-passive failover.
// Primary resource serves traffic when healthy. If health check fails,
// Route53 automatically routes traffic to the secondary resource.
message Route53FailoverRoutingPolicy {
  // Failover record type.
  // Must have exactly one PRIMARY and one SECONDARY record with the same name and type.
  FailoverRecordType type = 1 [(buf.validate.field).required = true];

  // Failover record type enum
  enum FailoverRecordType {
    // Default value (invalid, must specify PRIMARY or SECONDARY)
    FAILOVER_RECORD_TYPE_UNSPECIFIED = 0;
    // Primary record - serves traffic when healthy
    PRIMARY = 1;
    // Secondary record - serves traffic when primary fails health check
    SECONDARY = 2;
  }
}

// Route53GeolocationRoutingPolicy routes traffic based on user's geographic location.
// You can specify routing at the continent, country, or state level (US states only).
// Route53 selects the most specific match.
message Route53GeolocationRoutingPolicy {
  // Continent code (two-letter).
  // Examples: "NA" (North America), "EU" (Europe), "AS" (Asia)
  // Note: Use continent OR country, not both. Country is more specific.
  string continent = 1;

  // Country code (two-letter ISO 3166-1 alpha-2).
  // Examples: "US" (United States), "GB" (United Kingdom), "DE" (Germany)
  // More specific than continent.
  string country = 2;

  // Subdivision code (US state).
  // Only valid when country is "US".
  // Examples: "CA" (California), "NY" (New York), "TX" (Texas)
  // Most specific geolocation routing option.
  string subdivision = 3;
}
