// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/azure/azurekeyvault/v1/spec.proto

package azurekeyvaultv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/plantonhq/project-planton/apis/org/project_planton/shared/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// **AzureKeyVaultSku** defines the SKU tier for Azure Key Vault.
type AzureKeyVaultSku int32

const (
	// Unspecified SKU (will default to STANDARD)
	AzureKeyVaultSku_SKU_UNSPECIFIED AzureKeyVaultSku = 0
	// Standard SKU: Software-protected keys and secrets
	// Suitable for most applications, development, and non-regulated production workloads
	AzureKeyVaultSku_STANDARD AzureKeyVaultSku = 1
	// Premium SKU: HSM-backed keys (FIPS 140-2 Level 3 validated)
	// Required for compliance scenarios (PCI-DSS, HIPAA, FedRAMP, financial services)
	AzureKeyVaultSku_PREMIUM AzureKeyVaultSku = 2
)

// Enum value maps for AzureKeyVaultSku.
var (
	AzureKeyVaultSku_name = map[int32]string{
		0: "SKU_UNSPECIFIED",
		1: "STANDARD",
		2: "PREMIUM",
	}
	AzureKeyVaultSku_value = map[string]int32{
		"SKU_UNSPECIFIED": 0,
		"STANDARD":        1,
		"PREMIUM":         2,
	}
)

func (x AzureKeyVaultSku) Enum() *AzureKeyVaultSku {
	p := new(AzureKeyVaultSku)
	*p = x
	return p
}

func (x AzureKeyVaultSku) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AzureKeyVaultSku) Descriptor() protoreflect.EnumDescriptor {
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_enumTypes[0].Descriptor()
}

func (AzureKeyVaultSku) Type() protoreflect.EnumType {
	return &file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_enumTypes[0]
}

func (x AzureKeyVaultSku) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AzureKeyVaultSku.Descriptor instead.
func (AzureKeyVaultSku) EnumDescriptor() ([]byte, []int) {
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescGZIP(), []int{0}
}

// **AzureKeyVaultNetworkAction** defines the default network action for Key Vault.
type AzureKeyVaultNetworkAction int32

const (
	// Unspecified action (will default to DENY)
	AzureKeyVaultNetworkAction_ACTION_UNSPECIFIED AzureKeyVaultNetworkAction = 0
	// Allow all network traffic (not recommended for production)
	AzureKeyVaultNetworkAction_ALLOW AzureKeyVaultNetworkAction = 1
	// Deny all network traffic unless explicitly allowed (recommended for production)
	AzureKeyVaultNetworkAction_DENY AzureKeyVaultNetworkAction = 2
)

// Enum value maps for AzureKeyVaultNetworkAction.
var (
	AzureKeyVaultNetworkAction_name = map[int32]string{
		0: "ACTION_UNSPECIFIED",
		1: "ALLOW",
		2: "DENY",
	}
	AzureKeyVaultNetworkAction_value = map[string]int32{
		"ACTION_UNSPECIFIED": 0,
		"ALLOW":              1,
		"DENY":               2,
	}
)

func (x AzureKeyVaultNetworkAction) Enum() *AzureKeyVaultNetworkAction {
	p := new(AzureKeyVaultNetworkAction)
	*p = x
	return p
}

func (x AzureKeyVaultNetworkAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AzureKeyVaultNetworkAction) Descriptor() protoreflect.EnumDescriptor {
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_enumTypes[1].Descriptor()
}

func (AzureKeyVaultNetworkAction) Type() protoreflect.EnumType {
	return &file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_enumTypes[1]
}

func (x AzureKeyVaultNetworkAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AzureKeyVaultNetworkAction.Descriptor instead.
func (AzureKeyVaultNetworkAction) EnumDescriptor() ([]byte, []int) {
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescGZIP(), []int{1}
}

// **AzureKeyVaultSpec** defines the configuration for creating an Azure Key Vault.
// This follows the 80/20 principle: exposing the 20% of configurations that 80% of users need.
type AzureKeyVaultSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Azure region where the Key Vault will be deployed (e.g., "eastus", "westus2", "westeurope").
	// This is required as Key Vault is a regional service.
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// The Azure Resource Group name where the Key Vault will be created.
	// The resource group must already exist.
	ResourceGroup string `protobuf:"bytes,2,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// The SKU tier for the Key Vault.
	// - STANDARD: Software-protected keys, suitable for most applications
	// - PREMIUM: HSM-backed keys, required for compliance (PCI-DSS, FIPS 140-2 Level 3)
	// Default: STANDARD
	Sku *AzureKeyVaultSku `protobuf:"varint,3,opt,name=sku,proto3,enum=org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSku,oneof" json:"sku,omitempty"`
	// Enable Azure RBAC for authorization instead of vault access policies.
	// RBAC is the modern, recommended approach that integrates with Azure AD and PIM.
	// Default: true (strongly recommended for new deployments)
	EnableRbacAuthorization *bool `protobuf:"varint,4,opt,name=enable_rbac_authorization,json=enableRbacAuthorization,proto3,oneof" json:"enable_rbac_authorization,omitempty"`
	// Enable purge protection to prevent permanent deletion of the vault and its contents.
	// When enabled, deleted vaults are retained for the soft delete retention period and cannot be purged.
	// CRITICAL: Should always be true for production environments.
	// Default: true
	EnablePurgeProtection *bool `protobuf:"varint,5,opt,name=enable_purge_protection,json=enablePurgeProtection,proto3,oneof" json:"enable_purge_protection,omitempty"`
	// Soft delete retention period in days (7-90 days).
	// Deleted secrets, keys, and certificates are retained for this period and can be recovered.
	// Default: 90 days (maximum retention)
	SoftDeleteRetentionDays *int32 `protobuf:"varint,6,opt,name=soft_delete_retention_days,json=softDeleteRetentionDays,proto3,oneof" json:"soft_delete_retention_days,omitempty"`
	// Network access control configuration for the Key Vault.
	// Controls who can access the vault from where (public internet, specific IPs, VNets).
	NetworkAcls *AzureKeyVaultNetworkAcls `protobuf:"bytes,7,opt,name=network_acls,json=networkAcls,proto3,oneof" json:"network_acls,omitempty"`
	// List of secret names to create in the Key Vault.
	// The actual secret values should be set separately after vault creation using Azure SDK,
	// Azure CLI, or the Key Vault API (never hardcoded in IaC).
	SecretNames   []string `protobuf:"bytes,8,rep,name=secret_names,json=secretNames,proto3" json:"secret_names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AzureKeyVaultSpec) Reset() {
	*x = AzureKeyVaultSpec{}
	mi := &file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureKeyVaultSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureKeyVaultSpec) ProtoMessage() {}

func (x *AzureKeyVaultSpec) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureKeyVaultSpec.ProtoReflect.Descriptor instead.
func (*AzureKeyVaultSpec) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *AzureKeyVaultSpec) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *AzureKeyVaultSpec) GetResourceGroup() string {
	if x != nil {
		return x.ResourceGroup
	}
	return ""
}

func (x *AzureKeyVaultSpec) GetSku() AzureKeyVaultSku {
	if x != nil && x.Sku != nil {
		return *x.Sku
	}
	return AzureKeyVaultSku_SKU_UNSPECIFIED
}

func (x *AzureKeyVaultSpec) GetEnableRbacAuthorization() bool {
	if x != nil && x.EnableRbacAuthorization != nil {
		return *x.EnableRbacAuthorization
	}
	return false
}

func (x *AzureKeyVaultSpec) GetEnablePurgeProtection() bool {
	if x != nil && x.EnablePurgeProtection != nil {
		return *x.EnablePurgeProtection
	}
	return false
}

func (x *AzureKeyVaultSpec) GetSoftDeleteRetentionDays() int32 {
	if x != nil && x.SoftDeleteRetentionDays != nil {
		return *x.SoftDeleteRetentionDays
	}
	return 0
}

func (x *AzureKeyVaultSpec) GetNetworkAcls() *AzureKeyVaultNetworkAcls {
	if x != nil {
		return x.NetworkAcls
	}
	return nil
}

func (x *AzureKeyVaultSpec) GetSecretNames() []string {
	if x != nil {
		return x.SecretNames
	}
	return nil
}

// **AzureKeyVaultNetworkAcls** defines network access control rules for the Key Vault.
type AzureKeyVaultNetworkAcls struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Default action when no explicit rule matches.
	// - ALLOW: Permit all traffic (not recommended for production)
	// - DENY: Block all traffic unless explicitly allowed (recommended)
	// Default: DENY
	DefaultAction *AzureKeyVaultNetworkAction `protobuf:"varint,1,opt,name=default_action,json=defaultAction,proto3,enum=org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAction,oneof" json:"default_action,omitempty"`
	// Allow traffic from trusted Azure services even when default_action is DENY.
	// This includes services like Azure Backup, Azure Site Recovery, Azure Monitor, etc.
	// Default: true (recommended to allow Azure service integrations)
	BypassAzureServices *bool `protobuf:"varint,2,opt,name=bypass_azure_services,json=bypassAzureServices,proto3,oneof" json:"bypass_azure_services,omitempty"`
	// List of IP addresses or CIDR ranges allowed to access the vault.
	// Example: ["203.0.113.0/24", "198.51.100.42"]
	// Used for office IPs, VPN gateways, CI/CD runners, etc.
	IpRules []string `protobuf:"bytes,3,rep,name=ip_rules,json=ipRules,proto3" json:"ip_rules,omitempty"`
	// List of Azure Virtual Network subnet resource IDs allowed to access the vault.
	// Example: ["/subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/{subnet}"]
	// Used to restrict access to specific VNets/subnets.
	VirtualNetworkSubnetIds []string `protobuf:"bytes,4,rep,name=virtual_network_subnet_ids,json=virtualNetworkSubnetIds,proto3" json:"virtual_network_subnet_ids,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *AzureKeyVaultNetworkAcls) Reset() {
	*x = AzureKeyVaultNetworkAcls{}
	mi := &file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureKeyVaultNetworkAcls) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureKeyVaultNetworkAcls) ProtoMessage() {}

func (x *AzureKeyVaultNetworkAcls) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureKeyVaultNetworkAcls.ProtoReflect.Descriptor instead.
func (*AzureKeyVaultNetworkAcls) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *AzureKeyVaultNetworkAcls) GetDefaultAction() AzureKeyVaultNetworkAction {
	if x != nil && x.DefaultAction != nil {
		return *x.DefaultAction
	}
	return AzureKeyVaultNetworkAction_ACTION_UNSPECIFIED
}

func (x *AzureKeyVaultNetworkAcls) GetBypassAzureServices() bool {
	if x != nil && x.BypassAzureServices != nil {
		return *x.BypassAzureServices
	}
	return false
}

func (x *AzureKeyVaultNetworkAcls) GetIpRules() []string {
	if x != nil {
		return x.IpRules
	}
	return nil
}

func (x *AzureKeyVaultNetworkAcls) GetVirtualNetworkSubnetIds() []string {
	if x != nil {
		return x.VirtualNetworkSubnetIds
	}
	return nil
}

var File_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDesc = "" +
	"\n" +
	">org/project_planton/provider/azure/azurekeyvault/v1/spec.proto\x123org.project_planton.provider.azure.azurekeyvault.v1\x1a\x1bbuf/validate/validate.proto\x1a0org/project_planton/shared/options/options.proto\"\xd3\x05\n" +
	"\x11AzureKeyVaultSpec\x12\"\n" +
	"\x06region\x18\x01 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x01R\x06region\x121\n" +
	"\x0eresource_group\x18\x02 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x01R\rresourceGroup\x12j\n" +
	"\x03sku\x18\x03 \x01(\x0e2E.org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSkuB\f\x8a\xa6\x1d\bSTANDARDH\x00R\x03sku\x88\x01\x01\x12I\n" +
	"\x19enable_rbac_authorization\x18\x04 \x01(\bB\b\x8a\xa6\x1d\x04trueH\x01R\x17enableRbacAuthorization\x88\x01\x01\x12E\n" +
	"\x17enable_purge_protection\x18\x05 \x01(\bB\b\x8a\xa6\x1d\x04trueH\x02R\x15enablePurgeProtection\x88\x01\x01\x12Q\n" +
	"\x1asoft_delete_retention_days\x18\x06 \x01(\x05B\x0f\xbaH\x06\x1a\x04\x18Z(\a\x8a\xa6\x1d\x0290H\x03R\x17softDeleteRetentionDays\x88\x01\x01\x12u\n" +
	"\fnetwork_acls\x18\a \x01(\v2M.org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAclsH\x04R\vnetworkAcls\x88\x01\x01\x12-\n" +
	"\fsecret_names\x18\b \x03(\tB\n" +
	"\xbaH\a\x92\x01\x04\b\x00\x10dR\vsecretNamesB\x06\n" +
	"\x04_skuB\x1c\n" +
	"\x1a_enable_rbac_authorizationB\x1a\n" +
	"\x18_enable_purge_protectionB\x1d\n" +
	"\x1b_soft_delete_retention_daysB\x0f\n" +
	"\r_network_acls\"\xff\x02\n" +
	"\x18AzureKeyVaultNetworkAcls\x12\x85\x01\n" +
	"\x0edefault_action\x18\x01 \x01(\x0e2O.org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkActionB\b\x8a\xa6\x1d\x04DENYH\x00R\rdefaultAction\x88\x01\x01\x12A\n" +
	"\x15bypass_azure_services\x18\x02 \x01(\bB\b\x8a\xa6\x1d\x04trueH\x01R\x13bypassAzureServices\x88\x01\x01\x12$\n" +
	"\bip_rules\x18\x03 \x03(\tB\t\xbaH\x06\x92\x01\x03\x10\xc8\x01R\aipRules\x12E\n" +
	"\x1avirtual_network_subnet_ids\x18\x04 \x03(\tB\b\xbaH\x05\x92\x01\x02\x10dR\x17virtualNetworkSubnetIdsB\x11\n" +
	"\x0f_default_actionB\x18\n" +
	"\x16_bypass_azure_services*B\n" +
	"\x10AzureKeyVaultSku\x12\x13\n" +
	"\x0fSKU_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bSTANDARD\x10\x01\x12\v\n" +
	"\aPREMIUM\x10\x02*I\n" +
	"\x1aAzureKeyVaultNetworkAction\x12\x16\n" +
	"\x12ACTION_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05ALLOW\x10\x01\x12\b\n" +
	"\x04DENY\x10\x02B\xa2\x03\n" +
	"7com.org.project_planton.provider.azure.azurekeyvault.v1B\tSpecProtoP\x01Zmgithub.com/plantonhq/project-planton/apis/org/project_planton/provider/azure/azurekeyvault/v1;azurekeyvaultv1\xa2\x02\x05OPPAA\xaa\x022Org.ProjectPlanton.Provider.Azure.Azurekeyvault.V1\xca\x022Org\\ProjectPlanton\\Provider\\Azure\\Azurekeyvault\\V1\xe2\x02>Org\\ProjectPlanton\\Provider\\Azure\\Azurekeyvault\\V1\\GPBMetadata\xea\x027Org::ProjectPlanton::Provider::Azure::Azurekeyvault::V1b\x06proto3"

var (
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescData []byte
)

func file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDesc)))
	})
	return file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDescData
}

var file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_goTypes = []any{
	(AzureKeyVaultSku)(0),            // 0: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSku
	(AzureKeyVaultNetworkAction)(0),  // 1: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAction
	(*AzureKeyVaultSpec)(nil),        // 2: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSpec
	(*AzureKeyVaultNetworkAcls)(nil), // 3: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAcls
}
var file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_depIdxs = []int32{
	0, // 0: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSpec.sku:type_name -> org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSku
	3, // 1: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultSpec.network_acls:type_name -> org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAcls
	1, // 2: org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAcls.default_action:type_name -> org.project_planton.provider.azure.azurekeyvault.v1.AzureKeyVaultNetworkAction
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_init() }
func file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_init() {
	if File_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto != nil {
		return
	}
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes[0].OneofWrappers = []any{}
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes[1].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_depIdxs,
		EnumInfos:         file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_enumTypes,
		MessageInfos:      file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_msgTypes,
	}.Build()
	File_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto = out.File
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_goTypes = nil
	file_org_project_planton_provider_azure_azurekeyvault_v1_spec_proto_depIdxs = nil
}
