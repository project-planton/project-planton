// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/kubernetes/kubernetesdaemonset/v1/spec.proto

package kubernetesdaemonsetv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	kubernetes "github.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes"
	v1 "github.com/project-planton/project-planton/apis/org/project_planton/shared/foreignkey/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// **KubernetesDaemonSetSpec** defines the configuration for deploying a DaemonSet on a Kubernetes cluster.
// A DaemonSet ensures that all (or some) nodes run a copy of a pod. As nodes are added to the cluster,
// pods are added to them. As nodes are removed from the cluster, those pods are garbage collected.
// Common use cases include: cluster storage daemons, log collection daemons, and node monitoring daemons.
type KubernetesDaemonSetSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target Kubernetes Cluster
	TargetCluster *kubernetes.KubernetesClusterSelector `protobuf:"bytes,1,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	// Kubernetes Namespace
	Namespace *v1.StringValueOrRef `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Flag to indicate if the namespace should be created
	CreateNamespace bool `protobuf:"varint,3,opt,name=create_namespace,json=createNamespace,proto3" json:"create_namespace,omitempty"`
	// The container specifications for the DaemonSet.
	// This includes configurations for the main application container and any sidecar containers.
	Container *KubernetesDaemonSetContainer `protobuf:"bytes,4,opt,name=container,proto3" json:"container,omitempty"`
	// Node selector for constraining the DaemonSet pods to run on specific nodes.
	// Key-value pairs that must match labels on nodes for the pod to be scheduled.
	NodeSelector map[string]string `protobuf:"bytes,5,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Tolerations allow the DaemonSet pods to be scheduled on nodes with matching taints.
	// This is essential for running pods on master nodes or nodes with specific taints.
	Tolerations []*KubernetesDaemonSetToleration `protobuf:"bytes,6,rep,name=tolerations,proto3" json:"tolerations,omitempty"`
	// The update strategy for the DaemonSet.
	// Controls how pods are updated when the DaemonSet specification changes.
	UpdateStrategy *KubernetesDaemonSetUpdateStrategy `protobuf:"bytes,7,opt,name=update_strategy,json=updateStrategy,proto3" json:"update_strategy,omitempty"`
	// Minimum number of seconds for which a newly created DaemonSet pod should be ready
	// without any of its container crashing, for it to be considered available.
	// Defaults to 0 (pod will be considered available as soon as it is ready).
	MinReadySeconds int32 `protobuf:"varint,8,opt,name=min_ready_seconds,json=minReadySeconds,proto3" json:"min_ready_seconds,omitempty"`
	// *
	// Flag to indicate if a ServiceAccount should be created for this DaemonSet.
	// If true, a ServiceAccount with the name specified in service_account_name
	// (or the DaemonSet name if not specified) will be created.
	// The DaemonSet pods will use this ServiceAccount.
	CreateServiceAccount bool `protobuf:"varint,9,opt,name=create_service_account,json=createServiceAccount,proto3" json:"create_service_account,omitempty"`
	// *
	// Name of the ServiceAccount to use for the DaemonSet pods.
	// If create_service_account is true, a ServiceAccount with this name will be created.
	// If create_service_account is false, this references an existing ServiceAccount.
	// If not specified and create_service_account is true, uses the DaemonSet name.
	ServiceAccountName string `protobuf:"bytes,10,opt,name=service_account_name,json=serviceAccountName,proto3" json:"service_account_name,omitempty"`
	// *
	// ConfigMaps to create alongside the DaemonSet.
	// Key is the ConfigMap name, value is the content.
	// These ConfigMaps can be referenced in volume mounts.
	//
	// Example:
	//
	//	config_maps:
	//	  vector-config: |
	//	    data_dir: /var/lib/vector
	//	    sources:
	//	      kubernetes_logs:
	//	        type: kubernetes_logs
	ConfigMaps map[string]string `protobuf:"bytes,11,rep,name=config_maps,json=configMaps,proto3" json:"config_maps,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// *
	// RBAC configuration for the DaemonSet ServiceAccount.
	// Allows defining ClusterRole and Role permissions.
	// Only used if create_service_account is true.
	Rbac          *KubernetesDaemonSetRbac `protobuf:"bytes,12,opt,name=rbac,proto3" json:"rbac,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetSpec) Reset() {
	*x = KubernetesDaemonSetSpec{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetSpec) ProtoMessage() {}

func (x *KubernetesDaemonSetSpec) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetSpec.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetSpec) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *KubernetesDaemonSetSpec) GetTargetCluster() *kubernetes.KubernetesClusterSelector {
	if x != nil {
		return x.TargetCluster
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetNamespace() *v1.StringValueOrRef {
	if x != nil {
		return x.Namespace
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetCreateNamespace() bool {
	if x != nil {
		return x.CreateNamespace
	}
	return false
}

func (x *KubernetesDaemonSetSpec) GetContainer() *KubernetesDaemonSetContainer {
	if x != nil {
		return x.Container
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetNodeSelector() map[string]string {
	if x != nil {
		return x.NodeSelector
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetTolerations() []*KubernetesDaemonSetToleration {
	if x != nil {
		return x.Tolerations
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetUpdateStrategy() *KubernetesDaemonSetUpdateStrategy {
	if x != nil {
		return x.UpdateStrategy
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetMinReadySeconds() int32 {
	if x != nil {
		return x.MinReadySeconds
	}
	return 0
}

func (x *KubernetesDaemonSetSpec) GetCreateServiceAccount() bool {
	if x != nil {
		return x.CreateServiceAccount
	}
	return false
}

func (x *KubernetesDaemonSetSpec) GetServiceAccountName() string {
	if x != nil {
		return x.ServiceAccountName
	}
	return ""
}

func (x *KubernetesDaemonSetSpec) GetConfigMaps() map[string]string {
	if x != nil {
		return x.ConfigMaps
	}
	return nil
}

func (x *KubernetesDaemonSetSpec) GetRbac() *KubernetesDaemonSetRbac {
	if x != nil {
		return x.Rbac
	}
	return nil
}

// *
// **KubernetesDaemonSetContainer** specifies the container configuration for the DaemonSet.
// It includes the main application container and any sidecar containers that need to run alongside it.
type KubernetesDaemonSetContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The main application container specifications.
	App *KubernetesDaemonSetContainerApp `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
	// A list of sidecar containers to be deployed alongside the main application container.
	Sidecars      []*kubernetes.Container `protobuf:"bytes,2,rep,name=sidecars,proto3" json:"sidecars,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetContainer) Reset() {
	*x = KubernetesDaemonSetContainer{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetContainer) ProtoMessage() {}

func (x *KubernetesDaemonSetContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetContainer.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *KubernetesDaemonSetContainer) GetApp() *KubernetesDaemonSetContainerApp {
	if x != nil {
		return x.App
	}
	return nil
}

func (x *KubernetesDaemonSetContainer) GetSidecars() []*kubernetes.Container {
	if x != nil {
		return x.Sidecars
	}
	return nil
}

// *
// **KubernetesDaemonSetContainerApp** specifies the configuration for the main application container.
// It includes the container image, resource allocations, environment variables, and health probes.
type KubernetesDaemonSetContainerApp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The container image to be used for the application.
	// The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes DaemonSet resource.
	Image *kubernetes.ContainerImage `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// The CPU and memory resources allocated to the application container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// *
	// The environment variables and secrets for the application container.
	Env *KubernetesDaemonSetContainerAppEnv `protobuf:"bytes,3,opt,name=env,proto3" json:"env,omitempty"`
	// *
	// A list of ports to be configured for the application container.
	Ports []*KubernetesDaemonSetContainerAppPort `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	// *
	// Volume mounts for the container.
	// Supports ConfigMap, Secret, HostPath, EmptyDir, and PVC volumes.
	// DaemonSets commonly need HostPath mounts for log collection, node monitoring, etc.
	VolumeMounts []*kubernetes.VolumeMount `protobuf:"bytes,5,rep,name=volume_mounts,json=volumeMounts,proto3" json:"volume_mounts,omitempty"`
	// *
	// Liveness probe configuration.
	// Periodic probe of container liveness. Container will be restarted if the probe fails.
	LivenessProbe *kubernetes.Probe `protobuf:"bytes,6,opt,name=liveness_probe,json=livenessProbe,proto3" json:"liveness_probe,omitempty"`
	// *
	// Readiness probe configuration.
	// Periodic probe of container service readiness.
	ReadinessProbe *kubernetes.Probe `protobuf:"bytes,7,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	// *
	// Startup probe configuration.
	// Indicates whether the application within the container is started.
	StartupProbe *kubernetes.Probe `protobuf:"bytes,8,opt,name=startup_probe,json=startupProbe,proto3" json:"startup_probe,omitempty"`
	// *
	// Command to run in the container (overrides the container image's ENTRYPOINT).
	Command []string `protobuf:"bytes,9,rep,name=command,proto3" json:"command,omitempty"`
	// *
	// Arguments to pass to the command (overrides the container image's CMD).
	Args []string `protobuf:"bytes,10,rep,name=args,proto3" json:"args,omitempty"`
	// *
	// Security context for the container.
	// DaemonSets often need privileged access for node-level operations.
	SecurityContext *KubernetesDaemonSetSecurityContext `protobuf:"bytes,11,opt,name=security_context,json=securityContext,proto3" json:"security_context,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *KubernetesDaemonSetContainerApp) Reset() {
	*x = KubernetesDaemonSetContainerApp{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetContainerApp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetContainerApp) ProtoMessage() {}

func (x *KubernetesDaemonSetContainerApp) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetContainerApp.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetContainerApp) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *KubernetesDaemonSetContainerApp) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetEnv() *KubernetesDaemonSetContainerAppEnv {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetPorts() []*KubernetesDaemonSetContainerAppPort {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetVolumeMounts() []*kubernetes.VolumeMount {
	if x != nil {
		return x.VolumeMounts
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetLivenessProbe() *kubernetes.Probe {
	if x != nil {
		return x.LivenessProbe
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetReadinessProbe() *kubernetes.Probe {
	if x != nil {
		return x.ReadinessProbe
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetStartupProbe() *kubernetes.Probe {
	if x != nil {
		return x.StartupProbe
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetCommand() []string {
	if x != nil {
		return x.Command
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetArgs() []string {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *KubernetesDaemonSetContainerApp) GetSecurityContext() *KubernetesDaemonSetSecurityContext {
	if x != nil {
		return x.SecurityContext
	}
	return nil
}

// *
// **KubernetesDaemonSetContainerAppEnv** defines the environment variables and secrets for the application container.
type KubernetesDaemonSetContainerAppEnv struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A map of environment variable names to their values.
	Variables map[string]string `protobuf:"bytes,1,rep,name=variables,proto3" json:"variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// *
	// A map of secret environment variable names to their values.
	// Each secret can be provided either as a literal string value or as a reference
	// to an existing Kubernetes Secret.
	//
	// Using secret references is recommended for production deployments.
	Secrets       map[string]*kubernetes.KubernetesSensitiveValue `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetContainerAppEnv) Reset() {
	*x = KubernetesDaemonSetContainerAppEnv{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetContainerAppEnv) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetContainerAppEnv) ProtoMessage() {}

func (x *KubernetesDaemonSetContainerAppEnv) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetContainerAppEnv.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetContainerAppEnv) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *KubernetesDaemonSetContainerAppEnv) GetVariables() map[string]string {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *KubernetesDaemonSetContainerAppEnv) GetSecrets() map[string]*kubernetes.KubernetesSensitiveValue {
	if x != nil {
		return x.Secrets
	}
	return nil
}

// *
// **KubernetesDaemonSetContainerAppPort** specifies the port configuration for the application container.
type KubernetesDaemonSetContainerAppPort struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the port (e.g., "metrics", "health").
	// The name must only contain lowercase alphanumeric characters and hyphens.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The port number on the container.
	ContainerPort int32 `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	// The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
	NetworkProtocol string `protobuf:"bytes,3,opt,name=network_protocol,json=networkProtocol,proto3" json:"network_protocol,omitempty"`
	// Host port to expose the container port on.
	// Use with caution as it limits where pods can be scheduled.
	HostPort      int32 `protobuf:"varint,4,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetContainerAppPort) Reset() {
	*x = KubernetesDaemonSetContainerAppPort{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetContainerAppPort) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetContainerAppPort) ProtoMessage() {}

func (x *KubernetesDaemonSetContainerAppPort) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetContainerAppPort.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetContainerAppPort) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{4}
}

func (x *KubernetesDaemonSetContainerAppPort) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesDaemonSetContainerAppPort) GetContainerPort() int32 {
	if x != nil {
		return x.ContainerPort
	}
	return 0
}

func (x *KubernetesDaemonSetContainerAppPort) GetNetworkProtocol() string {
	if x != nil {
		return x.NetworkProtocol
	}
	return ""
}

func (x *KubernetesDaemonSetContainerAppPort) GetHostPort() int32 {
	if x != nil {
		return x.HostPort
	}
	return 0
}

// *
// **KubernetesDaemonSetToleration** defines a toleration for the DaemonSet pods.
type KubernetesDaemonSetToleration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the taint key that the toleration applies to.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// Value is the taint value the toleration matches to.
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Effect indicates the taint effect to match.
	// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
	Effect string `protobuf:"bytes,4,opt,name=effect,proto3" json:"effect,omitempty"`
	// TolerationSeconds represents the period of time the toleration tolerates the taint.
	// Only applicable when effect is NoExecute.
	TolerationSeconds int64 `protobuf:"varint,5,opt,name=toleration_seconds,json=tolerationSeconds,proto3" json:"toleration_seconds,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *KubernetesDaemonSetToleration) Reset() {
	*x = KubernetesDaemonSetToleration{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetToleration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetToleration) ProtoMessage() {}

func (x *KubernetesDaemonSetToleration) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetToleration.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetToleration) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{5}
}

func (x *KubernetesDaemonSetToleration) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KubernetesDaemonSetToleration) GetOperator() string {
	if x != nil {
		return x.Operator
	}
	return ""
}

func (x *KubernetesDaemonSetToleration) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *KubernetesDaemonSetToleration) GetEffect() string {
	if x != nil {
		return x.Effect
	}
	return ""
}

func (x *KubernetesDaemonSetToleration) GetTolerationSeconds() int64 {
	if x != nil {
		return x.TolerationSeconds
	}
	return 0
}

// *
// **KubernetesDaemonSetUpdateStrategy** defines the update strategy for the DaemonSet.
type KubernetesDaemonSetUpdateStrategy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of update strategy.
	// Can be "RollingUpdate" or "OnDelete".
	// RollingUpdate: The DaemonSet controller creates new pods and deletes old ones progressively.
	// OnDelete: Pods are only updated when they are manually deleted.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Rolling update config params. Present only if type = "RollingUpdate".
	RollingUpdate *KubernetesDaemonSetRollingUpdate `protobuf:"bytes,2,opt,name=rolling_update,json=rollingUpdate,proto3" json:"rolling_update,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetUpdateStrategy) Reset() {
	*x = KubernetesDaemonSetUpdateStrategy{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetUpdateStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetUpdateStrategy) ProtoMessage() {}

func (x *KubernetesDaemonSetUpdateStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetUpdateStrategy.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetUpdateStrategy) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{6}
}

func (x *KubernetesDaemonSetUpdateStrategy) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *KubernetesDaemonSetUpdateStrategy) GetRollingUpdate() *KubernetesDaemonSetRollingUpdate {
	if x != nil {
		return x.RollingUpdate
	}
	return nil
}

// *
// **KubernetesDaemonSetRollingUpdate** defines the parameters for rolling update strategy.
type KubernetesDaemonSetRollingUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum number of DaemonSet pods that can be unavailable during the update.
	// Can be an absolute number or a percentage (e.g., "1" or "10%").
	// This cannot be 0 if maxSurge is 0.
	// Defaults to 1.
	MaxUnavailable string `protobuf:"bytes,1,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	// The maximum number of nodes with an existing available DaemonSet pod that can have
	// an updated DaemonSet pod during an update.
	// Can be an absolute number or a percentage (e.g., "1" or "10%").
	// Defaults to 0.
	MaxSurge      string `protobuf:"bytes,2,opt,name=max_surge,json=maxSurge,proto3" json:"max_surge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetRollingUpdate) Reset() {
	*x = KubernetesDaemonSetRollingUpdate{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetRollingUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetRollingUpdate) ProtoMessage() {}

func (x *KubernetesDaemonSetRollingUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetRollingUpdate.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetRollingUpdate) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{7}
}

func (x *KubernetesDaemonSetRollingUpdate) GetMaxUnavailable() string {
	if x != nil {
		return x.MaxUnavailable
	}
	return ""
}

func (x *KubernetesDaemonSetRollingUpdate) GetMaxSurge() string {
	if x != nil {
		return x.MaxSurge
	}
	return ""
}

// *
// **KubernetesDaemonSetSecurityContext** defines the security context for the container.
type KubernetesDaemonSetSecurityContext struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Run as privileged container.
	// DaemonSets often need privileged access for node-level operations.
	Privileged bool `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// Run as a specific user ID.
	RunAsUser int64 `protobuf:"varint,2,opt,name=run_as_user,json=runAsUser,proto3" json:"run_as_user,omitempty"`
	// Run as a specific group ID.
	RunAsGroup int64 `protobuf:"varint,3,opt,name=run_as_group,json=runAsGroup,proto3" json:"run_as_group,omitempty"`
	// Run as non-root user.
	RunAsNonRoot bool `protobuf:"varint,4,opt,name=run_as_non_root,json=runAsNonRoot,proto3" json:"run_as_non_root,omitempty"`
	// Make the root filesystem read-only.
	ReadOnlyRootFilesystem bool `protobuf:"varint,5,opt,name=read_only_root_filesystem,json=readOnlyRootFilesystem,proto3" json:"read_only_root_filesystem,omitempty"`
	// Capabilities to add or drop.
	Capabilities  *KubernetesDaemonSetCapabilities `protobuf:"bytes,6,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetSecurityContext) Reset() {
	*x = KubernetesDaemonSetSecurityContext{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetSecurityContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetSecurityContext) ProtoMessage() {}

func (x *KubernetesDaemonSetSecurityContext) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetSecurityContext.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetSecurityContext) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{8}
}

func (x *KubernetesDaemonSetSecurityContext) GetPrivileged() bool {
	if x != nil {
		return x.Privileged
	}
	return false
}

func (x *KubernetesDaemonSetSecurityContext) GetRunAsUser() int64 {
	if x != nil {
		return x.RunAsUser
	}
	return 0
}

func (x *KubernetesDaemonSetSecurityContext) GetRunAsGroup() int64 {
	if x != nil {
		return x.RunAsGroup
	}
	return 0
}

func (x *KubernetesDaemonSetSecurityContext) GetRunAsNonRoot() bool {
	if x != nil {
		return x.RunAsNonRoot
	}
	return false
}

func (x *KubernetesDaemonSetSecurityContext) GetReadOnlyRootFilesystem() bool {
	if x != nil {
		return x.ReadOnlyRootFilesystem
	}
	return false
}

func (x *KubernetesDaemonSetSecurityContext) GetCapabilities() *KubernetesDaemonSetCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// *
// **KubernetesDaemonSetCapabilities** defines Linux capabilities to add or drop.
type KubernetesDaemonSetCapabilities struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of capabilities to add.
	Add []string `protobuf:"bytes,1,rep,name=add,proto3" json:"add,omitempty"`
	// List of capabilities to drop.
	Drop          []string `protobuf:"bytes,2,rep,name=drop,proto3" json:"drop,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetCapabilities) Reset() {
	*x = KubernetesDaemonSetCapabilities{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetCapabilities) ProtoMessage() {}

func (x *KubernetesDaemonSetCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetCapabilities.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetCapabilities) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{9}
}

func (x *KubernetesDaemonSetCapabilities) GetAdd() []string {
	if x != nil {
		return x.Add
	}
	return nil
}

func (x *KubernetesDaemonSetCapabilities) GetDrop() []string {
	if x != nil {
		return x.Drop
	}
	return nil
}

// *
// KubernetesDaemonSetRbac defines RBAC permissions for the DaemonSet ServiceAccount.
// Creates ClusterRole/ClusterRoleBinding for cluster-wide permissions
// and Role/RoleBinding for namespace-scoped permissions.
type KubernetesDaemonSetRbac struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Cluster-wide RBAC rules.
	// Creates a ClusterRole and ClusterRoleBinding.
	// Use for permissions that span across namespaces (e.g., reading all pods).
	ClusterRules []*KubernetesDaemonSetRbacRule `protobuf:"bytes,1,rep,name=cluster_rules,json=clusterRules,proto3" json:"cluster_rules,omitempty"`
	// *
	// Namespace-scoped RBAC rules.
	// Creates a Role and RoleBinding in the DaemonSet's namespace.
	// Use for permissions limited to the deployment namespace.
	NamespaceRules []*KubernetesDaemonSetRbacRule `protobuf:"bytes,2,rep,name=namespace_rules,json=namespaceRules,proto3" json:"namespace_rules,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *KubernetesDaemonSetRbac) Reset() {
	*x = KubernetesDaemonSetRbac{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetRbac) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetRbac) ProtoMessage() {}

func (x *KubernetesDaemonSetRbac) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetRbac.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetRbac) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{10}
}

func (x *KubernetesDaemonSetRbac) GetClusterRules() []*KubernetesDaemonSetRbacRule {
	if x != nil {
		return x.ClusterRules
	}
	return nil
}

func (x *KubernetesDaemonSetRbac) GetNamespaceRules() []*KubernetesDaemonSetRbacRule {
	if x != nil {
		return x.NamespaceRules
	}
	return nil
}

// *
// KubernetesDaemonSetRbacRule defines a single RBAC policy rule.
// Maps directly to Kubernetes RBAC PolicyRule.
type KubernetesDaemonSetRbacRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// API groups containing the resources.
	// Use "" for core API group.
	// Example: [""], ["apps"], ["batch"]
	ApiGroups []string `protobuf:"bytes,1,rep,name=api_groups,json=apiGroups,proto3" json:"api_groups,omitempty"`
	// *
	// Resources this rule applies to.
	// Example: ["pods", "services"], ["deployments"], ["configmaps", "secrets"]
	Resources []string `protobuf:"bytes,2,rep,name=resources,proto3" json:"resources,omitempty"`
	// *
	// Verbs specifying the actions allowed.
	// Example: ["get", "list", "watch"], ["create", "update", "delete"]
	Verbs []string `protobuf:"bytes,3,rep,name=verbs,proto3" json:"verbs,omitempty"`
	// *
	// Resource names to limit the rule to specific resources.
	// If empty, the rule applies to all resources of the specified type.
	// Example: ["my-configmap", "my-secret"]
	ResourceNames []string `protobuf:"bytes,4,rep,name=resource_names,json=resourceNames,proto3" json:"resource_names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesDaemonSetRbacRule) Reset() {
	*x = KubernetesDaemonSetRbacRule{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesDaemonSetRbacRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesDaemonSetRbacRule) ProtoMessage() {}

func (x *KubernetesDaemonSetRbacRule) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesDaemonSetRbacRule.ProtoReflect.Descriptor instead.
func (*KubernetesDaemonSetRbacRule) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP(), []int{11}
}

func (x *KubernetesDaemonSetRbacRule) GetApiGroups() []string {
	if x != nil {
		return x.ApiGroups
	}
	return nil
}

func (x *KubernetesDaemonSetRbacRule) GetResources() []string {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *KubernetesDaemonSetRbacRule) GetVerbs() []string {
	if x != nil {
		return x.Verbs
	}
	return nil
}

func (x *KubernetesDaemonSetRbacRule) GetResourceNames() []string {
	if x != nil {
		return x.ResourceNames
	}
	return nil
}

var File_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDesc = "" +
	"\n" +
	"Iorg/project_planton/provider/kubernetes/kubernetesdaemonset/v1/spec.proto\x12>org.project_planton.provider.kubernetes.kubernetesdaemonset.v1\x1a\x1bbuf/validate/validate.proto\x1a8org/project_planton/provider/kubernetes/kubernetes.proto\x1a?org/project_planton/provider/kubernetes/kubernetes_secret.proto\x1a5org/project_planton/provider/kubernetes/options.proto\x1a3org/project_planton/provider/kubernetes/probe.proto\x1a<org/project_planton/provider/kubernetes/target_cluster.proto\x1a:org/project_planton/provider/kubernetes/volume_mount.proto\x1a:org/project_planton/shared/foreignkey/v1/foreign_key.proto\"\xd3\n" +
	"\n" +
	"\x17KubernetesDaemonSetSpec\x12i\n" +
	"\x0etarget_cluster\x18\x01 \x01(\v2B.org.project_planton.provider.kubernetes.KubernetesClusterSelectorR\rtargetCluster\x12r\n" +
	"\tnamespace\x18\x02 \x01(\v2:.org.project_planton.shared.foreignkey.v1.StringValueOrRefB\x18\xbaH\x03\xc8\x01\x01\x88\xd4a\xc4\x06\x92\xd4a\tspec.nameR\tnamespace\x12)\n" +
	"\x10create_namespace\x18\x03 \x01(\bR\x0fcreateNamespace\x12\x82\x01\n" +
	"\tcontainer\x18\x04 \x01(\v2\\.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerB\x06\xbaH\x03\xc8\x01\x01R\tcontainer\x12\x8e\x01\n" +
	"\rnode_selector\x18\x05 \x03(\v2i.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.NodeSelectorEntryR\fnodeSelector\x12\x7f\n" +
	"\vtolerations\x18\x06 \x03(\v2].org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetTolerationR\vtolerations\x12\x8a\x01\n" +
	"\x0fupdate_strategy\x18\a \x01(\v2a.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategyR\x0eupdateStrategy\x12*\n" +
	"\x11min_ready_seconds\x18\b \x01(\x05R\x0fminReadySeconds\x124\n" +
	"\x16create_service_account\x18\t \x01(\bR\x14createServiceAccount\x120\n" +
	"\x14service_account_name\x18\n" +
	" \x01(\tR\x12serviceAccountName\x12\x88\x01\n" +
	"\vconfig_maps\x18\v \x03(\v2g.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.ConfigMapsEntryR\n" +
	"configMaps\x12k\n" +
	"\x04rbac\x18\f \x01(\v2W.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacR\x04rbac\x1a?\n" +
	"\x11NodeSelectorEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a=\n" +
	"\x0fConfigMapsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe9\x01\n" +
	"\x1cKubernetesDaemonSetContainer\x12y\n" +
	"\x03app\x18\x01 \x01(\v2_.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppB\x06\xbaH\x03\xc8\x01\x01R\x03app\x12N\n" +
	"\bsidecars\x18\x02 \x03(\v22.org.project_planton.provider.kubernetes.ContainerR\bsidecars\"\xbe\t\n" +
	"\x1fKubernetesDaemonSetContainerApp\x12\x8d\x02\n" +
	"\x05image\x18\x01 \x01(\v27.org.project_planton.provider.kubernetes.ContainerImageB\xbd\x01\xbaH\xb9\x01\xba\x01Z\n" +
	"\x1dspec.container.app.image.repo\x12\x16Image repo is required\x1a!has(this.repo) && this.repo != ''\xba\x01V\n" +
	"\x1cspec.container.app.image.tag\x12\x15Image tag is required\x1a\x1fhas(this.tag) && this.tag != ''\xc8\x01\x01R\x05image\x12|\n" +
	"\tresources\x18\x02 \x01(\v2;.org.project_planton.provider.kubernetes.ContainerResourcesB!\xba\xfb\xa4\x02\x1c\n" +
	"\f\n" +
	"\x051000m\x12\x031Gi\x12\f\n" +
	"\x0350m\x12\x05100MiR\tresources\x12t\n" +
	"\x03env\x18\x03 \x01(\v2b.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnvR\x03env\x12y\n" +
	"\x05ports\x18\x04 \x03(\v2c.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPortR\x05ports\x12Y\n" +
	"\rvolume_mounts\x18\x05 \x03(\v24.org.project_planton.provider.kubernetes.VolumeMountR\fvolumeMounts\x12U\n" +
	"\x0eliveness_probe\x18\x06 \x01(\v2..org.project_planton.provider.kubernetes.ProbeR\rlivenessProbe\x12W\n" +
	"\x0freadiness_probe\x18\a \x01(\v2..org.project_planton.provider.kubernetes.ProbeR\x0ereadinessProbe\x12S\n" +
	"\rstartup_probe\x18\b \x01(\v2..org.project_planton.provider.kubernetes.ProbeR\fstartupProbe\x12\x18\n" +
	"\acommand\x18\t \x03(\tR\acommand\x12\x12\n" +
	"\x04args\x18\n" +
	" \x03(\tR\x04args\x12\x8d\x01\n" +
	"\x10security_context\x18\v \x01(\v2b.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContextR\x0fsecurityContext\"\xff\x03\n" +
	"\"KubernetesDaemonSetContainerAppEnv\x12\x8f\x01\n" +
	"\tvariables\x18\x01 \x03(\v2q.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.VariablesEntryR\tvariables\x12\x89\x01\n" +
	"\asecrets\x18\x02 \x03(\v2o.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.SecretsEntryR\asecrets\x1a<\n" +
	"\x0eVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a}\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12W\n" +
	"\x05value\x18\x02 \x01(\v2A.org.project_planton.provider.kubernetes.KubernetesSensitiveValueR\x05value:\x028\x01\"\xb9\x04\n" +
	"#KubernetesDaemonSetContainerAppPort\x12\x82\x02\n" +
	"\x04name\x18\x01 \x01(\tB\xed\x01\xbaH\xe9\x01\xba\x01\xe2\x01\n" +
	"\x1dspec.container.app.ports.name\x12\x92\x01Name for ports must only contain lowercase alphanumeric characters and hyphens. Port names must also start and end with an alphanumeric character.\x1a,this.matches('^[a-z0-9][a-z0-9-]*[a-z0-9]$')\xc8\x01\x01R\x04name\x12-\n" +
	"\x0econtainer_port\x18\x02 \x01(\x05B\x06\xbaH\x03\xc8\x01\x01R\rcontainerPort\x12\xc0\x01\n" +
	"\x10network_protocol\x18\x03 \x01(\tB\x94\x01\xbaH\x90\x01\xba\x01\x89\x01\n" +
	")spec.container.app.ports.network_protocol\x12<The network protocol must be one of \"SCTP\", \"TCP\", or \"UDP\".\x1a\x1ethis in [\"SCTP\", \"TCP\", \"UDP\"]\xc8\x01\x01R\x0fnetworkProtocol\x12\x1b\n" +
	"\thost_port\x18\x04 \x01(\x05R\bhostPort\"\xe4\x03\n" +
	"\x1dKubernetesDaemonSetToleration\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x9a\x01\n" +
	"\boperator\x18\x02 \x01(\tB~\xbaH{\xba\x01x\n" +
	"\x19spec.tolerations.operator\x120The operator must be one of \"Exists\" or \"Equal\".\x1a)this == \"\" || this in [\"Exists\", \"Equal\"]R\boperator\x12\x14\n" +
	"\x05value\x18\x03 \x01(\tR\x05value\x12\xce\x01\n" +
	"\x06effect\x18\x04 \x01(\tB\xb5\x01\xbaH\xb1\x01\xba\x01\xad\x01\n" +
	"\x17spec.tolerations.effect\x12KThe effect must be one of \"NoSchedule\", \"PreferNoSchedule\", or \"NoExecute\".\x1aEthis == \"\" || this in [\"NoSchedule\", \"PreferNoSchedule\", \"NoExecute\"]R\x06effect\x12-\n" +
	"\x12toleration_seconds\x18\x05 \x01(\x03R\x11tolerationSeconds\"\xe5\x02\n" +
	"!KubernetesDaemonSetUpdateStrategy\x12\xb5\x01\n" +
	"\x04type\x18\x01 \x01(\tB\xa0\x01\xbaH\x9c\x01\xba\x01\x98\x01\n" +
	"\x19spec.update_strategy.type\x12FThe update strategy type must be one of \"RollingUpdate\" or \"OnDelete\".\x1a3this == \"\" || this in [\"RollingUpdate\", \"OnDelete\"]R\x04type\x12\x87\x01\n" +
	"\x0erolling_update\x18\x02 \x01(\v2`.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdateR\rrollingUpdate\"h\n" +
	" KubernetesDaemonSetRollingUpdate\x12'\n" +
	"\x0fmax_unavailable\x18\x01 \x01(\tR\x0emaxUnavailable\x12\x1b\n" +
	"\tmax_surge\x18\x02 \x01(\tR\bmaxSurge\"\xee\x02\n" +
	"\"KubernetesDaemonSetSecurityContext\x12\x1e\n" +
	"\n" +
	"privileged\x18\x01 \x01(\bR\n" +
	"privileged\x12\x1e\n" +
	"\vrun_as_user\x18\x02 \x01(\x03R\trunAsUser\x12 \n" +
	"\frun_as_group\x18\x03 \x01(\x03R\n" +
	"runAsGroup\x12%\n" +
	"\x0frun_as_non_root\x18\x04 \x01(\bR\frunAsNonRoot\x129\n" +
	"\x19read_only_root_filesystem\x18\x05 \x01(\bR\x16readOnlyRootFilesystem\x12\x83\x01\n" +
	"\fcapabilities\x18\x06 \x01(\v2_.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilitiesR\fcapabilities\"G\n" +
	"\x1fKubernetesDaemonSetCapabilities\x12\x10\n" +
	"\x03add\x18\x01 \x03(\tR\x03add\x12\x12\n" +
	"\x04drop\x18\x02 \x03(\tR\x04drop\"\xa3\x02\n" +
	"\x17KubernetesDaemonSetRbac\x12\x80\x01\n" +
	"\rcluster_rules\x18\x01 \x03(\v2[.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRuleR\fclusterRules\x12\x84\x01\n" +
	"\x0fnamespace_rules\x18\x02 \x03(\v2[.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRuleR\x0enamespaceRules\"\xb5\x01\n" +
	"\x1bKubernetesDaemonSetRbacRule\x12'\n" +
	"\n" +
	"api_groups\x18\x01 \x03(\tB\b\xbaH\x05\x92\x01\x02\b\x01R\tapiGroups\x12&\n" +
	"\tresources\x18\x02 \x03(\tB\b\xbaH\x05\x92\x01\x02\b\x01R\tresources\x12\x1e\n" +
	"\x05verbs\x18\x03 \x03(\tB\b\xbaH\x05\x92\x01\x02\b\x01R\x05verbs\x12%\n" +
	"\x0eresource_names\x18\x04 \x03(\tR\rresourceNamesB\xf1\x03\n" +
	"Bcom.org.project_planton.provider.kubernetes.kubernetesdaemonset.v1B\tSpecProtoP\x01Z\x84\x01github.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes/kubernetesdaemonset/v1;kubernetesdaemonsetv1\xa2\x02\x05OPPKK\xaa\x02=Org.ProjectPlanton.Provider.Kubernetes.Kubernetesdaemonset.V1\xca\x02=Org\\ProjectPlanton\\Provider\\Kubernetes\\Kubernetesdaemonset\\V1\xe2\x02IOrg\\ProjectPlanton\\Provider\\Kubernetes\\Kubernetesdaemonset\\V1\\GPBMetadata\xea\x02BOrg::ProjectPlanton::Provider::Kubernetes::Kubernetesdaemonset::V1b\x06proto3"

var (
	file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescData []byte
)

func file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDesc)))
	})
	return file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDescData
}

var file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_goTypes = []any{
	(*KubernetesDaemonSetSpec)(nil),              // 0: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec
	(*KubernetesDaemonSetContainer)(nil),         // 1: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer
	(*KubernetesDaemonSetContainerApp)(nil),      // 2: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp
	(*KubernetesDaemonSetContainerAppEnv)(nil),   // 3: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv
	(*KubernetesDaemonSetContainerAppPort)(nil),  // 4: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort
	(*KubernetesDaemonSetToleration)(nil),        // 5: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration
	(*KubernetesDaemonSetUpdateStrategy)(nil),    // 6: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy
	(*KubernetesDaemonSetRollingUpdate)(nil),     // 7: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate
	(*KubernetesDaemonSetSecurityContext)(nil),   // 8: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext
	(*KubernetesDaemonSetCapabilities)(nil),      // 9: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities
	(*KubernetesDaemonSetRbac)(nil),              // 10: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac
	(*KubernetesDaemonSetRbacRule)(nil),          // 11: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule
	nil,                                          // 12: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.NodeSelectorEntry
	nil,                                          // 13: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.ConfigMapsEntry
	nil,                                          // 14: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.VariablesEntry
	nil,                                          // 15: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.SecretsEntry
	(*kubernetes.KubernetesClusterSelector)(nil), // 16: org.project_planton.provider.kubernetes.KubernetesClusterSelector
	(*v1.StringValueOrRef)(nil),                  // 17: org.project_planton.shared.foreignkey.v1.StringValueOrRef
	(*kubernetes.Container)(nil),                 // 18: org.project_planton.provider.kubernetes.Container
	(*kubernetes.ContainerImage)(nil),            // 19: org.project_planton.provider.kubernetes.ContainerImage
	(*kubernetes.ContainerResources)(nil),        // 20: org.project_planton.provider.kubernetes.ContainerResources
	(*kubernetes.VolumeMount)(nil),               // 21: org.project_planton.provider.kubernetes.VolumeMount
	(*kubernetes.Probe)(nil),                     // 22: org.project_planton.provider.kubernetes.Probe
	(*kubernetes.KubernetesSensitiveValue)(nil),  // 23: org.project_planton.provider.kubernetes.KubernetesSensitiveValue
}
var file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_depIdxs = []int32{
	16, // 0: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.target_cluster:type_name -> org.project_planton.provider.kubernetes.KubernetesClusterSelector
	17, // 1: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.namespace:type_name -> org.project_planton.shared.foreignkey.v1.StringValueOrRef
	1,  // 2: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.container:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer
	12, // 3: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.node_selector:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.NodeSelectorEntry
	5,  // 4: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.tolerations:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration
	6,  // 5: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.update_strategy:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy
	13, // 6: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.config_maps:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.ConfigMapsEntry
	10, // 7: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.rbac:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac
	2,  // 8: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer.app:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp
	18, // 9: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer.sidecars:type_name -> org.project_planton.provider.kubernetes.Container
	19, // 10: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.image:type_name -> org.project_planton.provider.kubernetes.ContainerImage
	20, // 11: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.resources:type_name -> org.project_planton.provider.kubernetes.ContainerResources
	3,  // 12: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.env:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv
	4,  // 13: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.ports:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort
	21, // 14: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.volume_mounts:type_name -> org.project_planton.provider.kubernetes.VolumeMount
	22, // 15: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.liveness_probe:type_name -> org.project_planton.provider.kubernetes.Probe
	22, // 16: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.readiness_probe:type_name -> org.project_planton.provider.kubernetes.Probe
	22, // 17: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.startup_probe:type_name -> org.project_planton.provider.kubernetes.Probe
	8,  // 18: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.security_context:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext
	14, // 19: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.variables:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.VariablesEntry
	15, // 20: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.secrets:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.SecretsEntry
	7,  // 21: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy.rolling_update:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate
	9,  // 22: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext.capabilities:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities
	11, // 23: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac.cluster_rules:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule
	11, // 24: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac.namespace_rules:type_name -> org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule
	23, // 25: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.SecretsEntry.value:type_name -> org.project_planton.provider.kubernetes.KubernetesSensitiveValue
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_init() }
func file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_init() {
	if File_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_depIdxs,
		MessageInfos:      file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_msgTypes,
	}.Build()
	File_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto = out.File
	file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_goTypes = nil
	file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec_proto_depIdxs = nil
}
