// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/kubernetes/kubernetestekton/v1/spec.proto

package kubernetestektonv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	kubernetes "github.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes"
	_ "github.com/project-planton/project-planton/apis/org/project_planton/shared/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// KubernetesTektonSpec defines the configuration for deploying Tekton on Kubernetes using direct manifests.
//
// This component deploys Tekton Pipelines and optionally Tekton Dashboard using official release manifests,
// without requiring the Tekton Operator. This is ideal for users who want a simpler deployment model
// and don't need the operator's lifecycle management features.
//
// IMPORTANT: Namespace Behavior
// Tekton components are installed in the 'tekton-pipelines' namespace, which is created automatically
// by the official Tekton manifests. This namespace cannot be customized.
//
// Deployment is equivalent to:
//
//	kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
//	kubectl apply --filename https://infra.tekton.dev/tekton-releases/dashboard/latest/release.yaml
type KubernetesTektonSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target Kubernetes Cluster where Tekton will be deployed.
	TargetCluster *kubernetes.KubernetesClusterSelector `protobuf:"bytes,1,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	// The version of Tekton Pipelines to deploy.
	// This maps to release versions from https://github.com/tektoncd/pipeline/releases
	// Examples: "latest", "v0.65.2", "v0.64.0"
	PipelineVersion string `protobuf:"bytes,2,opt,name=pipeline_version,json=pipelineVersion,proto3" json:"pipeline_version,omitempty"`
	// Dashboard configuration for Tekton.
	// The dashboard provides a web UI for viewing and managing pipelines.
	Dashboard *KubernetesTektonDashboard `protobuf:"bytes,3,opt,name=dashboard,proto3" json:"dashboard,omitempty"`
	// Cloud Events configuration for pipeline notifications.
	// When configured, Tekton will send CloudEvents to the specified sink URL
	// for TaskRun and PipelineRun lifecycle events.
	CloudEvents   *KubernetesTektonCloudEvents `protobuf:"bytes,4,opt,name=cloud_events,json=cloudEvents,proto3" json:"cloud_events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesTektonSpec) Reset() {
	*x = KubernetesTektonSpec{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesTektonSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesTektonSpec) ProtoMessage() {}

func (x *KubernetesTektonSpec) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesTektonSpec.ProtoReflect.Descriptor instead.
func (*KubernetesTektonSpec) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *KubernetesTektonSpec) GetTargetCluster() *kubernetes.KubernetesClusterSelector {
	if x != nil {
		return x.TargetCluster
	}
	return nil
}

func (x *KubernetesTektonSpec) GetPipelineVersion() string {
	if x != nil {
		return x.PipelineVersion
	}
	return ""
}

func (x *KubernetesTektonSpec) GetDashboard() *KubernetesTektonDashboard {
	if x != nil {
		return x.Dashboard
	}
	return nil
}

func (x *KubernetesTektonSpec) GetCloudEvents() *KubernetesTektonCloudEvents {
	if x != nil {
		return x.CloudEvents
	}
	return nil
}

// KubernetesTektonDashboard configures the Tekton Dashboard deployment.
// The dashboard provides a web UI for viewing pipelines, tasks, and runs.
type KubernetesTektonDashboard struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Flag to enable or disable dashboard deployment.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// The version of Tekton Dashboard to deploy.
	// This maps to release versions from https://github.com/tektoncd/dashboard/releases
	// Examples: "latest", "v0.53.0", "v0.52.0"
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Ingress configuration for external access to the dashboard.
	Ingress       *KubernetesTektonDashboardIngress `protobuf:"bytes,3,opt,name=ingress,proto3" json:"ingress,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesTektonDashboard) Reset() {
	*x = KubernetesTektonDashboard{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesTektonDashboard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesTektonDashboard) ProtoMessage() {}

func (x *KubernetesTektonDashboard) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesTektonDashboard.ProtoReflect.Descriptor instead.
func (*KubernetesTektonDashboard) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *KubernetesTektonDashboard) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *KubernetesTektonDashboard) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *KubernetesTektonDashboard) GetIngress() *KubernetesTektonDashboardIngress {
	if x != nil {
		return x.Ingress
	}
	return nil
}

// KubernetesTektonDashboardIngress configures external access to the Tekton Dashboard
// using Kubernetes Gateway API with TLS termination and HTTP-to-HTTPS redirect.
type KubernetesTektonDashboardIngress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Flag to enable or disable dashboard ingress.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// The full hostname for external access to the dashboard.
	// Example: "tekton-dashboard.example.com"
	// Required when enabled is true.
	Hostname      string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesTektonDashboardIngress) Reset() {
	*x = KubernetesTektonDashboardIngress{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesTektonDashboardIngress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesTektonDashboardIngress) ProtoMessage() {}

func (x *KubernetesTektonDashboardIngress) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesTektonDashboardIngress.ProtoReflect.Descriptor instead.
func (*KubernetesTektonDashboardIngress) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *KubernetesTektonDashboardIngress) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *KubernetesTektonDashboardIngress) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

// KubernetesTektonCloudEvents configures CloudEvents integration for Tekton.
// CloudEvents are sent for TaskRun and PipelineRun state changes, enabling
// external systems to react to pipeline events.
//
// This configuration is applied to the 'config-defaults' ConfigMap in the tekton-pipelines namespace.
// See: https://tekton.dev/docs/pipelines/additional-configs/#configuring-cloudevents-notifications
type KubernetesTektonCloudEvents struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URL where CloudEvents will be sent.
	// Must be a valid HTTP/HTTPS URL that can receive CloudEvents.
	// Example: "http://my-service.my-namespace.svc.cluster.local/tekton/events"
	SinkUrl       string `protobuf:"bytes,1,opt,name=sink_url,json=sinkUrl,proto3" json:"sink_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesTektonCloudEvents) Reset() {
	*x = KubernetesTektonCloudEvents{}
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesTektonCloudEvents) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesTektonCloudEvents) ProtoMessage() {}

func (x *KubernetesTektonCloudEvents) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesTektonCloudEvents.ProtoReflect.Descriptor instead.
func (*KubernetesTektonCloudEvents) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *KubernetesTektonCloudEvents) GetSinkUrl() string {
	if x != nil {
		return x.SinkUrl
	}
	return ""
}

var File_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDesc = "" +
	"\n" +
	"Forg/project_planton/provider/kubernetes/kubernetestekton/v1/spec.proto\x12;org.project_planton.provider.kubernetes.kubernetestekton.v1\x1a\x1bbuf/validate/validate.proto\x1a<org/project_planton/provider/kubernetes/target_cluster.proto\x1a0org/project_planton/shared/options/options.proto\"\xab\x03\n" +
	"\x14KubernetesTektonSpec\x12i\n" +
	"\x0etarget_cluster\x18\x01 \x01(\v2B.org.project_planton.provider.kubernetes.KubernetesClusterSelectorR\rtargetCluster\x125\n" +
	"\x10pipeline_version\x18\x02 \x01(\tB\n" +
	"\x8a\xa6\x1d\x06latestR\x0fpipelineVersion\x12t\n" +
	"\tdashboard\x18\x03 \x01(\v2V.org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboardR\tdashboard\x12{\n" +
	"\fcloud_events\x18\x04 \x01(\v2X.org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonCloudEventsR\vcloudEvents\"\xd4\x01\n" +
	"\x19KubernetesTektonDashboard\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12$\n" +
	"\aversion\x18\x02 \x01(\tB\n" +
	"\x8a\xa6\x1d\x06latestR\aversion\x12w\n" +
	"\aingress\x18\x03 \x01(\v2].org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboardIngressR\aingress\"\xe9\x01\n" +
	" KubernetesTektonDashboardIngress\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname:\x8e\x01\xbaH\x8a\x01\x1a\x87\x01\n" +
	"#dashboard_ingress.hostname.required\x126hostname is required when dashboard ingress is enabled\x1a(!this.enabled || size(this.hostname) > 0\"\xf5\x01\n" +
	"\x1bKubernetesTektonCloudEvents\x12\x19\n" +
	"\bsink_url\x18\x01 \x01(\tR\asinkUrl:\xba\x01\xbaH\xb6\x01\x1a\xb3\x01\n" +
	"\x1ccloud_events.sink_url.format\x12*sink_url must be a valid HTTP or HTTPS URL\x1agsize(this.sink_url) == 0 || this.sink_url.startsWith('http://') || this.sink_url.startsWith('https://')B\xdb\x03\n" +
	"?com.org.project_planton.provider.kubernetes.kubernetestekton.v1B\tSpecProtoP\x01Z~github.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes/kubernetestekton/v1;kubernetestektonv1\xa2\x02\x05OPPKK\xaa\x02:Org.ProjectPlanton.Provider.Kubernetes.Kubernetestekton.V1\xca\x02:Org\\ProjectPlanton\\Provider\\Kubernetes\\Kubernetestekton\\V1\xe2\x02FOrg\\ProjectPlanton\\Provider\\Kubernetes\\Kubernetestekton\\V1\\GPBMetadata\xea\x02?Org::ProjectPlanton::Provider::Kubernetes::Kubernetestekton::V1b\x06proto3"

var (
	file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescData []byte
)

func file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDesc)))
	})
	return file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDescData
}

var file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_goTypes = []any{
	(*KubernetesTektonSpec)(nil),                 // 0: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonSpec
	(*KubernetesTektonDashboard)(nil),            // 1: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboard
	(*KubernetesTektonDashboardIngress)(nil),     // 2: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboardIngress
	(*KubernetesTektonCloudEvents)(nil),          // 3: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonCloudEvents
	(*kubernetes.KubernetesClusterSelector)(nil), // 4: org.project_planton.provider.kubernetes.KubernetesClusterSelector
}
var file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_depIdxs = []int32{
	4, // 0: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonSpec.target_cluster:type_name -> org.project_planton.provider.kubernetes.KubernetesClusterSelector
	1, // 1: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonSpec.dashboard:type_name -> org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboard
	3, // 2: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonSpec.cloud_events:type_name -> org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonCloudEvents
	2, // 3: org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboard.ingress:type_name -> org.project_planton.provider.kubernetes.kubernetestekton.v1.KubernetesTektonDashboardIngress
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_init() }
func file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_init() {
	if File_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_depIdxs,
		MessageInfos:      file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_msgTypes,
	}.Build()
	File_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto = out.File
	file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_goTypes = nil
	file_org_project_planton_provider_kubernetes_kubernetestekton_v1_spec_proto_depIdxs = nil
}
