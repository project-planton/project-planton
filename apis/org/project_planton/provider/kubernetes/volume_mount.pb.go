// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/kubernetes/volume_mount.proto

package kubernetes

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// VolumeMount defines how to mount a volume into a container.
// Supports multiple volume types: ConfigMap, Secret, HostPath, EmptyDir, and PVC.
// Only one volume source should be specified per mount.
//
// Example usage:
//
//	volumeMounts:
//	  - name: config
//	    mountPath: /etc/app/config.yaml
//	    configMap:
//	      name: app-config
//	      key: config.yaml
//	  - name: logs
//	    mountPath: /var/log
//	    hostPath:
//	      path: /var/log
//	      type: Directory
type VolumeMount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the volume mount. Must be unique within the container.
	// Used to correlate with the volume definition.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path within the container at which the volume should be mounted.
	// Must be an absolute path.
	MountPath string `protobuf:"bytes,2,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	// Whether the volume should be mounted read-only.
	// Default is false.
	ReadOnly bool `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	// Path within the volume from which the container's volume should be mounted.
	// Defaults to "" (volume's root).
	// Useful for mounting a subdirectory of a volume.
	SubPath string `protobuf:"bytes,4,opt,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
	// ConfigMap volume source.
	// Use this to mount a ConfigMap as a file or directory.
	ConfigMap *ConfigMapVolumeSource `protobuf:"bytes,5,opt,name=config_map,json=configMap,proto3" json:"config_map,omitempty"`
	// Secret volume source.
	// Use this to mount a Secret as a file or directory.
	Secret *SecretVolumeSource `protobuf:"bytes,6,opt,name=secret,proto3" json:"secret,omitempty"`
	// HostPath volume source.
	// Use this to mount a file or directory from the host node's filesystem.
	// Common for DaemonSets that need access to node-level resources.
	HostPath *HostPathVolumeSource `protobuf:"bytes,7,opt,name=host_path,json=hostPath,proto3" json:"host_path,omitempty"`
	// EmptyDir volume source.
	// Use this for temporary storage that is erased when the pod is removed.
	// Useful for scratch space, caching, or sharing data between containers.
	EmptyDir *EmptyDirVolumeSource `protobuf:"bytes,8,opt,name=empty_dir,json=emptyDir,proto3" json:"empty_dir,omitempty"`
	// PersistentVolumeClaim volume source.
	// Use this to mount an existing PVC.
	// For StatefulSets, this can reference a volumeClaimTemplate.
	Pvc           *PvcVolumeSource `protobuf:"bytes,9,opt,name=pvc,proto3" json:"pvc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeMount) Reset() {
	*x = VolumeMount{}
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeMount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeMount) ProtoMessage() {}

func (x *VolumeMount) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeMount.ProtoReflect.Descriptor instead.
func (*VolumeMount) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP(), []int{0}
}

func (x *VolumeMount) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VolumeMount) GetMountPath() string {
	if x != nil {
		return x.MountPath
	}
	return ""
}

func (x *VolumeMount) GetReadOnly() bool {
	if x != nil {
		return x.ReadOnly
	}
	return false
}

func (x *VolumeMount) GetSubPath() string {
	if x != nil {
		return x.SubPath
	}
	return ""
}

func (x *VolumeMount) GetConfigMap() *ConfigMapVolumeSource {
	if x != nil {
		return x.ConfigMap
	}
	return nil
}

func (x *VolumeMount) GetSecret() *SecretVolumeSource {
	if x != nil {
		return x.Secret
	}
	return nil
}

func (x *VolumeMount) GetHostPath() *HostPathVolumeSource {
	if x != nil {
		return x.HostPath
	}
	return nil
}

func (x *VolumeMount) GetEmptyDir() *EmptyDirVolumeSource {
	if x != nil {
		return x.EmptyDir
	}
	return nil
}

func (x *VolumeMount) GetPvc() *PvcVolumeSource {
	if x != nil {
		return x.Pvc
	}
	return nil
}

// *
// ConfigMapVolumeSource mounts a ConfigMap as a volume.
// The ConfigMap can be one defined in spec.config_maps or an existing ConfigMap in the namespace.
//
// When 'key' is specified, only that key is mounted as a single file.
// When 'key' is not specified, all keys are mounted as files in the directory.
//
// Example - Mount entire ConfigMap as directory:
//
//	configMap:
//	  name: app-config
//
// Example - Mount single key as file:
//
//	configMap:
//	  name: app-config
//	  key: database.yaml
//	  path: db-config.yaml
type ConfigMapVolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the ConfigMap to mount.
	// Can reference a ConfigMap defined in spec.config_maps or an existing one in the namespace.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specific key from the ConfigMap to mount as a single file.
	// If not specified, all keys are mounted as files in the directory.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// If key is specified, this is the filename to use for the mounted file.
	// Defaults to the key name if not specified.
	// Example: key="config" path="app.yaml" mounts the "config" key as "app.yaml"
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// Mode bits to use on created files. Must be a value between 0 and 0777.
	// Defaults to 0644.
	// Use 0755 (493 in decimal) for executable scripts.
	DefaultMode   int32 `protobuf:"varint,4,opt,name=default_mode,json=defaultMode,proto3" json:"default_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigMapVolumeSource) Reset() {
	*x = ConfigMapVolumeSource{}
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigMapVolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigMapVolumeSource) ProtoMessage() {}

func (x *ConfigMapVolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigMapVolumeSource.ProtoReflect.Descriptor instead.
func (*ConfigMapVolumeSource) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP(), []int{1}
}

func (x *ConfigMapVolumeSource) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ConfigMapVolumeSource) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *ConfigMapVolumeSource) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *ConfigMapVolumeSource) GetDefaultMode() int32 {
	if x != nil {
		return x.DefaultMode
	}
	return 0
}

// *
// SecretVolumeSource mounts a Secret as a volume.
// Works similarly to ConfigMapVolumeSource but for sensitive data.
//
// Example:
//
//	secret:
//	  name: tls-certs
//	  key: tls.crt
//	  path: server.crt
type SecretVolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the Secret to mount.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specific key from the Secret to mount as a single file.
	// If not specified, all keys are mounted as files in the directory.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// If key is specified, this is the filename to use for the mounted file.
	// Defaults to the key name if not specified.
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// Mode bits to use on created files. Must be a value between 0 and 0777.
	// Defaults to 0644.
	DefaultMode   int32 `protobuf:"varint,4,opt,name=default_mode,json=defaultMode,proto3" json:"default_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretVolumeSource) Reset() {
	*x = SecretVolumeSource{}
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretVolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretVolumeSource) ProtoMessage() {}

func (x *SecretVolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecretVolumeSource.ProtoReflect.Descriptor instead.
func (*SecretVolumeSource) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP(), []int{2}
}

func (x *SecretVolumeSource) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SecretVolumeSource) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *SecretVolumeSource) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *SecretVolumeSource) GetDefaultMode() int32 {
	if x != nil {
		return x.DefaultMode
	}
	return 0
}

// *
// HostPathVolumeSource mounts a file or directory from the host node's filesystem.
// Use with caution as it ties pods to specific nodes.
//
// Common use cases:
// - Log collection DaemonSets mounting /var/log
// - Node monitoring agents mounting /sys or /proc
// - Container runtime sockets (e.g., /var/run/docker.sock)
//
// Example:
//
//	hostPath:
//	  path: /var/log
//	  type: Directory
type HostPathVolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path on the host to mount.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Type of the host path.
	// Valid values:
	//
	//	"" - Empty string (default) means no check is performed before mounting
	//	"DirectoryOrCreate" - Create directory if it doesn't exist
	//	"Directory" - Directory must exist
	//	"FileOrCreate" - Create file if it doesn't exist
	//	"File" - File must exist
	//	"Socket" - UNIX socket must exist
	//	"CharDevice" - Character device must exist
	//	"BlockDevice" - Block device must exist
	Type          string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HostPathVolumeSource) Reset() {
	*x = HostPathVolumeSource{}
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostPathVolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostPathVolumeSource) ProtoMessage() {}

func (x *HostPathVolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostPathVolumeSource.ProtoReflect.Descriptor instead.
func (*HostPathVolumeSource) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP(), []int{3}
}

func (x *HostPathVolumeSource) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *HostPathVolumeSource) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

// *
// EmptyDirVolumeSource creates an empty directory for temporary storage.
// The directory is created when a pod is assigned to a node and exists as long as the pod runs.
// Data is deleted when the pod is removed.
//
// Use cases:
// - Scratch space for computations
// - Checkpoint storage for crash recovery
// - Shared space between containers in a pod
//
// Example - Default (disk-backed):
//
//	emptyDir: {}
//
// Example - Memory-backed (faster, but uses RAM):
//
//	emptyDir:
//	  medium: Memory
//	  sizeLimit: 256Mi
type EmptyDirVolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Medium for the empty directory.
	// "" (default) uses the node's default medium (typically disk).
	// "Memory" uses a tmpfs (RAM-backed filesystem).
	//
	// Memory-backed volumes are faster but:
	// - Count against container memory limits
	// - Are lost on node restart
	// - Should have sizeLimit set to prevent OOM
	Medium string `protobuf:"bytes,1,opt,name=medium,proto3" json:"medium,omitempty"`
	// Size limit for the empty directory.
	// Format: Kubernetes quantity (e.g., "1Gi", "500Mi").
	// Only strictly enforced when medium is "Memory".
	// For disk-backed volumes, this is a best-effort limit.
	SizeLimit     string `protobuf:"bytes,2,opt,name=size_limit,json=sizeLimit,proto3" json:"size_limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmptyDirVolumeSource) Reset() {
	*x = EmptyDirVolumeSource{}
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmptyDirVolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmptyDirVolumeSource) ProtoMessage() {}

func (x *EmptyDirVolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmptyDirVolumeSource.ProtoReflect.Descriptor instead.
func (*EmptyDirVolumeSource) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP(), []int{4}
}

func (x *EmptyDirVolumeSource) GetMedium() string {
	if x != nil {
		return x.Medium
	}
	return ""
}

func (x *EmptyDirVolumeSource) GetSizeLimit() string {
	if x != nil {
		return x.SizeLimit
	}
	return ""
}

// *
// PvcVolumeSource mounts an existing PersistentVolumeClaim.
//
// For StatefulSets: The claimName can reference a volumeClaimTemplate name,
// and the StatefulSet controller will automatically handle per-pod PVC binding.
//
// Example:
//
//	pvc:
//	  claimName: data-volume
//	  readOnly: false
type PvcVolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the PersistentVolumeClaim to mount.
	// For StatefulSets, this can be the name of a volumeClaimTemplate.
	ClaimName string `protobuf:"bytes,1,opt,name=claim_name,json=claimName,proto3" json:"claim_name,omitempty"`
	// Whether the PVC should be mounted read-only.
	// Default is false.
	ReadOnly      bool `protobuf:"varint,2,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PvcVolumeSource) Reset() {
	*x = PvcVolumeSource{}
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PvcVolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PvcVolumeSource) ProtoMessage() {}

func (x *PvcVolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PvcVolumeSource.ProtoReflect.Descriptor instead.
func (*PvcVolumeSource) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP(), []int{5}
}

func (x *PvcVolumeSource) GetClaimName() string {
	if x != nil {
		return x.ClaimName
	}
	return ""
}

func (x *PvcVolumeSource) GetReadOnly() bool {
	if x != nil {
		return x.ReadOnly
	}
	return false
}

var File_org_project_planton_provider_kubernetes_volume_mount_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDesc = "" +
	"\n" +
	":org/project_planton/provider/kubernetes/volume_mount.proto\x12'org.project_planton.provider.kubernetes\x1a\x1bbuf/validate/validate.proto\"\xc0\x04\n" +
	"\vVolumeMount\x12\x1a\n" +
	"\x04name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04name\x12%\n" +
	"\n" +
	"mount_path\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\tmountPath\x12\x1b\n" +
	"\tread_only\x18\x03 \x01(\bR\breadOnly\x12\x19\n" +
	"\bsub_path\x18\x04 \x01(\tR\asubPath\x12]\n" +
	"\n" +
	"config_map\x18\x05 \x01(\v2>.org.project_planton.provider.kubernetes.ConfigMapVolumeSourceR\tconfigMap\x12S\n" +
	"\x06secret\x18\x06 \x01(\v2;.org.project_planton.provider.kubernetes.SecretVolumeSourceR\x06secret\x12Z\n" +
	"\thost_path\x18\a \x01(\v2=.org.project_planton.provider.kubernetes.HostPathVolumeSourceR\bhostPath\x12Z\n" +
	"\tempty_dir\x18\b \x01(\v2=.org.project_planton.provider.kubernetes.EmptyDirVolumeSourceR\bemptyDir\x12J\n" +
	"\x03pvc\x18\t \x01(\v28.org.project_planton.provider.kubernetes.PvcVolumeSourceR\x03pvc\"|\n" +
	"\x15ConfigMapVolumeSource\x12\x1a\n" +
	"\x04name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04name\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12!\n" +
	"\fdefault_mode\x18\x04 \x01(\x05R\vdefaultMode\"y\n" +
	"\x12SecretVolumeSource\x12\x1a\n" +
	"\x04name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04name\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12!\n" +
	"\fdefault_mode\x18\x04 \x01(\x05R\vdefaultMode\"\xdf\x02\n" +
	"\x14HostPathVolumeSource\x12\x1a\n" +
	"\x04path\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04path\x12\xaa\x02\n" +
	"\x04type\x18\x02 \x01(\tB\x95\x02\xbaH\x91\x02\xba\x01\x8d\x02\n" +
	"\x0ehost_path.type\x12xType must be one of: \"\", \"DirectoryOrCreate\", \"Directory\", \"FileOrCreate\", \"File\", \"Socket\", \"CharDevice\", \"BlockDevice\"\x1a\x80\x01size(this) == 0 || this in [\"\", \"DirectoryOrCreate\", \"Directory\", \"FileOrCreate\", \"File\", \"Socket\", \"CharDevice\", \"BlockDevice\"]R\x04type\"\xb9\x01\n" +
	"\x14EmptyDirVolumeSource\x12\x81\x01\n" +
	"\x06medium\x18\x01 \x01(\tBi\xbaHf\xba\x01c\n" +
	"\x10empty_dir.medium\x12$Medium must be either \"\" or \"Memory\"\x1a)size(this) == 0 || this in [\"\", \"Memory\"]R\x06medium\x12\x1d\n" +
	"\n" +
	"size_limit\x18\x02 \x01(\tR\tsizeLimit\"U\n" +
	"\x0fPvcVolumeSource\x12%\n" +
	"\n" +
	"claim_name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\tclaimName\x12\x1b\n" +
	"\tread_only\x18\x02 \x01(\bR\breadOnlyB\xd4\x02\n" +
	"+com.org.project_planton.provider.kubernetesB\x10VolumeMountProtoP\x01ZWgithub.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes\xa2\x02\x04OPPK\xaa\x02&Org.ProjectPlanton.Provider.Kubernetes\xca\x02&Org\\ProjectPlanton\\Provider\\Kubernetes\xe2\x022Org\\ProjectPlanton\\Provider\\Kubernetes\\GPBMetadata\xea\x02)Org::ProjectPlanton::Provider::Kubernetesb\x06proto3"

var (
	file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescData []byte
)

func file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDesc)))
	})
	return file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDescData
}

var file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_org_project_planton_provider_kubernetes_volume_mount_proto_goTypes = []any{
	(*VolumeMount)(nil),           // 0: org.project_planton.provider.kubernetes.VolumeMount
	(*ConfigMapVolumeSource)(nil), // 1: org.project_planton.provider.kubernetes.ConfigMapVolumeSource
	(*SecretVolumeSource)(nil),    // 2: org.project_planton.provider.kubernetes.SecretVolumeSource
	(*HostPathVolumeSource)(nil),  // 3: org.project_planton.provider.kubernetes.HostPathVolumeSource
	(*EmptyDirVolumeSource)(nil),  // 4: org.project_planton.provider.kubernetes.EmptyDirVolumeSource
	(*PvcVolumeSource)(nil),       // 5: org.project_planton.provider.kubernetes.PvcVolumeSource
}
var file_org_project_planton_provider_kubernetes_volume_mount_proto_depIdxs = []int32{
	1, // 0: org.project_planton.provider.kubernetes.VolumeMount.config_map:type_name -> org.project_planton.provider.kubernetes.ConfigMapVolumeSource
	2, // 1: org.project_planton.provider.kubernetes.VolumeMount.secret:type_name -> org.project_planton.provider.kubernetes.SecretVolumeSource
	3, // 2: org.project_planton.provider.kubernetes.VolumeMount.host_path:type_name -> org.project_planton.provider.kubernetes.HostPathVolumeSource
	4, // 3: org.project_planton.provider.kubernetes.VolumeMount.empty_dir:type_name -> org.project_planton.provider.kubernetes.EmptyDirVolumeSource
	5, // 4: org.project_planton.provider.kubernetes.VolumeMount.pvc:type_name -> org.project_planton.provider.kubernetes.PvcVolumeSource
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_org_project_planton_provider_kubernetes_volume_mount_proto_init() }
func file_org_project_planton_provider_kubernetes_volume_mount_proto_init() {
	if File_org_project_planton_provider_kubernetes_volume_mount_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_volume_mount_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_kubernetes_volume_mount_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_kubernetes_volume_mount_proto_depIdxs,
		MessageInfos:      file_org_project_planton_provider_kubernetes_volume_mount_proto_msgTypes,
	}.Build()
	File_org_project_planton_provider_kubernetes_volume_mount_proto = out.File
	file_org_project_planton_provider_kubernetes_volume_mount_proto_goTypes = nil
	file_org_project_planton_provider_kubernetes_volume_mount_proto_depIdxs = nil
}
