# Deploy the Kafka UI (Kowl) only if var.spec.is_deploy_kafka_ui == true.
# Resource names are prefixed with the metadata name to avoid conflicts when
# multiple Kafka instances share the same namespace.

###############################################################################
# 1) Create a ConfigMap for Kowl configuration
###############################################################################
resource "kubernetes_manifest" "kowl_configmap" {
  count = local.is_deploy_kafka_ui ? 1 : 0

  manifest = {
    apiVersion = "v1"
    kind       = "ConfigMap"
    metadata = {
      name      = local.kowl_config_map_name
      namespace = local.namespace
      labels    = local.final_labels
    }
    data = {
      "kowl.yaml" = <<-EOT
    kafka:
      brokers:
        - ${local.bootstrap_kube_service_fqdn}:${9094}
      clientId: "kowl-on-cluster"
      sasl:
        enabled: true
        username: "${local.admin_username}"
        mechanism: "SCRAM-SHA-512"
      tls:
        enabled: false
      schemaRegistry:
        enabled: ${local.is_schema_registry_enabled}
        urls: ["http://${coalesce(local.schema_registry_internal_hostname, local.schema_registry_kube_service_fqdn)}"]
      protobuf:
        enabled: ${local.is_schema_registry_enabled}
        schemaRegistry:
          enabled: ${local.is_schema_registry_enabled}
          refreshInterval: ${5}m
  EOT
    }
  }

  depends_on = [
    kubernetes_manifest.kafka_cluster,
    kubernetes_manifest.kafka_admin_user
  ]
}

###############################################################################
# 2) Create a Deployment for Kowl
###############################################################################
resource "kubernetes_manifest" "kowl_deployment" {
  count = local.is_deploy_kafka_ui ? 1 : 0

  manifest = {
    apiVersion = "apps/v1"
    kind       = "Deployment"
    metadata = {
      name      = local.kowl_deployment_name
      namespace = local.namespace
      labels = merge(local.final_labels, {
        "app" = local.kowl_deployment_name
      })
    }
    spec = {
      replicas = 1
      selector = {
        matchLabels = {
          "app" = local.kowl_deployment_name
        }
      }
      template = {
        metadata = {
          labels = {
            "app" = local.kowl_deployment_name
          }
        }
        spec = {
          containers = [
            {
              name = local.kowl_deployment_name
              image = "quay.io/cloudhut/kowl:master-59f68da"

              # Kowl arguments to load the config file & reference Kafka password
              args = [
                "--config.filepath=/var/kowl/config.yaml",
                "--kafka.sasl.password=$KAFKA_SASL_PASSWORD"
              ]

              ports = [
                {
                  name          = "http"
                  containerPort = 8080
                }
              ]

              # Retrieve the Kafka admin password from the secret generated by the KafkaUser
              env = [
                {
                  name = "KAFKA_SASL_PASSWORD"
                  valueFrom = {
                    secretKeyRef = {
                      name = local.admin_password_secret_name    # matches the KafkaUser secret
                      key = "password" # scram-sha-512 password
                    }
                  }
                }
              ]

              volumeMounts = [
                {
                  name      = "kowl-config"
                  mountPath = "/var/kowl/config.yaml"
                  subPath   = "kowl.yaml"
                }
              ]

              # Minimal resource requests/limits
              resources = {
                limits = {
                  cpu    = "150m"
                  memory = "180Mi"
                }
                requests = {
                  cpu    = "25m"
                  memory = "90Mi"
                }
              }
            }
          ]

          volumes = [
            {
              name = "kowl-config"
              configMap = {
                name = local.kowl_config_map_name
              }
            }
          ]
        }
      }
    }
  }

  depends_on = [
    kubernetes_manifest.kowl_configmap
  ]
}

###############################################################################
# 3) Create a ClusterIP Service for Kowl
###############################################################################
resource "kubernetes_manifest" "kowl_service" {
  count = local.is_deploy_kafka_ui ? 1 : 0

  manifest = {
    apiVersion = "v1"
    kind       = "Service"
    metadata = {
      name      = local.kowl_kube_service_name
      namespace = local.namespace
      labels    = local.final_labels
    }
    spec = {
      type = "ClusterIP"

      selector = {
        "app" = local.kowl_deployment_name
      }

      ports = [
        {
          name       = "http"
          protocol   = "TCP"
          port       = 80
          targetPort = 8080
        }
      ]
    }
  }

  depends_on = [
    kubernetes_manifest.kowl_deployment
  ]
}

###############################################################################
# 4) (Optional) Create a Certificate + Gateway + HTTPRoute for external Kowl access
#    using Istio + Gateway API, only if:
#    - Kowl is deployed
#    - Ingress is enabled
#    - ingress_dns_domain is non-empty
###############################################################################

# 4a) Create a TLS certificate using cert-manager (requires ClusterIssuer with the same name as the domain)
resource "kubernetes_manifest" "kowl_ingress_certificate" {
  count = (local.is_deploy_kafka_ui && local.ingress_is_enabled && local.ingress_dns_domain != "") ? 1 : 0

  manifest = {
    apiVersion = "cert-manager.io/v1"
    kind       = "Certificate"
    metadata = {
      name      = local.ingress_kowl_cert_secret_name
      namespace = "istio-ingress"
      labels    = local.final_labels
    }
    spec = {
      dnsNames = [local.kowl_external_hostname]
      secretName = local.ingress_kowl_cert_secret_name
      issuerRef = {
        kind = "ClusterIssuer"
        name = local.ingress_dns_domain
      }
    }
  }

  depends_on = [
    kubernetes_manifest.kowl_service
  ]
}

# 4b) Define the Gateway for the external Kowl hostname
resource "kubernetes_manifest" "kowl_gateway" {
  count = (local.is_deploy_kafka_ui && local.ingress_is_enabled && local.ingress_dns_domain != "") ? 1 : 0

  manifest = {
    apiVersion = "gateway.networking.k8s.io/v1beta1"
    kind       = "Gateway"
    metadata = {
      name      = "${var.metadata.name}-kowl-external"
      namespace = "istio-ingress"
      labels    = local.final_labels
    }
    spec = {
      gatewayClassName = "istio"
      addresses = [
        {
          type  = "Hostname"
          value = "ingress-external.istio-ingress.svc.cluster.local"
        }
      ]
      listeners = [
        {
          name     = "https-external"
          hostname = local.kowl_external_hostname
          port     = 443
          protocol = "HTTPS"
          tls = {
            mode = "Terminate"
            certificateRefs = [
              {
                name = local.ingress_kowl_cert_secret_name
              }
            ]
          }
          allowedRoutes = {
            namespaces = {
              from = "All"
            }
          }
        },
        {
          name     = "http-external"
          hostname = local.kowl_external_hostname
          port     = 80
          protocol = "HTTP"
          allowedRoutes = {
            namespaces = {
              from = "All"
            }
          }
        }
      ]
    }
  }

  depends_on = [
    kubernetes_manifest.kowl_ingress_certificate
  ]
}

# 4c) Create an HTTPRoute that routes traffic from the Gateway to the Kowl service
resource "kubernetes_manifest" "kowl_http_route" {
  count = (local.is_deploy_kafka_ui && local.ingress_is_enabled && local.ingress_dns_domain != "") ? 1 : 0

  manifest = {
    apiVersion = "gateway.networking.k8s.io/v1beta1"
    kind       = "HTTPRoute"
    metadata = {
      name      = "${var.metadata.name}-kowl"
      namespace = local.namespace
      labels    = local.final_labels
    }
    spec = {
      hostnames = [local.kowl_external_hostname]
      parentRefs = [
        {
          name      = "${var.metadata.name}-kowl-external"
          namespace = "istio-ingress"
        }
      ]
      rules = [
        {
          matches = [
            {
              path = {
                type  = "PathPrefix"
                value = "/"
              }
            }
          ]
          backendRefs = [
            {
              name = local.kowl_kube_service_name # reference the Service name
              namespace = local.namespace
              port      = 80
            }
          ]
        }
      ]
    }
  }

  depends_on = [
    kubernetes_manifest.kowl_gateway,
    kubernetes_manifest.kowl_service
  ]
}
