# Deploy the Schema Registry if enabled in var.spec.schema_registry_container.is_enabled == true.
# For simplicity, this is a minimal example showing how you might deploy Confluent Schema Registry.
# The Pulumi code sets up environment variables to connect to Kafka with SCRAM-SHA-512.
# Resource names are prefixed with the metadata name to avoid conflicts when multiple
# Kafka instances share the same namespace.

# This resource is created only when is_schema_registry_enabled is true.
resource "kubernetes_manifest" "schema_registry_deployment" {
  count = local.is_schema_registry_enabled ? 1 : 0

  manifest = {
    apiVersion = "apps/v1"
    kind       = "Deployment"
    metadata = {
      name      = local.schema_registry_deployment_name
      namespace = local.namespace
      labels = merge(local.final_labels, {
        "app" = local.schema_registry_deployment_name
      })
    }
    spec = {
      replicas = try(var.spec.schema_registry_container.replicas, 1)
      selector = {
        matchLabels = {
          "app" = local.schema_registry_deployment_name
        }
      }
      template = {
        metadata = {
          labels = {
            "app" = local.schema_registry_deployment_name
          }
        }
        spec = {
          containers = [
            {
              name  = local.schema_registry_deployment_name
              image = "confluentinc/cp-schema-registry:7.2.6"

              ports = [
                {
                  name          = "http"
                  containerPort = 8081
                }
              ]

              resources = {
                limits = {
                  cpu = try(var.spec.schema_registry_container.resources.limits.cpu, "1000m")
                  memory = try(var.spec.schema_registry_container.resources.limits.memory, "1Gi")
                }
                requests = {
                  cpu = try(var.spec.schema_registry_container.resources.requests.cpu, "50m")
                  memory = try(var.spec.schema_registry_container.resources.requests.memory, "100Mi")
                }
              }

              env = [
                {
                  name = "SCHEMA_REGISTRY_HOST_NAME"
                  valueFrom = {
                    fieldRef = {
                      fieldPath = "status.podIP"
                    }
                  }
                },
                {
                  name  = "SCHEMA_REGISTRY_LISTENERS"
                  value = "http://0.0.0.0:8081"
                },
                {
                  name  = "SCHEMA_REGISTRY_KAFKASTORE_SASL_MECHANISM"
                  value = "SCRAM-SHA-512"
                },
                {
                  name  = "SCHEMA_REGISTRY_KAFKASTORE_SECURITY_PROTOCOL"
                  value = "SASL_PLAINTEXT"
                },
                {
                  name  = "SCHEMA_REGISTRY_KAFKASTORE_TOPIC"
                  value = "schema-registry"
                },
                {
                  name  = "SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS"
                  value = "${local.bootstrap_kube_service_fqdn}:9094"
                },
                # This references the Secret generated by the KafkaUser admin resource for SASL credentials
                {
                  name = "SCHEMA_REGISTRY_KAFKASTORE_SASL_JAAS_CONFIG"
                  valueFrom = {
                    secretKeyRef = {
                      name = local.admin_password_secret_name  # The KafkaUser Secret uses the same name as the user
                      key = "sasl.jaas.config"
                    }
                  }
                }
              ]
            }
          ]
        }
      }
    }
  }

  depends_on = [
    kubernetes_manifest.kafka_cluster
  ]
}

# Create a ClusterIP Service for Schema Registry, if enabled.
resource "kubernetes_manifest" "schema_registry_service" {
  count = local.is_schema_registry_enabled ? 1 : 0

  manifest = {
    apiVersion = "v1"
    kind       = "Service"
    metadata = {
      name      = local.schema_registry_kube_service_name
      namespace = local.namespace
      labels    = local.final_labels
    }
    spec = {
      type = "ClusterIP"

      selector = {
        "app" = local.schema_registry_deployment_name
      }

      ports = [
        {
          name       = "http"
          protocol   = "TCP"
          port       = 80
          targetPort = 8081
        }
      ]
    }
  }

  depends_on = [
    kubernetes_manifest.schema_registry_deployment
  ]
}
