syntax = "proto3";

package org.project_planton.provider.kubernetes;

import "buf/validate/validate.proto";

// =============================================================================
// SHARED VOLUME MOUNT DEFINITIONS
// =============================================================================
//
// This file contains shared protobuf messages for volume mounts that are used
// across multiple Kubernetes workload components:
// - KubernetesDeployment
// - KubernetesDaemonSet
// - KubernetesStatefulSet
// - KubernetesCronJob
//
// By centralizing these definitions, we ensure consistency and reduce duplication.
// =============================================================================

/**
 * VolumeMount defines how to mount a volume into a container.
 * Supports multiple volume types: ConfigMap, Secret, HostPath, EmptyDir, and PVC.
 * Only one volume source should be specified per mount.
 *
 * Example usage:
 *   volumeMounts:
 *     - name: config
 *       mountPath: /etc/app/config.yaml
 *       configMap:
 *         name: app-config
 *         key: config.yaml
 *     - name: logs
 *       mountPath: /var/log
 *       hostPath:
 *         path: /var/log
 *         type: Directory
 */
message VolumeMount {
  // Name of the volume mount. Must be unique within the container.
  // Used to correlate with the volume definition.
  string name = 1 [(buf.validate.field).required = true];

  // Path within the container at which the volume should be mounted.
  // Must be an absolute path.
  string mount_path = 2 [(buf.validate.field).required = true];

  // Whether the volume should be mounted read-only.
  // Default is false.
  bool read_only = 3;

  // Path within the volume from which the container's volume should be mounted.
  // Defaults to "" (volume's root).
  // Useful for mounting a subdirectory of a volume.
  string sub_path = 4;

  // ConfigMap volume source.
  // Use this to mount a ConfigMap as a file or directory.
  ConfigMapVolumeSource config_map = 5;

  // Secret volume source.
  // Use this to mount a Secret as a file or directory.
  SecretVolumeSource secret = 6;

  // HostPath volume source.
  // Use this to mount a file or directory from the host node's filesystem.
  // Common for DaemonSets that need access to node-level resources.
  HostPathVolumeSource host_path = 7;

  // EmptyDir volume source.
  // Use this for temporary storage that is erased when the pod is removed.
  // Useful for scratch space, caching, or sharing data between containers.
  EmptyDirVolumeSource empty_dir = 8;

  // PersistentVolumeClaim volume source.
  // Use this to mount an existing PVC.
  // For StatefulSets, this can reference a volumeClaimTemplate.
  PvcVolumeSource pvc = 9;
}

/**
 * ConfigMapVolumeSource mounts a ConfigMap as a volume.
 * The ConfigMap can be one defined in spec.config_maps or an existing ConfigMap in the namespace.
 *
 * When 'key' is specified, only that key is mounted as a single file.
 * When 'key' is not specified, all keys are mounted as files in the directory.
 *
 * Example - Mount entire ConfigMap as directory:
 *   configMap:
 *     name: app-config
 *
 * Example - Mount single key as file:
 *   configMap:
 *     name: app-config
 *     key: database.yaml
 *     path: db-config.yaml
 */
message ConfigMapVolumeSource {
  // Name of the ConfigMap to mount.
  // Can reference a ConfigMap defined in spec.config_maps or an existing one in the namespace.
  string name = 1 [(buf.validate.field).required = true];

  // Specific key from the ConfigMap to mount as a single file.
  // If not specified, all keys are mounted as files in the directory.
  string key = 2;

  // If key is specified, this is the filename to use for the mounted file.
  // Defaults to the key name if not specified.
  // Example: key="config" path="app.yaml" mounts the "config" key as "app.yaml"
  string path = 3;

  // Mode bits to use on created files. Must be a value between 0 and 0777.
  // Defaults to 0644.
  // Use 0755 (493 in decimal) for executable scripts.
  int32 default_mode = 4;
}

/**
 * SecretVolumeSource mounts a Secret as a volume.
 * Works similarly to ConfigMapVolumeSource but for sensitive data.
 *
 * Example:
 *   secret:
 *     name: tls-certs
 *     key: tls.crt
 *     path: server.crt
 */
message SecretVolumeSource {
  // Name of the Secret to mount.
  string name = 1 [(buf.validate.field).required = true];

  // Specific key from the Secret to mount as a single file.
  // If not specified, all keys are mounted as files in the directory.
  string key = 2;

  // If key is specified, this is the filename to use for the mounted file.
  // Defaults to the key name if not specified.
  string path = 3;

  // Mode bits to use on created files. Must be a value between 0 and 0777.
  // Defaults to 0644.
  int32 default_mode = 4;
}

/**
 * HostPathVolumeSource mounts a file or directory from the host node's filesystem.
 * Use with caution as it ties pods to specific nodes.
 *
 * Common use cases:
 * - Log collection DaemonSets mounting /var/log
 * - Node monitoring agents mounting /sys or /proc
 * - Container runtime sockets (e.g., /var/run/docker.sock)
 *
 * Example:
 *   hostPath:
 *     path: /var/log
 *     type: Directory
 */
message HostPathVolumeSource {
  // Path on the host to mount.
  string path = 1 [(buf.validate.field).required = true];

  // Type of the host path.
  // Valid values:
  //   "" - Empty string (default) means no check is performed before mounting
  //   "DirectoryOrCreate" - Create directory if it doesn't exist
  //   "Directory" - Directory must exist
  //   "FileOrCreate" - Create file if it doesn't exist
  //   "File" - File must exist
  //   "Socket" - UNIX socket must exist
  //   "CharDevice" - Character device must exist
  //   "BlockDevice" - Block device must exist
  string type = 2 [(buf.validate.field).cel = {
    id: "host_path.type"
    message: 'Type must be one of: "", "DirectoryOrCreate", "Directory", "FileOrCreate", "File", "Socket", "CharDevice", "BlockDevice"'
    expression: 'size(this) == 0 || this in ["", "DirectoryOrCreate", "Directory", "FileOrCreate", "File", "Socket", "CharDevice", "BlockDevice"]'
  }];
}

/**
 * EmptyDirVolumeSource creates an empty directory for temporary storage.
 * The directory is created when a pod is assigned to a node and exists as long as the pod runs.
 * Data is deleted when the pod is removed.
 *
 * Use cases:
 * - Scratch space for computations
 * - Checkpoint storage for crash recovery
 * - Shared space between containers in a pod
 *
 * Example - Default (disk-backed):
 *   emptyDir: {}
 *
 * Example - Memory-backed (faster, but uses RAM):
 *   emptyDir:
 *     medium: Memory
 *     sizeLimit: 256Mi
 */
message EmptyDirVolumeSource {
  // Medium for the empty directory.
  // "" (default) uses the node's default medium (typically disk).
  // "Memory" uses a tmpfs (RAM-backed filesystem).
  //
  // Memory-backed volumes are faster but:
  // - Count against container memory limits
  // - Are lost on node restart
  // - Should have sizeLimit set to prevent OOM
  string medium = 1 [(buf.validate.field).cel = {
    id: "empty_dir.medium"
    message: 'Medium must be either "" or "Memory"'
    expression: 'size(this) == 0 || this in ["", "Memory"]'
  }];

  // Size limit for the empty directory.
  // Format: Kubernetes quantity (e.g., "1Gi", "500Mi").
  // Only strictly enforced when medium is "Memory".
  // For disk-backed volumes, this is a best-effort limit.
  string size_limit = 2;
}

/**
 * PvcVolumeSource mounts an existing PersistentVolumeClaim.
 *
 * For StatefulSets: The claimName can reference a volumeClaimTemplate name,
 * and the StatefulSet controller will automatically handle per-pod PVC binding.
 *
 * Example:
 *   pvc:
 *     claimName: data-volume
 *     readOnly: false
 */
message PvcVolumeSource {
  // Name of the PersistentVolumeClaim to mount.
  // For StatefulSets, this can be the name of a volumeClaimTemplate.
  string claim_name = 1 [(buf.validate.field).required = true];

  // Whether the PVC should be mounted read-only.
  // Default is false.
  bool read_only = 2;
}
