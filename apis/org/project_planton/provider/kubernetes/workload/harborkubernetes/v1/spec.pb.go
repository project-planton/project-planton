// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto

package harborkubernetesv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	kubernetes "github.com/project-planton/project-planton/apis/org/project_planton/shared/kubernetes"
	_ "github.com/project-planton/project-planton/apis/org/project_planton/shared/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// **HarborKubernetesStorageType** enumerates the supported storage backends for Harbor artifacts.
type HarborKubernetesStorageType int32

const (
	// unspecified should not be used
	HarborKubernetesStorageType_harbor_kubernetes_storage_type_unspecified HarborKubernetesStorageType = 0
	// Filesystem storage (PVC) - suitable for development only, not recommended for production HA
	HarborKubernetesStorageType_filesystem HarborKubernetesStorageType = 1
	// AWS S3 or S3-compatible object storage
	HarborKubernetesStorageType_s3 HarborKubernetesStorageType = 2
	// Google Cloud Storage
	HarborKubernetesStorageType_gcs HarborKubernetesStorageType = 3
	// Azure Blob Storage
	HarborKubernetesStorageType_azure HarborKubernetesStorageType = 4
	// Alibaba Cloud OSS
	HarborKubernetesStorageType_oss HarborKubernetesStorageType = 5
)

// Enum value maps for HarborKubernetesStorageType.
var (
	HarborKubernetesStorageType_name = map[int32]string{
		0: "harbor_kubernetes_storage_type_unspecified",
		1: "filesystem",
		2: "s3",
		3: "gcs",
		4: "azure",
		5: "oss",
	}
	HarborKubernetesStorageType_value = map[string]int32{
		"harbor_kubernetes_storage_type_unspecified": 0,
		"filesystem": 1,
		"s3":         2,
		"gcs":        3,
		"azure":      4,
		"oss":        5,
	}
)

func (x HarborKubernetesStorageType) Enum() *HarborKubernetesStorageType {
	p := new(HarborKubernetesStorageType)
	*p = x
	return p
}

func (x HarborKubernetesStorageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HarborKubernetesStorageType) Descriptor() protoreflect.EnumDescriptor {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_enumTypes[0].Descriptor()
}

func (HarborKubernetesStorageType) Type() protoreflect.EnumType {
	return &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_enumTypes[0]
}

func (x HarborKubernetesStorageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HarborKubernetesStorageType.Descriptor instead.
func (HarborKubernetesStorageType) EnumDescriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{0}
}

// *
// **HarborKubernetesSpec** defines the configuration for deploying Harbor cloud-native registry on Kubernetes.
// Harbor is an open source registry that secures artifacts with policies and role-based access control,
// ensures images are scanned and free from vulnerabilities, and signs images as trusted.
// This spec supports both self-managed and external PostgreSQL and Redis configurations, enabling flexible
// deployment patterns from simple single-node installations to production-grade high-availability clusters.
type HarborKubernetesSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The container specifications for Harbor Core (API server, authentication, webhook).
	CoreContainer *HarborKubernetesContainer `protobuf:"bytes,1,opt,name=core_container,json=coreContainer,proto3" json:"core_container,omitempty"`
	// The container specifications for Harbor Portal (web UI).
	PortalContainer *HarborKubernetesContainer `protobuf:"bytes,2,opt,name=portal_container,json=portalContainer,proto3" json:"portal_container,omitempty"`
	// The container specifications for Harbor Registry (Docker/OCI registry backend).
	RegistryContainer *HarborKubernetesContainer `protobuf:"bytes,3,opt,name=registry_container,json=registryContainer,proto3" json:"registry_container,omitempty"`
	// The container specifications for Harbor Jobservice (background job execution).
	JobserviceContainer *HarborKubernetesContainer `protobuf:"bytes,4,opt,name=jobservice_container,json=jobserviceContainer,proto3" json:"jobservice_container,omitempty"`
	// The database configuration for Harbor, supporting both self-managed and external PostgreSQL.
	Database *HarborKubernetesDatabaseConfig `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	// The cache configuration for Harbor, supporting both self-managed and external Redis.
	Cache *HarborKubernetesCacheConfig `protobuf:"bytes,6,opt,name=cache,proto3" json:"cache,omitempty"`
	// The object storage configuration for Harbor artifact storage.
	Storage *HarborKubernetesStorageConfig `protobuf:"bytes,7,opt,name=storage,proto3" json:"storage,omitempty"`
	// The ingress configuration for Harbor UI and registry endpoints.
	Ingress *HarborKubernetesIngress `protobuf:"bytes,8,opt,name=ingress,proto3" json:"ingress,omitempty"`
	// *
	// A map of key-value pairs that provide additional customization options for the Harbor Helm chart.
	// These values allow for further refinement of the deployment, such as enabling Trivy scanner,
	// configuring Notary for image signing, or customizing authentication providers.
	// For detailed information on available options, refer to the Helm chart documentation at:
	// https://github.com/goharbor/harbor-helm
	HelmValues    map[string]string `protobuf:"bytes,9,rep,name=helm_values,json=helmValues,proto3" json:"helm_values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesSpec) Reset() {
	*x = HarborKubernetesSpec{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesSpec) ProtoMessage() {}

func (x *HarborKubernetesSpec) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesSpec.ProtoReflect.Descriptor instead.
func (*HarborKubernetesSpec) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *HarborKubernetesSpec) GetCoreContainer() *HarborKubernetesContainer {
	if x != nil {
		return x.CoreContainer
	}
	return nil
}

func (x *HarborKubernetesSpec) GetPortalContainer() *HarborKubernetesContainer {
	if x != nil {
		return x.PortalContainer
	}
	return nil
}

func (x *HarborKubernetesSpec) GetRegistryContainer() *HarborKubernetesContainer {
	if x != nil {
		return x.RegistryContainer
	}
	return nil
}

func (x *HarborKubernetesSpec) GetJobserviceContainer() *HarborKubernetesContainer {
	if x != nil {
		return x.JobserviceContainer
	}
	return nil
}

func (x *HarborKubernetesSpec) GetDatabase() *HarborKubernetesDatabaseConfig {
	if x != nil {
		return x.Database
	}
	return nil
}

func (x *HarborKubernetesSpec) GetCache() *HarborKubernetesCacheConfig {
	if x != nil {
		return x.Cache
	}
	return nil
}

func (x *HarborKubernetesSpec) GetStorage() *HarborKubernetesStorageConfig {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *HarborKubernetesSpec) GetIngress() *HarborKubernetesIngress {
	if x != nil {
		return x.Ingress
	}
	return nil
}

func (x *HarborKubernetesSpec) GetHelmValues() map[string]string {
	if x != nil {
		return x.HelmValues
	}
	return nil
}

// *
// **HarborKubernetesContainer** specifies the container configuration for various Harbor components.
// It includes settings such as the number of replicas, container image, and resource allocations.
type HarborKubernetesContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of pods to deploy for this component.
	Replicas int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	// The CPU and memory resources allocated to the container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// The container image configuration (repository and tag).
	Image         *kubernetes.ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesContainer) Reset() {
	*x = HarborKubernetesContainer{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesContainer) ProtoMessage() {}

func (x *HarborKubernetesContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesContainer.ProtoReflect.Descriptor instead.
func (*HarborKubernetesContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *HarborKubernetesContainer) GetReplicas() int32 {
	if x != nil {
		return x.Replicas
	}
	return 0
}

func (x *HarborKubernetesContainer) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *HarborKubernetesContainer) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

// *
// **HarborKubernetesDatabaseConfig** defines the PostgreSQL database configuration for Harbor.
// It supports two deployment modes:
// 1. Self-managed: Deploy PostgreSQL within the Kubernetes cluster (default).
// 2. External: Connect to an existing external PostgreSQL instance.
type HarborKubernetesDatabaseConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Flag to enable using an external PostgreSQL database.
	// When false (default), Harbor will deploy and manage its own PostgreSQL instance.
	// When true, the external_database field must be configured.
	IsExternal bool `protobuf:"varint,1,opt,name=is_external,json=isExternal,proto3" json:"is_external,omitempty"`
	// *
	// External PostgreSQL database connection details.
	// This field is required when is_external is true and ignored when false.
	ExternalDatabase *HarborKubernetesExternalPostgresql `protobuf:"bytes,2,opt,name=external_database,json=externalDatabase,proto3" json:"external_database,omitempty"`
	// *
	// Self-managed PostgreSQL configuration.
	// This field is used when is_external is false and configures the in-cluster PostgreSQL deployment.
	ManagedDatabase *HarborKubernetesManagedPostgresql `protobuf:"bytes,3,opt,name=managed_database,json=managedDatabase,proto3" json:"managed_database,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *HarborKubernetesDatabaseConfig) Reset() {
	*x = HarborKubernetesDatabaseConfig{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesDatabaseConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesDatabaseConfig) ProtoMessage() {}

func (x *HarborKubernetesDatabaseConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesDatabaseConfig.ProtoReflect.Descriptor instead.
func (*HarborKubernetesDatabaseConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *HarborKubernetesDatabaseConfig) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *HarborKubernetesDatabaseConfig) GetExternalDatabase() *HarborKubernetesExternalPostgresql {
	if x != nil {
		return x.ExternalDatabase
	}
	return nil
}

func (x *HarborKubernetesDatabaseConfig) GetManagedDatabase() *HarborKubernetesManagedPostgresql {
	if x != nil {
		return x.ManagedDatabase
	}
	return nil
}

// *
// **HarborKubernetesExternalPostgresql** defines connection parameters for an external PostgreSQL instance.
// This allows Harbor to use a pre-existing PostgreSQL database instead of deploying one within the cluster.
type HarborKubernetesExternalPostgresql struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hostname or endpoint of the external PostgreSQL instance.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The port for PostgreSQL (default is 5432).
	Port *int32 `protobuf:"varint,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
	// The username for authenticating to PostgreSQL.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// The password for authenticating to PostgreSQL.
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// The name of the database for Harbor Core (default is "registry").
	CoreDatabase *string `protobuf:"bytes,5,opt,name=core_database,json=coreDatabase,proto3,oneof" json:"core_database,omitempty"`
	// The name of the database for Clair (vulnerability scanner).
	ClairDatabase *string `protobuf:"bytes,6,opt,name=clair_database,json=clairDatabase,proto3,oneof" json:"clair_database,omitempty"`
	// The name of the database for Notary Server (image signing).
	NotaryServerDatabase *string `protobuf:"bytes,7,opt,name=notary_server_database,json=notaryServerDatabase,proto3,oneof" json:"notary_server_database,omitempty"`
	// The name of the database for Notary Signer (image signing).
	NotarySignerDatabase *string `protobuf:"bytes,8,opt,name=notary_signer_database,json=notarySignerDatabase,proto3,oneof" json:"notary_signer_database,omitempty"`
	// Whether to use SSL/TLS connection to PostgreSQL.
	UseSsl        bool `protobuf:"varint,9,opt,name=use_ssl,json=useSsl,proto3" json:"use_ssl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesExternalPostgresql) Reset() {
	*x = HarborKubernetesExternalPostgresql{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesExternalPostgresql) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesExternalPostgresql) ProtoMessage() {}

func (x *HarborKubernetesExternalPostgresql) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesExternalPostgresql.ProtoReflect.Descriptor instead.
func (*HarborKubernetesExternalPostgresql) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *HarborKubernetesExternalPostgresql) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *HarborKubernetesExternalPostgresql) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetCoreDatabase() string {
	if x != nil && x.CoreDatabase != nil {
		return *x.CoreDatabase
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetClairDatabase() string {
	if x != nil && x.ClairDatabase != nil {
		return *x.ClairDatabase
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetNotaryServerDatabase() string {
	if x != nil && x.NotaryServerDatabase != nil {
		return *x.NotaryServerDatabase
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetNotarySignerDatabase() string {
	if x != nil && x.NotarySignerDatabase != nil {
		return *x.NotarySignerDatabase
	}
	return ""
}

func (x *HarborKubernetesExternalPostgresql) GetUseSsl() bool {
	if x != nil {
		return x.UseSsl
	}
	return false
}

// *
// **HarborKubernetesManagedPostgresql** defines configuration for a self-managed PostgreSQL deployment.
// This supports simple single-node deployments suitable for development and testing.
type HarborKubernetesManagedPostgresql struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The container specifications for PostgreSQL.
	Container     *HarborKubernetesPostgresqlContainer `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesManagedPostgresql) Reset() {
	*x = HarborKubernetesManagedPostgresql{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesManagedPostgresql) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesManagedPostgresql) ProtoMessage() {}

func (x *HarborKubernetesManagedPostgresql) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesManagedPostgresql.ProtoReflect.Descriptor instead.
func (*HarborKubernetesManagedPostgresql) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{4}
}

func (x *HarborKubernetesManagedPostgresql) GetContainer() *HarborKubernetesPostgresqlContainer {
	if x != nil {
		return x.Container
	}
	return nil
}

// *
// **HarborKubernetesPostgresqlContainer** specifies the container configuration for PostgreSQL.
// It includes replica count, resource allocations, and persistence settings.
type HarborKubernetesPostgresqlContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of PostgreSQL pods to deploy.
	Replicas int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	// The CPU and memory resources allocated to the PostgreSQL container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// The container image configuration for PostgreSQL.
	Image *kubernetes.ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// *
	// Flag to enable or disable data persistence for PostgreSQL.
	// When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	// Defaults to true.
	PersistenceEnabled bool `protobuf:"varint,4,opt,name=persistence_enabled,json=persistenceEnabled,proto3" json:"persistence_enabled,omitempty"`
	// *
	// The size of the persistent volume attached to each PostgreSQL pod (e.g., "20Gi").
	// This attribute is ignored when persistence is not enabled.
	// Note: This value cannot be modified after creation due to Kubernetes StatefulSet limitations.
	DiskSize      string `protobuf:"bytes,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesPostgresqlContainer) Reset() {
	*x = HarborKubernetesPostgresqlContainer{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesPostgresqlContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesPostgresqlContainer) ProtoMessage() {}

func (x *HarborKubernetesPostgresqlContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesPostgresqlContainer.ProtoReflect.Descriptor instead.
func (*HarborKubernetesPostgresqlContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{5}
}

func (x *HarborKubernetesPostgresqlContainer) GetReplicas() int32 {
	if x != nil {
		return x.Replicas
	}
	return 0
}

func (x *HarborKubernetesPostgresqlContainer) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *HarborKubernetesPostgresqlContainer) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *HarborKubernetesPostgresqlContainer) GetPersistenceEnabled() bool {
	if x != nil {
		return x.PersistenceEnabled
	}
	return false
}

func (x *HarborKubernetesPostgresqlContainer) GetDiskSize() string {
	if x != nil {
		return x.DiskSize
	}
	return ""
}

// *
// **HarborKubernetesCacheConfig** defines the Redis cache configuration for Harbor.
// It supports two deployment modes:
// 1. Self-managed: Deploy Redis within the Kubernetes cluster (default).
// 2. External: Connect to an existing external Redis instance.
type HarborKubernetesCacheConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Flag to enable using an external Redis cache.
	// When false (default), Harbor will deploy and manage its own Redis instance.
	// When true, the external_cache field must be configured.
	IsExternal bool `protobuf:"varint,1,opt,name=is_external,json=isExternal,proto3" json:"is_external,omitempty"`
	// *
	// External Redis cache connection details.
	// This field is required when is_external is true and ignored when false.
	ExternalCache *HarborKubernetesExternalRedis `protobuf:"bytes,2,opt,name=external_cache,json=externalCache,proto3" json:"external_cache,omitempty"`
	// *
	// Self-managed Redis configuration.
	// This field is used when is_external is false and configures the in-cluster Redis deployment.
	ManagedCache  *HarborKubernetesManagedRedis `protobuf:"bytes,3,opt,name=managed_cache,json=managedCache,proto3" json:"managed_cache,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesCacheConfig) Reset() {
	*x = HarborKubernetesCacheConfig{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesCacheConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesCacheConfig) ProtoMessage() {}

func (x *HarborKubernetesCacheConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesCacheConfig.ProtoReflect.Descriptor instead.
func (*HarborKubernetesCacheConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{6}
}

func (x *HarborKubernetesCacheConfig) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *HarborKubernetesCacheConfig) GetExternalCache() *HarborKubernetesExternalRedis {
	if x != nil {
		return x.ExternalCache
	}
	return nil
}

func (x *HarborKubernetesCacheConfig) GetManagedCache() *HarborKubernetesManagedRedis {
	if x != nil {
		return x.ManagedCache
	}
	return nil
}

// *
// **HarborKubernetesExternalRedis** defines connection parameters for an external Redis instance.
// This allows Harbor to use a pre-existing Redis cache instead of deploying one within the cluster.
type HarborKubernetesExternalRedis struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hostname or endpoint of the external Redis instance (e.g., "redis.example.com:6379").
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The port for Redis (default is 6379).
	Port *int32 `protobuf:"varint,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
	// The username for authenticating to Redis (if ACLs are enabled).
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// The password for authenticating to Redis.
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// The Redis database index to use (default is 0).
	DatabaseIndex *int32 `protobuf:"varint,5,opt,name=database_index,json=databaseIndex,proto3,oneof" json:"database_index,omitempty"`
	// Whether to use Sentinel for high availability.
	UseSentinel bool `protobuf:"varint,6,opt,name=use_sentinel,json=useSentinel,proto3" json:"use_sentinel,omitempty"`
	// The Sentinel master set name (required if use_sentinel is true).
	SentinelMasterSet string `protobuf:"bytes,7,opt,name=sentinel_master_set,json=sentinelMasterSet,proto3" json:"sentinel_master_set,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *HarborKubernetesExternalRedis) Reset() {
	*x = HarborKubernetesExternalRedis{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesExternalRedis) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesExternalRedis) ProtoMessage() {}

func (x *HarborKubernetesExternalRedis) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesExternalRedis.ProtoReflect.Descriptor instead.
func (*HarborKubernetesExternalRedis) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{7}
}

func (x *HarborKubernetesExternalRedis) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *HarborKubernetesExternalRedis) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *HarborKubernetesExternalRedis) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *HarborKubernetesExternalRedis) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *HarborKubernetesExternalRedis) GetDatabaseIndex() int32 {
	if x != nil && x.DatabaseIndex != nil {
		return *x.DatabaseIndex
	}
	return 0
}

func (x *HarborKubernetesExternalRedis) GetUseSentinel() bool {
	if x != nil {
		return x.UseSentinel
	}
	return false
}

func (x *HarborKubernetesExternalRedis) GetSentinelMasterSet() string {
	if x != nil {
		return x.SentinelMasterSet
	}
	return ""
}

// *
// **HarborKubernetesManagedRedis** defines configuration for a self-managed Redis deployment.
// This supports simple single-node deployments suitable for development and testing.
type HarborKubernetesManagedRedis struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The container specifications for Redis.
	Container     *HarborKubernetesRedisContainer `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesManagedRedis) Reset() {
	*x = HarborKubernetesManagedRedis{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesManagedRedis) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesManagedRedis) ProtoMessage() {}

func (x *HarborKubernetesManagedRedis) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesManagedRedis.ProtoReflect.Descriptor instead.
func (*HarborKubernetesManagedRedis) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{8}
}

func (x *HarborKubernetesManagedRedis) GetContainer() *HarborKubernetesRedisContainer {
	if x != nil {
		return x.Container
	}
	return nil
}

// *
// **HarborKubernetesRedisContainer** specifies the container configuration for Redis.
// It includes replica count, resource allocations, and persistence settings.
type HarborKubernetesRedisContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of Redis pods to deploy.
	Replicas int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	// The CPU and memory resources allocated to the Redis container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// The container image configuration for Redis.
	Image *kubernetes.ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// *
	// Flag to enable or disable data persistence for Redis.
	// When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	// Defaults to true.
	PersistenceEnabled bool `protobuf:"varint,4,opt,name=persistence_enabled,json=persistenceEnabled,proto3" json:"persistence_enabled,omitempty"`
	// *
	// The size of the persistent volume attached to each Redis pod (e.g., "8Gi").
	// This attribute is ignored when persistence is not enabled.
	DiskSize      string `protobuf:"bytes,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesRedisContainer) Reset() {
	*x = HarborKubernetesRedisContainer{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesRedisContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesRedisContainer) ProtoMessage() {}

func (x *HarborKubernetesRedisContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesRedisContainer.ProtoReflect.Descriptor instead.
func (*HarborKubernetesRedisContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{9}
}

func (x *HarborKubernetesRedisContainer) GetReplicas() int32 {
	if x != nil {
		return x.Replicas
	}
	return 0
}

func (x *HarborKubernetesRedisContainer) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *HarborKubernetesRedisContainer) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *HarborKubernetesRedisContainer) GetPersistenceEnabled() bool {
	if x != nil {
		return x.PersistenceEnabled
	}
	return false
}

func (x *HarborKubernetesRedisContainer) GetDiskSize() string {
	if x != nil {
		return x.DiskSize
	}
	return ""
}

// *
// **HarborKubernetesStorageConfig** defines the storage configuration for Harbor artifacts.
// For production high-availability deployments, external object storage (S3, GCS, Azure) is required.
type HarborKubernetesStorageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of storage backend to use.
	Type HarborKubernetesStorageType `protobuf:"varint,1,opt,name=type,proto3,enum=org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageType" json:"type,omitempty"`
	// S3-compatible storage configuration (required when type is s3).
	S3 *HarborKubernetesS3Storage `protobuf:"bytes,2,opt,name=s3,proto3" json:"s3,omitempty"`
	// Google Cloud Storage configuration (required when type is gcs).
	Gcs *HarborKubernetesGcsStorage `protobuf:"bytes,3,opt,name=gcs,proto3" json:"gcs,omitempty"`
	// Azure Blob Storage configuration (required when type is azure).
	Azure *HarborKubernetesAzureStorage `protobuf:"bytes,4,opt,name=azure,proto3" json:"azure,omitempty"`
	// Alibaba Cloud OSS configuration (required when type is oss).
	Oss *HarborKubernetesOssStorage `protobuf:"bytes,5,opt,name=oss,proto3" json:"oss,omitempty"`
	// Filesystem storage configuration (required when type is filesystem).
	Filesystem    *HarborKubernetesFilesystemStorage `protobuf:"bytes,6,opt,name=filesystem,proto3" json:"filesystem,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesStorageConfig) Reset() {
	*x = HarborKubernetesStorageConfig{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesStorageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesStorageConfig) ProtoMessage() {}

func (x *HarborKubernetesStorageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesStorageConfig.ProtoReflect.Descriptor instead.
func (*HarborKubernetesStorageConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{10}
}

func (x *HarborKubernetesStorageConfig) GetType() HarborKubernetesStorageType {
	if x != nil {
		return x.Type
	}
	return HarborKubernetesStorageType_harbor_kubernetes_storage_type_unspecified
}

func (x *HarborKubernetesStorageConfig) GetS3() *HarborKubernetesS3Storage {
	if x != nil {
		return x.S3
	}
	return nil
}

func (x *HarborKubernetesStorageConfig) GetGcs() *HarborKubernetesGcsStorage {
	if x != nil {
		return x.Gcs
	}
	return nil
}

func (x *HarborKubernetesStorageConfig) GetAzure() *HarborKubernetesAzureStorage {
	if x != nil {
		return x.Azure
	}
	return nil
}

func (x *HarborKubernetesStorageConfig) GetOss() *HarborKubernetesOssStorage {
	if x != nil {
		return x.Oss
	}
	return nil
}

func (x *HarborKubernetesStorageConfig) GetFilesystem() *HarborKubernetesFilesystemStorage {
	if x != nil {
		return x.Filesystem
	}
	return nil
}

// *
// **HarborKubernetesS3Storage** defines S3-compatible object storage configuration.
type HarborKubernetesS3Storage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The S3 bucket name.
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// The AWS region (e.g., "us-west-2").
	Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	// The AWS access key ID.
	AccessKey string `protobuf:"bytes,3,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	// The AWS secret access key.
	SecretKey string `protobuf:"bytes,4,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	// Whether to use regional endpoint (default is false for global endpoint).
	RegionEndpoint bool `protobuf:"varint,5,opt,name=region_endpoint,json=regionEndpoint,proto3" json:"region_endpoint,omitempty"`
	// Whether to encrypt objects using server-side encryption.
	Encrypt bool `protobuf:"varint,6,opt,name=encrypt,proto3" json:"encrypt,omitempty"`
	// Whether to use secure (HTTPS) connection.
	Secure bool `protobuf:"varint,7,opt,name=secure,proto3" json:"secure,omitempty"`
	// The root directory path within the bucket.
	RootDirectory string `protobuf:"bytes,8,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	// Custom S3 endpoint URL (for S3-compatible services like MinIO).
	EndpointUrl   string `protobuf:"bytes,9,opt,name=endpoint_url,json=endpointUrl,proto3" json:"endpoint_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesS3Storage) Reset() {
	*x = HarborKubernetesS3Storage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesS3Storage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesS3Storage) ProtoMessage() {}

func (x *HarborKubernetesS3Storage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesS3Storage.ProtoReflect.Descriptor instead.
func (*HarborKubernetesS3Storage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{11}
}

func (x *HarborKubernetesS3Storage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *HarborKubernetesS3Storage) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *HarborKubernetesS3Storage) GetAccessKey() string {
	if x != nil {
		return x.AccessKey
	}
	return ""
}

func (x *HarborKubernetesS3Storage) GetSecretKey() string {
	if x != nil {
		return x.SecretKey
	}
	return ""
}

func (x *HarborKubernetesS3Storage) GetRegionEndpoint() bool {
	if x != nil {
		return x.RegionEndpoint
	}
	return false
}

func (x *HarborKubernetesS3Storage) GetEncrypt() bool {
	if x != nil {
		return x.Encrypt
	}
	return false
}

func (x *HarborKubernetesS3Storage) GetSecure() bool {
	if x != nil {
		return x.Secure
	}
	return false
}

func (x *HarborKubernetesS3Storage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

func (x *HarborKubernetesS3Storage) GetEndpointUrl() string {
	if x != nil {
		return x.EndpointUrl
	}
	return ""
}

// *
// **HarborKubernetesGcsStorage** defines Google Cloud Storage configuration.
type HarborKubernetesGcsStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The GCS bucket name.
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// The base64-encoded service account key JSON.
	KeyData string `protobuf:"bytes,2,opt,name=key_data,json=keyData,proto3" json:"key_data,omitempty"`
	// The root directory path within the bucket.
	RootDirectory string `protobuf:"bytes,3,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	// The chunk size for upload (default is 5242880 bytes).
	ChunkSize     *int32 `protobuf:"varint,4,opt,name=chunk_size,json=chunkSize,proto3,oneof" json:"chunk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesGcsStorage) Reset() {
	*x = HarborKubernetesGcsStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesGcsStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesGcsStorage) ProtoMessage() {}

func (x *HarborKubernetesGcsStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesGcsStorage.ProtoReflect.Descriptor instead.
func (*HarborKubernetesGcsStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{12}
}

func (x *HarborKubernetesGcsStorage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *HarborKubernetesGcsStorage) GetKeyData() string {
	if x != nil {
		return x.KeyData
	}
	return ""
}

func (x *HarborKubernetesGcsStorage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

func (x *HarborKubernetesGcsStorage) GetChunkSize() int32 {
	if x != nil && x.ChunkSize != nil {
		return *x.ChunkSize
	}
	return 0
}

// *
// **HarborKubernetesAzureStorage** defines Azure Blob Storage configuration.
type HarborKubernetesAzureStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Azure storage account name.
	AccountName string `protobuf:"bytes,1,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	// The Azure storage account key.
	AccountKey string `protobuf:"bytes,2,opt,name=account_key,json=accountKey,proto3" json:"account_key,omitempty"`
	// The Azure blob container name.
	Container string `protobuf:"bytes,3,opt,name=container,proto3" json:"container,omitempty"`
	// The root directory path within the container.
	RootDirectory string `protobuf:"bytes,4,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesAzureStorage) Reset() {
	*x = HarborKubernetesAzureStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesAzureStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesAzureStorage) ProtoMessage() {}

func (x *HarborKubernetesAzureStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesAzureStorage.ProtoReflect.Descriptor instead.
func (*HarborKubernetesAzureStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{13}
}

func (x *HarborKubernetesAzureStorage) GetAccountName() string {
	if x != nil {
		return x.AccountName
	}
	return ""
}

func (x *HarborKubernetesAzureStorage) GetAccountKey() string {
	if x != nil {
		return x.AccountKey
	}
	return ""
}

func (x *HarborKubernetesAzureStorage) GetContainer() string {
	if x != nil {
		return x.Container
	}
	return ""
}

func (x *HarborKubernetesAzureStorage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

// *
// **HarborKubernetesOssStorage** defines Alibaba Cloud OSS configuration.
type HarborKubernetesOssStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The OSS bucket name.
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// The OSS endpoint (e.g., "oss-cn-hangzhou.aliyuncs.com").
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// The access key ID.
	AccessKeyId string `protobuf:"bytes,3,opt,name=access_key_id,json=accessKeyId,proto3" json:"access_key_id,omitempty"`
	// The access key secret.
	AccessKeySecret string `protobuf:"bytes,4,opt,name=access_key_secret,json=accessKeySecret,proto3" json:"access_key_secret,omitempty"`
	// The root directory path within the bucket.
	RootDirectory string `protobuf:"bytes,5,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	// Whether to use HTTPS.
	Secure        bool `protobuf:"varint,6,opt,name=secure,proto3" json:"secure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesOssStorage) Reset() {
	*x = HarborKubernetesOssStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesOssStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesOssStorage) ProtoMessage() {}

func (x *HarborKubernetesOssStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesOssStorage.ProtoReflect.Descriptor instead.
func (*HarborKubernetesOssStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{14}
}

func (x *HarborKubernetesOssStorage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *HarborKubernetesOssStorage) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *HarborKubernetesOssStorage) GetAccessKeyId() string {
	if x != nil {
		return x.AccessKeyId
	}
	return ""
}

func (x *HarborKubernetesOssStorage) GetAccessKeySecret() string {
	if x != nil {
		return x.AccessKeySecret
	}
	return ""
}

func (x *HarborKubernetesOssStorage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

func (x *HarborKubernetesOssStorage) GetSecure() bool {
	if x != nil {
		return x.Secure
	}
	return false
}

// *
// **HarborKubernetesFilesystemStorage** defines filesystem (PVC) storage configuration.
// Note: This is not suitable for production high-availability deployments.
type HarborKubernetesFilesystemStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The size of the persistent volume for storing artifacts (e.g., "100Gi").
	// Note: This value cannot be modified after creation due to Kubernetes PVC limitations.
	DiskSize string `protobuf:"bytes,1,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// The storage class to use for the PVC.
	StorageClass  string `protobuf:"bytes,2,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesFilesystemStorage) Reset() {
	*x = HarborKubernetesFilesystemStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesFilesystemStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesFilesystemStorage) ProtoMessage() {}

func (x *HarborKubernetesFilesystemStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesFilesystemStorage.ProtoReflect.Descriptor instead.
func (*HarborKubernetesFilesystemStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{15}
}

func (x *HarborKubernetesFilesystemStorage) GetDiskSize() string {
	if x != nil {
		return x.DiskSize
	}
	return ""
}

func (x *HarborKubernetesFilesystemStorage) GetStorageClass() string {
	if x != nil {
		return x.StorageClass
	}
	return ""
}

// *
// **HarborKubernetesIngress** defines the ingress configuration for Harbor endpoints.
// It provides separate ingress settings for the Core/Portal UI and Notary service.
type HarborKubernetesIngress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ingress configuration for Harbor Core and Portal (web UI and API).
	Core *HarborKubernetesIngressEndpoint `protobuf:"bytes,1,opt,name=core,proto3" json:"core,omitempty"`
	// Ingress configuration for Notary service (image signing).
	Notary        *HarborKubernetesIngressEndpoint `protobuf:"bytes,2,opt,name=notary,proto3" json:"notary,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesIngress) Reset() {
	*x = HarborKubernetesIngress{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesIngress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesIngress) ProtoMessage() {}

func (x *HarborKubernetesIngress) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesIngress.ProtoReflect.Descriptor instead.
func (*HarborKubernetesIngress) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{16}
}

func (x *HarborKubernetesIngress) GetCore() *HarborKubernetesIngressEndpoint {
	if x != nil {
		return x.Core
	}
	return nil
}

func (x *HarborKubernetesIngress) GetNotary() *HarborKubernetesIngressEndpoint {
	if x != nil {
		return x.Notary
	}
	return nil
}

// *
// **HarborKubernetesIngressEndpoint** defines ingress configuration for a specific Harbor endpoint.
type HarborKubernetesIngressEndpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Flag to enable or disable ingress for this endpoint.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// The full hostname for external access (e.g., "harbor.example.com").
	// This hostname will be configured via Gateway API resources.
	// Required when enabled is true.
	Hostname      string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HarborKubernetesIngressEndpoint) Reset() {
	*x = HarborKubernetesIngressEndpoint{}
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HarborKubernetesIngressEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HarborKubernetesIngressEndpoint) ProtoMessage() {}

func (x *HarborKubernetesIngressEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HarborKubernetesIngressEndpoint.ProtoReflect.Descriptor instead.
func (*HarborKubernetesIngressEndpoint) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP(), []int{17}
}

func (x *HarborKubernetesIngressEndpoint) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *HarborKubernetesIngressEndpoint) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

var file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*HarborKubernetesContainer)(nil),
		Field:         570001,
		Name:          "org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_core_container",
		Tag:           "bytes,570001,opt,name=default_harbor_core_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*HarborKubernetesContainer)(nil),
		Field:         570002,
		Name:          "org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_portal_container",
		Tag:           "bytes,570002,opt,name=default_harbor_portal_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*HarborKubernetesContainer)(nil),
		Field:         570003,
		Name:          "org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_registry_container",
		Tag:           "bytes,570003,opt,name=default_harbor_registry_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*HarborKubernetesContainer)(nil),
		Field:         570004,
		Name:          "org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_jobservice_container",
		Tag:           "bytes,570004,opt,name=default_harbor_jobservice_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*HarborKubernetesPostgresqlContainer)(nil),
		Field:         570005,
		Name:          "org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_postgresql_container",
		Tag:           "bytes,570005,opt,name=default_postgresql_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*HarborKubernetesRedisContainer)(nil),
		Field:         570006,
		Name:          "org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_redis_container",
		Tag:           "bytes,570006,opt,name=default_redis_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto",
	},
}

// Extension fields to descriptorpb.FieldOptions.
var (
	// optional org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer default_harbor_core_container = 570001;
	E_DefaultHarborCoreContainer = &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes[0]
	// optional org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer default_harbor_portal_container = 570002;
	E_DefaultHarborPortalContainer = &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes[1]
	// optional org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer default_harbor_registry_container = 570003;
	E_DefaultHarborRegistryContainer = &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes[2]
	// optional org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer default_harbor_jobservice_container = 570004;
	E_DefaultHarborJobserviceContainer = &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes[3]
	// optional org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainer default_postgresql_container = 570005;
	E_DefaultPostgresqlContainer = &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes[4]
	// optional org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainer default_redis_container = 570006;
	E_DefaultRedisContainer = &file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes[5]
)

var File_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDesc = "" +
	"\n" +
	"Oorg/project_planton/provider/kubernetes/workload/harborkubernetes/v1/spec.proto\x12Dorg.project_planton.provider.kubernetes.workload.harborkubernetes.v1\x1a\x1bbuf/validate/validate.proto\x1a google/protobuf/descriptor.proto\x1a6org/project_planton/shared/kubernetes/kubernetes.proto\x1a0org/project_planton/shared/options/options.proto\"\xcd\v\n" +
	"\x14HarborKubernetesSpec\x12\xae\x01\n" +
	"\x0ecore_container\x18\x01 \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerB&\x8a\xa9\x96\x02!\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x032Gi\x12\r\n" +
	"\x04200m\x12\x05512MiR\rcoreContainer\x12\xb3\x01\n" +
	"\x10portal_container\x18\x02 \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerB'\x92\xa9\x96\x02\"\b\x01\x12\x1e\n" +
	"\r\n" +
	"\x04500m\x12\x05512Mi\x12\r\n" +
	"\x04100m\x12\x05256MiR\x0fportalContainer\x12\xb6\x01\n" +
	"\x12registry_container\x18\x03 \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerB&\x9a\xa9\x96\x02!\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x032Gi\x12\r\n" +
	"\x04200m\x12\x05512MiR\x11registryContainer\x12\xba\x01\n" +
	"\x14jobservice_container\x18\x04 \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerB&\xa2\xa9\x96\x02!\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x031Gi\x12\r\n" +
	"\x04100m\x12\x05256MiR\x13jobserviceContainer\x12\x88\x01\n" +
	"\bdatabase\x18\x05 \x01(\v2d.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesDatabaseConfigB\x06\xbaH\x03\xc8\x01\x01R\bdatabase\x12\x7f\n" +
	"\x05cache\x18\x06 \x01(\v2a.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesCacheConfigB\x06\xbaH\x03\xc8\x01\x01R\x05cache\x12\x85\x01\n" +
	"\astorage\x18\a \x01(\v2c.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfigB\x06\xbaH\x03\xc8\x01\x01R\astorage\x12w\n" +
	"\aingress\x18\b \x01(\v2].org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngressR\aingress\x12\x8b\x01\n" +
	"\vhelm_values\x18\t \x03(\v2j.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.HelmValuesEntryR\n" +
	"helmValues\x1a=\n" +
	"\x0fHelmValuesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe6\x01\n" +
	"\x19HarborKubernetesContainer\x12#\n" +
	"\breplicas\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02(\x01R\breplicas\x12W\n" +
	"\tresources\x18\x02 \x01(\v29.org.project_planton.shared.kubernetes.ContainerResourcesR\tresources\x12K\n" +
	"\x05image\x18\x03 \x01(\v25.org.project_planton.shared.kubernetes.ContainerImageR\x05image\"\x91\x04\n" +
	"\x1eHarborKubernetesDatabaseConfig\x12\x1f\n" +
	"\vis_external\x18\x01 \x01(\bR\n" +
	"isExternal\x12\x95\x01\n" +
	"\x11external_database\x18\x02 \x01(\v2h.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesExternalPostgresqlR\x10externalDatabase\x12\x92\x01\n" +
	"\x10managed_database\x18\x03 \x01(\v2g.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedPostgresqlR\x0fmanagedDatabase:\xa0\x01\xbaH\x9c\x01\x1a\x99\x01\n" +
	"\x1fspec.database.external_required\x12DExternal database configuration is required when is_external is true\x1a0!this.is_external || has(this.external_database)\"\xbe\x04\n" +
	"\"HarborKubernetesExternalPostgresql\x12\x1a\n" +
	"\x04host\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04host\x12,\n" +
	"\x04port\x18\x02 \x01(\x05B\x13\xbaH\b\x1a\x06\x18\xff\xff\x03 \x00\x8a\xa6\x1d\x045432H\x00R\x04port\x88\x01\x01\x12\"\n" +
	"\busername\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\busername\x12\"\n" +
	"\bpassword\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bpassword\x126\n" +
	"\rcore_database\x18\x05 \x01(\tB\f\x8a\xa6\x1d\bregistryH\x01R\fcoreDatabase\x88\x01\x01\x125\n" +
	"\x0eclair_database\x18\x06 \x01(\tB\t\x8a\xa6\x1d\x05clairH\x02R\rclairDatabase\x88\x01\x01\x12L\n" +
	"\x16notary_server_database\x18\a \x01(\tB\x11\x8a\xa6\x1d\rnotary_serverH\x03R\x14notaryServerDatabase\x88\x01\x01\x12L\n" +
	"\x16notary_signer_database\x18\b \x01(\tB\x11\x8a\xa6\x1d\rnotary_signerH\x04R\x14notarySignerDatabase\x88\x01\x01\x12\x17\n" +
	"\ause_ssl\x18\t \x01(\bR\x06useSslB\a\n" +
	"\x05_portB\x10\n" +
	"\x0e_core_databaseB\x11\n" +
	"\x0f_clair_databaseB\x19\n" +
	"\x17_notary_server_databaseB\x19\n" +
	"\x17_notary_signer_database\"\xdd\x01\n" +
	"!HarborKubernetesManagedPostgresql\x12\xb7\x01\n" +
	"\tcontainer\x18\x01 \x01(\v2i.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainerB.\xaa\xa9\x96\x02)\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x032Gi\x12\r\n" +
	"\x04200m\x12\x05512Mi \x01*\x0420GiR\tcontainer\"\xa3\x05\n" +
	"#HarborKubernetesPostgresqlContainer\x12#\n" +
	"\breplicas\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02(\x01R\breplicas\x12W\n" +
	"\tresources\x18\x02 \x01(\v29.org.project_planton.shared.kubernetes.ContainerResourcesR\tresources\x12K\n" +
	"\x05image\x18\x03 \x01(\v25.org.project_planton.shared.kubernetes.ContainerImageR\x05image\x12/\n" +
	"\x13persistence_enabled\x18\x04 \x01(\bR\x12persistenceEnabled\x12\x1b\n" +
	"\tdisk_size\x18\x05 \x01(\tR\bdiskSize:\xe2\x02\xbaH\xde\x02\x1a\xdb\x02\n" +
	",spec.postgresql.container.disk_size.required\x12IDisk size is required and must match the format if persistence is enabled\x1a\xdf\x01((!this.persistence_enabled && (size(this.disk_size) == 0 || this.disk_size == '')) || (this.persistence_enabled && size(this.disk_size) > 0 && this.disk_size.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')))\"\xef\x03\n" +
	"\x1bHarborKubernetesCacheConfig\x12\x1f\n" +
	"\vis_external\x18\x01 \x01(\bR\n" +
	"isExternal\x12\x8a\x01\n" +
	"\x0eexternal_cache\x18\x02 \x01(\v2c.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesExternalRedisR\rexternalCache\x12\x87\x01\n" +
	"\rmanaged_cache\x18\x03 \x01(\v2b.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedRedisR\fmanagedCache:\x97\x01\xbaH\x93\x01\x1a\x90\x01\n" +
	"\x1cspec.cache.external_required\x12AExternal cache configuration is required when is_external is true\x1a-!this.is_external || has(this.external_cache)\"\xec\x03\n" +
	"\x1dHarborKubernetesExternalRedis\x12\x1a\n" +
	"\x04host\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04host\x12,\n" +
	"\x04port\x18\x02 \x01(\x05B\x13\xbaH\b\x1a\x06\x18\xff\xff\x03 \x00\x8a\xa6\x1d\x046379H\x00R\x04port\x88\x01\x01\x12\x1a\n" +
	"\busername\x18\x03 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x04 \x01(\tR\bpassword\x121\n" +
	"\x0edatabase_index\x18\x05 \x01(\x05B\x05\x8a\xa6\x1d\x010H\x01R\rdatabaseIndex\x88\x01\x01\x12!\n" +
	"\fuse_sentinel\x18\x06 \x01(\bR\vuseSentinel\x12.\n" +
	"\x13sentinel_master_set\x18\a \x01(\tR\x11sentinelMasterSet:\xa6\x01\xbaH\xa2\x01\x1a\x9f\x01\n" +
	"#spec.cache.sentinel_master_required\x12>Sentinel master set name is required when use_sentinel is true\x1a8!this.use_sentinel || size(this.sentinel_master_set) > 0B\a\n" +
	"\x05_portB\x11\n" +
	"\x0f_database_index\"\xd3\x01\n" +
	"\x1cHarborKubernetesManagedRedis\x12\xb2\x01\n" +
	"\tcontainer\x18\x01 \x01(\v2d.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainerB.\xb2\xa9\x96\x02)\b\x01\x12\x1e\n" +
	"\r\n" +
	"\x04500m\x12\x05512Mi\x12\r\n" +
	"\x04100m\x12\x05256Mi \x01*\x038GiR\tcontainer\"\x99\x05\n" +
	"\x1eHarborKubernetesRedisContainer\x12#\n" +
	"\breplicas\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02(\x01R\breplicas\x12W\n" +
	"\tresources\x18\x02 \x01(\v29.org.project_planton.shared.kubernetes.ContainerResourcesR\tresources\x12K\n" +
	"\x05image\x18\x03 \x01(\v25.org.project_planton.shared.kubernetes.ContainerImageR\x05image\x12/\n" +
	"\x13persistence_enabled\x18\x04 \x01(\bR\x12persistenceEnabled\x12\x1b\n" +
	"\tdisk_size\x18\x05 \x01(\tR\bdiskSize:\xdd\x02\xbaH\xd9\x02\x1a\xd6\x02\n" +
	"'spec.redis.container.disk_size.required\x12IDisk size is required and must match the format if persistence is enabled\x1a\xdf\x01((!this.persistence_enabled && (size(this.disk_size) == 0 || this.disk_size == '')) || (this.persistence_enabled && size(this.disk_size) > 0 && this.disk_size.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')))\"\xf1\n" +
	"\n" +
	"\x1dHarborKubernetesStorageConfig\x12}\n" +
	"\x04type\x18\x01 \x01(\x0e2a.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageTypeB\x06\xbaH\x03\xc8\x01\x01R\x04type\x12o\n" +
	"\x02s3\x18\x02 \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesS3StorageR\x02s3\x12r\n" +
	"\x03gcs\x18\x03 \x01(\v2`.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesGcsStorageR\x03gcs\x12x\n" +
	"\x05azure\x18\x04 \x01(\v2b.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesAzureStorageR\x05azure\x12r\n" +
	"\x03oss\x18\x05 \x01(\v2`.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesOssStorageR\x03oss\x12\x87\x01\n" +
	"\n" +
	"filesystem\x18\x06 \x01(\v2g.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesFilesystemStorageR\n" +
	"filesystem:\xf3\x04\xbaH\xef\x04\x1ap\n" +
	"\x18spec.storage.s3_required\x124S3 configuration is required when storage type is s3\x1a\x1ethis.type != 2 || has(this.s3)\x1at\n" +
	"\x19spec.storage.gcs_required\x126GCS configuration is required when storage type is gcs\x1a\x1fthis.type != 3 || has(this.gcs)\x1a|\n" +
	"\x1bspec.storage.azure_required\x12:Azure configuration is required when storage type is azure\x1a!this.type != 4 || has(this.azure)\x1at\n" +
	"\x19spec.storage.oss_required\x126OSS configuration is required when storage type is oss\x1a\x1fthis.type != 5 || has(this.oss)\x1a\x90\x01\n" +
	" spec.storage.filesystem_required\x12DFilesystem configuration is required when storage type is filesystem\x1a&this.type != 1 || has(this.filesystem)\"\xce\x02\n" +
	"\x19HarborKubernetesS3Storage\x12\x1e\n" +
	"\x06bucket\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06bucket\x12\x1e\n" +
	"\x06region\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06region\x12%\n" +
	"\n" +
	"access_key\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\taccessKey\x12%\n" +
	"\n" +
	"secret_key\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\tsecretKey\x12'\n" +
	"\x0fregion_endpoint\x18\x05 \x01(\bR\x0eregionEndpoint\x12\x18\n" +
	"\aencrypt\x18\x06 \x01(\bR\aencrypt\x12\x16\n" +
	"\x06secure\x18\a \x01(\bR\x06secure\x12%\n" +
	"\x0eroot_directory\x18\b \x01(\tR\rrootDirectory\x12!\n" +
	"\fendpoint_url\x18\t \x01(\tR\vendpointUrl\"\xc6\x01\n" +
	"\x1aHarborKubernetesGcsStorage\x12\x1e\n" +
	"\x06bucket\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06bucket\x12!\n" +
	"\bkey_data\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\akeyData\x12%\n" +
	"\x0eroot_directory\x18\x03 \x01(\tR\rrootDirectory\x12/\n" +
	"\n" +
	"chunk_size\x18\x04 \x01(\x05B\v\x8a\xa6\x1d\a5242880H\x00R\tchunkSize\x88\x01\x01B\r\n" +
	"\v_chunk_size\"\xbf\x01\n" +
	"\x1cHarborKubernetesAzureStorage\x12)\n" +
	"\faccount_name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vaccountName\x12'\n" +
	"\vaccount_key\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"accountKey\x12$\n" +
	"\tcontainer\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\tcontainer\x12%\n" +
	"\x0eroot_directory\x18\x04 \x01(\tR\rrootDirectory\"\xff\x01\n" +
	"\x1aHarborKubernetesOssStorage\x12\x1e\n" +
	"\x06bucket\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06bucket\x12\"\n" +
	"\bendpoint\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bendpoint\x12*\n" +
	"\raccess_key_id\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vaccessKeyId\x122\n" +
	"\x11access_key_secret\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x0faccessKeySecret\x12%\n" +
	"\x0eroot_directory\x18\x05 \x01(\tR\rrootDirectory\x12\x16\n" +
	"\x06secure\x18\x06 \x01(\bR\x06secure\"\xa5\x02\n" +
	"!HarborKubernetesFilesystemStorage\x12\xda\x01\n" +
	"\tdisk_size\x18\x01 \x01(\tB\xbc\x01\xbaH\xb8\x01\xba\x01\xb4\x01\n" +
	"*spec.storage.filesystem.disk_size.required\x12/Disk size is required and must match the format\x1aUsize(this) > 0 && this.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')R\bdiskSize\x12#\n" +
	"\rstorage_class\x18\x02 \x01(\tR\fstorageClass\"\x93\x02\n" +
	"\x17HarborKubernetesIngress\x12y\n" +
	"\x04core\x18\x01 \x01(\v2e.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngressEndpointR\x04core\x12}\n" +
	"\x06notary\x18\x02 \x01(\v2e.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngressEndpointR\x06notary\"\xd6\x01\n" +
	"\x1fHarborKubernetesIngressEndpoint\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname:}\xbaHz\x1ax\n" +
	"\x1espec.ingress.hostname.required\x12,hostname is required when ingress is enabled\x1a(!this.enabled || size(this.hostname) > 0*\x82\x01\n" +
	"\x1bHarborKubernetesStorageType\x12.\n" +
	"*harbor_kubernetes_storage_type_unspecified\x10\x00\x12\x0e\n" +
	"\n" +
	"filesystem\x10\x01\x12\x06\n" +
	"\x02s3\x10\x02\x12\a\n" +
	"\x03gcs\x10\x03\x12\t\n" +
	"\x05azure\x10\x04\x12\a\n" +
	"\x03oss\x10\x05:\xc3\x01\n" +
	"\x1ddefault_harbor_core_container\x12\x1d.google.protobuf.FieldOptions\x18\x91\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerR\x1adefaultHarborCoreContainer:\xc7\x01\n" +
	"\x1fdefault_harbor_portal_container\x12\x1d.google.protobuf.FieldOptions\x18\x92\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerR\x1cdefaultHarborPortalContainer:\xcb\x01\n" +
	"!default_harbor_registry_container\x12\x1d.google.protobuf.FieldOptions\x18\x93\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerR\x1edefaultHarborRegistryContainer:\xcf\x01\n" +
	"#default_harbor_jobservice_container\x12\x1d.google.protobuf.FieldOptions\x18\x94\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainerR defaultHarborJobserviceContainer:\xcc\x01\n" +
	"\x1cdefault_postgresql_container\x12\x1d.google.protobuf.FieldOptions\x18\x95\xe5\" \x01(\v2i.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainerR\x1adefaultPostgresqlContainer:\xbd\x01\n" +
	"\x17default_redis_container\x12\x1d.google.protobuf.FieldOptions\x18\x96\xe5\" \x01(\v2d.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainerR\x15defaultRedisContainerB\x94\x04\n" +
	"Hcom.org.project_planton.provider.kubernetes.workload.harborkubernetes.v1B\tSpecProtoP\x01Z\x87\x01github.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes/workload/harborkubernetes/v1;harborkubernetesv1\xa2\x02\x06OPPKWH\xaa\x02COrg.ProjectPlanton.Provider.Kubernetes.Workload.Harborkubernetes.V1\xca\x02COrg\\ProjectPlanton\\Provider\\Kubernetes\\Workload\\Harborkubernetes\\V1\xe2\x02OOrg\\ProjectPlanton\\Provider\\Kubernetes\\Workload\\Harborkubernetes\\V1\\GPBMetadata\xea\x02IOrg::ProjectPlanton::Provider::Kubernetes::Workload::Harborkubernetes::V1b\x06proto3"

var (
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescData []byte
)

func file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDesc)))
	})
	return file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDescData
}

var file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_goTypes = []any{
	(HarborKubernetesStorageType)(0),            // 0: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageType
	(*HarborKubernetesSpec)(nil),                // 1: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec
	(*HarborKubernetesContainer)(nil),           // 2: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	(*HarborKubernetesDatabaseConfig)(nil),      // 3: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesDatabaseConfig
	(*HarborKubernetesExternalPostgresql)(nil),  // 4: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesExternalPostgresql
	(*HarborKubernetesManagedPostgresql)(nil),   // 5: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedPostgresql
	(*HarborKubernetesPostgresqlContainer)(nil), // 6: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainer
	(*HarborKubernetesCacheConfig)(nil),         // 7: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesCacheConfig
	(*HarborKubernetesExternalRedis)(nil),       // 8: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesExternalRedis
	(*HarborKubernetesManagedRedis)(nil),        // 9: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedRedis
	(*HarborKubernetesRedisContainer)(nil),      // 10: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainer
	(*HarborKubernetesStorageConfig)(nil),       // 11: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig
	(*HarborKubernetesS3Storage)(nil),           // 12: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesS3Storage
	(*HarborKubernetesGcsStorage)(nil),          // 13: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesGcsStorage
	(*HarborKubernetesAzureStorage)(nil),        // 14: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesAzureStorage
	(*HarborKubernetesOssStorage)(nil),          // 15: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesOssStorage
	(*HarborKubernetesFilesystemStorage)(nil),   // 16: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesFilesystemStorage
	(*HarborKubernetesIngress)(nil),             // 17: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngress
	(*HarborKubernetesIngressEndpoint)(nil),     // 18: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngressEndpoint
	nil,                                         // 19: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.HelmValuesEntry
	(*kubernetes.ContainerResources)(nil),       // 20: org.project_planton.shared.kubernetes.ContainerResources
	(*kubernetes.ContainerImage)(nil),           // 21: org.project_planton.shared.kubernetes.ContainerImage
	(*descriptorpb.FieldOptions)(nil),           // 22: google.protobuf.FieldOptions
}
var file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_depIdxs = []int32{
	2,  // 0: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.core_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	2,  // 1: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.portal_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	2,  // 2: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.registry_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	2,  // 3: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.jobservice_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	3,  // 4: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.database:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesDatabaseConfig
	7,  // 5: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.cache:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesCacheConfig
	11, // 6: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.storage:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig
	17, // 7: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.ingress:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngress
	19, // 8: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.helm_values:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesSpec.HelmValuesEntry
	20, // 9: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer.resources:type_name -> org.project_planton.shared.kubernetes.ContainerResources
	21, // 10: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer.image:type_name -> org.project_planton.shared.kubernetes.ContainerImage
	4,  // 11: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesDatabaseConfig.external_database:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesExternalPostgresql
	5,  // 12: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesDatabaseConfig.managed_database:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedPostgresql
	6,  // 13: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedPostgresql.container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainer
	20, // 14: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainer.resources:type_name -> org.project_planton.shared.kubernetes.ContainerResources
	21, // 15: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainer.image:type_name -> org.project_planton.shared.kubernetes.ContainerImage
	8,  // 16: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesCacheConfig.external_cache:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesExternalRedis
	9,  // 17: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesCacheConfig.managed_cache:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedRedis
	10, // 18: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesManagedRedis.container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainer
	20, // 19: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainer.resources:type_name -> org.project_planton.shared.kubernetes.ContainerResources
	21, // 20: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainer.image:type_name -> org.project_planton.shared.kubernetes.ContainerImage
	0,  // 21: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig.type:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageType
	12, // 22: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig.s3:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesS3Storage
	13, // 23: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig.gcs:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesGcsStorage
	14, // 24: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig.azure:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesAzureStorage
	15, // 25: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig.oss:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesOssStorage
	16, // 26: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesStorageConfig.filesystem:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesFilesystemStorage
	18, // 27: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngress.core:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngressEndpoint
	18, // 28: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngress.notary:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesIngressEndpoint
	22, // 29: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_core_container:extendee -> google.protobuf.FieldOptions
	22, // 30: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_portal_container:extendee -> google.protobuf.FieldOptions
	22, // 31: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_registry_container:extendee -> google.protobuf.FieldOptions
	22, // 32: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_jobservice_container:extendee -> google.protobuf.FieldOptions
	22, // 33: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_postgresql_container:extendee -> google.protobuf.FieldOptions
	22, // 34: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_redis_container:extendee -> google.protobuf.FieldOptions
	2,  // 35: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_core_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	2,  // 36: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_portal_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	2,  // 37: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_registry_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	2,  // 38: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_harbor_jobservice_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesContainer
	6,  // 39: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_postgresql_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesPostgresqlContainer
	10, // 40: org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.default_redis_container:type_name -> org.project_planton.provider.kubernetes.workload.harborkubernetes.v1.HarborKubernetesRedisContainer
	41, // [41:41] is the sub-list for method output_type
	41, // [41:41] is the sub-list for method input_type
	35, // [35:41] is the sub-list for extension type_name
	29, // [29:35] is the sub-list for extension extendee
	0,  // [0:29] is the sub-list for field type_name
}

func init() {
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_init()
}
func file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_init() {
	if File_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto != nil {
		return
	}
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[3].OneofWrappers = []any{}
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[7].OneofWrappers = []any{}
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes[12].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   19,
			NumExtensions: 6,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_depIdxs,
		EnumInfos:         file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_enumTypes,
		MessageInfos:      file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_msgTypes,
		ExtensionInfos:    file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_extTypes,
	}.Build()
	File_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto = out.File
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_goTypes = nil
	file_org_project_planton_provider_kubernetes_workload_harborkubernetes_v1_spec_proto_depIdxs = nil
}
