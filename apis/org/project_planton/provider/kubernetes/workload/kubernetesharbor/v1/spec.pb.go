// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto

package kubernetesharborv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	kubernetes "github.com/project-planton/project-planton/apis/org/project_planton/shared/kubernetes"
	_ "github.com/project-planton/project-planton/apis/org/project_planton/shared/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// **KubernetesHarborStorageType** enumerates the supported storage backends for Harbor artifacts.
type KubernetesHarborStorageType int32

const (
	// unspecified should not be used
	KubernetesHarborStorageType_kubernetes_harbor_storage_type_unspecified KubernetesHarborStorageType = 0
	// Filesystem storage (PVC) - suitable for development only, not recommended for production HA
	KubernetesHarborStorageType_filesystem KubernetesHarborStorageType = 1
	// AWS S3 or S3-compatible object storage
	KubernetesHarborStorageType_s3 KubernetesHarborStorageType = 2
	// Google Cloud Storage
	KubernetesHarborStorageType_gcs KubernetesHarborStorageType = 3
	// Azure Blob Storage
	KubernetesHarborStorageType_azure KubernetesHarborStorageType = 4
	// Alibaba Cloud OSS
	KubernetesHarborStorageType_oss KubernetesHarborStorageType = 5
)

// Enum value maps for KubernetesHarborStorageType.
var (
	KubernetesHarborStorageType_name = map[int32]string{
		0: "kubernetes_harbor_storage_type_unspecified",
		1: "filesystem",
		2: "s3",
		3: "gcs",
		4: "azure",
		5: "oss",
	}
	KubernetesHarborStorageType_value = map[string]int32{
		"kubernetes_harbor_storage_type_unspecified": 0,
		"filesystem": 1,
		"s3":         2,
		"gcs":        3,
		"azure":      4,
		"oss":        5,
	}
)

func (x KubernetesHarborStorageType) Enum() *KubernetesHarborStorageType {
	p := new(KubernetesHarborStorageType)
	*p = x
	return p
}

func (x KubernetesHarborStorageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KubernetesHarborStorageType) Descriptor() protoreflect.EnumDescriptor {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_enumTypes[0].Descriptor()
}

func (KubernetesHarborStorageType) Type() protoreflect.EnumType {
	return &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_enumTypes[0]
}

func (x KubernetesHarborStorageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KubernetesHarborStorageType.Descriptor instead.
func (KubernetesHarborStorageType) EnumDescriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{0}
}

// *
// **KubernetesHarborSpec** defines the configuration for deploying Harbor cloud-native registry on Kubernetes.
// Harbor is an open source registry that secures artifacts with policies and role-based access control,
// ensures images are scanned and free from vulnerabilities, and signs images as trusted.
// This spec supports both self-managed and external PostgreSQL and Redis configurations, enabling flexible
// deployment patterns from simple single-node installations to production-grade high-availability clusters.
type KubernetesHarborSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The container specifications for Harbor Core (API server, authentication, webhook).
	CoreContainer *KubernetesHarborContainer `protobuf:"bytes,1,opt,name=core_container,json=coreContainer,proto3" json:"core_container,omitempty"`
	// The container specifications for Harbor Portal (web UI).
	PortalContainer *KubernetesHarborContainer `protobuf:"bytes,2,opt,name=portal_container,json=portalContainer,proto3" json:"portal_container,omitempty"`
	// The container specifications for Harbor Registry (Docker/OCI registry backend).
	RegistryContainer *KubernetesHarborContainer `protobuf:"bytes,3,opt,name=registry_container,json=registryContainer,proto3" json:"registry_container,omitempty"`
	// The container specifications for Harbor Jobservice (background job execution).
	JobserviceContainer *KubernetesHarborContainer `protobuf:"bytes,4,opt,name=jobservice_container,json=jobserviceContainer,proto3" json:"jobservice_container,omitempty"`
	// The database configuration for Harbor, supporting both self-managed and external PostgreSQL.
	Database *KubernetesHarborDatabaseConfig `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	// The cache configuration for Harbor, supporting both self-managed and external Redis.
	Cache *KubernetesHarborCacheConfig `protobuf:"bytes,6,opt,name=cache,proto3" json:"cache,omitempty"`
	// The object storage configuration for Harbor artifact storage.
	Storage *KubernetesHarborStorageConfig `protobuf:"bytes,7,opt,name=storage,proto3" json:"storage,omitempty"`
	// The ingress configuration for Harbor UI and registry endpoints.
	Ingress *KubernetesHarborIngress `protobuf:"bytes,8,opt,name=ingress,proto3" json:"ingress,omitempty"`
	// *
	// A map of key-value pairs that provide additional customization options for the Harbor Helm chart.
	// These values allow for further refinement of the deployment, such as enabling Trivy scanner,
	// configuring Notary for image signing, or customizing authentication providers.
	// For detailed information on available options, refer to the Helm chart documentation at:
	// https://github.com/goharbor/harbor-helm
	HelmValues    map[string]string `protobuf:"bytes,9,rep,name=helm_values,json=helmValues,proto3" json:"helm_values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborSpec) Reset() {
	*x = KubernetesHarborSpec{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborSpec) ProtoMessage() {}

func (x *KubernetesHarborSpec) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborSpec.ProtoReflect.Descriptor instead.
func (*KubernetesHarborSpec) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *KubernetesHarborSpec) GetCoreContainer() *KubernetesHarborContainer {
	if x != nil {
		return x.CoreContainer
	}
	return nil
}

func (x *KubernetesHarborSpec) GetPortalContainer() *KubernetesHarborContainer {
	if x != nil {
		return x.PortalContainer
	}
	return nil
}

func (x *KubernetesHarborSpec) GetRegistryContainer() *KubernetesHarborContainer {
	if x != nil {
		return x.RegistryContainer
	}
	return nil
}

func (x *KubernetesHarborSpec) GetJobserviceContainer() *KubernetesHarborContainer {
	if x != nil {
		return x.JobserviceContainer
	}
	return nil
}

func (x *KubernetesHarborSpec) GetDatabase() *KubernetesHarborDatabaseConfig {
	if x != nil {
		return x.Database
	}
	return nil
}

func (x *KubernetesHarborSpec) GetCache() *KubernetesHarborCacheConfig {
	if x != nil {
		return x.Cache
	}
	return nil
}

func (x *KubernetesHarborSpec) GetStorage() *KubernetesHarborStorageConfig {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *KubernetesHarborSpec) GetIngress() *KubernetesHarborIngress {
	if x != nil {
		return x.Ingress
	}
	return nil
}

func (x *KubernetesHarborSpec) GetHelmValues() map[string]string {
	if x != nil {
		return x.HelmValues
	}
	return nil
}

// *
// **KubernetesHarborContainer** specifies the container configuration for various Harbor components.
// It includes settings such as the number of replicas, container image, and resource allocations.
type KubernetesHarborContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of pods to deploy for this component.
	Replicas int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	// The CPU and memory resources allocated to the container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// The container image configuration (repository and tag).
	Image         *kubernetes.ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborContainer) Reset() {
	*x = KubernetesHarborContainer{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborContainer) ProtoMessage() {}

func (x *KubernetesHarborContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborContainer.ProtoReflect.Descriptor instead.
func (*KubernetesHarborContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *KubernetesHarborContainer) GetReplicas() int32 {
	if x != nil {
		return x.Replicas
	}
	return 0
}

func (x *KubernetesHarborContainer) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *KubernetesHarborContainer) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

// *
// **KubernetesHarborDatabaseConfig** defines the PostgreSQL database configuration for Harbor.
// It supports two deployment modes:
// 1. Self-managed: Deploy PostgreSQL within the Kubernetes cluster (default).
// 2. External: Connect to an existing external PostgreSQL instance.
type KubernetesHarborDatabaseConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Flag to enable using an external PostgreSQL database.
	// When false (default), Harbor will deploy and manage its own PostgreSQL instance.
	// When true, the external_database field must be configured.
	IsExternal bool `protobuf:"varint,1,opt,name=is_external,json=isExternal,proto3" json:"is_external,omitempty"`
	// *
	// External PostgreSQL database connection details.
	// This field is required when is_external is true and ignored when false.
	ExternalDatabase *KubernetesHarborExternalPostgresql `protobuf:"bytes,2,opt,name=external_database,json=externalDatabase,proto3" json:"external_database,omitempty"`
	// *
	// Self-managed PostgreSQL configuration.
	// This field is used when is_external is false and configures the in-cluster PostgreSQL deployment.
	ManagedDatabase *KubernetesHarborManagedPostgresql `protobuf:"bytes,3,opt,name=managed_database,json=managedDatabase,proto3" json:"managed_database,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *KubernetesHarborDatabaseConfig) Reset() {
	*x = KubernetesHarborDatabaseConfig{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborDatabaseConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborDatabaseConfig) ProtoMessage() {}

func (x *KubernetesHarborDatabaseConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborDatabaseConfig.ProtoReflect.Descriptor instead.
func (*KubernetesHarborDatabaseConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *KubernetesHarborDatabaseConfig) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *KubernetesHarborDatabaseConfig) GetExternalDatabase() *KubernetesHarborExternalPostgresql {
	if x != nil {
		return x.ExternalDatabase
	}
	return nil
}

func (x *KubernetesHarborDatabaseConfig) GetManagedDatabase() *KubernetesHarborManagedPostgresql {
	if x != nil {
		return x.ManagedDatabase
	}
	return nil
}

// *
// **KubernetesHarborExternalPostgresql** defines connection parameters for an external PostgreSQL instance.
// This allows Harbor to use a pre-existing PostgreSQL database instead of deploying one within the cluster.
type KubernetesHarborExternalPostgresql struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hostname or endpoint of the external PostgreSQL instance.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The port for PostgreSQL (default is 5432).
	Port *int32 `protobuf:"varint,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
	// The username for authenticating to PostgreSQL.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// The password for authenticating to PostgreSQL.
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// The name of the database for Harbor Core (default is "registry").
	CoreDatabase *string `protobuf:"bytes,5,opt,name=core_database,json=coreDatabase,proto3,oneof" json:"core_database,omitempty"`
	// The name of the database for Clair (vulnerability scanner).
	ClairDatabase *string `protobuf:"bytes,6,opt,name=clair_database,json=clairDatabase,proto3,oneof" json:"clair_database,omitempty"`
	// The name of the database for Notary Server (image signing).
	NotaryServerDatabase *string `protobuf:"bytes,7,opt,name=notary_server_database,json=notaryServerDatabase,proto3,oneof" json:"notary_server_database,omitempty"`
	// The name of the database for Notary Signer (image signing).
	NotarySignerDatabase *string `protobuf:"bytes,8,opt,name=notary_signer_database,json=notarySignerDatabase,proto3,oneof" json:"notary_signer_database,omitempty"`
	// Whether to use SSL/TLS connection to PostgreSQL.
	UseSsl        bool `protobuf:"varint,9,opt,name=use_ssl,json=useSsl,proto3" json:"use_ssl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborExternalPostgresql) Reset() {
	*x = KubernetesHarborExternalPostgresql{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborExternalPostgresql) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborExternalPostgresql) ProtoMessage() {}

func (x *KubernetesHarborExternalPostgresql) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborExternalPostgresql.ProtoReflect.Descriptor instead.
func (*KubernetesHarborExternalPostgresql) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *KubernetesHarborExternalPostgresql) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *KubernetesHarborExternalPostgresql) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetCoreDatabase() string {
	if x != nil && x.CoreDatabase != nil {
		return *x.CoreDatabase
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetClairDatabase() string {
	if x != nil && x.ClairDatabase != nil {
		return *x.ClairDatabase
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetNotaryServerDatabase() string {
	if x != nil && x.NotaryServerDatabase != nil {
		return *x.NotaryServerDatabase
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetNotarySignerDatabase() string {
	if x != nil && x.NotarySignerDatabase != nil {
		return *x.NotarySignerDatabase
	}
	return ""
}

func (x *KubernetesHarborExternalPostgresql) GetUseSsl() bool {
	if x != nil {
		return x.UseSsl
	}
	return false
}

// *
// **KubernetesHarborManagedPostgresql** defines configuration for a self-managed PostgreSQL deployment.
// This supports simple single-node deployments suitable for development and testing.
type KubernetesHarborManagedPostgresql struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The container specifications for PostgreSQL.
	Container     *KubernetesHarborPostgresqlContainer `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborManagedPostgresql) Reset() {
	*x = KubernetesHarborManagedPostgresql{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborManagedPostgresql) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborManagedPostgresql) ProtoMessage() {}

func (x *KubernetesHarborManagedPostgresql) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborManagedPostgresql.ProtoReflect.Descriptor instead.
func (*KubernetesHarborManagedPostgresql) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{4}
}

func (x *KubernetesHarborManagedPostgresql) GetContainer() *KubernetesHarborPostgresqlContainer {
	if x != nil {
		return x.Container
	}
	return nil
}

// *
// **KubernetesHarborPostgresqlContainer** specifies the container configuration for PostgreSQL.
// It includes replica count, resource allocations, and persistence settings.
type KubernetesHarborPostgresqlContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of PostgreSQL pods to deploy.
	Replicas int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	// The CPU and memory resources allocated to the PostgreSQL container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// The container image configuration for PostgreSQL.
	Image *kubernetes.ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// *
	// Flag to enable or disable data persistence for PostgreSQL.
	// When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	// Defaults to true.
	PersistenceEnabled bool `protobuf:"varint,4,opt,name=persistence_enabled,json=persistenceEnabled,proto3" json:"persistence_enabled,omitempty"`
	// *
	// The size of the persistent volume attached to each PostgreSQL pod (e.g., "20Gi").
	// This attribute is ignored when persistence is not enabled.
	// Note: This value cannot be modified after creation due to Kubernetes StatefulSet limitations.
	DiskSize      string `protobuf:"bytes,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborPostgresqlContainer) Reset() {
	*x = KubernetesHarborPostgresqlContainer{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborPostgresqlContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborPostgresqlContainer) ProtoMessage() {}

func (x *KubernetesHarborPostgresqlContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborPostgresqlContainer.ProtoReflect.Descriptor instead.
func (*KubernetesHarborPostgresqlContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{5}
}

func (x *KubernetesHarborPostgresqlContainer) GetReplicas() int32 {
	if x != nil {
		return x.Replicas
	}
	return 0
}

func (x *KubernetesHarborPostgresqlContainer) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *KubernetesHarborPostgresqlContainer) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *KubernetesHarborPostgresqlContainer) GetPersistenceEnabled() bool {
	if x != nil {
		return x.PersistenceEnabled
	}
	return false
}

func (x *KubernetesHarborPostgresqlContainer) GetDiskSize() string {
	if x != nil {
		return x.DiskSize
	}
	return ""
}

// *
// **KubernetesHarborCacheConfig** defines the Redis cache configuration for Harbor.
// It supports two deployment modes:
// 1. Self-managed: Deploy Redis within the Kubernetes cluster (default).
// 2. External: Connect to an existing external Redis instance.
type KubernetesHarborCacheConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Flag to enable using an external Redis cache.
	// When false (default), Harbor will deploy and manage its own Redis instance.
	// When true, the external_cache field must be configured.
	IsExternal bool `protobuf:"varint,1,opt,name=is_external,json=isExternal,proto3" json:"is_external,omitempty"`
	// *
	// External Redis cache connection details.
	// This field is required when is_external is true and ignored when false.
	ExternalCache *KubernetesHarborExternalRedis `protobuf:"bytes,2,opt,name=external_cache,json=externalCache,proto3" json:"external_cache,omitempty"`
	// *
	// Self-managed Redis configuration.
	// This field is used when is_external is false and configures the in-cluster Redis deployment.
	ManagedCache  *KubernetesHarborManagedRedis `protobuf:"bytes,3,opt,name=managed_cache,json=managedCache,proto3" json:"managed_cache,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborCacheConfig) Reset() {
	*x = KubernetesHarborCacheConfig{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborCacheConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborCacheConfig) ProtoMessage() {}

func (x *KubernetesHarborCacheConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborCacheConfig.ProtoReflect.Descriptor instead.
func (*KubernetesHarborCacheConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{6}
}

func (x *KubernetesHarborCacheConfig) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *KubernetesHarborCacheConfig) GetExternalCache() *KubernetesHarborExternalRedis {
	if x != nil {
		return x.ExternalCache
	}
	return nil
}

func (x *KubernetesHarborCacheConfig) GetManagedCache() *KubernetesHarborManagedRedis {
	if x != nil {
		return x.ManagedCache
	}
	return nil
}

// *
// **KubernetesHarborExternalRedis** defines connection parameters for an external Redis instance.
// This allows Harbor to use a pre-existing Redis cache instead of deploying one within the cluster.
type KubernetesHarborExternalRedis struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hostname or endpoint of the external Redis instance (e.g., "redis.example.com:6379").
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The port for Redis (default is 6379).
	Port *int32 `protobuf:"varint,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
	// The username for authenticating to Redis (if ACLs are enabled).
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// The password for authenticating to Redis.
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// The Redis database index to use (default is 0).
	DatabaseIndex *int32 `protobuf:"varint,5,opt,name=database_index,json=databaseIndex,proto3,oneof" json:"database_index,omitempty"`
	// Whether to use Sentinel for high availability.
	UseSentinel bool `protobuf:"varint,6,opt,name=use_sentinel,json=useSentinel,proto3" json:"use_sentinel,omitempty"`
	// The Sentinel master set name (required if use_sentinel is true).
	SentinelMasterSet string `protobuf:"bytes,7,opt,name=sentinel_master_set,json=sentinelMasterSet,proto3" json:"sentinel_master_set,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *KubernetesHarborExternalRedis) Reset() {
	*x = KubernetesHarborExternalRedis{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborExternalRedis) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborExternalRedis) ProtoMessage() {}

func (x *KubernetesHarborExternalRedis) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborExternalRedis.ProtoReflect.Descriptor instead.
func (*KubernetesHarborExternalRedis) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{7}
}

func (x *KubernetesHarborExternalRedis) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *KubernetesHarborExternalRedis) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *KubernetesHarborExternalRedis) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *KubernetesHarborExternalRedis) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *KubernetesHarborExternalRedis) GetDatabaseIndex() int32 {
	if x != nil && x.DatabaseIndex != nil {
		return *x.DatabaseIndex
	}
	return 0
}

func (x *KubernetesHarborExternalRedis) GetUseSentinel() bool {
	if x != nil {
		return x.UseSentinel
	}
	return false
}

func (x *KubernetesHarborExternalRedis) GetSentinelMasterSet() string {
	if x != nil {
		return x.SentinelMasterSet
	}
	return ""
}

// *
// **KubernetesHarborManagedRedis** defines configuration for a self-managed Redis deployment.
// This supports simple single-node deployments suitable for development and testing.
type KubernetesHarborManagedRedis struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The container specifications for Redis.
	Container     *KubernetesHarborRedisContainer `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborManagedRedis) Reset() {
	*x = KubernetesHarborManagedRedis{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborManagedRedis) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborManagedRedis) ProtoMessage() {}

func (x *KubernetesHarborManagedRedis) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborManagedRedis.ProtoReflect.Descriptor instead.
func (*KubernetesHarborManagedRedis) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{8}
}

func (x *KubernetesHarborManagedRedis) GetContainer() *KubernetesHarborRedisContainer {
	if x != nil {
		return x.Container
	}
	return nil
}

// *
// **KubernetesHarborRedisContainer** specifies the container configuration for Redis.
// It includes replica count, resource allocations, and persistence settings.
type KubernetesHarborRedisContainer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of Redis pods to deploy.
	Replicas int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	// The CPU and memory resources allocated to the Redis container.
	Resources *kubernetes.ContainerResources `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// The container image configuration for Redis.
	Image *kubernetes.ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// *
	// Flag to enable or disable data persistence for Redis.
	// When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	// Defaults to true.
	PersistenceEnabled bool `protobuf:"varint,4,opt,name=persistence_enabled,json=persistenceEnabled,proto3" json:"persistence_enabled,omitempty"`
	// *
	// The size of the persistent volume attached to each Redis pod (e.g., "8Gi").
	// This attribute is ignored when persistence is not enabled.
	DiskSize      string `protobuf:"bytes,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborRedisContainer) Reset() {
	*x = KubernetesHarborRedisContainer{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborRedisContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborRedisContainer) ProtoMessage() {}

func (x *KubernetesHarborRedisContainer) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborRedisContainer.ProtoReflect.Descriptor instead.
func (*KubernetesHarborRedisContainer) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{9}
}

func (x *KubernetesHarborRedisContainer) GetReplicas() int32 {
	if x != nil {
		return x.Replicas
	}
	return 0
}

func (x *KubernetesHarborRedisContainer) GetResources() *kubernetes.ContainerResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *KubernetesHarborRedisContainer) GetImage() *kubernetes.ContainerImage {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *KubernetesHarborRedisContainer) GetPersistenceEnabled() bool {
	if x != nil {
		return x.PersistenceEnabled
	}
	return false
}

func (x *KubernetesHarborRedisContainer) GetDiskSize() string {
	if x != nil {
		return x.DiskSize
	}
	return ""
}

// *
// **KubernetesHarborStorageConfig** defines the storage configuration for Harbor artifacts.
// For production high-availability deployments, external object storage (S3, GCS, Azure) is required.
type KubernetesHarborStorageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of storage backend to use.
	Type KubernetesHarborStorageType `protobuf:"varint,1,opt,name=type,proto3,enum=org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageType" json:"type,omitempty"`
	// S3-compatible storage configuration (required when type is s3).
	S3 *KubernetesHarborS3Storage `protobuf:"bytes,2,opt,name=s3,proto3" json:"s3,omitempty"`
	// Google Cloud Storage configuration (required when type is gcs).
	Gcs *KubernetesHarborGcsStorage `protobuf:"bytes,3,opt,name=gcs,proto3" json:"gcs,omitempty"`
	// Azure Blob Storage configuration (required when type is azure).
	Azure *KubernetesHarborAzureStorage `protobuf:"bytes,4,opt,name=azure,proto3" json:"azure,omitempty"`
	// Alibaba Cloud OSS configuration (required when type is oss).
	Oss *KubernetesHarborOssStorage `protobuf:"bytes,5,opt,name=oss,proto3" json:"oss,omitempty"`
	// Filesystem storage configuration (required when type is filesystem).
	Filesystem    *KubernetesHarborFilesystemStorage `protobuf:"bytes,6,opt,name=filesystem,proto3" json:"filesystem,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborStorageConfig) Reset() {
	*x = KubernetesHarborStorageConfig{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborStorageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborStorageConfig) ProtoMessage() {}

func (x *KubernetesHarborStorageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborStorageConfig.ProtoReflect.Descriptor instead.
func (*KubernetesHarborStorageConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{10}
}

func (x *KubernetesHarborStorageConfig) GetType() KubernetesHarborStorageType {
	if x != nil {
		return x.Type
	}
	return KubernetesHarborStorageType_kubernetes_harbor_storage_type_unspecified
}

func (x *KubernetesHarborStorageConfig) GetS3() *KubernetesHarborS3Storage {
	if x != nil {
		return x.S3
	}
	return nil
}

func (x *KubernetesHarborStorageConfig) GetGcs() *KubernetesHarborGcsStorage {
	if x != nil {
		return x.Gcs
	}
	return nil
}

func (x *KubernetesHarborStorageConfig) GetAzure() *KubernetesHarborAzureStorage {
	if x != nil {
		return x.Azure
	}
	return nil
}

func (x *KubernetesHarborStorageConfig) GetOss() *KubernetesHarborOssStorage {
	if x != nil {
		return x.Oss
	}
	return nil
}

func (x *KubernetesHarborStorageConfig) GetFilesystem() *KubernetesHarborFilesystemStorage {
	if x != nil {
		return x.Filesystem
	}
	return nil
}

// *
// **KubernetesHarborS3Storage** defines S3-compatible object storage configuration.
type KubernetesHarborS3Storage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The S3 bucket name.
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// The AWS region (e.g., "us-west-2").
	Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	// The AWS access key ID.
	AccessKey string `protobuf:"bytes,3,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	// The AWS secret access key.
	SecretKey string `protobuf:"bytes,4,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	// Whether to use regional endpoint (default is false for global endpoint).
	RegionEndpoint bool `protobuf:"varint,5,opt,name=region_endpoint,json=regionEndpoint,proto3" json:"region_endpoint,omitempty"`
	// Whether to encrypt objects using server-side encryption.
	Encrypt bool `protobuf:"varint,6,opt,name=encrypt,proto3" json:"encrypt,omitempty"`
	// Whether to use secure (HTTPS) connection.
	Secure bool `protobuf:"varint,7,opt,name=secure,proto3" json:"secure,omitempty"`
	// The root directory path within the bucket.
	RootDirectory string `protobuf:"bytes,8,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	// Custom S3 endpoint URL (for S3-compatible services like MinIO).
	EndpointUrl   string `protobuf:"bytes,9,opt,name=endpoint_url,json=endpointUrl,proto3" json:"endpoint_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborS3Storage) Reset() {
	*x = KubernetesHarborS3Storage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborS3Storage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborS3Storage) ProtoMessage() {}

func (x *KubernetesHarborS3Storage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborS3Storage.ProtoReflect.Descriptor instead.
func (*KubernetesHarborS3Storage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{11}
}

func (x *KubernetesHarborS3Storage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *KubernetesHarborS3Storage) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *KubernetesHarborS3Storage) GetAccessKey() string {
	if x != nil {
		return x.AccessKey
	}
	return ""
}

func (x *KubernetesHarborS3Storage) GetSecretKey() string {
	if x != nil {
		return x.SecretKey
	}
	return ""
}

func (x *KubernetesHarborS3Storage) GetRegionEndpoint() bool {
	if x != nil {
		return x.RegionEndpoint
	}
	return false
}

func (x *KubernetesHarborS3Storage) GetEncrypt() bool {
	if x != nil {
		return x.Encrypt
	}
	return false
}

func (x *KubernetesHarborS3Storage) GetSecure() bool {
	if x != nil {
		return x.Secure
	}
	return false
}

func (x *KubernetesHarborS3Storage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

func (x *KubernetesHarborS3Storage) GetEndpointUrl() string {
	if x != nil {
		return x.EndpointUrl
	}
	return ""
}

// *
// **KubernetesHarborGcsStorage** defines Google Cloud Storage configuration.
type KubernetesHarborGcsStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The GCS bucket name.
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// The base64-encoded service account key JSON.
	KeyData string `protobuf:"bytes,2,opt,name=key_data,json=keyData,proto3" json:"key_data,omitempty"`
	// The root directory path within the bucket.
	RootDirectory string `protobuf:"bytes,3,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	// The chunk size for upload (default is 5242880 bytes).
	ChunkSize     *int32 `protobuf:"varint,4,opt,name=chunk_size,json=chunkSize,proto3,oneof" json:"chunk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborGcsStorage) Reset() {
	*x = KubernetesHarborGcsStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborGcsStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborGcsStorage) ProtoMessage() {}

func (x *KubernetesHarborGcsStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborGcsStorage.ProtoReflect.Descriptor instead.
func (*KubernetesHarborGcsStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{12}
}

func (x *KubernetesHarborGcsStorage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *KubernetesHarborGcsStorage) GetKeyData() string {
	if x != nil {
		return x.KeyData
	}
	return ""
}

func (x *KubernetesHarborGcsStorage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

func (x *KubernetesHarborGcsStorage) GetChunkSize() int32 {
	if x != nil && x.ChunkSize != nil {
		return *x.ChunkSize
	}
	return 0
}

// *
// **KubernetesHarborAzureStorage** defines Azure Blob Storage configuration.
type KubernetesHarborAzureStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Azure storage account name.
	AccountName string `protobuf:"bytes,1,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	// The Azure storage account key.
	AccountKey string `protobuf:"bytes,2,opt,name=account_key,json=accountKey,proto3" json:"account_key,omitempty"`
	// The Azure blob container name.
	Container string `protobuf:"bytes,3,opt,name=container,proto3" json:"container,omitempty"`
	// The root directory path within the container.
	RootDirectory string `protobuf:"bytes,4,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborAzureStorage) Reset() {
	*x = KubernetesHarborAzureStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborAzureStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborAzureStorage) ProtoMessage() {}

func (x *KubernetesHarborAzureStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborAzureStorage.ProtoReflect.Descriptor instead.
func (*KubernetesHarborAzureStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{13}
}

func (x *KubernetesHarborAzureStorage) GetAccountName() string {
	if x != nil {
		return x.AccountName
	}
	return ""
}

func (x *KubernetesHarborAzureStorage) GetAccountKey() string {
	if x != nil {
		return x.AccountKey
	}
	return ""
}

func (x *KubernetesHarborAzureStorage) GetContainer() string {
	if x != nil {
		return x.Container
	}
	return ""
}

func (x *KubernetesHarborAzureStorage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

// *
// **KubernetesHarborOssStorage** defines Alibaba Cloud OSS configuration.
type KubernetesHarborOssStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The OSS bucket name.
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// The OSS endpoint (e.g., "oss-cn-hangzhou.aliyuncs.com").
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// The access key ID.
	AccessKeyId string `protobuf:"bytes,3,opt,name=access_key_id,json=accessKeyId,proto3" json:"access_key_id,omitempty"`
	// The access key secret.
	AccessKeySecret string `protobuf:"bytes,4,opt,name=access_key_secret,json=accessKeySecret,proto3" json:"access_key_secret,omitempty"`
	// The root directory path within the bucket.
	RootDirectory string `protobuf:"bytes,5,opt,name=root_directory,json=rootDirectory,proto3" json:"root_directory,omitempty"`
	// Whether to use HTTPS.
	Secure        bool `protobuf:"varint,6,opt,name=secure,proto3" json:"secure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborOssStorage) Reset() {
	*x = KubernetesHarborOssStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborOssStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborOssStorage) ProtoMessage() {}

func (x *KubernetesHarborOssStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborOssStorage.ProtoReflect.Descriptor instead.
func (*KubernetesHarborOssStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{14}
}

func (x *KubernetesHarborOssStorage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *KubernetesHarborOssStorage) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *KubernetesHarborOssStorage) GetAccessKeyId() string {
	if x != nil {
		return x.AccessKeyId
	}
	return ""
}

func (x *KubernetesHarborOssStorage) GetAccessKeySecret() string {
	if x != nil {
		return x.AccessKeySecret
	}
	return ""
}

func (x *KubernetesHarborOssStorage) GetRootDirectory() string {
	if x != nil {
		return x.RootDirectory
	}
	return ""
}

func (x *KubernetesHarborOssStorage) GetSecure() bool {
	if x != nil {
		return x.Secure
	}
	return false
}

// *
// **KubernetesHarborFilesystemStorage** defines filesystem (PVC) storage configuration.
// Note: This is not suitable for production high-availability deployments.
type KubernetesHarborFilesystemStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The size of the persistent volume for storing artifacts (e.g., "100Gi").
	// Note: This value cannot be modified after creation due to Kubernetes PVC limitations.
	DiskSize string `protobuf:"bytes,1,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// The storage class to use for the PVC.
	StorageClass  string `protobuf:"bytes,2,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborFilesystemStorage) Reset() {
	*x = KubernetesHarborFilesystemStorage{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborFilesystemStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborFilesystemStorage) ProtoMessage() {}

func (x *KubernetesHarborFilesystemStorage) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborFilesystemStorage.ProtoReflect.Descriptor instead.
func (*KubernetesHarborFilesystemStorage) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{15}
}

func (x *KubernetesHarborFilesystemStorage) GetDiskSize() string {
	if x != nil {
		return x.DiskSize
	}
	return ""
}

func (x *KubernetesHarborFilesystemStorage) GetStorageClass() string {
	if x != nil {
		return x.StorageClass
	}
	return ""
}

// *
// **KubernetesHarborIngress** defines the ingress configuration for Harbor endpoints.
// It provides separate ingress settings for the Core/Portal UI and Notary service.
type KubernetesHarborIngress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ingress configuration for Harbor Core and Portal (web UI and API).
	Core *KubernetesHarborIngressEndpoint `protobuf:"bytes,1,opt,name=core,proto3" json:"core,omitempty"`
	// Ingress configuration for Notary service (image signing).
	Notary        *KubernetesHarborIngressEndpoint `protobuf:"bytes,2,opt,name=notary,proto3" json:"notary,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborIngress) Reset() {
	*x = KubernetesHarborIngress{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborIngress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborIngress) ProtoMessage() {}

func (x *KubernetesHarborIngress) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborIngress.ProtoReflect.Descriptor instead.
func (*KubernetesHarborIngress) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{16}
}

func (x *KubernetesHarborIngress) GetCore() *KubernetesHarborIngressEndpoint {
	if x != nil {
		return x.Core
	}
	return nil
}

func (x *KubernetesHarborIngress) GetNotary() *KubernetesHarborIngressEndpoint {
	if x != nil {
		return x.Notary
	}
	return nil
}

// *
// **KubernetesHarborIngressEndpoint** defines ingress configuration for a specific Harbor endpoint.
type KubernetesHarborIngressEndpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Flag to enable or disable ingress for this endpoint.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// The full hostname for external access (e.g., "harbor.example.com").
	// This hostname will be configured via Gateway API resources.
	// Required when enabled is true.
	Hostname      string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesHarborIngressEndpoint) Reset() {
	*x = KubernetesHarborIngressEndpoint{}
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesHarborIngressEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesHarborIngressEndpoint) ProtoMessage() {}

func (x *KubernetesHarborIngressEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesHarborIngressEndpoint.ProtoReflect.Descriptor instead.
func (*KubernetesHarborIngressEndpoint) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP(), []int{17}
}

func (x *KubernetesHarborIngressEndpoint) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *KubernetesHarborIngressEndpoint) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

var file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*KubernetesHarborContainer)(nil),
		Field:         570001,
		Name:          "org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_core_container",
		Tag:           "bytes,570001,opt,name=default_harbor_core_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*KubernetesHarborContainer)(nil),
		Field:         570002,
		Name:          "org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_portal_container",
		Tag:           "bytes,570002,opt,name=default_harbor_portal_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*KubernetesHarborContainer)(nil),
		Field:         570003,
		Name:          "org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_registry_container",
		Tag:           "bytes,570003,opt,name=default_harbor_registry_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*KubernetesHarborContainer)(nil),
		Field:         570004,
		Name:          "org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_jobservice_container",
		Tag:           "bytes,570004,opt,name=default_harbor_jobservice_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*KubernetesHarborPostgresqlContainer)(nil),
		Field:         570005,
		Name:          "org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_postgresql_container",
		Tag:           "bytes,570005,opt,name=default_postgresql_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto",
	},
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*KubernetesHarborRedisContainer)(nil),
		Field:         570006,
		Name:          "org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_redis_container",
		Tag:           "bytes,570006,opt,name=default_redis_container",
		Filename:      "org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto",
	},
}

// Extension fields to descriptorpb.FieldOptions.
var (
	// optional org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer default_harbor_core_container = 570001;
	E_DefaultHarborCoreContainer = &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes[0]
	// optional org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer default_harbor_portal_container = 570002;
	E_DefaultHarborPortalContainer = &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes[1]
	// optional org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer default_harbor_registry_container = 570003;
	E_DefaultHarborRegistryContainer = &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes[2]
	// optional org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer default_harbor_jobservice_container = 570004;
	E_DefaultHarborJobserviceContainer = &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes[3]
	// optional org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainer default_postgresql_container = 570005;
	E_DefaultPostgresqlContainer = &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes[4]
	// optional org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainer default_redis_container = 570006;
	E_DefaultRedisContainer = &file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes[5]
)

var File_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDesc = "" +
	"\n" +
	"Oorg/project_planton/provider/kubernetes/workload/kubernetesharbor/v1/spec.proto\x12Dorg.project_planton.provider.kubernetes.workload.kubernetesharbor.v1\x1a\x1bbuf/validate/validate.proto\x1a google/protobuf/descriptor.proto\x1a6org/project_planton/shared/kubernetes/kubernetes.proto\x1a0org/project_planton/shared/options/options.proto\"\xcd\v\n" +
	"\x14KubernetesHarborSpec\x12\xae\x01\n" +
	"\x0ecore_container\x18\x01 \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerB&\x8a\xa9\x96\x02!\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x032Gi\x12\r\n" +
	"\x04200m\x12\x05512MiR\rcoreContainer\x12\xb3\x01\n" +
	"\x10portal_container\x18\x02 \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerB'\x92\xa9\x96\x02\"\b\x01\x12\x1e\n" +
	"\r\n" +
	"\x04500m\x12\x05512Mi\x12\r\n" +
	"\x04100m\x12\x05256MiR\x0fportalContainer\x12\xb6\x01\n" +
	"\x12registry_container\x18\x03 \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerB&\x9a\xa9\x96\x02!\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x032Gi\x12\r\n" +
	"\x04200m\x12\x05512MiR\x11registryContainer\x12\xba\x01\n" +
	"\x14jobservice_container\x18\x04 \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerB&\xa2\xa9\x96\x02!\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x031Gi\x12\r\n" +
	"\x04100m\x12\x05256MiR\x13jobserviceContainer\x12\x88\x01\n" +
	"\bdatabase\x18\x05 \x01(\v2d.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborDatabaseConfigB\x06\xbaH\x03\xc8\x01\x01R\bdatabase\x12\x7f\n" +
	"\x05cache\x18\x06 \x01(\v2a.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborCacheConfigB\x06\xbaH\x03\xc8\x01\x01R\x05cache\x12\x85\x01\n" +
	"\astorage\x18\a \x01(\v2c.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfigB\x06\xbaH\x03\xc8\x01\x01R\astorage\x12w\n" +
	"\aingress\x18\b \x01(\v2].org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngressR\aingress\x12\x8b\x01\n" +
	"\vhelm_values\x18\t \x03(\v2j.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.HelmValuesEntryR\n" +
	"helmValues\x1a=\n" +
	"\x0fHelmValuesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe6\x01\n" +
	"\x19KubernetesHarborContainer\x12#\n" +
	"\breplicas\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02(\x01R\breplicas\x12W\n" +
	"\tresources\x18\x02 \x01(\v29.org.project_planton.shared.kubernetes.ContainerResourcesR\tresources\x12K\n" +
	"\x05image\x18\x03 \x01(\v25.org.project_planton.shared.kubernetes.ContainerImageR\x05image\"\x91\x04\n" +
	"\x1eKubernetesHarborDatabaseConfig\x12\x1f\n" +
	"\vis_external\x18\x01 \x01(\bR\n" +
	"isExternal\x12\x95\x01\n" +
	"\x11external_database\x18\x02 \x01(\v2h.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborExternalPostgresqlR\x10externalDatabase\x12\x92\x01\n" +
	"\x10managed_database\x18\x03 \x01(\v2g.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedPostgresqlR\x0fmanagedDatabase:\xa0\x01\xbaH\x9c\x01\x1a\x99\x01\n" +
	"\x1fspec.database.external_required\x12DExternal database configuration is required when is_external is true\x1a0!this.is_external || has(this.external_database)\"\xbe\x04\n" +
	"\"KubernetesHarborExternalPostgresql\x12\x1a\n" +
	"\x04host\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04host\x12,\n" +
	"\x04port\x18\x02 \x01(\x05B\x13\xbaH\b\x1a\x06\x18\xff\xff\x03 \x00\x8a\xa6\x1d\x045432H\x00R\x04port\x88\x01\x01\x12\"\n" +
	"\busername\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\busername\x12\"\n" +
	"\bpassword\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bpassword\x126\n" +
	"\rcore_database\x18\x05 \x01(\tB\f\x8a\xa6\x1d\bregistryH\x01R\fcoreDatabase\x88\x01\x01\x125\n" +
	"\x0eclair_database\x18\x06 \x01(\tB\t\x8a\xa6\x1d\x05clairH\x02R\rclairDatabase\x88\x01\x01\x12L\n" +
	"\x16notary_server_database\x18\a \x01(\tB\x11\x8a\xa6\x1d\rnotary_serverH\x03R\x14notaryServerDatabase\x88\x01\x01\x12L\n" +
	"\x16notary_signer_database\x18\b \x01(\tB\x11\x8a\xa6\x1d\rnotary_signerH\x04R\x14notarySignerDatabase\x88\x01\x01\x12\x17\n" +
	"\ause_ssl\x18\t \x01(\bR\x06useSslB\a\n" +
	"\x05_portB\x10\n" +
	"\x0e_core_databaseB\x11\n" +
	"\x0f_clair_databaseB\x19\n" +
	"\x17_notary_server_databaseB\x19\n" +
	"\x17_notary_signer_database\"\xdd\x01\n" +
	"!KubernetesHarborManagedPostgresql\x12\xb7\x01\n" +
	"\tcontainer\x18\x01 \x01(\v2i.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainerB.\xaa\xa9\x96\x02)\b\x01\x12\x1d\n" +
	"\f\n" +
	"\x051000m\x12\x032Gi\x12\r\n" +
	"\x04200m\x12\x05512Mi \x01*\x0420GiR\tcontainer\"\xa3\x05\n" +
	"#KubernetesHarborPostgresqlContainer\x12#\n" +
	"\breplicas\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02(\x01R\breplicas\x12W\n" +
	"\tresources\x18\x02 \x01(\v29.org.project_planton.shared.kubernetes.ContainerResourcesR\tresources\x12K\n" +
	"\x05image\x18\x03 \x01(\v25.org.project_planton.shared.kubernetes.ContainerImageR\x05image\x12/\n" +
	"\x13persistence_enabled\x18\x04 \x01(\bR\x12persistenceEnabled\x12\x1b\n" +
	"\tdisk_size\x18\x05 \x01(\tR\bdiskSize:\xe2\x02\xbaH\xde\x02\x1a\xdb\x02\n" +
	",spec.postgresql.container.disk_size.required\x12IDisk size is required and must match the format if persistence is enabled\x1a\xdf\x01((!this.persistence_enabled && (size(this.disk_size) == 0 || this.disk_size == '')) || (this.persistence_enabled && size(this.disk_size) > 0 && this.disk_size.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')))\"\xef\x03\n" +
	"\x1bKubernetesHarborCacheConfig\x12\x1f\n" +
	"\vis_external\x18\x01 \x01(\bR\n" +
	"isExternal\x12\x8a\x01\n" +
	"\x0eexternal_cache\x18\x02 \x01(\v2c.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborExternalRedisR\rexternalCache\x12\x87\x01\n" +
	"\rmanaged_cache\x18\x03 \x01(\v2b.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedRedisR\fmanagedCache:\x97\x01\xbaH\x93\x01\x1a\x90\x01\n" +
	"\x1cspec.cache.external_required\x12AExternal cache configuration is required when is_external is true\x1a-!this.is_external || has(this.external_cache)\"\xec\x03\n" +
	"\x1dKubernetesHarborExternalRedis\x12\x1a\n" +
	"\x04host\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04host\x12,\n" +
	"\x04port\x18\x02 \x01(\x05B\x13\xbaH\b\x1a\x06\x18\xff\xff\x03 \x00\x8a\xa6\x1d\x046379H\x00R\x04port\x88\x01\x01\x12\x1a\n" +
	"\busername\x18\x03 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x04 \x01(\tR\bpassword\x121\n" +
	"\x0edatabase_index\x18\x05 \x01(\x05B\x05\x8a\xa6\x1d\x010H\x01R\rdatabaseIndex\x88\x01\x01\x12!\n" +
	"\fuse_sentinel\x18\x06 \x01(\bR\vuseSentinel\x12.\n" +
	"\x13sentinel_master_set\x18\a \x01(\tR\x11sentinelMasterSet:\xa6\x01\xbaH\xa2\x01\x1a\x9f\x01\n" +
	"#spec.cache.sentinel_master_required\x12>Sentinel master set name is required when use_sentinel is true\x1a8!this.use_sentinel || size(this.sentinel_master_set) > 0B\a\n" +
	"\x05_portB\x11\n" +
	"\x0f_database_index\"\xd3\x01\n" +
	"\x1cKubernetesHarborManagedRedis\x12\xb2\x01\n" +
	"\tcontainer\x18\x01 \x01(\v2d.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainerB.\xb2\xa9\x96\x02)\b\x01\x12\x1e\n" +
	"\r\n" +
	"\x04500m\x12\x05512Mi\x12\r\n" +
	"\x04100m\x12\x05256Mi \x01*\x038GiR\tcontainer\"\x99\x05\n" +
	"\x1eKubernetesHarborRedisContainer\x12#\n" +
	"\breplicas\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02(\x01R\breplicas\x12W\n" +
	"\tresources\x18\x02 \x01(\v29.org.project_planton.shared.kubernetes.ContainerResourcesR\tresources\x12K\n" +
	"\x05image\x18\x03 \x01(\v25.org.project_planton.shared.kubernetes.ContainerImageR\x05image\x12/\n" +
	"\x13persistence_enabled\x18\x04 \x01(\bR\x12persistenceEnabled\x12\x1b\n" +
	"\tdisk_size\x18\x05 \x01(\tR\bdiskSize:\xdd\x02\xbaH\xd9\x02\x1a\xd6\x02\n" +
	"'spec.redis.container.disk_size.required\x12IDisk size is required and must match the format if persistence is enabled\x1a\xdf\x01((!this.persistence_enabled && (size(this.disk_size) == 0 || this.disk_size == '')) || (this.persistence_enabled && size(this.disk_size) > 0 && this.disk_size.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')))\"\xf1\n" +
	"\n" +
	"\x1dKubernetesHarborStorageConfig\x12}\n" +
	"\x04type\x18\x01 \x01(\x0e2a.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageTypeB\x06\xbaH\x03\xc8\x01\x01R\x04type\x12o\n" +
	"\x02s3\x18\x02 \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborS3StorageR\x02s3\x12r\n" +
	"\x03gcs\x18\x03 \x01(\v2`.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborGcsStorageR\x03gcs\x12x\n" +
	"\x05azure\x18\x04 \x01(\v2b.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborAzureStorageR\x05azure\x12r\n" +
	"\x03oss\x18\x05 \x01(\v2`.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborOssStorageR\x03oss\x12\x87\x01\n" +
	"\n" +
	"filesystem\x18\x06 \x01(\v2g.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborFilesystemStorageR\n" +
	"filesystem:\xf3\x04\xbaH\xef\x04\x1ap\n" +
	"\x18spec.storage.s3_required\x124S3 configuration is required when storage type is s3\x1a\x1ethis.type != 2 || has(this.s3)\x1at\n" +
	"\x19spec.storage.gcs_required\x126GCS configuration is required when storage type is gcs\x1a\x1fthis.type != 3 || has(this.gcs)\x1a|\n" +
	"\x1bspec.storage.azure_required\x12:Azure configuration is required when storage type is azure\x1a!this.type != 4 || has(this.azure)\x1at\n" +
	"\x19spec.storage.oss_required\x126OSS configuration is required when storage type is oss\x1a\x1fthis.type != 5 || has(this.oss)\x1a\x90\x01\n" +
	" spec.storage.filesystem_required\x12DFilesystem configuration is required when storage type is filesystem\x1a&this.type != 1 || has(this.filesystem)\"\xce\x02\n" +
	"\x19KubernetesHarborS3Storage\x12\x1e\n" +
	"\x06bucket\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06bucket\x12\x1e\n" +
	"\x06region\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06region\x12%\n" +
	"\n" +
	"access_key\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\taccessKey\x12%\n" +
	"\n" +
	"secret_key\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\tsecretKey\x12'\n" +
	"\x0fregion_endpoint\x18\x05 \x01(\bR\x0eregionEndpoint\x12\x18\n" +
	"\aencrypt\x18\x06 \x01(\bR\aencrypt\x12\x16\n" +
	"\x06secure\x18\a \x01(\bR\x06secure\x12%\n" +
	"\x0eroot_directory\x18\b \x01(\tR\rrootDirectory\x12!\n" +
	"\fendpoint_url\x18\t \x01(\tR\vendpointUrl\"\xc6\x01\n" +
	"\x1aKubernetesHarborGcsStorage\x12\x1e\n" +
	"\x06bucket\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06bucket\x12!\n" +
	"\bkey_data\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\akeyData\x12%\n" +
	"\x0eroot_directory\x18\x03 \x01(\tR\rrootDirectory\x12/\n" +
	"\n" +
	"chunk_size\x18\x04 \x01(\x05B\v\x8a\xa6\x1d\a5242880H\x00R\tchunkSize\x88\x01\x01B\r\n" +
	"\v_chunk_size\"\xbf\x01\n" +
	"\x1cKubernetesHarborAzureStorage\x12)\n" +
	"\faccount_name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vaccountName\x12'\n" +
	"\vaccount_key\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"accountKey\x12$\n" +
	"\tcontainer\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\tcontainer\x12%\n" +
	"\x0eroot_directory\x18\x04 \x01(\tR\rrootDirectory\"\xff\x01\n" +
	"\x1aKubernetesHarborOssStorage\x12\x1e\n" +
	"\x06bucket\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06bucket\x12\"\n" +
	"\bendpoint\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bendpoint\x12*\n" +
	"\raccess_key_id\x18\x03 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vaccessKeyId\x122\n" +
	"\x11access_key_secret\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x0faccessKeySecret\x12%\n" +
	"\x0eroot_directory\x18\x05 \x01(\tR\rrootDirectory\x12\x16\n" +
	"\x06secure\x18\x06 \x01(\bR\x06secure\"\xa5\x02\n" +
	"!KubernetesHarborFilesystemStorage\x12\xda\x01\n" +
	"\tdisk_size\x18\x01 \x01(\tB\xbc\x01\xbaH\xb8\x01\xba\x01\xb4\x01\n" +
	"*spec.storage.filesystem.disk_size.required\x12/Disk size is required and must match the format\x1aUsize(this) > 0 && this.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')R\bdiskSize\x12#\n" +
	"\rstorage_class\x18\x02 \x01(\tR\fstorageClass\"\x93\x02\n" +
	"\x17KubernetesHarborIngress\x12y\n" +
	"\x04core\x18\x01 \x01(\v2e.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngressEndpointR\x04core\x12}\n" +
	"\x06notary\x18\x02 \x01(\v2e.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngressEndpointR\x06notary\"\xd6\x01\n" +
	"\x1fKubernetesHarborIngressEndpoint\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname:}\xbaHz\x1ax\n" +
	"\x1espec.ingress.hostname.required\x12,hostname is required when ingress is enabled\x1a(!this.enabled || size(this.hostname) > 0*\x82\x01\n" +
	"\x1bKubernetesHarborStorageType\x12.\n" +
	"*kubernetes_harbor_storage_type_unspecified\x10\x00\x12\x0e\n" +
	"\n" +
	"filesystem\x10\x01\x12\x06\n" +
	"\x02s3\x10\x02\x12\a\n" +
	"\x03gcs\x10\x03\x12\t\n" +
	"\x05azure\x10\x04\x12\a\n" +
	"\x03oss\x10\x05:\xc3\x01\n" +
	"\x1ddefault_harbor_core_container\x12\x1d.google.protobuf.FieldOptions\x18\x91\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerR\x1adefaultHarborCoreContainer:\xc7\x01\n" +
	"\x1fdefault_harbor_portal_container\x12\x1d.google.protobuf.FieldOptions\x18\x92\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerR\x1cdefaultHarborPortalContainer:\xcb\x01\n" +
	"!default_harbor_registry_container\x12\x1d.google.protobuf.FieldOptions\x18\x93\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerR\x1edefaultHarborRegistryContainer:\xcf\x01\n" +
	"#default_harbor_jobservice_container\x12\x1d.google.protobuf.FieldOptions\x18\x94\xe5\" \x01(\v2_.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainerR defaultHarborJobserviceContainer:\xcc\x01\n" +
	"\x1cdefault_postgresql_container\x12\x1d.google.protobuf.FieldOptions\x18\x95\xe5\" \x01(\v2i.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainerR\x1adefaultPostgresqlContainer:\xbd\x01\n" +
	"\x17default_redis_container\x12\x1d.google.protobuf.FieldOptions\x18\x96\xe5\" \x01(\v2d.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainerR\x15defaultRedisContainerB\x94\x04\n" +
	"Hcom.org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1B\tSpecProtoP\x01Z\x87\x01github.com/project-planton/project-planton/apis/org/project_planton/provider/kubernetes/workload/kubernetesharbor/v1;kubernetesharborv1\xa2\x02\x06OPPKWK\xaa\x02COrg.ProjectPlanton.Provider.Kubernetes.Workload.Kubernetesharbor.V1\xca\x02COrg\\ProjectPlanton\\Provider\\Kubernetes\\Workload\\Kubernetesharbor\\V1\xe2\x02OOrg\\ProjectPlanton\\Provider\\Kubernetes\\Workload\\Kubernetesharbor\\V1\\GPBMetadata\xea\x02IOrg::ProjectPlanton::Provider::Kubernetes::Workload::Kubernetesharbor::V1b\x06proto3"

var (
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescData []byte
)

func file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDesc)))
	})
	return file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDescData
}

var file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_goTypes = []any{
	(KubernetesHarborStorageType)(0),            // 0: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageType
	(*KubernetesHarborSpec)(nil),                // 1: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec
	(*KubernetesHarborContainer)(nil),           // 2: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	(*KubernetesHarborDatabaseConfig)(nil),      // 3: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborDatabaseConfig
	(*KubernetesHarborExternalPostgresql)(nil),  // 4: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborExternalPostgresql
	(*KubernetesHarborManagedPostgresql)(nil),   // 5: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedPostgresql
	(*KubernetesHarborPostgresqlContainer)(nil), // 6: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainer
	(*KubernetesHarborCacheConfig)(nil),         // 7: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborCacheConfig
	(*KubernetesHarborExternalRedis)(nil),       // 8: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborExternalRedis
	(*KubernetesHarborManagedRedis)(nil),        // 9: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedRedis
	(*KubernetesHarborRedisContainer)(nil),      // 10: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainer
	(*KubernetesHarborStorageConfig)(nil),       // 11: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig
	(*KubernetesHarborS3Storage)(nil),           // 12: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborS3Storage
	(*KubernetesHarborGcsStorage)(nil),          // 13: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborGcsStorage
	(*KubernetesHarborAzureStorage)(nil),        // 14: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborAzureStorage
	(*KubernetesHarborOssStorage)(nil),          // 15: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborOssStorage
	(*KubernetesHarborFilesystemStorage)(nil),   // 16: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborFilesystemStorage
	(*KubernetesHarborIngress)(nil),             // 17: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngress
	(*KubernetesHarborIngressEndpoint)(nil),     // 18: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngressEndpoint
	nil,                                         // 19: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.HelmValuesEntry
	(*kubernetes.ContainerResources)(nil),       // 20: org.project_planton.shared.kubernetes.ContainerResources
	(*kubernetes.ContainerImage)(nil),           // 21: org.project_planton.shared.kubernetes.ContainerImage
	(*descriptorpb.FieldOptions)(nil),           // 22: google.protobuf.FieldOptions
}
var file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_depIdxs = []int32{
	2,  // 0: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.core_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	2,  // 1: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.portal_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	2,  // 2: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.registry_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	2,  // 3: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.jobservice_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	3,  // 4: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.database:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborDatabaseConfig
	7,  // 5: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.cache:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborCacheConfig
	11, // 6: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.storage:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig
	17, // 7: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.ingress:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngress
	19, // 8: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.helm_values:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborSpec.HelmValuesEntry
	20, // 9: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer.resources:type_name -> org.project_planton.shared.kubernetes.ContainerResources
	21, // 10: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer.image:type_name -> org.project_planton.shared.kubernetes.ContainerImage
	4,  // 11: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborDatabaseConfig.external_database:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborExternalPostgresql
	5,  // 12: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborDatabaseConfig.managed_database:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedPostgresql
	6,  // 13: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedPostgresql.container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainer
	20, // 14: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainer.resources:type_name -> org.project_planton.shared.kubernetes.ContainerResources
	21, // 15: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainer.image:type_name -> org.project_planton.shared.kubernetes.ContainerImage
	8,  // 16: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborCacheConfig.external_cache:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborExternalRedis
	9,  // 17: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborCacheConfig.managed_cache:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedRedis
	10, // 18: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborManagedRedis.container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainer
	20, // 19: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainer.resources:type_name -> org.project_planton.shared.kubernetes.ContainerResources
	21, // 20: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainer.image:type_name -> org.project_planton.shared.kubernetes.ContainerImage
	0,  // 21: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig.type:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageType
	12, // 22: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig.s3:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborS3Storage
	13, // 23: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig.gcs:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborGcsStorage
	14, // 24: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig.azure:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborAzureStorage
	15, // 25: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig.oss:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborOssStorage
	16, // 26: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborStorageConfig.filesystem:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborFilesystemStorage
	18, // 27: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngress.core:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngressEndpoint
	18, // 28: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngress.notary:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborIngressEndpoint
	22, // 29: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_core_container:extendee -> google.protobuf.FieldOptions
	22, // 30: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_portal_container:extendee -> google.protobuf.FieldOptions
	22, // 31: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_registry_container:extendee -> google.protobuf.FieldOptions
	22, // 32: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_jobservice_container:extendee -> google.protobuf.FieldOptions
	22, // 33: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_postgresql_container:extendee -> google.protobuf.FieldOptions
	22, // 34: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_redis_container:extendee -> google.protobuf.FieldOptions
	2,  // 35: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_core_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	2,  // 36: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_portal_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	2,  // 37: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_registry_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	2,  // 38: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_harbor_jobservice_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborContainer
	6,  // 39: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_postgresql_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborPostgresqlContainer
	10, // 40: org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.default_redis_container:type_name -> org.project_planton.provider.kubernetes.workload.kubernetesharbor.v1.KubernetesHarborRedisContainer
	41, // [41:41] is the sub-list for method output_type
	41, // [41:41] is the sub-list for method input_type
	35, // [35:41] is the sub-list for extension type_name
	29, // [29:35] is the sub-list for extension extendee
	0,  // [0:29] is the sub-list for field type_name
}

func init() {
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_init()
}
func file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_init() {
	if File_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto != nil {
		return
	}
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[3].OneofWrappers = []any{}
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[7].OneofWrappers = []any{}
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes[12].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   19,
			NumExtensions: 6,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_depIdxs,
		EnumInfos:         file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_enumTypes,
		MessageInfos:      file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_msgTypes,
		ExtensionInfos:    file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_extTypes,
	}.Build()
	File_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto = out.File
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_goTypes = nil
	file_org_project_planton_provider_kubernetes_workload_kubernetesharbor_v1_spec_proto_depIdxs = nil
}
