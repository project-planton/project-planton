syntax = "proto3";

package org.project_planton.provider.kubernetes.kubernetestemporal.v1;

import "buf/validate/validate.proto";
import "org/project_planton/provider/kubernetes/target_cluster.proto";
import "org/project_planton/shared/foreignkey/v1/foreign_key.proto";
import "org/project_planton/shared/options/options.proto";

// temporal kubernetes database backend enumerates the supported databases.
enum KubernetesTemporalDatabaseBackend {
  // unspecified should not be used
  kubernetes_temporal_database_backend_unspecified = 0;

  // uses cassandra
  cassandra = 1;

  // uses postgresql
  postgresql = 2;

  // uses mysql
  mysql = 3;
}

// temporal kubernetes spec defines minimal fields for deploying temporal on kubernetes.
message KubernetesTemporalSpec {
  // The Kubernetes cluster to install Temporal on.
  org.project_planton.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;

  // Kubernetes namespace to install Temporal.
  org.project_planton.shared.foreignkey.v1.StringValueOrRef namespace = 2 [
    (buf.validate.field).required = true,
    (org.project_planton.shared.foreignkey.v1.default_kind) = KubernetesNamespace,
    (org.project_planton.shared.foreignkey.v1.default_kind_field_path) = "spec.name"
  ];

  // database configuration
  KubernetesTemporalDatabaseConfig database = 3 [(buf.validate.field).required = true];
  // disables temporal web ui
  bool disable_web_ui = 4;
  // enables embedded elasticsearch for temporal
  // this is ignored if external elasticsearch is set
  bool enable_embedded_elasticsearch = 5;
  // enables monitoring stack for temporal
  // enabling this will deploy prometheus and grafana
  bool enable_monitoring_stack = 6;
  //number of cassandra nodes to be deployed
  //this is only honored when the backend is cassandra, and no external database is provided.
  optional int32 cassandra_replicas = 7 [(org.project_planton.shared.options.default) = "1"];
  //The ingress configuration for the temporal deployment.
  //if enabled, the frontend will be exposed using a load-balancer
  // and also if web ui is enabled it will be exposed using the kubernetes ingress controller.
  KubernetesTemporalIngress ingress = 8;
  // external elasticsearch configuration to be used by temporal for configuring observability.
  KubernetesTemporalExternalElasticsearch external_elasticsearch = 9;
  // version of the Temporal Helm chart to deploy (e.g., "0.62.0")
  // if not specified, the default version configured in the Pulumi module will be used
  string version = 10;
}

// groups database configuration settings.
message KubernetesTemporalDatabaseConfig {
  // selected database backend
  KubernetesTemporalDatabaseBackend backend = 1 [(buf.validate.field).required = true];

  // external database configuration, if this is not set, in-cluster cassandra would be created
  KubernetesTemporalExternalDatabase external_database = 2;

  // primary database or keyspace name
  optional string database_name = 6 [(org.project_planton.shared.options.default) = "temporal"];

  // visibility database or keyspace name
  optional string visibility_name = 7 [(org.project_planton.shared.options.default) = "temporal_visibility"];

  // disables automatic schema creation
  bool disable_auto_schema_setup = 8;
}

// describes an external database that temporal can use
message KubernetesTemporalExternalDatabase {
  // hostname for external database
  string host = 1;

  // port for external database
  int32 port = 2;

  // username for database
  string username = 3;

  // password for database
  string password = 4;
}

// describes an external elasticsearch cluster that temporal can use
// for advanced visibility instead of deploying an in-cluster es chart.
message KubernetesTemporalExternalElasticsearch {
  // the host address of the existing elasticsearch cluster
  string host = 1;

  // the port for the existing elasticsearch cluster
  int32 port = 2;

  // optional username, if the external cluster requires auth
  string user = 3;

  // optional password, if the external cluster requires auth
  string password = 4;
}

// ingress configuration for temporal deployment with separate frontend and web ui endpoints
message KubernetesTemporalIngress {
  // frontend (gRPC + HTTP) ingress configuration
  KubernetesTemporalFrontendIngressEndpoint frontend = 1;

  // web ui ingress configuration
  KubernetesTemporalWebUiIngressEndpoint web_ui = 2;
}

// frontend ingress endpoint configuration supporting both gRPC and HTTP protocols
message KubernetesTemporalFrontendIngressEndpoint {
  // flag to enable or disable frontend ingress
  bool enabled = 1;

  // the full hostname for gRPC access via LoadBalancer (e.g., "temporal-frontend-grpc.example.com")
  // required when enabled is true
  string grpc_hostname = 2;

  // the full hostname for HTTP access via Gateway API (e.g., "temporal-frontend-http.example.com")
  // optional - only creates Gateway/HTTPRoute resources if provided
  string http_hostname = 3;

  option (buf.validate.message).cel = {
    id: "spec.ingress.frontend.grpc_hostname.required"
    expression: "!this.enabled || size(this.grpc_hostname) > 0"
    message: "frontend.grpc_hostname is required when frontend ingress is enabled"
  };
}

// web ui ingress endpoint configuration for HTTP-only access
message KubernetesTemporalWebUiIngressEndpoint {
  // flag to enable or disable web ui ingress
  bool enabled = 1;

  // the full hostname for HTTP access via Gateway API (e.g., "temporal-ui.example.com")
  // required when enabled is true
  string hostname = 2;

  option (buf.validate.message).cel = {
    id: "spec.ingress.web_ui.hostname.required"
    expression: "!this.enabled || size(this.hostname) > 0"
    message: "web_ui.hostname is required when web ui ingress is enabled"
  };
}
