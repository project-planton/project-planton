syntax = "proto3";

package org.project_planton.provider.kubernetes.kubernetesharbor.v1;

import "buf/validate/validate.proto";
import "google/protobuf/descriptor.proto";
import "org/project_planton/shared/kubernetes/kubernetes.proto";
import "org/project_planton/shared/options/options.proto";

extend google.protobuf.FieldOptions {
  KubernetesHarborContainer default_harbor_core_container = 570001;
  KubernetesHarborContainer default_harbor_portal_container = 570002;
  KubernetesHarborContainer default_harbor_registry_container = 570003;
  KubernetesHarborContainer default_harbor_jobservice_container = 570004;
  KubernetesHarborPostgresqlContainer default_postgresql_container = 570005;
  KubernetesHarborRedisContainer default_redis_container = 570006;
}

/**
 * **KubernetesHarborSpec** defines the configuration for deploying Harbor cloud-native registry on Kubernetes.
 * Harbor is an open source registry that secures artifacts with policies and role-based access control,
 * ensures images are scanned and free from vulnerabilities, and signs images as trusted.
 * This spec supports both self-managed and external PostgreSQL and Redis configurations, enabling flexible
 * deployment patterns from simple single-node installations to production-grade high-availability clusters.
 */
message KubernetesHarborSpec {
  // The container specifications for Harbor Core (API server, authentication, webhook).
  KubernetesHarborContainer core_container = 1 [(default_harbor_core_container) = {
    replicas: 1
    resources: {
      limits: {
        cpu: "1000m"
        memory: "2Gi"
      }
      requests: {
        cpu: "200m"
        memory: "512Mi"
      }
    }
  }];

  // The container specifications for Harbor Portal (web UI).
  KubernetesHarborContainer portal_container = 2 [(default_harbor_portal_container) = {
    replicas: 1
    resources: {
      limits: {
        cpu: "500m"
        memory: "512Mi"
      }
      requests: {
        cpu: "100m"
        memory: "256Mi"
      }
    }
  }];

  // The container specifications for Harbor Registry (Docker/OCI registry backend).
  KubernetesHarborContainer registry_container = 3 [(default_harbor_registry_container) = {
    replicas: 1
    resources: {
      limits: {
        cpu: "1000m"
        memory: "2Gi"
      }
      requests: {
        cpu: "200m"
        memory: "512Mi"
      }
    }
  }];

  // The container specifications for Harbor Jobservice (background job execution).
  KubernetesHarborContainer jobservice_container = 4 [(default_harbor_jobservice_container) = {
    replicas: 1
    resources: {
      limits: {
        cpu: "1000m"
        memory: "1Gi"
      }
      requests: {
        cpu: "100m"
        memory: "256Mi"
      }
    }
  }];

  // The database configuration for Harbor, supporting both self-managed and external PostgreSQL.
  KubernetesHarborDatabaseConfig database = 5 [(buf.validate.field).required = true];

  // The cache configuration for Harbor, supporting both self-managed and external Redis.
  KubernetesHarborCacheConfig cache = 6 [(buf.validate.field).required = true];

  // The object storage configuration for Harbor artifact storage.
  KubernetesHarborStorageConfig storage = 7 [(buf.validate.field).required = true];

  // The ingress configuration for Harbor UI and registry endpoints.
  KubernetesHarborIngress ingress = 8;

  /**
   * A map of key-value pairs that provide additional customization options for the Harbor Helm chart.
   * These values allow for further refinement of the deployment, such as enabling Trivy scanner,
   * configuring Notary for image signing, or customizing authentication providers.
   * For detailed information on available options, refer to the Helm chart documentation at:
   * https://github.com/goharbor/harbor-helm
   */
  map<string, string> helm_values = 9;
}

/**
 * **KubernetesHarborContainer** specifies the container configuration for various Harbor components.
 * It includes settings such as the number of replicas, container image, and resource allocations.
 */
message KubernetesHarborContainer {
  // The number of pods to deploy for this component.
  int32 replicas = 1 [(buf.validate.field).int32.gte = 1];

  // The CPU and memory resources allocated to the container.
  org.project_planton.shared.kubernetes.ContainerResources resources = 2;

  // The container image configuration (repository and tag).
  org.project_planton.shared.kubernetes.ContainerImage image = 3;
}

/**
 * **KubernetesHarborDatabaseConfig** defines the PostgreSQL database configuration for Harbor.
 * It supports two deployment modes:
 * 1. Self-managed: Deploy PostgreSQL within the Kubernetes cluster (default).
 * 2. External: Connect to an existing external PostgreSQL instance.
 */
message KubernetesHarborDatabaseConfig {
  /**
   * Flag to enable using an external PostgreSQL database.
   * When false (default), Harbor will deploy and manage its own PostgreSQL instance.
   * When true, the external_database field must be configured.
   */
  bool is_external = 1;

  /**
   * External PostgreSQL database connection details.
   * This field is required when is_external is true and ignored when false.
   */
  KubernetesHarborExternalPostgresql external_database = 2;

  /**
   * Self-managed PostgreSQL configuration.
   * This field is used when is_external is false and configures the in-cluster PostgreSQL deployment.
   */
  KubernetesHarborManagedPostgresql managed_database = 3;

  option (buf.validate.message).cel = {
    id: "spec.database.external_required"
    expression: "!this.is_external || has(this.external_database)"
    message: "External database configuration is required when is_external is true"
  };
}

/**
 * **KubernetesHarborExternalPostgresql** defines connection parameters for an external PostgreSQL instance.
 * This allows Harbor to use a pre-existing PostgreSQL database instead of deploying one within the cluster.
 */
message KubernetesHarborExternalPostgresql {
  // The hostname or endpoint of the external PostgreSQL instance.
  string host = 1 [(buf.validate.field).required = true];

  // The port for PostgreSQL (default is 5432).
  optional int32 port = 2 [
    (org.project_planton.shared.options.default) = "5432",
    (buf.validate.field).int32.gt = 0,
    (buf.validate.field).int32.lte = 65535
  ];

  // The username for authenticating to PostgreSQL.
  string username = 3 [(buf.validate.field).required = true];

  // The password for authenticating to PostgreSQL.
  string password = 4 [(buf.validate.field).required = true];

  // The name of the database for Harbor Core (default is "registry").
  optional string core_database = 5 [(org.project_planton.shared.options.default) = "registry"];

  // The name of the database for Clair (vulnerability scanner).
  optional string clair_database = 6 [(org.project_planton.shared.options.default) = "clair"];

  // The name of the database for Notary Server (image signing).
  optional string notary_server_database = 7 [(org.project_planton.shared.options.default) = "notary_server"];

  // The name of the database for Notary Signer (image signing).
  optional string notary_signer_database = 8 [(org.project_planton.shared.options.default) = "notary_signer"];

  // Whether to use SSL/TLS connection to PostgreSQL.
  bool use_ssl = 9;
}

/**
 * **KubernetesHarborManagedPostgresql** defines configuration for a self-managed PostgreSQL deployment.
 * This supports simple single-node deployments suitable for development and testing.
 */
message KubernetesHarborManagedPostgresql {
  // The container specifications for PostgreSQL.
  KubernetesHarborPostgresqlContainer container = 1 [(default_postgresql_container) = {
    replicas: 1
    resources: {
      limits: {
        cpu: "1000m"
        memory: "2Gi"
      }
      requests: {
        cpu: "200m"
        memory: "512Mi"
      }
    }
    persistence_enabled: true
    disk_size: "20Gi"
  }];
}

/**
 * **KubernetesHarborPostgresqlContainer** specifies the container configuration for PostgreSQL.
 * It includes replica count, resource allocations, and persistence settings.
 */
message KubernetesHarborPostgresqlContainer {
  // The number of PostgreSQL pods to deploy.
  int32 replicas = 1 [(buf.validate.field).int32.gte = 1];

  // The CPU and memory resources allocated to the PostgreSQL container.
  org.project_planton.shared.kubernetes.ContainerResources resources = 2;

  // The container image configuration for PostgreSQL.
  org.project_planton.shared.kubernetes.ContainerImage image = 3;

  /**
   * Flag to enable or disable data persistence for PostgreSQL.
   * When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
   * Defaults to true.
   */
  bool persistence_enabled = 4;

  /**
   * The size of the persistent volume attached to each PostgreSQL pod (e.g., "20Gi").
   * This attribute is ignored when persistence is not enabled.
   * Note: This value cannot be modified after creation due to Kubernetes StatefulSet limitations.
   */
  string disk_size = 5;

  option (buf.validate.message).cel = {
    id: "spec.postgresql.container.disk_size.required"
    expression: "((!this.persistence_enabled && (size(this.disk_size) == 0 || this.disk_size == '')) || (this.persistence_enabled && size(this.disk_size) > 0 && this.disk_size.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')))"
    message: "Disk size is required and must match the format if persistence is enabled"
  };
}

/**
 * **KubernetesHarborCacheConfig** defines the Redis cache configuration for Harbor.
 * It supports two deployment modes:
 * 1. Self-managed: Deploy Redis within the Kubernetes cluster (default).
 * 2. External: Connect to an existing external Redis instance.
 */
message KubernetesHarborCacheConfig {
  /**
   * Flag to enable using an external Redis cache.
   * When false (default), Harbor will deploy and manage its own Redis instance.
   * When true, the external_cache field must be configured.
   */
  bool is_external = 1;

  /**
   * External Redis cache connection details.
   * This field is required when is_external is true and ignored when false.
   */
  KubernetesHarborExternalRedis external_cache = 2;

  /**
   * Self-managed Redis configuration.
   * This field is used when is_external is false and configures the in-cluster Redis deployment.
   */
  KubernetesHarborManagedRedis managed_cache = 3;

  option (buf.validate.message).cel = {
    id: "spec.cache.external_required"
    expression: "!this.is_external || has(this.external_cache)"
    message: "External cache configuration is required when is_external is true"
  };
}

/**
 * **KubernetesHarborExternalRedis** defines connection parameters for an external Redis instance.
 * This allows Harbor to use a pre-existing Redis cache instead of deploying one within the cluster.
 */
message KubernetesHarborExternalRedis {
  // The hostname or endpoint of the external Redis instance (e.g., "redis.example.com:6379").
  string host = 1 [(buf.validate.field).required = true];

  // The port for Redis (default is 6379).
  optional int32 port = 2 [
    (org.project_planton.shared.options.default) = "6379",
    (buf.validate.field).int32.gt = 0,
    (buf.validate.field).int32.lte = 65535
  ];

  // The username for authenticating to Redis (if ACLs are enabled).
  string username = 3;

  // The password for authenticating to Redis.
  string password = 4;

  // The Redis database index to use (default is 0).
  optional int32 database_index = 5 [(org.project_planton.shared.options.default) = "0"];

  // Whether to use Sentinel for high availability.
  bool use_sentinel = 6;

  // The Sentinel master set name (required if use_sentinel is true).
  string sentinel_master_set = 7;

  option (buf.validate.message).cel = {
    id: "spec.cache.sentinel_master_required"
    expression: "!this.use_sentinel || size(this.sentinel_master_set) > 0"
    message: "Sentinel master set name is required when use_sentinel is true"
  };
}

/**
 * **KubernetesHarborManagedRedis** defines configuration for a self-managed Redis deployment.
 * This supports simple single-node deployments suitable for development and testing.
 */
message KubernetesHarborManagedRedis {
  // The container specifications for Redis.
  KubernetesHarborRedisContainer container = 1 [(default_redis_container) = {
    replicas: 1
    resources: {
      limits: {
        cpu: "500m"
        memory: "512Mi"
      }
      requests: {
        cpu: "100m"
        memory: "256Mi"
      }
    }
    persistence_enabled: true
    disk_size: "8Gi"
  }];
}

/**
 * **KubernetesHarborRedisContainer** specifies the container configuration for Redis.
 * It includes replica count, resource allocations, and persistence settings.
 */
message KubernetesHarborRedisContainer {
  // The number of Redis pods to deploy.
  int32 replicas = 1 [(buf.validate.field).int32.gte = 1];

  // The CPU and memory resources allocated to the Redis container.
  org.project_planton.shared.kubernetes.ContainerResources resources = 2;

  // The container image configuration for Redis.
  org.project_planton.shared.kubernetes.ContainerImage image = 3;

  /**
   * Flag to enable or disable data persistence for Redis.
   * When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
   * Defaults to true.
   */
  bool persistence_enabled = 4;

  /**
   * The size of the persistent volume attached to each Redis pod (e.g., "8Gi").
   * This attribute is ignored when persistence is not enabled.
   */
  string disk_size = 5;

  option (buf.validate.message).cel = {
    id: "spec.redis.container.disk_size.required"
    expression: "((!this.persistence_enabled && (size(this.disk_size) == 0 || this.disk_size == '')) || (this.persistence_enabled && size(this.disk_size) > 0 && this.disk_size.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')))"
    message: "Disk size is required and must match the format if persistence is enabled"
  };
}

/**
 * **KubernetesHarborStorageType** enumerates the supported storage backends for Harbor artifacts.
 */
enum KubernetesHarborStorageType {
  // unspecified should not be used
  kubernetes_harbor_storage_type_unspecified = 0;

  // Filesystem storage (PVC) - suitable for development only, not recommended for production HA
  filesystem = 1;

  // AWS S3 or S3-compatible object storage
  s3 = 2;

  // Google Cloud Storage
  gcs = 3;

  // Azure Blob Storage
  azure = 4;

  // Alibaba Cloud OSS
  oss = 5;
}

/**
 * **KubernetesHarborStorageConfig** defines the storage configuration for Harbor artifacts.
 * For production high-availability deployments, external object storage (S3, GCS, Azure) is required.
 */
message KubernetesHarborStorageConfig {
  // The type of storage backend to use.
  KubernetesHarborStorageType type = 1 [(buf.validate.field).required = true];

  // S3-compatible storage configuration (required when type is s3).
  KubernetesHarborS3Storage s3 = 2;

  // Google Cloud Storage configuration (required when type is gcs).
  KubernetesHarborGcsStorage gcs = 3;

  // Azure Blob Storage configuration (required when type is azure).
  KubernetesHarborAzureStorage azure = 4;

  // Alibaba Cloud OSS configuration (required when type is oss).
  KubernetesHarborOssStorage oss = 5;

  // Filesystem storage configuration (required when type is filesystem).
  KubernetesHarborFilesystemStorage filesystem = 6;

  option (buf.validate.message).cel = {
    id: "spec.storage.s3_required"
    expression: "this.type != 2 || has(this.s3)"
    message: "S3 configuration is required when storage type is s3"
  };

  option (buf.validate.message).cel = {
    id: "spec.storage.gcs_required"
    expression: "this.type != 3 || has(this.gcs)"
    message: "GCS configuration is required when storage type is gcs"
  };

  option (buf.validate.message).cel = {
    id: "spec.storage.azure_required"
    expression: "this.type != 4 || has(this.azure)"
    message: "Azure configuration is required when storage type is azure"
  };

  option (buf.validate.message).cel = {
    id: "spec.storage.oss_required"
    expression: "this.type != 5 || has(this.oss)"
    message: "OSS configuration is required when storage type is oss"
  };

  option (buf.validate.message).cel = {
    id: "spec.storage.filesystem_required"
    expression: "this.type != 1 || has(this.filesystem)"
    message: "Filesystem configuration is required when storage type is filesystem"
  };
}

/**
 * **KubernetesHarborS3Storage** defines S3-compatible object storage configuration.
 */
message KubernetesHarborS3Storage {
  // The S3 bucket name.
  string bucket = 1 [(buf.validate.field).required = true];

  // The AWS region (e.g., "us-west-2").
  string region = 2 [(buf.validate.field).required = true];

  // The AWS access key ID.
  string access_key = 3 [(buf.validate.field).required = true];

  // The AWS secret access key.
  string secret_key = 4 [(buf.validate.field).required = true];

  // Whether to use regional endpoint (default is false for global endpoint).
  bool region_endpoint = 5;

  // Whether to encrypt objects using server-side encryption.
  bool encrypt = 6;

  // Whether to use secure (HTTPS) connection.
  bool secure = 7;

  // The root directory path within the bucket.
  string root_directory = 8;

  // Custom S3 endpoint URL (for S3-compatible services like MinIO).
  string endpoint_url = 9;
}

/**
 * **KubernetesHarborGcsStorage** defines Google Cloud Storage configuration.
 */
message KubernetesHarborGcsStorage {
  // The GCS bucket name.
  string bucket = 1 [(buf.validate.field).required = true];

  // The base64-encoded service account key JSON.
  string key_data = 2 [(buf.validate.field).required = true];

  // The root directory path within the bucket.
  string root_directory = 3;

  // The chunk size for upload (default is 5242880 bytes).
  optional int32 chunk_size = 4 [(org.project_planton.shared.options.default) = "5242880"];
}

/**
 * **KubernetesHarborAzureStorage** defines Azure Blob Storage configuration.
 */
message KubernetesHarborAzureStorage {
  // The Azure storage account name.
  string account_name = 1 [(buf.validate.field).required = true];

  // The Azure storage account key.
  string account_key = 2 [(buf.validate.field).required = true];

  // The Azure blob container name.
  string container = 3 [(buf.validate.field).required = true];

  // The root directory path within the container.
  string root_directory = 4;
}

/**
 * **KubernetesHarborOssStorage** defines Alibaba Cloud OSS configuration.
 */
message KubernetesHarborOssStorage {
  // The OSS bucket name.
  string bucket = 1 [(buf.validate.field).required = true];

  // The OSS endpoint (e.g., "oss-cn-hangzhou.aliyuncs.com").
  string endpoint = 2 [(buf.validate.field).required = true];

  // The access key ID.
  string access_key_id = 3 [(buf.validate.field).required = true];

  // The access key secret.
  string access_key_secret = 4 [(buf.validate.field).required = true];

  // The root directory path within the bucket.
  string root_directory = 5;

  // Whether to use HTTPS.
  bool secure = 6;
}

/**
 * **KubernetesHarborFilesystemStorage** defines filesystem (PVC) storage configuration.
 * Note: This is not suitable for production high-availability deployments.
 */
message KubernetesHarborFilesystemStorage {
  /**
   * The size of the persistent volume for storing artifacts (e.g., "100Gi").
   * Note: This value cannot be modified after creation due to Kubernetes PVC limitations.
   */
  string disk_size = 1 [(buf.validate.field).cel = {
    id: "spec.storage.filesystem.disk_size.required"
    message: "Disk size is required and must match the format"
    expression: "size(this) > 0 && this.matches('^\\\\d+(\\\\.\\\\d+)?\\\\s?(Ki|Mi|Gi|Ti|Pi|Ei|K|M|G|T|P|E)$')"
  }];

  // The storage class to use for the PVC.
  string storage_class = 2;
}

/**
 * **KubernetesHarborIngress** defines the ingress configuration for Harbor endpoints.
 * It provides separate ingress settings for the Core/Portal UI and Notary service.
 */
message KubernetesHarborIngress {
  // Ingress configuration for Harbor Core and Portal (web UI and API).
  KubernetesHarborIngressEndpoint core = 1;

  // Ingress configuration for Notary service (image signing).
  KubernetesHarborIngressEndpoint notary = 2;
}

/**
 * **KubernetesHarborIngressEndpoint** defines ingress configuration for a specific Harbor endpoint.
 */
message KubernetesHarborIngressEndpoint {
  // Flag to enable or disable ingress for this endpoint.
  bool enabled = 1;

  // The full hostname for external access (e.g., "harbor.example.com").
  // This hostname will be configured via Gateway API resources.
  // Required when enabled is true.
  string hostname = 2;

  option (buf.validate.message).cel = {
    id: "spec.ingress.hostname.required"
    expression: "!this.enabled || size(this.hostname) > 0"
    message: "hostname is required when ingress is enabled"
  };
}
