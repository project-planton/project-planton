// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: org/project_planton/provider/gcp/gcpcloudcdn/v1/spec.proto

package gcpcloudcdnv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	v1 "github.com/project-planton/project-planton/apis/org/project_planton/shared/foreignkey/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// **CacheMode** defines the caching strategy for Cloud CDN.
type CacheMode int32

const (
	// Unspecified cache mode (will use GCP default: CACHE_ALL_STATIC).
	CacheMode_CACHE_MODE_UNSPECIFIED CacheMode = 0
	// Automatically cache static content (CSS, JS, images) and respect Cache-Control headers.
	// Recommended for 90% of deployments - safe and flexible.
	CacheMode_CACHE_ALL_STATIC CacheMode = 1
	// Only cache content with explicit Cache-Control or Expires headers from origin.
	// Use when origin has perfect cache header management.
	CacheMode_USE_ORIGIN_HEADERS CacheMode = 2
	// Aggressively cache all 200 OK responses, ignoring Cache-Control: private/no-store.
	// WARNING: Use ONLY for public static content. Risk of data leak if misused.
	CacheMode_FORCE_CACHE_ALL CacheMode = 3
)

// Enum value maps for CacheMode.
var (
	CacheMode_name = map[int32]string{
		0: "CACHE_MODE_UNSPECIFIED",
		1: "CACHE_ALL_STATIC",
		2: "USE_ORIGIN_HEADERS",
		3: "FORCE_CACHE_ALL",
	}
	CacheMode_value = map[string]int32{
		"CACHE_MODE_UNSPECIFIED": 0,
		"CACHE_ALL_STATIC":       1,
		"USE_ORIGIN_HEADERS":     2,
		"FORCE_CACHE_ALL":        3,
	}
)

func (x CacheMode) Enum() *CacheMode {
	p := new(CacheMode)
	*p = x
	return p
}

func (x CacheMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CacheMode) Descriptor() protoreflect.EnumDescriptor {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_enumTypes[0].Descriptor()
}

func (CacheMode) Type() protoreflect.EnumType {
	return &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_enumTypes[0]
}

func (x CacheMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CacheMode.Descriptor instead.
func (CacheMode) EnumDescriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{0}
}

// **BackendProtocol** defines the protocol used to connect to backend origin.
type BackendProtocol int32

const (
	// Unspecified protocol (will use default based on backend type).
	BackendProtocol_BACKEND_PROTOCOL_UNSPECIFIED BackendProtocol = 0
	// HTTP protocol (port 80 default).
	BackendProtocol_HTTP BackendProtocol = 1
	// HTTPS protocol (port 443 default, recommended for security).
	BackendProtocol_HTTPS BackendProtocol = 2
)

// Enum value maps for BackendProtocol.
var (
	BackendProtocol_name = map[int32]string{
		0: "BACKEND_PROTOCOL_UNSPECIFIED",
		1: "HTTP",
		2: "HTTPS",
	}
	BackendProtocol_value = map[string]int32{
		"BACKEND_PROTOCOL_UNSPECIFIED": 0,
		"HTTP":                         1,
		"HTTPS":                        2,
	}
)

func (x BackendProtocol) Enum() *BackendProtocol {
	p := new(BackendProtocol)
	*p = x
	return p
}

func (x BackendProtocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BackendProtocol) Descriptor() protoreflect.EnumDescriptor {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_enumTypes[1].Descriptor()
}

func (BackendProtocol) Type() protoreflect.EnumType {
	return &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_enumTypes[1]
}

func (x BackendProtocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BackendProtocol.Descriptor instead.
func (BackendProtocol) EnumDescriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{1}
}

// **GcpCloudCdnSpec** defines the configuration for deploying a Google Cloud CDN (Content Delivery Network).
// This message specifies the necessary parameters to create and manage a Cloud CDN within a
// specified GCP project. Cloud CDN is a feature of Google's Global Application Load Balancer that
// caches content at edge locations globally, improving load times and reducing latency for end-users.
//
// Following the 80/20 configuration principle, essential CDN settings (backend, cache mode, TTLs)
// are top-level fields, while advanced configuration (cache keys, signed URLs) are nested for clarity.
type GcpCloudCdnSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the GCP project where the Cloud CDN resources will be created.
	// This field supports cross-resource references using ValueFrom to dynamically
	// retrieve the project ID from a GcpProject resource.
	// Required field.
	GcpProjectId *v1.StringValueOrRef `protobuf:"bytes,1,opt,name=gcp_project_id,json=gcpProjectId,proto3" json:"gcp_project_id,omitempty"`
	// Backend configuration defines the origin server that Cloud CDN will cache content from.
	// This can be a GCS bucket, Compute Engine service, Cloud Run, or external origin.
	// Required field.
	Backend *GcpCloudCdnBackend `protobuf:"bytes,2,opt,name=backend,proto3" json:"backend,omitempty"`
	// Cache mode determines what content gets cached and when to trust origin headers.
	// CACHE_ALL_STATIC (default): Automatically caches common static file types and respects Cache-Control headers.
	// USE_ORIGIN_HEADERS: Only caches content with valid Cache-Control or Expires headers from origin.
	// FORCE_CACHE_ALL: Aggressively caches all 200 OK responses (use only for public static content).
	// Default: CACHE_ALL_STATIC (recommended for 90% of deployments).
	CacheMode *CacheMode `protobuf:"varint,3,opt,name=cache_mode,json=cacheMode,proto3,enum=org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheMode,oneof" json:"cache_mode,omitempty"`
	// Default Time-To-Live (TTL) in seconds for cached content when origin doesn't specify Cache-Control.
	// Recommended: 3600 (1 hour) for most use cases.
	// Optional field. If not set, GCP uses default of 3600 seconds.
	DefaultTtlSeconds *int32 `protobuf:"varint,4,opt,name=default_ttl_seconds,json=defaultTtlSeconds,proto3,oneof" json:"default_ttl_seconds,omitempty"`
	// Maximum TTL in seconds. This is a hard ceiling that overrides origin Cache-Control headers.
	// Recommended: 86400 (1 day) to balance freshness and cache hit ratio.
	// Optional field. If not set, GCP uses default of 86400 seconds.
	MaxTtlSeconds *int32 `protobuf:"varint,5,opt,name=max_ttl_seconds,json=maxTtlSeconds,proto3,oneof" json:"max_ttl_seconds,omitempty"`
	// Client TTL in seconds. Overrides max-age directive for browser caches.
	// Use this to set different cache duration for browsers vs edge caches.
	// Optional field. If not set, uses max_ttl_seconds.
	ClientTtlSeconds *int32 `protobuf:"varint,6,opt,name=client_ttl_seconds,json=clientTtlSeconds,proto3,oneof" json:"client_ttl_seconds,omitempty"`
	// Enable caching of HTTP 4xx/5xx error responses to prevent origin overload during failures.
	// Recommended: true (best practice to cache 404s and 5xx errors).
	// Default: false.
	EnableNegativeCaching *bool `protobuf:"varint,7,opt,name=enable_negative_caching,json=enableNegativeCaching,proto3,oneof" json:"enable_negative_caching,omitempty"`
	// Advanced cache configuration (20% of use cases).
	// Configure cache keys, signed URLs, and granular caching policies.
	AdvancedConfig *GcpCloudCdnAdvancedConfig `protobuf:"bytes,8,opt,name=advanced_config,json=advancedConfig,proto3,oneof" json:"advanced_config,omitempty"`
	// Load balancer frontend configuration (SSL certificates, domains, Cloud Armor).
	// If not specified, creates a basic load balancer with auto-generated HTTPS setup.
	FrontendConfig *GcpCloudCdnFrontendConfig `protobuf:"bytes,9,opt,name=frontend_config,json=frontendConfig,proto3,oneof" json:"frontend_config,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GcpCloudCdnSpec) Reset() {
	*x = GcpCloudCdnSpec{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GcpCloudCdnSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GcpCloudCdnSpec) ProtoMessage() {}

func (x *GcpCloudCdnSpec) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GcpCloudCdnSpec.ProtoReflect.Descriptor instead.
func (*GcpCloudCdnSpec) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *GcpCloudCdnSpec) GetGcpProjectId() *v1.StringValueOrRef {
	if x != nil {
		return x.GcpProjectId
	}
	return nil
}

func (x *GcpCloudCdnSpec) GetBackend() *GcpCloudCdnBackend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *GcpCloudCdnSpec) GetCacheMode() CacheMode {
	if x != nil && x.CacheMode != nil {
		return *x.CacheMode
	}
	return CacheMode_CACHE_MODE_UNSPECIFIED
}

func (x *GcpCloudCdnSpec) GetDefaultTtlSeconds() int32 {
	if x != nil && x.DefaultTtlSeconds != nil {
		return *x.DefaultTtlSeconds
	}
	return 0
}

func (x *GcpCloudCdnSpec) GetMaxTtlSeconds() int32 {
	if x != nil && x.MaxTtlSeconds != nil {
		return *x.MaxTtlSeconds
	}
	return 0
}

func (x *GcpCloudCdnSpec) GetClientTtlSeconds() int32 {
	if x != nil && x.ClientTtlSeconds != nil {
		return *x.ClientTtlSeconds
	}
	return 0
}

func (x *GcpCloudCdnSpec) GetEnableNegativeCaching() bool {
	if x != nil && x.EnableNegativeCaching != nil {
		return *x.EnableNegativeCaching
	}
	return false
}

func (x *GcpCloudCdnSpec) GetAdvancedConfig() *GcpCloudCdnAdvancedConfig {
	if x != nil {
		return x.AdvancedConfig
	}
	return nil
}

func (x *GcpCloudCdnSpec) GetFrontendConfig() *GcpCloudCdnFrontendConfig {
	if x != nil {
		return x.FrontendConfig
	}
	return nil
}

// **GcpCloudCdnBackend** defines the origin server configuration for Cloud CDN.
// Cloud CDN supports multiple backend types: GCS buckets (static content),
// Compute Engine (VMs), Cloud Run (serverless), and external origins.
type GcpCloudCdnBackend struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Backend type determines what kind of origin Cloud CDN will use.
	// Required field.
	//
	// Types that are valid to be assigned to BackendType:
	//
	//	*GcpCloudCdnBackend_GcsBucket
	//	*GcpCloudCdnBackend_ComputeService
	//	*GcpCloudCdnBackend_CloudRunService
	//	*GcpCloudCdnBackend_ExternalOrigin
	BackendType   isGcpCloudCdnBackend_BackendType `protobuf_oneof:"backend_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GcpCloudCdnBackend) Reset() {
	*x = GcpCloudCdnBackend{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GcpCloudCdnBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GcpCloudCdnBackend) ProtoMessage() {}

func (x *GcpCloudCdnBackend) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GcpCloudCdnBackend.ProtoReflect.Descriptor instead.
func (*GcpCloudCdnBackend) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *GcpCloudCdnBackend) GetBackendType() isGcpCloudCdnBackend_BackendType {
	if x != nil {
		return x.BackendType
	}
	return nil
}

func (x *GcpCloudCdnBackend) GetGcsBucket() *GcsBackendConfig {
	if x != nil {
		if x, ok := x.BackendType.(*GcpCloudCdnBackend_GcsBucket); ok {
			return x.GcsBucket
		}
	}
	return nil
}

func (x *GcpCloudCdnBackend) GetComputeService() *ComputeBackendConfig {
	if x != nil {
		if x, ok := x.BackendType.(*GcpCloudCdnBackend_ComputeService); ok {
			return x.ComputeService
		}
	}
	return nil
}

func (x *GcpCloudCdnBackend) GetCloudRunService() *CloudRunBackendConfig {
	if x != nil {
		if x, ok := x.BackendType.(*GcpCloudCdnBackend_CloudRunService); ok {
			return x.CloudRunService
		}
	}
	return nil
}

func (x *GcpCloudCdnBackend) GetExternalOrigin() *ExternalBackendConfig {
	if x != nil {
		if x, ok := x.BackendType.(*GcpCloudCdnBackend_ExternalOrigin); ok {
			return x.ExternalOrigin
		}
	}
	return nil
}

type isGcpCloudCdnBackend_BackendType interface {
	isGcpCloudCdnBackend_BackendType()
}

type GcpCloudCdnBackend_GcsBucket struct {
	// Google Cloud Storage bucket backend for static website hosting and file downloads.
	// Most common use case (~80% of deployments).
	GcsBucket *GcsBackendConfig `protobuf:"bytes,1,opt,name=gcs_bucket,json=gcsBucket,proto3,oneof"`
}

type GcpCloudCdnBackend_ComputeService struct {
	// Compute Engine backend service for VMs (Managed Instance Groups).
	// Use for traditional web applications and APIs.
	ComputeService *ComputeBackendConfig `protobuf:"bytes,2,opt,name=compute_service,json=computeService,proto3,oneof"`
}

type GcpCloudCdnBackend_CloudRunService struct {
	// Cloud Run backend for serverless container workloads.
	// Automatically creates Serverless Network Endpoint Group (NEG).
	CloudRunService *CloudRunBackendConfig `protobuf:"bytes,3,opt,name=cloud_run_service,json=cloudRunService,proto3,oneof"`
}

type GcpCloudCdnBackend_ExternalOrigin struct {
	// External/hybrid backend for origins outside GCP (AWS S3, on-prem servers).
	// Uses Internet Network Endpoint Group.
	ExternalOrigin *ExternalBackendConfig `protobuf:"bytes,4,opt,name=external_origin,json=externalOrigin,proto3,oneof"`
}

func (*GcpCloudCdnBackend_GcsBucket) isGcpCloudCdnBackend_BackendType() {}

func (*GcpCloudCdnBackend_ComputeService) isGcpCloudCdnBackend_BackendType() {}

func (*GcpCloudCdnBackend_CloudRunService) isGcpCloudCdnBackend_BackendType() {}

func (*GcpCloudCdnBackend_ExternalOrigin) isGcpCloudCdnBackend_BackendType() {}

// **GcsBackendConfig** configures a Google Cloud Storage bucket as the CDN origin.
// Use this for static websites, media files, and downloadable content.
type GcsBackendConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the GCS bucket to use as origin.
	// The bucket must already exist in the same GCP project.
	// Required field.
	BucketName string `protobuf:"bytes,1,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// Enable uniform bucket-level access (recommended for security).
	// When true, uses IAM for all access control (no legacy ACLs).
	// Default: true.
	EnableUniformAccess *bool `protobuf:"varint,2,opt,name=enable_uniform_access,json=enableUniformAccess,proto3,oneof" json:"enable_uniform_access,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *GcsBackendConfig) Reset() {
	*x = GcsBackendConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GcsBackendConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GcsBackendConfig) ProtoMessage() {}

func (x *GcsBackendConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GcsBackendConfig.ProtoReflect.Descriptor instead.
func (*GcsBackendConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *GcsBackendConfig) GetBucketName() string {
	if x != nil {
		return x.BucketName
	}
	return ""
}

func (x *GcsBackendConfig) GetEnableUniformAccess() bool {
	if x != nil && x.EnableUniformAccess != nil {
		return *x.EnableUniformAccess
	}
	return false
}

// **ComputeBackendConfig** configures Compute Engine as the CDN origin.
// Use this for VM-based web applications and APIs.
type ComputeBackendConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the Managed Instance Group to use as backend.
	// Required field.
	InstanceGroupName string `protobuf:"bytes,1,opt,name=instance_group_name,json=instanceGroupName,proto3" json:"instance_group_name,omitempty"`
	// Health check configuration for the backend instances.
	// If not specified, creates a default HTTP health check.
	HealthCheck *HealthCheckConfig `protobuf:"bytes,2,opt,name=health_check,json=healthCheck,proto3,oneof" json:"health_check,omitempty"`
	// Backend protocol (HTTP or HTTPS).
	// Default: HTTP.
	Protocol *BackendProtocol `protobuf:"varint,3,opt,name=protocol,proto3,enum=org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocol,oneof" json:"protocol,omitempty"`
	// Port number where backend instances serve traffic.
	// Default: 80 for HTTP, 443 for HTTPS.
	Port          *int32 `protobuf:"varint,4,opt,name=port,proto3,oneof" json:"port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComputeBackendConfig) Reset() {
	*x = ComputeBackendConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeBackendConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeBackendConfig) ProtoMessage() {}

func (x *ComputeBackendConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputeBackendConfig.ProtoReflect.Descriptor instead.
func (*ComputeBackendConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *ComputeBackendConfig) GetInstanceGroupName() string {
	if x != nil {
		return x.InstanceGroupName
	}
	return ""
}

func (x *ComputeBackendConfig) GetHealthCheck() *HealthCheckConfig {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *ComputeBackendConfig) GetProtocol() BackendProtocol {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return BackendProtocol_BACKEND_PROTOCOL_UNSPECIFIED
}

func (x *ComputeBackendConfig) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

// **CloudRunBackendConfig** configures Cloud Run as the CDN origin.
// Automatically creates a Serverless Network Endpoint Group for the Cloud Run service.
type CloudRunBackendConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the Cloud Run service to use as backend.
	// The service must be deployed in the same GCP project.
	// Required field.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// GCP region where the Cloud Run service is deployed.
	// Required field.
	Region        string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloudRunBackendConfig) Reset() {
	*x = CloudRunBackendConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloudRunBackendConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloudRunBackendConfig) ProtoMessage() {}

func (x *CloudRunBackendConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloudRunBackendConfig.ProtoReflect.Descriptor instead.
func (*CloudRunBackendConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{4}
}

func (x *CloudRunBackendConfig) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *CloudRunBackendConfig) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

// **ExternalBackendConfig** configures an external origin (outside GCP).
// Use this for hybrid/multi-cloud deployments or gradual migration to GCP.
type ExternalBackendConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Fully qualified domain name (FQDN) or IP address of the external origin.
	// Required field.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Port number where the external origin serves traffic.
	// Default: 443 for HTTPS, 80 for HTTP.
	Port *int32 `protobuf:"varint,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
	// Protocol for connecting to external origin.
	// Default: HTTPS (recommended for security).
	Protocol      *BackendProtocol `protobuf:"varint,3,opt,name=protocol,proto3,enum=org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocol,oneof" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExternalBackendConfig) Reset() {
	*x = ExternalBackendConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalBackendConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalBackendConfig) ProtoMessage() {}

func (x *ExternalBackendConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalBackendConfig.ProtoReflect.Descriptor instead.
func (*ExternalBackendConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{5}
}

func (x *ExternalBackendConfig) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *ExternalBackendConfig) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *ExternalBackendConfig) GetProtocol() BackendProtocol {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return BackendProtocol_BACKEND_PROTOCOL_UNSPECIFIED
}

// **HealthCheckConfig** defines health check configuration for backend instances.
type HealthCheckConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path to use for health check requests.
	// Default: / (root path).
	Path *string `protobuf:"bytes,1,opt,name=path,proto3,oneof" json:"path,omitempty"`
	// Port to use for health checks.
	// If not specified, uses the backend port.
	Port *int32 `protobuf:"varint,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
	// Interval between health checks in seconds.
	// Default: 5 seconds.
	CheckIntervalSeconds *int32 `protobuf:"varint,3,opt,name=check_interval_seconds,json=checkIntervalSeconds,proto3,oneof" json:"check_interval_seconds,omitempty"`
	// Timeout for each health check in seconds.
	// Default: 5 seconds.
	TimeoutSeconds *int32 `protobuf:"varint,4,opt,name=timeout_seconds,json=timeoutSeconds,proto3,oneof" json:"timeout_seconds,omitempty"`
	// Number of consecutive successes required to mark backend healthy.
	// Default: 2.
	HealthyThreshold *int32 `protobuf:"varint,5,opt,name=healthy_threshold,json=healthyThreshold,proto3,oneof" json:"healthy_threshold,omitempty"`
	// Number of consecutive failures required to mark backend unhealthy.
	// Default: 2.
	UnhealthyThreshold *int32 `protobuf:"varint,6,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3,oneof" json:"unhealthy_threshold,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *HealthCheckConfig) Reset() {
	*x = HealthCheckConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckConfig) ProtoMessage() {}

func (x *HealthCheckConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckConfig.ProtoReflect.Descriptor instead.
func (*HealthCheckConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{6}
}

func (x *HealthCheckConfig) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *HealthCheckConfig) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *HealthCheckConfig) GetCheckIntervalSeconds() int32 {
	if x != nil && x.CheckIntervalSeconds != nil {
		return *x.CheckIntervalSeconds
	}
	return 0
}

func (x *HealthCheckConfig) GetTimeoutSeconds() int32 {
	if x != nil && x.TimeoutSeconds != nil {
		return *x.TimeoutSeconds
	}
	return 0
}

func (x *HealthCheckConfig) GetHealthyThreshold() int32 {
	if x != nil && x.HealthyThreshold != nil {
		return *x.HealthyThreshold
	}
	return 0
}

func (x *HealthCheckConfig) GetUnhealthyThreshold() int32 {
	if x != nil && x.UnhealthyThreshold != nil {
		return *x.UnhealthyThreshold
	}
	return 0
}

// **GcpCloudCdnAdvancedConfig** contains advanced CDN configuration options (20% use cases).
// These settings provide fine-grained control over caching behavior, security, and optimization.
type GcpCloudCdnAdvancedConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Cache key policy controls what request attributes are included in the cache key.
	// Tune this to avoid "cache shattering" (too many unique cache keys with low hit ratio).
	CacheKeyPolicy *CacheKeyPolicy `protobuf:"bytes,1,opt,name=cache_key_policy,json=cacheKeyPolicy,proto3,oneof" json:"cache_key_policy,omitempty"`
	// Signed URL configuration for serving private/paid content via Cloud CDN.
	// Enables time-limited, cryptographically signed URLs for access control.
	SignedUrlConfig *SignedUrlConfig `protobuf:"bytes,2,opt,name=signed_url_config,json=signedUrlConfig,proto3,oneof" json:"signed_url_config,omitempty"`
	// Negative caching policies per HTTP status code.
	// Allows granular control over error response caching (e.g., cache 404 for 10 minutes, 503 for 1 minute).
	NegativeCachingPolicies []*NegativeCachingPolicy `protobuf:"bytes,3,rep,name=negative_caching_policies,json=negativeCachingPolicies,proto3" json:"negative_caching_policies,omitempty"`
	// Serve stale content while revalidating with origin (RFC 5861 stale-while-revalidate).
	// Improves performance by serving cached content immediately while fetching fresh content in background.
	// Value in seconds. Default: 0 (disabled).
	ServeWhileStaleSeconds *int32 `protobuf:"varint,4,opt,name=serve_while_stale_seconds,json=serveWhileStaleSeconds,proto3,oneof" json:"serve_while_stale_seconds,omitempty"`
	// Request coalescing combines multiple identical requests into one origin fetch.
	// Reduces origin load during cache misses. Recommended: true.
	// Default: true.
	EnableRequestCoalescing *bool `protobuf:"varint,5,opt,name=enable_request_coalescing,json=enableRequestCoalescing,proto3,oneof" json:"enable_request_coalescing,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *GcpCloudCdnAdvancedConfig) Reset() {
	*x = GcpCloudCdnAdvancedConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GcpCloudCdnAdvancedConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GcpCloudCdnAdvancedConfig) ProtoMessage() {}

func (x *GcpCloudCdnAdvancedConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GcpCloudCdnAdvancedConfig.ProtoReflect.Descriptor instead.
func (*GcpCloudCdnAdvancedConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{7}
}

func (x *GcpCloudCdnAdvancedConfig) GetCacheKeyPolicy() *CacheKeyPolicy {
	if x != nil {
		return x.CacheKeyPolicy
	}
	return nil
}

func (x *GcpCloudCdnAdvancedConfig) GetSignedUrlConfig() *SignedUrlConfig {
	if x != nil {
		return x.SignedUrlConfig
	}
	return nil
}

func (x *GcpCloudCdnAdvancedConfig) GetNegativeCachingPolicies() []*NegativeCachingPolicy {
	if x != nil {
		return x.NegativeCachingPolicies
	}
	return nil
}

func (x *GcpCloudCdnAdvancedConfig) GetServeWhileStaleSeconds() int32 {
	if x != nil && x.ServeWhileStaleSeconds != nil {
		return *x.ServeWhileStaleSeconds
	}
	return 0
}

func (x *GcpCloudCdnAdvancedConfig) GetEnableRequestCoalescing() bool {
	if x != nil && x.EnableRequestCoalescing != nil {
		return *x.EnableRequestCoalescing
	}
	return false
}

// **CacheKeyPolicy** controls what attributes are included in the cache key.
// The cache key determines whether two requests share the same cached response.
// Default: Protocol + Host + Path + Query String.
type CacheKeyPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Include URL query string in cache key.
	// Set to false if query parameters don't affect response content (e.g., analytics parameters).
	// Default: true.
	IncludeQueryString *bool `protobuf:"varint,1,opt,name=include_query_string,json=includeQueryString,proto3,oneof" json:"include_query_string,omitempty"`
	// Whitelist of query parameters to include in cache key.
	// All other query parameters are ignored, preventing cache shattering.
	// Example: ["version", "lang", "page"] - only these params affect caching.
	// If empty, includes all query parameters (when include_query_string = true).
	QueryStringWhitelist []string `protobuf:"bytes,2,rep,name=query_string_whitelist,json=queryStringWhitelist,proto3" json:"query_string_whitelist,omitempty"`
	// Include request protocol (HTTP vs HTTPS) in cache key.
	// Default: true (recommended to keep separate caches for HTTP and HTTPS).
	IncludeProtocol *bool `protobuf:"varint,3,opt,name=include_protocol,json=includeProtocol,proto3,oneof" json:"include_protocol,omitempty"`
	// Include Host header in cache key.
	// Set to false if serving the same content for multiple hostnames.
	// Default: true.
	IncludeHost *bool `protobuf:"varint,4,opt,name=include_host,json=includeHost,proto3,oneof" json:"include_host,omitempty"`
	// Include specific request headers in the cache key.
	// Use sparingly - too many headers in cache key leads to cache shattering.
	// Cloud CDN only supports: Accept, Accept-Encoding, Origin.
	IncludedHeaders []string `protobuf:"bytes,5,rep,name=included_headers,json=includedHeaders,proto3" json:"included_headers,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CacheKeyPolicy) Reset() {
	*x = CacheKeyPolicy{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CacheKeyPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CacheKeyPolicy) ProtoMessage() {}

func (x *CacheKeyPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CacheKeyPolicy.ProtoReflect.Descriptor instead.
func (*CacheKeyPolicy) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{8}
}

func (x *CacheKeyPolicy) GetIncludeQueryString() bool {
	if x != nil && x.IncludeQueryString != nil {
		return *x.IncludeQueryString
	}
	return false
}

func (x *CacheKeyPolicy) GetQueryStringWhitelist() []string {
	if x != nil {
		return x.QueryStringWhitelist
	}
	return nil
}

func (x *CacheKeyPolicy) GetIncludeProtocol() bool {
	if x != nil && x.IncludeProtocol != nil {
		return *x.IncludeProtocol
	}
	return false
}

func (x *CacheKeyPolicy) GetIncludeHost() bool {
	if x != nil && x.IncludeHost != nil {
		return *x.IncludeHost
	}
	return false
}

func (x *CacheKeyPolicy) GetIncludedHeaders() []string {
	if x != nil {
		return x.IncludedHeaders
	}
	return nil
}

// **SignedUrlConfig** enables signed URLs for private content delivery via Cloud CDN.
// Generate time-limited URLs with cryptographic signatures to control access to cached content.
type SignedUrlConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable signed URL validation.
	// Required: true to activate signed URL feature.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// List of signing keys for URL validation.
	// Multiple keys enable key rotation without downtime.
	// Required when enabled = true.
	Keys          []*SignedUrlKey `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignedUrlConfig) Reset() {
	*x = SignedUrlConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedUrlConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedUrlConfig) ProtoMessage() {}

func (x *SignedUrlConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedUrlConfig.ProtoReflect.Descriptor instead.
func (*SignedUrlConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{9}
}

func (x *SignedUrlConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *SignedUrlConfig) GetKeys() []*SignedUrlKey {
	if x != nil {
		return x.Keys
	}
	return nil
}

// **SignedUrlKey** defines a cryptographic key for signing and validating URLs.
type SignedUrlKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique name for this signing key.
	// Used to identify which key signed a URL.
	// Required field.
	KeyName string `protobuf:"bytes,1,opt,name=key_name,json=keyName,proto3" json:"key_name,omitempty"`
	// Base64-encoded key value (128-bit recommended).
	// Generate with: openssl rand -base64 16
	// Required field.
	KeyValue      string `protobuf:"bytes,2,opt,name=key_value,json=keyValue,proto3" json:"key_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignedUrlKey) Reset() {
	*x = SignedUrlKey{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedUrlKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedUrlKey) ProtoMessage() {}

func (x *SignedUrlKey) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedUrlKey.ProtoReflect.Descriptor instead.
func (*SignedUrlKey) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{10}
}

func (x *SignedUrlKey) GetKeyName() string {
	if x != nil {
		return x.KeyName
	}
	return ""
}

func (x *SignedUrlKey) GetKeyValue() string {
	if x != nil {
		return x.KeyValue
	}
	return ""
}

// **NegativeCachingPolicy** defines caching behavior for specific HTTP error codes.
// Prevents origin overload by caching error responses at the edge.
type NegativeCachingPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// HTTP status code to cache (e.g., 404, 503).
	// Required field.
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// TTL in seconds for caching this error response.
	// Recommended: 600 (10 minutes) for 404, 60 (1 minute) for 5xx errors.
	// Required field.
	TtlSeconds    int32 `protobuf:"varint,2,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NegativeCachingPolicy) Reset() {
	*x = NegativeCachingPolicy{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NegativeCachingPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NegativeCachingPolicy) ProtoMessage() {}

func (x *NegativeCachingPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NegativeCachingPolicy.ProtoReflect.Descriptor instead.
func (*NegativeCachingPolicy) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{11}
}

func (x *NegativeCachingPolicy) GetCode() int32 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *NegativeCachingPolicy) GetTtlSeconds() int32 {
	if x != nil {
		return x.TtlSeconds
	}
	return 0
}

// **GcpCloudCdnFrontendConfig** configures the load balancer frontend (SSL, domains, security).
// If not specified, creates a basic HTTPS load balancer with auto-managed certificate.
type GcpCloudCdnFrontendConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Custom domains for the CDN endpoint.
	// If not specified, uses the default GCP load balancer domain (*.globalgcp.net).
	CustomDomains []string `protobuf:"bytes,1,rep,name=custom_domains,json=customDomains,proto3" json:"custom_domains,omitempty"`
	// SSL certificate configuration.
	// If not specified, uses Google-managed certificate for custom_domains.
	SslCertificate *SslCertificateConfig `protobuf:"bytes,2,opt,name=ssl_certificate,json=sslCertificate,proto3,oneof" json:"ssl_certificate,omitempty"`
	// Enable Cloud Armor (WAF/DDoS protection).
	// Requires specifying a Cloud Armor security policy.
	CloudArmor *CloudArmorConfig `protobuf:"bytes,3,opt,name=cloud_armor,json=cloudArmor,proto3,oneof" json:"cloud_armor,omitempty"`
	// Enable HTTP to HTTPS redirect.
	// Recommended: true for production deployments.
	// Default: true.
	EnableHttpsRedirect *bool `protobuf:"varint,4,opt,name=enable_https_redirect,json=enableHttpsRedirect,proto3,oneof" json:"enable_https_redirect,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *GcpCloudCdnFrontendConfig) Reset() {
	*x = GcpCloudCdnFrontendConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GcpCloudCdnFrontendConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GcpCloudCdnFrontendConfig) ProtoMessage() {}

func (x *GcpCloudCdnFrontendConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GcpCloudCdnFrontendConfig.ProtoReflect.Descriptor instead.
func (*GcpCloudCdnFrontendConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{12}
}

func (x *GcpCloudCdnFrontendConfig) GetCustomDomains() []string {
	if x != nil {
		return x.CustomDomains
	}
	return nil
}

func (x *GcpCloudCdnFrontendConfig) GetSslCertificate() *SslCertificateConfig {
	if x != nil {
		return x.SslCertificate
	}
	return nil
}

func (x *GcpCloudCdnFrontendConfig) GetCloudArmor() *CloudArmorConfig {
	if x != nil {
		return x.CloudArmor
	}
	return nil
}

func (x *GcpCloudCdnFrontendConfig) GetEnableHttpsRedirect() bool {
	if x != nil && x.EnableHttpsRedirect != nil {
		return *x.EnableHttpsRedirect
	}
	return false
}

// **SslCertificateConfig** defines SSL/TLS certificate configuration for HTTPS.
type SslCertificateConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Certificate configuration type.
	//
	// Types that are valid to be assigned to CertificateType:
	//
	//	*SslCertificateConfig_GoogleManaged
	//	*SslCertificateConfig_SelfManaged
	CertificateType isSslCertificateConfig_CertificateType `protobuf_oneof:"certificate_type"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SslCertificateConfig) Reset() {
	*x = SslCertificateConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SslCertificateConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SslCertificateConfig) ProtoMessage() {}

func (x *SslCertificateConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SslCertificateConfig.ProtoReflect.Descriptor instead.
func (*SslCertificateConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{13}
}

func (x *SslCertificateConfig) GetCertificateType() isSslCertificateConfig_CertificateType {
	if x != nil {
		return x.CertificateType
	}
	return nil
}

func (x *SslCertificateConfig) GetGoogleManaged() *GoogleManagedCertificateConfig {
	if x != nil {
		if x, ok := x.CertificateType.(*SslCertificateConfig_GoogleManaged); ok {
			return x.GoogleManaged
		}
	}
	return nil
}

func (x *SslCertificateConfig) GetSelfManaged() *SelfManagedCertificateConfig {
	if x != nil {
		if x, ok := x.CertificateType.(*SslCertificateConfig_SelfManaged); ok {
			return x.SelfManaged
		}
	}
	return nil
}

type isSslCertificateConfig_CertificateType interface {
	isSslCertificateConfig_CertificateType()
}

type SslCertificateConfig_GoogleManaged struct {
	// Use Google-managed certificate (automatic issuance and renewal).
	// Recommended for most use cases.
	GoogleManaged *GoogleManagedCertificateConfig `protobuf:"bytes,1,opt,name=google_managed,json=googleManaged,proto3,oneof"`
}

type SslCertificateConfig_SelfManaged struct {
	// Use self-managed certificate (bring your own certificate).
	// Use when you have specific certificate requirements or existing certificates.
	SelfManaged *SelfManagedCertificateConfig `protobuf:"bytes,2,opt,name=self_managed,json=selfManaged,proto3,oneof"`
}

func (*SslCertificateConfig_GoogleManaged) isSslCertificateConfig_CertificateType() {}

func (*SslCertificateConfig_SelfManaged) isSslCertificateConfig_CertificateType() {}

// **GoogleManagedCertificateConfig** uses Google-managed SSL certificates.
// Google automatically provisions and renews certificates via Let's Encrypt.
type GoogleManagedCertificateConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Domains to include in the certificate.
	// Must match or be subset of frontend_config.custom_domains.
	// Required field.
	Domains       []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GoogleManagedCertificateConfig) Reset() {
	*x = GoogleManagedCertificateConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GoogleManagedCertificateConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GoogleManagedCertificateConfig) ProtoMessage() {}

func (x *GoogleManagedCertificateConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GoogleManagedCertificateConfig.ProtoReflect.Descriptor instead.
func (*GoogleManagedCertificateConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{14}
}

func (x *GoogleManagedCertificateConfig) GetDomains() []string {
	if x != nil {
		return x.Domains
	}
	return nil
}

// **SelfManagedCertificateConfig** uses user-provided SSL certificates.
type SelfManagedCertificateConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// PEM-encoded SSL certificate chain.
	// Required field.
	CertificatePem string `protobuf:"bytes,1,opt,name=certificate_pem,json=certificatePem,proto3" json:"certificate_pem,omitempty"`
	// PEM-encoded private key.
	// Required field.
	PrivateKeyPem string `protobuf:"bytes,2,opt,name=private_key_pem,json=privateKeyPem,proto3" json:"private_key_pem,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelfManagedCertificateConfig) Reset() {
	*x = SelfManagedCertificateConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelfManagedCertificateConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelfManagedCertificateConfig) ProtoMessage() {}

func (x *SelfManagedCertificateConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelfManagedCertificateConfig.ProtoReflect.Descriptor instead.
func (*SelfManagedCertificateConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{15}
}

func (x *SelfManagedCertificateConfig) GetCertificatePem() string {
	if x != nil {
		return x.CertificatePem
	}
	return ""
}

func (x *SelfManagedCertificateConfig) GetPrivateKeyPem() string {
	if x != nil {
		return x.PrivateKeyPem
	}
	return ""
}

// **CloudArmorConfig** enables Google Cloud Armor (WAF and DDoS protection).
type CloudArmorConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable Cloud Armor protection.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Name of existing Cloud Armor security policy to attach.
	// The policy must exist in the same GCP project.
	// Required when enabled = true.
	SecurityPolicyName string `protobuf:"bytes,2,opt,name=security_policy_name,json=securityPolicyName,proto3" json:"security_policy_name,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CloudArmorConfig) Reset() {
	*x = CloudArmorConfig{}
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloudArmorConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloudArmorConfig) ProtoMessage() {}

func (x *CloudArmorConfig) ProtoReflect() protoreflect.Message {
	mi := &file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloudArmorConfig.ProtoReflect.Descriptor instead.
func (*CloudArmorConfig) Descriptor() ([]byte, []int) {
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP(), []int{16}
}

func (x *CloudArmorConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *CloudArmorConfig) GetSecurityPolicyName() string {
	if x != nil {
		return x.SecurityPolicyName
	}
	return ""
}

var File_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto protoreflect.FileDescriptor

const file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDesc = "" +
	"\n" +
	":org/project_planton/provider/gcp/gcpcloudcdn/v1/spec.proto\x12/org.project_planton.provider.gcp.gcpcloudcdn.v1\x1a\x1bbuf/validate/validate.proto\x1a:org/project_planton/shared/foreignkey/v1/foreign_key.proto\"\xf5\a\n" +
	"\x0fGcpCloudCdnSpec\x12\x8a\x01\n" +
	"\x0egcp_project_id\x18\x01 \x01(\v2:.org.project_planton.shared.foreignkey.v1.StringValueOrRefB(\xbaH\x03\xc8\x01\x01\x88\xd4a\xe1\x04\x92\xd4a\x19status.outputs.project_idR\fgcpProjectId\x12e\n" +
	"\abackend\x18\x02 \x01(\v2C.org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackendB\x06\xbaH\x03\xc8\x01\x01R\abackend\x12h\n" +
	"\n" +
	"cache_mode\x18\x03 \x01(\x0e2:.org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheModeB\b\xbaH\x05\x82\x01\x02\x10\x01H\x00R\tcacheMode\x88\x01\x01\x12A\n" +
	"\x13default_ttl_seconds\x18\x04 \x01(\x05B\f\xbaH\t\x1a\a\x18\x80\xe7\x84\x0f(\x00H\x01R\x11defaultTtlSeconds\x88\x01\x01\x129\n" +
	"\x0fmax_ttl_seconds\x18\x05 \x01(\x05B\f\xbaH\t\x1a\a\x18\x80\xe7\x84\x0f(\x00H\x02R\rmaxTtlSeconds\x88\x01\x01\x12?\n" +
	"\x12client_ttl_seconds\x18\x06 \x01(\x05B\f\xbaH\t\x1a\a\x18\x80\xe7\x84\x0f(\x00H\x03R\x10clientTtlSeconds\x88\x01\x01\x12;\n" +
	"\x17enable_negative_caching\x18\a \x01(\bH\x04R\x15enableNegativeCaching\x88\x01\x01\x12x\n" +
	"\x0fadvanced_config\x18\b \x01(\v2J.org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnAdvancedConfigH\x05R\x0eadvancedConfig\x88\x01\x01\x12x\n" +
	"\x0ffrontend_config\x18\t \x01(\v2J.org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnFrontendConfigH\x06R\x0efrontendConfig\x88\x01\x01B\r\n" +
	"\v_cache_modeB\x16\n" +
	"\x14_default_ttl_secondsB\x12\n" +
	"\x10_max_ttl_secondsB\x15\n" +
	"\x13_client_ttl_secondsB\x1a\n" +
	"\x18_enable_negative_cachingB\x12\n" +
	"\x10_advanced_configB\x12\n" +
	"\x10_frontend_config\"\xe3\x03\n" +
	"\x12GcpCloudCdnBackend\x12b\n" +
	"\n" +
	"gcs_bucket\x18\x01 \x01(\v2A.org.project_planton.provider.gcp.gcpcloudcdn.v1.GcsBackendConfigH\x00R\tgcsBucket\x12p\n" +
	"\x0fcompute_service\x18\x02 \x01(\v2E.org.project_planton.provider.gcp.gcpcloudcdn.v1.ComputeBackendConfigH\x00R\x0ecomputeService\x12t\n" +
	"\x11cloud_run_service\x18\x03 \x01(\v2F.org.project_planton.provider.gcp.gcpcloudcdn.v1.CloudRunBackendConfigH\x00R\x0fcloudRunService\x12q\n" +
	"\x0fexternal_origin\x18\x04 \x01(\v2F.org.project_planton.provider.gcp.gcpcloudcdn.v1.ExternalBackendConfigH\x00R\x0eexternalOriginB\x0e\n" +
	"\fbackend_type\"\xb5\x01\n" +
	"\x10GcsBackendConfig\x12N\n" +
	"\vbucket_name\x18\x01 \x01(\tB-\xbaH*\xc8\x01\x01r%2#^[a-z0-9][a-z0-9-_.]{1,61}[a-z0-9]$R\n" +
	"bucketName\x127\n" +
	"\x15enable_uniform_access\x18\x02 \x01(\bH\x00R\x13enableUniformAccess\x88\x01\x01B\x18\n" +
	"\x16_enable_uniform_access\"\xf4\x02\n" +
	"\x14ComputeBackendConfig\x126\n" +
	"\x13instance_group_name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x11instanceGroupName\x12j\n" +
	"\fhealth_check\x18\x02 \x01(\v2B.org.project_planton.provider.gcp.gcpcloudcdn.v1.HealthCheckConfigH\x00R\vhealthCheck\x88\x01\x01\x12k\n" +
	"\bprotocol\x18\x03 \x01(\x0e2@.org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocolB\b\xbaH\x05\x82\x01\x02\x10\x01H\x01R\bprotocol\x88\x01\x01\x12$\n" +
	"\x04port\x18\x04 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x01H\x02R\x04port\x88\x01\x01B\x0f\n" +
	"\r_health_checkB\v\n" +
	"\t_protocolB\a\n" +
	"\x05_port\"f\n" +
	"\x15CloudRunBackendConfig\x12)\n" +
	"\fservice_name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vserviceName\x12\"\n" +
	"\x06region\x18\x02 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x01R\x06region\"\xe8\x01\n" +
	"\x15ExternalBackendConfig\x12&\n" +
	"\bhostname\x18\x01 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x01R\bhostname\x12$\n" +
	"\x04port\x18\x02 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x01H\x00R\x04port\x88\x01\x01\x12k\n" +
	"\bprotocol\x18\x03 \x01(\x0e2@.org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocolB\b\xbaH\x05\x82\x01\x02\x10\x01H\x01R\bprotocol\x88\x01\x01B\a\n" +
	"\x05_portB\v\n" +
	"\t_protocol\"\xc0\x03\n" +
	"\x11HealthCheckConfig\x12\x17\n" +
	"\x04path\x18\x01 \x01(\tH\x00R\x04path\x88\x01\x01\x12$\n" +
	"\x04port\x18\x02 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x01H\x01R\x04port\x88\x01\x01\x12E\n" +
	"\x16check_interval_seconds\x18\x03 \x01(\x05B\n" +
	"\xbaH\a\x1a\x05\x18\xac\x02(\x01H\x02R\x14checkIntervalSeconds\x88\x01\x01\x128\n" +
	"\x0ftimeout_seconds\x18\x04 \x01(\x05B\n" +
	"\xbaH\a\x1a\x05\x18\xac\x02(\x01H\x03R\x0etimeoutSeconds\x88\x01\x01\x12;\n" +
	"\x11healthy_threshold\x18\x05 \x01(\x05B\t\xbaH\x06\x1a\x04\x18\n" +
	"(\x01H\x04R\x10healthyThreshold\x88\x01\x01\x12?\n" +
	"\x13unhealthy_threshold\x18\x06 \x01(\x05B\t\xbaH\x06\x1a\x04\x18\n" +
	"(\x01H\x05R\x12unhealthyThreshold\x88\x01\x01B\a\n" +
	"\x05_pathB\a\n" +
	"\x05_portB\x19\n" +
	"\x17_check_interval_secondsB\x12\n" +
	"\x10_timeout_secondsB\x14\n" +
	"\x12_healthy_thresholdB\x16\n" +
	"\x14_unhealthy_threshold\"\xf8\x04\n" +
	"\x19GcpCloudCdnAdvancedConfig\x12n\n" +
	"\x10cache_key_policy\x18\x01 \x01(\v2?.org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheKeyPolicyH\x00R\x0ecacheKeyPolicy\x88\x01\x01\x12q\n" +
	"\x11signed_url_config\x18\x02 \x01(\v2@.org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlConfigH\x01R\x0fsignedUrlConfig\x88\x01\x01\x12\x82\x01\n" +
	"\x19negative_caching_policies\x18\x03 \x03(\v2F.org.project_planton.provider.gcp.gcpcloudcdn.v1.NegativeCachingPolicyR\x17negativeCachingPolicies\x12K\n" +
	"\x19serve_while_stale_seconds\x18\x04 \x01(\x05B\v\xbaH\b\x1a\x06\x18\x80\xf5$(\x00H\x02R\x16serveWhileStaleSeconds\x88\x01\x01\x12?\n" +
	"\x19enable_request_coalescing\x18\x05 \x01(\bH\x03R\x17enableRequestCoalescing\x88\x01\x01B\x13\n" +
	"\x11_cache_key_policyB\x14\n" +
	"\x12_signed_url_configB\x1c\n" +
	"\x1a_serve_while_stale_secondsB\x1c\n" +
	"\x1a_enable_request_coalescing\"\xbf\x02\n" +
	"\x0eCacheKeyPolicy\x125\n" +
	"\x14include_query_string\x18\x01 \x01(\bH\x00R\x12includeQueryString\x88\x01\x01\x124\n" +
	"\x16query_string_whitelist\x18\x02 \x03(\tR\x14queryStringWhitelist\x12.\n" +
	"\x10include_protocol\x18\x03 \x01(\bH\x01R\x0fincludeProtocol\x88\x01\x01\x12&\n" +
	"\finclude_host\x18\x04 \x01(\bH\x02R\vincludeHost\x88\x01\x01\x12)\n" +
	"\x10included_headers\x18\x05 \x03(\tR\x0fincludedHeadersB\x17\n" +
	"\x15_include_query_stringB\x13\n" +
	"\x11_include_protocolB\x0f\n" +
	"\r_include_host\"\x88\x01\n" +
	"\x0fSignedUrlConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12[\n" +
	"\x04keys\x18\x02 \x03(\v2=.org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlKeyB\b\xbaH\x05\x92\x01\x02\b\x01R\x04keys\"s\n" +
	"\fSignedUrlKey\x12:\n" +
	"\bkey_name\x18\x01 \x01(\tB\x1f\xbaH\x1c\xc8\x01\x01r\x172\x15^[a-zA-Z0-9_-]{1,63}$R\akeyName\x12'\n" +
	"\tkey_value\x18\x02 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x10R\bkeyValue\"l\n" +
	"\x15NegativeCachingPolicy\x12\"\n" +
	"\x04code\x18\x01 \x01(\x05B\x0e\xbaH\v\xc8\x01\x01\x1a\x06\x18\xd7\x04(\x90\x03R\x04code\x12/\n" +
	"\vttl_seconds\x18\x02 \x01(\x05B\x0e\xbaH\v\xc8\x01\x01\x1a\x06\x18\x80\xa3\x05(\x00R\n" +
	"ttlSeconds\"\xcb\x03\n" +
	"\x19GcpCloudCdnFrontendConfig\x12Y\n" +
	"\x0ecustom_domains\x18\x01 \x03(\tB2\xbaH/\x92\x01,\"*r(2&^([a-z0-9-]+\\.)*[a-z0-9-]+\\.[a-z]{2,}$R\rcustomDomains\x12s\n" +
	"\x0fssl_certificate\x18\x02 \x01(\v2E.org.project_planton.provider.gcp.gcpcloudcdn.v1.SslCertificateConfigH\x00R\x0esslCertificate\x88\x01\x01\x12g\n" +
	"\vcloud_armor\x18\x03 \x01(\v2A.org.project_planton.provider.gcp.gcpcloudcdn.v1.CloudArmorConfigH\x01R\n" +
	"cloudArmor\x88\x01\x01\x127\n" +
	"\x15enable_https_redirect\x18\x04 \x01(\bH\x02R\x13enableHttpsRedirect\x88\x01\x01B\x12\n" +
	"\x10_ssl_certificateB\x0e\n" +
	"\f_cloud_armorB\x18\n" +
	"\x16_enable_https_redirect\"\x98\x02\n" +
	"\x14SslCertificateConfig\x12x\n" +
	"\x0egoogle_managed\x18\x01 \x01(\v2O.org.project_planton.provider.gcp.gcpcloudcdn.v1.GoogleManagedCertificateConfigH\x00R\rgoogleManaged\x12r\n" +
	"\fself_managed\x18\x02 \x01(\v2M.org.project_planton.provider.gcp.gcpcloudcdn.v1.SelfManagedCertificateConfigH\x00R\vselfManagedB\x12\n" +
	"\x10certificate_type\"s\n" +
	"\x1eGoogleManagedCertificateConfig\x12Q\n" +
	"\adomains\x18\x01 \x03(\tB7\xbaH4\xc8\x01\x01\x92\x01.\b\x01\"*r(2&^([a-z0-9-]+\\.)*[a-z0-9-]+\\.[a-z]{2,}$R\adomains\"\x7f\n" +
	"\x1cSelfManagedCertificateConfig\x12/\n" +
	"\x0fcertificate_pem\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x0ecertificatePem\x12.\n" +
	"\x0fprivate_key_pem\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\rprivateKeyPem\"^\n" +
	"\x10CloudArmorConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x120\n" +
	"\x14security_policy_name\x18\x02 \x01(\tR\x12securityPolicyName*j\n" +
	"\tCacheMode\x12\x1a\n" +
	"\x16CACHE_MODE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10CACHE_ALL_STATIC\x10\x01\x12\x16\n" +
	"\x12USE_ORIGIN_HEADERS\x10\x02\x12\x13\n" +
	"\x0fFORCE_CACHE_ALL\x10\x03*H\n" +
	"\x0fBackendProtocol\x12 \n" +
	"\x1cBACKEND_PROTOCOL_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04HTTP\x10\x01\x12\t\n" +
	"\x05HTTPS\x10\x02B\x8e\x03\n" +
	"3com.org.project_planton.provider.gcp.gcpcloudcdn.v1B\tSpecProtoP\x01Zmgithub.com/project-planton/project-planton/apis/org/project_planton/provider/gcp/gcpcloudcdn/v1;gcpcloudcdnv1\xa2\x02\x05OPPGG\xaa\x02.Org.ProjectPlanton.Provider.Gcp.Gcpcloudcdn.V1\xca\x02.Org\\ProjectPlanton\\Provider\\Gcp\\Gcpcloudcdn\\V1\xe2\x02:Org\\ProjectPlanton\\Provider\\Gcp\\Gcpcloudcdn\\V1\\GPBMetadata\xea\x023Org::ProjectPlanton::Provider::Gcp::Gcpcloudcdn::V1b\x06proto3"

var (
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescOnce sync.Once
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescData []byte
)

func file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescGZIP() []byte {
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescOnce.Do(func() {
		file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDesc)))
	})
	return file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDescData
}

var file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_goTypes = []any{
	(CacheMode)(0),                         // 0: org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheMode
	(BackendProtocol)(0),                   // 1: org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocol
	(*GcpCloudCdnSpec)(nil),                // 2: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnSpec
	(*GcpCloudCdnBackend)(nil),             // 3: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackend
	(*GcsBackendConfig)(nil),               // 4: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcsBackendConfig
	(*ComputeBackendConfig)(nil),           // 5: org.project_planton.provider.gcp.gcpcloudcdn.v1.ComputeBackendConfig
	(*CloudRunBackendConfig)(nil),          // 6: org.project_planton.provider.gcp.gcpcloudcdn.v1.CloudRunBackendConfig
	(*ExternalBackendConfig)(nil),          // 7: org.project_planton.provider.gcp.gcpcloudcdn.v1.ExternalBackendConfig
	(*HealthCheckConfig)(nil),              // 8: org.project_planton.provider.gcp.gcpcloudcdn.v1.HealthCheckConfig
	(*GcpCloudCdnAdvancedConfig)(nil),      // 9: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnAdvancedConfig
	(*CacheKeyPolicy)(nil),                 // 10: org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheKeyPolicy
	(*SignedUrlConfig)(nil),                // 11: org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlConfig
	(*SignedUrlKey)(nil),                   // 12: org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlKey
	(*NegativeCachingPolicy)(nil),          // 13: org.project_planton.provider.gcp.gcpcloudcdn.v1.NegativeCachingPolicy
	(*GcpCloudCdnFrontendConfig)(nil),      // 14: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnFrontendConfig
	(*SslCertificateConfig)(nil),           // 15: org.project_planton.provider.gcp.gcpcloudcdn.v1.SslCertificateConfig
	(*GoogleManagedCertificateConfig)(nil), // 16: org.project_planton.provider.gcp.gcpcloudcdn.v1.GoogleManagedCertificateConfig
	(*SelfManagedCertificateConfig)(nil),   // 17: org.project_planton.provider.gcp.gcpcloudcdn.v1.SelfManagedCertificateConfig
	(*CloudArmorConfig)(nil),               // 18: org.project_planton.provider.gcp.gcpcloudcdn.v1.CloudArmorConfig
	(*v1.StringValueOrRef)(nil),            // 19: org.project_planton.shared.foreignkey.v1.StringValueOrRef
}
var file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_depIdxs = []int32{
	19, // 0: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnSpec.gcp_project_id:type_name -> org.project_planton.shared.foreignkey.v1.StringValueOrRef
	3,  // 1: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnSpec.backend:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackend
	0,  // 2: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnSpec.cache_mode:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheMode
	9,  // 3: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnSpec.advanced_config:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnAdvancedConfig
	14, // 4: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnSpec.frontend_config:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnFrontendConfig
	4,  // 5: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackend.gcs_bucket:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.GcsBackendConfig
	5,  // 6: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackend.compute_service:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.ComputeBackendConfig
	6,  // 7: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackend.cloud_run_service:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.CloudRunBackendConfig
	7,  // 8: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnBackend.external_origin:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.ExternalBackendConfig
	8,  // 9: org.project_planton.provider.gcp.gcpcloudcdn.v1.ComputeBackendConfig.health_check:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.HealthCheckConfig
	1,  // 10: org.project_planton.provider.gcp.gcpcloudcdn.v1.ComputeBackendConfig.protocol:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocol
	1,  // 11: org.project_planton.provider.gcp.gcpcloudcdn.v1.ExternalBackendConfig.protocol:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.BackendProtocol
	10, // 12: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnAdvancedConfig.cache_key_policy:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.CacheKeyPolicy
	11, // 13: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnAdvancedConfig.signed_url_config:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlConfig
	13, // 14: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnAdvancedConfig.negative_caching_policies:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.NegativeCachingPolicy
	12, // 15: org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlConfig.keys:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.SignedUrlKey
	15, // 16: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnFrontendConfig.ssl_certificate:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.SslCertificateConfig
	18, // 17: org.project_planton.provider.gcp.gcpcloudcdn.v1.GcpCloudCdnFrontendConfig.cloud_armor:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.CloudArmorConfig
	16, // 18: org.project_planton.provider.gcp.gcpcloudcdn.v1.SslCertificateConfig.google_managed:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.GoogleManagedCertificateConfig
	17, // 19: org.project_planton.provider.gcp.gcpcloudcdn.v1.SslCertificateConfig.self_managed:type_name -> org.project_planton.provider.gcp.gcpcloudcdn.v1.SelfManagedCertificateConfig
	20, // [20:20] is the sub-list for method output_type
	20, // [20:20] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_init() }
func file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_init() {
	if File_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto != nil {
		return
	}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[0].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[1].OneofWrappers = []any{
		(*GcpCloudCdnBackend_GcsBucket)(nil),
		(*GcpCloudCdnBackend_ComputeService)(nil),
		(*GcpCloudCdnBackend_CloudRunService)(nil),
		(*GcpCloudCdnBackend_ExternalOrigin)(nil),
	}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[2].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[3].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[5].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[6].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[7].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[8].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[12].OneofWrappers = []any{}
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes[13].OneofWrappers = []any{
		(*SslCertificateConfig_GoogleManaged)(nil),
		(*SslCertificateConfig_SelfManaged)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDesc), len(file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_goTypes,
		DependencyIndexes: file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_depIdxs,
		EnumInfos:         file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_enumTypes,
		MessageInfos:      file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_msgTypes,
	}.Build()
	File_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto = out.File
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_goTypes = nil
	file_org_project_planton_provider_gcp_gcpcloudcdn_v1_spec_proto_depIdxs = nil
}
