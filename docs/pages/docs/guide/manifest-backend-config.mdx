import { Callout, Steps } from 'nextra/components'

# Backend Configuration via Manifest Labels

Have you ever wanted to share a ProjectPlanton manifest that "just works" without requiring the recipient to configure backend details? Or perhaps you've grown tired of typing the same backend configuration flags every time you deploy? This guide shows you how to embed backend configuration directly in your manifests using labels, making your infrastructure deployments more portable and user-friendly.

## The Problem: Backend Configuration Friction

When deploying infrastructure with ProjectPlanton, you typically need to specify where to store your state. This means every `pulumi update` or `tofu apply` command requires backend configuration through CLI flags:

```bash
# The traditional way - specifying backend via CLI flags
project-planton pulumi update \
  --manifest my-vpc.yaml \
  --stack my-org/my-project/dev

# Or for Terraform/Tofu
project-planton tofu apply \
  --manifest my-database.yaml \
  --backend-config s3://my-bucket/terraform/state
```

While this works well for routine deployments, it creates friction in several scenarios:

- **Quick Starts & Demos**: When sharing examples or creating tutorials, recipients need to understand and configure their own backend settings before they can even try your manifest
- **Team Onboarding**: New team members need to learn the correct backend configuration for each environment
- **CI/CD Pipelines**: Backend configuration must be duplicated across multiple pipeline definitions
- **URL-based Deployments**: You can't easily share a manifest URL that includes everything needed to deploy

<Callout type="info">
Think of it like sharing a recipe that requires the reader to figure out oven settings on their own. Wouldn't it be better if the recipe included all the necessary details?
</Callout>

## The Solution: Embedded Backend Configuration

ProjectPlanton now supports embedding backend configuration directly in your manifest using Kubernetes labels. This means your manifests can be completely self-contained, including both the infrastructure definition AND where to store the state.

Here's what it looks like:

### Pulumi Backend Configuration

```yaml {4-5}
apiVersion: aws.project-planton.org/v1
kind: AwsVpc
metadata:
  name: demo-vpc
  labels:
    # Embed the Pulumi stack configuration right in the manifest
    pulumi.project-planton.org/stack.fqdn: "demo-org/network/production"
spec:
  cidrBlock: "10.0.0.0/16"
  region: "us-east-1"
```

Now anyone can deploy this with just:
```bash
project-planton pulumi update --manifest https://example.com/manifests/demo-vpc.yaml
```

No additional backend configuration needed! The CLI reads the labels and automatically configures the Pulumi backend.

### Terraform/Tofu Backend Configuration

```yaml {4-6}
apiVersion: gcp.project-planton.org/v1
kind: GcpCloudSql
metadata:
  name: app-database
  labels:
    # Embed the Terraform backend configuration
    terraform.project-planton.org/backend.type: "s3"
    terraform.project-planton.org/backend.object: "terraform-states/databases/production/app-db"
spec:
  instanceType: "db-f1-micro"
  databaseVersion: "POSTGRES_14"
```

Deploy with:
```bash
project-planton tofu apply --manifest https://example.com/manifests/app-database.yaml
```

The Terraform backend is automatically configured from the labels!

## How It Works

<Steps>

### CLI reads the manifest

When you run a ProjectPlanton command with a manifest, the CLI first loads and parses the manifest file.

### Extract backend configuration

The CLI looks for specific labels in the manifest's metadata section that define backend configuration.

### Apply configuration precedence

The configuration follows this precedence order:
1. **Manifest labels** (highest priority)
2. **CLI flags** (override manifests if specified)
3. **Environment defaults** (fallback)

### Execute with configured backend

The CLI configures the appropriate backend (Pulumi or Terraform) and proceeds with the deployment.

</Steps>

## Label Reference

### Pulumi Labels

ProjectPlanton supports two approaches for Pulumi backend configuration:

#### Option 1: Simple Stack FQDN (Recommended)
```yaml
labels:
  pulumi.project-planton.org/stack.fqdn: "organization/project/stack"
```

#### Option 2: Individual Components
```yaml
labels:
  pulumi.project-planton.org/organization: "my-org"
  pulumi.project-planton.org/project: "infrastructure"
  pulumi.project-planton.org/stack.name: "production"
```

<Callout>
The `stack.fqdn` label takes precedence if both approaches are present. We recommend using it for simplicity.
</Callout>

### Terraform/Tofu Labels

For Terraform and OpenTofu backends:

```yaml
labels:
  terraform.project-planton.org/backend.type: "s3"    # or "gcs", "azurerm", "local"
  terraform.project-planton.org/backend.object: "bucket-name/path/to/state"
```

**Backend Type Options:**
- `s3` - Amazon S3
- `gcs` - Google Cloud Storage
- `azurerm` - Azure Blob Storage
- `local` - Local filesystem (development only)

## Real-World Benefits

### 1. Quick Start Experiences

Create manifests that work immediately for demos and tutorials:

```yaml
apiVersion: kubernetes.project-planton.org/v1
kind: RedisKubernetes
metadata:
  name: quick-start-redis
  labels:
    # Using local backend for quick demos
    pulumi.project-planton.org/stack.fqdn: "organization/quick-start/demo"
spec:
  container:
    replicas: 1
    diskSize: 1Gi
```

Share this manifest URL, and users can deploy instantly without any backend setup knowledge.

### 2. Environment-Specific Configurations

Maintain separate manifests for each environment with their backend configuration embedded:

**dev-environment.yaml:**
```yaml
metadata:
  labels:
    pulumi.project-planton.org/stack.fqdn: "acme-corp/infrastructure/dev"
```

**prod-environment.yaml:**
```yaml
metadata:
  labels:
    pulumi.project-planton.org/stack.fqdn: "acme-corp/infrastructure/prod"
```

### 3. GitOps Workflows

Your Git repository becomes the complete source of truth, including backend configuration:

```yaml
# Everything needed for deployment is in the manifest
apiVersion: aws.project-planton.org/v1
kind: AwsRdsInstance
metadata:
  name: app-database
  labels:
    terraform.project-planton.org/backend.type: "s3"
    terraform.project-planton.org/backend.object: "terraform-state/rds/production"
spec:
  engine: "postgres"
  engineVersion: "14.7"
  instanceClass: "db.t3.micro"
```

Your CI/CD pipeline simply needs to run:
```bash
project-planton tofu apply --manifest manifests/production/database.yaml
```

### 4. Team Collaboration

New team members can start deploying immediately without learning backend conventions:

```yaml
# Team members don't need to know where state is stored
metadata:
  labels:
    pulumi.project-planton.org/organization: "platform-team"
    pulumi.project-planton.org/project: "shared-services"
    pulumi.project-planton.org/stack.name: "monitoring"
```

## Migration Guide

### Transitioning Existing Deployments

If you have existing deployments using CLI flags, you can gradually transition to label-based configuration:

1. **Add labels to your manifests** while keeping your existing CLI commands unchanged
2. **Test** that the labels work by omitting CLI flags in development environments
3. **Update CI/CD pipelines** to use simplified commands once confident
4. **Document** the change for your team

### Example Migration

**Before (CLI flags required):**
```bash
project-planton pulumi update \
  --manifest vpc.yaml \
  --stack platform-team/network/production
```

**After (self-contained manifest):**
```yaml
# vpc.yaml
metadata:
  labels:
    pulumi.project-planton.org/stack.fqdn: "platform-team/network/production"
```

```bash
# Simplified command
project-planton pulumi update --manifest vpc.yaml
```

## Best Practices

### DO ✅

- **Use stack.fqdn for Pulumi** when possible - it's simpler and less error-prone
- **Document your backend strategy** in your repository's README
- **Use consistent naming conventions** across your organization
- **Test manifests with embedded backends** before sharing them
- **Keep backend paths organized** (e.g., `environment/resource-type/resource-name`)

### DON'T ❌

- **Don't embed credentials** in labels - use environment variables or credential files
- **Don't use production backends** in example or demo manifests
- **Don't mix backend strategies** - choose either labels or CLI flags consistently per environment
- **Don't forget to update labels** when copying manifests between environments

## Troubleshooting

### Labels Not Being Recognized

If your backend labels aren't being picked up:

1. **Check label syntax** - ensure you're using the exact label keys shown above
2. **Verify manifest structure** - labels must be under `metadata.labels`
3. **Check CLI version** - ensure you're using a version that supports backend labels
4. **Look for CLI flag overrides** - CLI flags take precedence over labels

### Precedence Issues

Remember the precedence order:
1. CLI flags (highest) - explicitly provided flags always win
2. Manifest labels - used when no CLI flags are provided
3. Defaults (lowest) - fallback values

If you specify `--stack` on the CLI, it will override any Pulumi labels in the manifest.

### State Migration

If you need to change backend configuration for existing resources:

<Callout type="warning">
Changing backend configuration for existing deployments requires careful state migration. Always backup your state before making changes.
</Callout>

1. Export current state using your IaC tool's export commands
2. Update the manifest with new backend labels
3. Import the state to the new backend
4. Verify the deployment still works correctly

## Security Considerations

- **Backend labels are visible** to anyone who can read the manifest
- **Don't include sensitive paths** that might reveal infrastructure details
- **Use separate backends** for different security zones
- **Implement proper access controls** on your state storage backends
- **Consider using separate manifests** for sensitive production deployments

## Summary

Embedding backend configuration in manifest labels transforms ProjectPlanton manifests from infrastructure descriptions into complete, portable deployment packages. This approach:

- **Simplifies deployments** by eliminating the need for separate backend configuration
- **Enables true quick-starts** where users can deploy from URLs without setup
- **Improves team velocity** by removing configuration friction
- **Maintains flexibility** through the precedence system that allows overrides when needed

Whether you're creating demos, onboarding team members, or building GitOps workflows, backend labels make your infrastructure deployments more accessible and maintainable.

<Callout type="success">
Your manifests are no longer just blueprints - they're complete, ready-to-deploy packages that include everything needed for successful infrastructure provisioning.
</Callout>
