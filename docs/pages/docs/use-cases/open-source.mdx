ProjectPlanton provides a standardized approach to deploying popular open source software on Kubernetes by leveraging Kubernetes-like manifests and consistent APIs. Instead of dealing with the intricacies of various installation methods or learning bespoke tools for each deployment, users can use ProjectPlanton's unified framework to deploy open source software with a consistent workflow across multiple environments.

This section help you learn how ProjectPlanton can be used to easily deploy various open source software using declarative YAML manifests, and why this method is more robust and easier to maintain compared to traditional alternatives, such as Helm charts.

**Benefits of Using ProjectPlanton for Open Source Software Deployment**

## Unified Deployment Approach

Deploying open source software often involves learning different tools, syntaxes, and patterns. With ProjectPlanton, the deployment is standardized, using the same declarative YAML-based approach for all supported modules. This consistency reduces the learning curve and helps teams stay productive without the need to master numerous deployment tools.

## Consistent API Definitions

Every open source software deployed using ProjectPlanton follows the same consistent API patterns, defined using Protobuf. This means that developers interact with software deployment in the same way, no matter what is being deployed. This approach contrasts with using Helm charts, which often require software-specific configurations and come with a steep learning curve to understand the values and configuration nuances.

## Kubernetes-Like Manifests

The familiar Kubernetes-like manifest structure allows for ease of adoption. Developers familiar with defining Kubernetes resources can quickly adapt to using ProjectPlanton without having to learn new paradigms. Each open source software deployment is defined in a YAML manifest, following Kubernetes Resource Model conventions (`apiVersion`, `kind`, `metadata`, `spec`).

## Clear Separation of Concerns

With ProjectPlanton, users can clearly separate configuration from the actual deployment logic. Unlike Helm charts, which can often combine application-specific logic with configuration values, ProjectPlanton keeps these aspects modular. The declarative YAML manifests focus on specifying "what" needs to be deployed, while the Pulumi modules handle the implementation of "how" to deploy.

## Simplified Multi-Environment Deployments

ProjectPlanton's approach makes it easy to adapt configurations for different environments (e.g., development, staging, production). Each environment can have its own manifest file, making it straightforward to apply different configurations without changing the deployment logic.

**Open Source Software Modules Available**:

ProjectPlanton provides modules for deploying a wide variety of popular open source software on Kubernetes. Each of these modules has its own well-defined API and can be easily deployed using the ProjectPlanton CLI. Here are some of the modules that are available:

- [ArgoCD Kubernetes Pulumi Module](https://github.com/project-planton/argocd-kubernetes-pulumi-module)
- [Elasticsearch Kubernetes Pulumi Module](https://github.com/project-planton/elasticsearch-kubernetes-pulumi-module)
- [GitLab Kubernetes Pulumi Module](https://github.com/project-planton/gitlab-kubernetes-pulumi-module)
- [Grafana Kubernetes Pulumi Module](https://github.com/project-planton/grafana-kubernetes-pulumi-module)
- [Jenkins Kubernetes Pulumi Module](https://github.com/project-planton/jenkins-kubernetes-pulumi-module)
- [Kafka Kubernetes Pulumi Module](https://github.com/project-planton/kafka-kubernetes-pulumi-module)
- [Keycloak Kubernetes Pulumi Module](https://github.com/project-planton/keycloak-kubernetes-pulumi-module)
- [Locust Kubernetes Pulumi Module](https://github.com/project-planton/locust-kubernetes-pulumi-module)
- [MongoDB Kubernetes Pulumi Module](https://github.com/project-planton/mongodb-kubernetes-pulumi-module)
- [Neo4j Kubernetes Pulumi Module](https://github.com/project-planton/neo4j-kubernetes-pulumi-module)
- [OpenFGA Kubernetes Pulumi Module](https://github.com/project-planton/openfga-kubernetes-pulumi-module)
- [Postgres Kubernetes Pulumi Module](https://github.com/project-planton/postgres-kubernetes-pulumi-module)
- [Prometheus Kubernetes Pulumi Module](https://github.com/project-planton/prometheus-kubernetes-pulumi-module)
- [Redis Kubernetes Pulumi Module](https://github.com/project-planton/redis-kubernetes-pulumi-module)
- [Signoz Kubernetes Pulumi Module](https://github.com/project-planton/signoz-kubernetes-pulumi-module)
- [Solr Kubernetes Pulumi Module](https://github.com/project-planton/solr-kubernetes-pulumi-module)

**How to Deploy Open Source Software Using ProjectPlanton**:

    1. **Define a Manifest**: Create a YAML manifest for the desired software using the corresponding API definition (e.g., Redis, Kafka).
    2. **Use the CLI**: Run the `project-planton pulumi up` command to deploy the manifest. This command will automatically select the appropriate Pulumi module and handle the deployment.
    3. **Customize as Needed**: Use environment-specific manifests to customize deployments for different environments without changing the core logic.

**Summary**:

ProjectPlanton offers a unified, consistent, and efficient way to deploy popular open source software on Kubernetes. By leveraging declarative manifests and well-defined APIs, it simplifies the deployment process, eliminates the need to learn multiple deployment tools, and ensures transparency and maintainability. Whether you're deploying ArgoCD, Jenkins, Kafka, or any other supported software, ProjectPlanton makes it easy to manage infrastructure as code, making it a powerful alternative to traditional methods like Helm charts.
