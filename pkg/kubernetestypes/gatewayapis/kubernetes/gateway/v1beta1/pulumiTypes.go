// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *GatewaySpec       `pulumi:"spec"`
	Status   *GatewayStatus     `pulumi:"status"`
}

// GatewayTypeInput is an input type that accepts GatewayTypeArgs and GatewayTypeOutput values.
// You can construct a concrete instance of `GatewayTypeInput` via:
//
//	GatewayTypeArgs{...}
type GatewayTypeInput interface {
	pulumi.Input

	ToGatewayTypeOutput() GatewayTypeOutput
	ToGatewayTypeOutputWithContext(context.Context) GatewayTypeOutput
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     GatewaySpecPtrInput       `pulumi:"spec"`
	Status   GatewayStatusPtrInput     `pulumi:"status"`
}

func (GatewayTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayType)(nil)).Elem()
}

func (i GatewayTypeArgs) ToGatewayTypeOutput() GatewayTypeOutput {
	return i.ToGatewayTypeOutputWithContext(context.Background())
}

func (i GatewayTypeArgs) ToGatewayTypeOutputWithContext(ctx context.Context) GatewayTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayTypeOutput)
}

// GatewayTypeArrayInput is an input type that accepts GatewayTypeArray and GatewayTypeArrayOutput values.
// You can construct a concrete instance of `GatewayTypeArrayInput` via:
//
//	GatewayTypeArray{ GatewayTypeArgs{...} }
type GatewayTypeArrayInput interface {
	pulumi.Input

	ToGatewayTypeArrayOutput() GatewayTypeArrayOutput
	ToGatewayTypeArrayOutputWithContext(context.Context) GatewayTypeArrayOutput
}

type GatewayTypeArray []GatewayTypeInput

func (GatewayTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayType)(nil)).Elem()
}

func (i GatewayTypeArray) ToGatewayTypeArrayOutput() GatewayTypeArrayOutput {
	return i.ToGatewayTypeArrayOutputWithContext(context.Background())
}

func (i GatewayTypeArray) ToGatewayTypeArrayOutputWithContext(ctx context.Context) GatewayTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayTypeArrayOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayTypeOutput struct{ *pulumi.OutputState }

func (GatewayTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayType)(nil)).Elem()
}

func (o GatewayTypeOutput) ToGatewayTypeOutput() GatewayTypeOutput {
	return o
}

func (o GatewayTypeOutput) ToGatewayTypeOutputWithContext(ctx context.Context) GatewayTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v GatewayType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o GatewayTypeOutput) Spec() GatewaySpecPtrOutput {
	return o.ApplyT(func(v GatewayType) *GatewaySpec { return v.Spec }).(GatewaySpecPtrOutput)
}

func (o GatewayTypeOutput) Status() GatewayStatusPtrOutput {
	return o.ApplyT(func(v GatewayType) *GatewayStatus { return v.Status }).(GatewayStatusPtrOutput)
}

type GatewayTypeArrayOutput struct{ *pulumi.OutputState }

func (GatewayTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayType)(nil)).Elem()
}

func (o GatewayTypeArrayOutput) ToGatewayTypeArrayOutput() GatewayTypeArrayOutput {
	return o
}

func (o GatewayTypeArrayOutput) ToGatewayTypeArrayOutputWithContext(ctx context.Context) GatewayTypeArrayOutput {
	return o
}

func (o GatewayTypeArrayOutput) Index(i pulumi.IntInput) GatewayTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayType {
		return vs[0].([]GatewayType)[vs[1].(int)]
	}).(GatewayTypeOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta  `pulumi:"metadata"`
	Spec     *GatewayClassSpec   `pulumi:"spec"`
	Status   *GatewayClassStatus `pulumi:"status"`
}

// GatewayClassTypeInput is an input type that accepts GatewayClassTypeArgs and GatewayClassTypeOutput values.
// You can construct a concrete instance of `GatewayClassTypeInput` via:
//
//	GatewayClassTypeArgs{...}
type GatewayClassTypeInput interface {
	pulumi.Input

	ToGatewayClassTypeOutput() GatewayClassTypeOutput
	ToGatewayClassTypeOutputWithContext(context.Context) GatewayClassTypeOutput
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput  `pulumi:"metadata"`
	Spec     GatewayClassSpecPtrInput   `pulumi:"spec"`
	Status   GatewayClassStatusPtrInput `pulumi:"status"`
}

func (GatewayClassTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassType)(nil)).Elem()
}

func (i GatewayClassTypeArgs) ToGatewayClassTypeOutput() GatewayClassTypeOutput {
	return i.ToGatewayClassTypeOutputWithContext(context.Background())
}

func (i GatewayClassTypeArgs) ToGatewayClassTypeOutputWithContext(ctx context.Context) GatewayClassTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassTypeOutput)
}

// GatewayClassTypeArrayInput is an input type that accepts GatewayClassTypeArray and GatewayClassTypeArrayOutput values.
// You can construct a concrete instance of `GatewayClassTypeArrayInput` via:
//
//	GatewayClassTypeArray{ GatewayClassTypeArgs{...} }
type GatewayClassTypeArrayInput interface {
	pulumi.Input

	ToGatewayClassTypeArrayOutput() GatewayClassTypeArrayOutput
	ToGatewayClassTypeArrayOutputWithContext(context.Context) GatewayClassTypeArrayOutput
}

type GatewayClassTypeArray []GatewayClassTypeInput

func (GatewayClassTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassType)(nil)).Elem()
}

func (i GatewayClassTypeArray) ToGatewayClassTypeArrayOutput() GatewayClassTypeArrayOutput {
	return i.ToGatewayClassTypeArrayOutputWithContext(context.Background())
}

func (i GatewayClassTypeArray) ToGatewayClassTypeArrayOutputWithContext(ctx context.Context) GatewayClassTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassTypeArrayOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassTypeOutput struct{ *pulumi.OutputState }

func (GatewayClassTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassType)(nil)).Elem()
}

func (o GatewayClassTypeOutput) ToGatewayClassTypeOutput() GatewayClassTypeOutput {
	return o
}

func (o GatewayClassTypeOutput) ToGatewayClassTypeOutputWithContext(ctx context.Context) GatewayClassTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayClassTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayClassTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o GatewayClassTypeOutput) Spec() GatewayClassSpecPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *GatewayClassSpec { return v.Spec }).(GatewayClassSpecPtrOutput)
}

func (o GatewayClassTypeOutput) Status() GatewayClassStatusPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *GatewayClassStatus { return v.Status }).(GatewayClassStatusPtrOutput)
}

type GatewayClassTypeArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassType)(nil)).Elem()
}

func (o GatewayClassTypeArrayOutput) ToGatewayClassTypeArrayOutput() GatewayClassTypeArrayOutput {
	return o
}

func (o GatewayClassTypeArrayOutput) ToGatewayClassTypeArrayOutputWithContext(ctx context.Context) GatewayClassTypeArrayOutput {
	return o
}

func (o GatewayClassTypeArrayOutput) Index(i pulumi.IntInput) GatewayClassTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassType {
		return vs[0].([]GatewayClassType)[vs[1].(int)]
	}).(GatewayClassTypeOutput)
}

// GatewayClassList is a list of GatewayClass
type GatewayClassListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []GatewayClassType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// GatewayClassListTypeInput is an input type that accepts GatewayClassListTypeArgs and GatewayClassListTypeOutput values.
// You can construct a concrete instance of `GatewayClassListTypeInput` via:
//
//	GatewayClassListTypeArgs{...}
type GatewayClassListTypeInput interface {
	pulumi.Input

	ToGatewayClassListTypeOutput() GatewayClassListTypeOutput
	ToGatewayClassListTypeOutputWithContext(context.Context) GatewayClassListTypeOutput
}

// GatewayClassList is a list of GatewayClass
type GatewayClassListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items GatewayClassTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (GatewayClassListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassListType)(nil)).Elem()
}

func (i GatewayClassListTypeArgs) ToGatewayClassListTypeOutput() GatewayClassListTypeOutput {
	return i.ToGatewayClassListTypeOutputWithContext(context.Background())
}

func (i GatewayClassListTypeArgs) ToGatewayClassListTypeOutputWithContext(ctx context.Context) GatewayClassListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassListTypeOutput)
}

// GatewayClassList is a list of GatewayClass
type GatewayClassListTypeOutput struct{ *pulumi.OutputState }

func (GatewayClassListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassListType)(nil)).Elem()
}

func (o GatewayClassListTypeOutput) ToGatewayClassListTypeOutput() GatewayClassListTypeOutput {
	return o
}

func (o GatewayClassListTypeOutput) ToGatewayClassListTypeOutputWithContext(ctx context.Context) GatewayClassListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayClassListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o GatewayClassListTypeOutput) Items() GatewayClassTypeArrayOutput {
	return o.ApplyT(func(v GatewayClassListType) []GatewayClassType { return v.Items }).(GatewayClassTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v GatewayClassListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch  `pulumi:"metadata"`
	Spec     *GatewayClassSpecPatch   `pulumi:"spec"`
	Status   *GatewayClassStatusPatch `pulumi:"status"`
}

// GatewayClassPatchTypeInput is an input type that accepts GatewayClassPatchTypeArgs and GatewayClassPatchTypeOutput values.
// You can construct a concrete instance of `GatewayClassPatchTypeInput` via:
//
//	GatewayClassPatchTypeArgs{...}
type GatewayClassPatchTypeInput interface {
	pulumi.Input

	ToGatewayClassPatchTypeOutput() GatewayClassPatchTypeOutput
	ToGatewayClassPatchTypeOutputWithContext(context.Context) GatewayClassPatchTypeOutput
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput  `pulumi:"metadata"`
	Spec     GatewayClassSpecPatchPtrInput   `pulumi:"spec"`
	Status   GatewayClassStatusPatchPtrInput `pulumi:"status"`
}

func (GatewayClassPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassPatchType)(nil)).Elem()
}

func (i GatewayClassPatchTypeArgs) ToGatewayClassPatchTypeOutput() GatewayClassPatchTypeOutput {
	return i.ToGatewayClassPatchTypeOutputWithContext(context.Background())
}

func (i GatewayClassPatchTypeArgs) ToGatewayClassPatchTypeOutputWithContext(ctx context.Context) GatewayClassPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassPatchTypeOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassPatchTypeOutput struct{ *pulumi.OutputState }

func (GatewayClassPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassPatchType)(nil)).Elem()
}

func (o GatewayClassPatchTypeOutput) ToGatewayClassPatchTypeOutput() GatewayClassPatchTypeOutput {
	return o
}

func (o GatewayClassPatchTypeOutput) ToGatewayClassPatchTypeOutputWithContext(ctx context.Context) GatewayClassPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayClassPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayClassPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o GatewayClassPatchTypeOutput) Spec() GatewayClassSpecPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *GatewayClassSpecPatch { return v.Spec }).(GatewayClassSpecPatchPtrOutput)
}

func (o GatewayClassPatchTypeOutput) Status() GatewayClassStatusPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *GatewayClassStatusPatch { return v.Status }).(GatewayClassStatusPatchPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpec struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName *string `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   *string                        `pulumi:"description"`
	ParametersRef *GatewayClassSpecParametersRef `pulumi:"parametersRef"`
}

// GatewayClassSpecInput is an input type that accepts GatewayClassSpecArgs and GatewayClassSpecOutput values.
// You can construct a concrete instance of `GatewayClassSpecInput` via:
//
//	GatewayClassSpecArgs{...}
type GatewayClassSpecInput interface {
	pulumi.Input

	ToGatewayClassSpecOutput() GatewayClassSpecOutput
	ToGatewayClassSpecOutputWithContext(context.Context) GatewayClassSpecOutput
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecArgs struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName pulumi.StringPtrInput `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   pulumi.StringPtrInput                 `pulumi:"description"`
	ParametersRef GatewayClassSpecParametersRefPtrInput `pulumi:"parametersRef"`
}

func (GatewayClassSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpec)(nil)).Elem()
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecOutput() GatewayClassSpecOutput {
	return i.ToGatewayClassSpecOutputWithContext(context.Background())
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecOutputWithContext(ctx context.Context) GatewayClassSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecOutput)
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return i.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecOutput).ToGatewayClassSpecPtrOutputWithContext(ctx)
}

// GatewayClassSpecPtrInput is an input type that accepts GatewayClassSpecArgs, GatewayClassSpecPtr and GatewayClassSpecPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecPtrInput` via:
//
//	        GatewayClassSpecArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput
	ToGatewayClassSpecPtrOutputWithContext(context.Context) GatewayClassSpecPtrOutput
}

type gatewayClassSpecPtrType GatewayClassSpecArgs

func GatewayClassSpecPtr(v *GatewayClassSpecArgs) GatewayClassSpecPtrInput {
	return (*gatewayClassSpecPtrType)(v)
}

func (*gatewayClassSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpec)(nil)).Elem()
}

func (i *gatewayClassSpecPtrType) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return i.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecPtrType) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpec)(nil)).Elem()
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecOutput() GatewayClassSpecOutput {
	return o
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecOutputWithContext(ctx context.Context) GatewayClassSpecOutput {
	return o
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return o.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpec) *GatewayClassSpec {
		return &v
	}).(GatewayClassSpecPtrOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecOutput) ParametersRef() GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *GatewayClassSpecParametersRef { return v.ParametersRef }).(GatewayClassSpecParametersRefPtrOutput)
}

type GatewayClassSpecPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpec)(nil)).Elem()
}

func (o GatewayClassSpecPtrOutput) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return o
}

func (o GatewayClassSpecPtrOutput) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return o
}

func (o GatewayClassSpecPtrOutput) Elem() GatewayClassSpecOutput {
	return o.ApplyT(func(v *GatewayClassSpec) GatewayClassSpec {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpec
		return ret
	}).(GatewayClassSpecOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPtrOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *string {
		if v == nil {
			return nil
		}
		return v.ControllerName
	}).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecPtrOutput) ParametersRef() GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *GatewayClassSpecParametersRef {
		if v == nil {
			return nil
		}
		return v.ParametersRef
	}).(GatewayClassSpecParametersRefPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRef struct {
	// Group is the group of the referent.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace *string `pulumi:"namespace"`
}

// GatewayClassSpecParametersRefInput is an input type that accepts GatewayClassSpecParametersRefArgs and GatewayClassSpecParametersRefOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefInput` via:
//
//	GatewayClassSpecParametersRefArgs{...}
type GatewayClassSpecParametersRefInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput
	ToGatewayClassSpecParametersRefOutputWithContext(context.Context) GatewayClassSpecParametersRefOutput
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewayClassSpecParametersRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRef)(nil)).Elem()
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput {
	return i.ToGatewayClassSpecParametersRefOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefOutput)
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return i.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefOutput).ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx)
}

// GatewayClassSpecParametersRefPtrInput is an input type that accepts GatewayClassSpecParametersRefArgs, GatewayClassSpecParametersRefPtr and GatewayClassSpecParametersRefPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPtrInput` via:
//
//	        GatewayClassSpecParametersRefArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecParametersRefPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput
	ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Context) GatewayClassSpecParametersRefPtrOutput
}

type gatewayClassSpecParametersRefPtrType GatewayClassSpecParametersRefArgs

func GatewayClassSpecParametersRefPtr(v *GatewayClassSpecParametersRefArgs) GatewayClassSpecParametersRefPtrInput {
	return (*gatewayClassSpecParametersRefPtrType)(v)
}

func (*gatewayClassSpecParametersRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRef)(nil)).Elem()
}

func (i *gatewayClassSpecParametersRefPtrType) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return i.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecParametersRefPtrType) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRef)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput {
	return o
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefOutput {
	return o
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return o.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecParametersRef) *GatewayClassSpecParametersRef {
		return &v
	}).(GatewayClassSpecParametersRefPtrOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewayClassSpecParametersRefPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRef)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPtrOutput) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPtrOutput) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPtrOutput) Elem() GatewayClassSpecParametersRefOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) GatewayClassSpecParametersRef {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecParametersRef
		return ret
	}).(GatewayClassSpecParametersRefOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefPatch struct {
	// Group is the group of the referent.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace *string `pulumi:"namespace"`
}

// GatewayClassSpecParametersRefPatchInput is an input type that accepts GatewayClassSpecParametersRefPatchArgs and GatewayClassSpecParametersRefPatchOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPatchInput` via:
//
//	GatewayClassSpecParametersRefPatchArgs{...}
type GatewayClassSpecParametersRefPatchInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPatchOutput() GatewayClassSpecParametersRefPatchOutput
	ToGatewayClassSpecParametersRefPatchOutputWithContext(context.Context) GatewayClassSpecParametersRefPatchOutput
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefPatchArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewayClassSpecParametersRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchOutput() GatewayClassSpecParametersRefPatchOutput {
	return i.ToGatewayClassSpecParametersRefPatchOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPatchOutput)
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return i.ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPatchOutput).ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx)
}

// GatewayClassSpecParametersRefPatchPtrInput is an input type that accepts GatewayClassSpecParametersRefPatchArgs, GatewayClassSpecParametersRefPatchPtr and GatewayClassSpecParametersRefPatchPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPatchPtrInput` via:
//
//	        GatewayClassSpecParametersRefPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecParametersRefPatchPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput
	ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Context) GatewayClassSpecParametersRefPatchPtrOutput
}

type gatewayClassSpecParametersRefPatchPtrType GatewayClassSpecParametersRefPatchArgs

func GatewayClassSpecParametersRefPatchPtr(v *GatewayClassSpecParametersRefPatchArgs) GatewayClassSpecParametersRefPatchPtrInput {
	return (*gatewayClassSpecParametersRefPatchPtrType)(v)
}

func (*gatewayClassSpecParametersRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (i *gatewayClassSpecParametersRefPatchPtrType) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return i.ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecParametersRefPatchPtrType) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPatchPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchOutput() GatewayClassSpecParametersRefPatchOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecParametersRefPatch) *GatewayClassSpecParametersRefPatch {
		return &v
	}).(GatewayClassSpecParametersRefPatchPtrOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewayClassSpecParametersRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPatchPtrOutput) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchPtrOutput) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchPtrOutput) Elem() GatewayClassSpecParametersRefPatchOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) GatewayClassSpecParametersRefPatch {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecParametersRefPatch
		return ret
	}).(GatewayClassSpecParametersRefPatchOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecPatch struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName *string `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   *string                             `pulumi:"description"`
	ParametersRef *GatewayClassSpecParametersRefPatch `pulumi:"parametersRef"`
}

// GatewayClassSpecPatchInput is an input type that accepts GatewayClassSpecPatchArgs and GatewayClassSpecPatchOutput values.
// You can construct a concrete instance of `GatewayClassSpecPatchInput` via:
//
//	GatewayClassSpecPatchArgs{...}
type GatewayClassSpecPatchInput interface {
	pulumi.Input

	ToGatewayClassSpecPatchOutput() GatewayClassSpecPatchOutput
	ToGatewayClassSpecPatchOutputWithContext(context.Context) GatewayClassSpecPatchOutput
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecPatchArgs struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName pulumi.StringPtrInput `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   pulumi.StringPtrInput                      `pulumi:"description"`
	ParametersRef GatewayClassSpecParametersRefPatchPtrInput `pulumi:"parametersRef"`
}

func (GatewayClassSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecPatch)(nil)).Elem()
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchOutput() GatewayClassSpecPatchOutput {
	return i.ToGatewayClassSpecPatchOutputWithContext(context.Background())
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchOutputWithContext(ctx context.Context) GatewayClassSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPatchOutput)
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return i.ToGatewayClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPatchOutput).ToGatewayClassSpecPatchPtrOutputWithContext(ctx)
}

// GatewayClassSpecPatchPtrInput is an input type that accepts GatewayClassSpecPatchArgs, GatewayClassSpecPatchPtr and GatewayClassSpecPatchPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecPatchPtrInput` via:
//
//	        GatewayClassSpecPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecPatchPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput
	ToGatewayClassSpecPatchPtrOutputWithContext(context.Context) GatewayClassSpecPatchPtrOutput
}

type gatewayClassSpecPatchPtrType GatewayClassSpecPatchArgs

func GatewayClassSpecPatchPtr(v *GatewayClassSpecPatchArgs) GatewayClassSpecPatchPtrInput {
	return (*gatewayClassSpecPatchPtrType)(v)
}

func (*gatewayClassSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecPatch)(nil)).Elem()
}

func (i *gatewayClassSpecPatchPtrType) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return i.ToGatewayClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecPatchPtrType) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPatchPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecPatch)(nil)).Elem()
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchOutput() GatewayClassSpecPatchOutput {
	return o
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchOutputWithContext(ctx context.Context) GatewayClassSpecPatchOutput {
	return o
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return o.ToGatewayClassSpecPatchPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecPatch) *GatewayClassSpecPatch {
		return &v
	}).(GatewayClassSpecPatchPtrOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPatchOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecPatch) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecPatchOutput) ParametersRef() GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecPatch) *GatewayClassSpecParametersRefPatch { return v.ParametersRef }).(GatewayClassSpecParametersRefPatchPtrOutput)
}

type GatewayClassSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecPatch)(nil)).Elem()
}

func (o GatewayClassSpecPatchPtrOutput) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return o
}

func (o GatewayClassSpecPatchPtrOutput) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return o
}

func (o GatewayClassSpecPatchPtrOutput) Elem() GatewayClassSpecPatchOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) GatewayClassSpecPatch {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecPatch
		return ret
	}).(GatewayClassSpecPatchOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPatchPtrOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ControllerName
	}).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPatchPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecPatchPtrOutput) ParametersRef() GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) *GatewayClassSpecParametersRefPatch {
		if v == nil {
			return nil
		}
		return v.ParametersRef
	}).(GatewayClassSpecParametersRefPatchPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatus struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions []GatewayClassStatusConditions `pulumi:"conditions"`
}

// GatewayClassStatusInput is an input type that accepts GatewayClassStatusArgs and GatewayClassStatusOutput values.
// You can construct a concrete instance of `GatewayClassStatusInput` via:
//
//	GatewayClassStatusArgs{...}
type GatewayClassStatusInput interface {
	pulumi.Input

	ToGatewayClassStatusOutput() GatewayClassStatusOutput
	ToGatewayClassStatusOutputWithContext(context.Context) GatewayClassStatusOutput
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusArgs struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions GatewayClassStatusConditionsArrayInput `pulumi:"conditions"`
}

func (GatewayClassStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatus)(nil)).Elem()
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusOutput() GatewayClassStatusOutput {
	return i.ToGatewayClassStatusOutputWithContext(context.Background())
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusOutputWithContext(ctx context.Context) GatewayClassStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusOutput)
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return i.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusOutput).ToGatewayClassStatusPtrOutputWithContext(ctx)
}

// GatewayClassStatusPtrInput is an input type that accepts GatewayClassStatusArgs, GatewayClassStatusPtr and GatewayClassStatusPtrOutput values.
// You can construct a concrete instance of `GatewayClassStatusPtrInput` via:
//
//	        GatewayClassStatusArgs{...}
//
//	or:
//
//	        nil
type GatewayClassStatusPtrInput interface {
	pulumi.Input

	ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput
	ToGatewayClassStatusPtrOutputWithContext(context.Context) GatewayClassStatusPtrOutput
}

type gatewayClassStatusPtrType GatewayClassStatusArgs

func GatewayClassStatusPtr(v *GatewayClassStatusArgs) GatewayClassStatusPtrInput {
	return (*gatewayClassStatusPtrType)(v)
}

func (*gatewayClassStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatus)(nil)).Elem()
}

func (i *gatewayClassStatusPtrType) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return i.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (i *gatewayClassStatusPtrType) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatus)(nil)).Elem()
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusOutput() GatewayClassStatusOutput {
	return o
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusOutputWithContext(ctx context.Context) GatewayClassStatusOutput {
	return o
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return o.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassStatus) *GatewayClassStatus {
		return &v
	}).(GatewayClassStatusPtrOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusOutput) Conditions() GatewayClassStatusConditionsArrayOutput {
	return o.ApplyT(func(v GatewayClassStatus) []GatewayClassStatusConditions { return v.Conditions }).(GatewayClassStatusConditionsArrayOutput)
}

type GatewayClassStatusPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatus)(nil)).Elem()
}

func (o GatewayClassStatusPtrOutput) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return o
}

func (o GatewayClassStatusPtrOutput) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return o
}

func (o GatewayClassStatusPtrOutput) Elem() GatewayClassStatusOutput {
	return o.ApplyT(func(v *GatewayClassStatus) GatewayClassStatus {
		if v != nil {
			return *v
		}
		var ret GatewayClassStatus
		return ret
	}).(GatewayClassStatusOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPtrOutput) Conditions() GatewayClassStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GatewayClassStatus) []GatewayClassStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayClassStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayClassStatusConditionsInput is an input type that accepts GatewayClassStatusConditionsArgs and GatewayClassStatusConditionsOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsInput` via:
//
//	GatewayClassStatusConditionsArgs{...}
type GatewayClassStatusConditionsInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput
	ToGatewayClassStatusConditionsOutputWithContext(context.Context) GatewayClassStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayClassStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditions)(nil)).Elem()
}

func (i GatewayClassStatusConditionsArgs) ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput {
	return i.ToGatewayClassStatusConditionsOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsArgs) ToGatewayClassStatusConditionsOutputWithContext(ctx context.Context) GatewayClassStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsOutput)
}

// GatewayClassStatusConditionsArrayInput is an input type that accepts GatewayClassStatusConditionsArray and GatewayClassStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsArrayInput` via:
//
//	GatewayClassStatusConditionsArray{ GatewayClassStatusConditionsArgs{...} }
type GatewayClassStatusConditionsArrayInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput
	ToGatewayClassStatusConditionsArrayOutputWithContext(context.Context) GatewayClassStatusConditionsArrayOutput
}

type GatewayClassStatusConditionsArray []GatewayClassStatusConditionsInput

func (GatewayClassStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditions)(nil)).Elem()
}

func (i GatewayClassStatusConditionsArray) ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput {
	return i.ToGatewayClassStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsArray) ToGatewayClassStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditions)(nil)).Elem()
}

func (o GatewayClassStatusConditionsOutput) ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput {
	return o
}

func (o GatewayClassStatusConditionsOutput) ToGatewayClassStatusConditionsOutputWithContext(ctx context.Context) GatewayClassStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayClassStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayClassStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayClassStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayClassStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayClassStatusConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayClassStatusConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayClassStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditions)(nil)).Elem()
}

func (o GatewayClassStatusConditionsArrayOutput) ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsArrayOutput) ToGatewayClassStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsArrayOutput) Index(i pulumi.IntInput) GatewayClassStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassStatusConditions {
		return vs[0].([]GatewayClassStatusConditions)[vs[1].(int)]
	}).(GatewayClassStatusConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayClassStatusConditionsPatchInput is an input type that accepts GatewayClassStatusConditionsPatchArgs and GatewayClassStatusConditionsPatchOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsPatchInput` via:
//
//	GatewayClassStatusConditionsPatchArgs{...}
type GatewayClassStatusConditionsPatchInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsPatchOutput() GatewayClassStatusConditionsPatchOutput
	ToGatewayClassStatusConditionsPatchOutputWithContext(context.Context) GatewayClassStatusConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayClassStatusConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayClassStatusConditionsPatchArgs) ToGatewayClassStatusConditionsPatchOutput() GatewayClassStatusConditionsPatchOutput {
	return i.ToGatewayClassStatusConditionsPatchOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsPatchArgs) ToGatewayClassStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsPatchOutput)
}

// GatewayClassStatusConditionsPatchArrayInput is an input type that accepts GatewayClassStatusConditionsPatchArray and GatewayClassStatusConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsPatchArrayInput` via:
//
//	GatewayClassStatusConditionsPatchArray{ GatewayClassStatusConditionsPatchArgs{...} }
type GatewayClassStatusConditionsPatchArrayInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsPatchArrayOutput() GatewayClassStatusConditionsPatchArrayOutput
	ToGatewayClassStatusConditionsPatchArrayOutputWithContext(context.Context) GatewayClassStatusConditionsPatchArrayOutput
}

type GatewayClassStatusConditionsPatchArray []GatewayClassStatusConditionsPatchInput

func (GatewayClassStatusConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayClassStatusConditionsPatchArray) ToGatewayClassStatusConditionsPatchArrayOutput() GatewayClassStatusConditionsPatchArrayOutput {
	return i.ToGatewayClassStatusConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsPatchArray) ToGatewayClassStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayClassStatusConditionsPatchOutput) ToGatewayClassStatusConditionsPatchOutput() GatewayClassStatusConditionsPatchOutput {
	return o
}

func (o GatewayClassStatusConditionsPatchOutput) ToGatewayClassStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayClassStatusConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayClassStatusConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayClassStatusConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayClassStatusConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayClassStatusConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayClassStatusConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayClassStatusConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayClassStatusConditionsPatchArrayOutput) ToGatewayClassStatusConditionsPatchArrayOutput() GatewayClassStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsPatchArrayOutput) ToGatewayClassStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsPatchArrayOutput) Index(i pulumi.IntInput) GatewayClassStatusConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassStatusConditionsPatch {
		return vs[0].([]GatewayClassStatusConditionsPatch)[vs[1].(int)]
	}).(GatewayClassStatusConditionsPatchOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusPatch struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions []GatewayClassStatusConditionsPatch `pulumi:"conditions"`
}

// GatewayClassStatusPatchInput is an input type that accepts GatewayClassStatusPatchArgs and GatewayClassStatusPatchOutput values.
// You can construct a concrete instance of `GatewayClassStatusPatchInput` via:
//
//	GatewayClassStatusPatchArgs{...}
type GatewayClassStatusPatchInput interface {
	pulumi.Input

	ToGatewayClassStatusPatchOutput() GatewayClassStatusPatchOutput
	ToGatewayClassStatusPatchOutputWithContext(context.Context) GatewayClassStatusPatchOutput
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusPatchArgs struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions GatewayClassStatusConditionsPatchArrayInput `pulumi:"conditions"`
}

func (GatewayClassStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusPatch)(nil)).Elem()
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchOutput() GatewayClassStatusPatchOutput {
	return i.ToGatewayClassStatusPatchOutputWithContext(context.Background())
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchOutputWithContext(ctx context.Context) GatewayClassStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPatchOutput)
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return i.ToGatewayClassStatusPatchPtrOutputWithContext(context.Background())
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPatchOutput).ToGatewayClassStatusPatchPtrOutputWithContext(ctx)
}

// GatewayClassStatusPatchPtrInput is an input type that accepts GatewayClassStatusPatchArgs, GatewayClassStatusPatchPtr and GatewayClassStatusPatchPtrOutput values.
// You can construct a concrete instance of `GatewayClassStatusPatchPtrInput` via:
//
//	        GatewayClassStatusPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayClassStatusPatchPtrInput interface {
	pulumi.Input

	ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput
	ToGatewayClassStatusPatchPtrOutputWithContext(context.Context) GatewayClassStatusPatchPtrOutput
}

type gatewayClassStatusPatchPtrType GatewayClassStatusPatchArgs

func GatewayClassStatusPatchPtr(v *GatewayClassStatusPatchArgs) GatewayClassStatusPatchPtrInput {
	return (*gatewayClassStatusPatchPtrType)(v)
}

func (*gatewayClassStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatusPatch)(nil)).Elem()
}

func (i *gatewayClassStatusPatchPtrType) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return i.ToGatewayClassStatusPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayClassStatusPatchPtrType) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPatchPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusPatch)(nil)).Elem()
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchOutput() GatewayClassStatusPatchOutput {
	return o
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchOutputWithContext(ctx context.Context) GatewayClassStatusPatchOutput {
	return o
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return o.ToGatewayClassStatusPatchPtrOutputWithContext(context.Background())
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassStatusPatch) *GatewayClassStatusPatch {
		return &v
	}).(GatewayClassStatusPatchPtrOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPatchOutput) Conditions() GatewayClassStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v GatewayClassStatusPatch) []GatewayClassStatusConditionsPatch { return v.Conditions }).(GatewayClassStatusConditionsPatchArrayOutput)
}

type GatewayClassStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatusPatch)(nil)).Elem()
}

func (o GatewayClassStatusPatchPtrOutput) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return o
}

func (o GatewayClassStatusPatchPtrOutput) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return o
}

func (o GatewayClassStatusPatchPtrOutput) Elem() GatewayClassStatusPatchOutput {
	return o.ApplyT(func(v *GatewayClassStatusPatch) GatewayClassStatusPatch {
		if v != nil {
			return *v
		}
		var ret GatewayClassStatusPatch
		return ret
	}).(GatewayClassStatusPatchOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPatchPtrOutput) Conditions() GatewayClassStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v *GatewayClassStatusPatch) []GatewayClassStatusConditionsPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayClassStatusConditionsPatchArrayOutput)
}

// GatewayList is a list of Gateway
type GatewayListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []GatewayType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// GatewayListTypeInput is an input type that accepts GatewayListTypeArgs and GatewayListTypeOutput values.
// You can construct a concrete instance of `GatewayListTypeInput` via:
//
//	GatewayListTypeArgs{...}
type GatewayListTypeInput interface {
	pulumi.Input

	ToGatewayListTypeOutput() GatewayListTypeOutput
	ToGatewayListTypeOutputWithContext(context.Context) GatewayListTypeOutput
}

// GatewayList is a list of Gateway
type GatewayListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items GatewayTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (GatewayListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayListType)(nil)).Elem()
}

func (i GatewayListTypeArgs) ToGatewayListTypeOutput() GatewayListTypeOutput {
	return i.ToGatewayListTypeOutputWithContext(context.Background())
}

func (i GatewayListTypeArgs) ToGatewayListTypeOutputWithContext(ctx context.Context) GatewayListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayListTypeOutput)
}

// GatewayList is a list of Gateway
type GatewayListTypeOutput struct{ *pulumi.OutputState }

func (GatewayListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayListType)(nil)).Elem()
}

func (o GatewayListTypeOutput) ToGatewayListTypeOutput() GatewayListTypeOutput {
	return o
}

func (o GatewayListTypeOutput) ToGatewayListTypeOutputWithContext(ctx context.Context) GatewayListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o GatewayListTypeOutput) Items() GatewayTypeArrayOutput {
	return o.ApplyT(func(v GatewayListType) []GatewayType { return v.Items }).(GatewayTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v GatewayListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *GatewaySpecPatch       `pulumi:"spec"`
	Status   *GatewayStatusPatch     `pulumi:"status"`
}

// GatewayPatchTypeInput is an input type that accepts GatewayPatchTypeArgs and GatewayPatchTypeOutput values.
// You can construct a concrete instance of `GatewayPatchTypeInput` via:
//
//	GatewayPatchTypeArgs{...}
type GatewayPatchTypeInput interface {
	pulumi.Input

	ToGatewayPatchTypeOutput() GatewayPatchTypeOutput
	ToGatewayPatchTypeOutputWithContext(context.Context) GatewayPatchTypeOutput
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     GatewaySpecPatchPtrInput       `pulumi:"spec"`
	Status   GatewayStatusPatchPtrInput     `pulumi:"status"`
}

func (GatewayPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayPatchType)(nil)).Elem()
}

func (i GatewayPatchTypeArgs) ToGatewayPatchTypeOutput() GatewayPatchTypeOutput {
	return i.ToGatewayPatchTypeOutputWithContext(context.Background())
}

func (i GatewayPatchTypeArgs) ToGatewayPatchTypeOutputWithContext(ctx context.Context) GatewayPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayPatchTypeOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayPatchTypeOutput struct{ *pulumi.OutputState }

func (GatewayPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayPatchType)(nil)).Elem()
}

func (o GatewayPatchTypeOutput) ToGatewayPatchTypeOutput() GatewayPatchTypeOutput {
	return o
}

func (o GatewayPatchTypeOutput) ToGatewayPatchTypeOutputWithContext(ctx context.Context) GatewayPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o GatewayPatchTypeOutput) Spec() GatewaySpecPatchPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *GatewaySpecPatch { return v.Spec }).(GatewaySpecPatchPtrOutput)
}

func (o GatewayPatchTypeOutput) Status() GatewayStatusPatchPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *GatewayStatusPatch { return v.Status }).(GatewayStatusPatchPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpec struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses []GatewaySpecAddresses `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName *string `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners []GatewaySpecListeners `pulumi:"listeners"`
}

// GatewaySpecInput is an input type that accepts GatewaySpecArgs and GatewaySpecOutput values.
// You can construct a concrete instance of `GatewaySpecInput` via:
//
//	GatewaySpecArgs{...}
type GatewaySpecInput interface {
	pulumi.Input

	ToGatewaySpecOutput() GatewaySpecOutput
	ToGatewaySpecOutputWithContext(context.Context) GatewaySpecOutput
}

// Spec defines the desired state of Gateway.
type GatewaySpecArgs struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses GatewaySpecAddressesArrayInput `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName pulumi.StringPtrInput `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners GatewaySpecListenersArrayInput `pulumi:"listeners"`
}

func (GatewaySpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpec)(nil)).Elem()
}

func (i GatewaySpecArgs) ToGatewaySpecOutput() GatewaySpecOutput {
	return i.ToGatewaySpecOutputWithContext(context.Background())
}

func (i GatewaySpecArgs) ToGatewaySpecOutputWithContext(ctx context.Context) GatewaySpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecOutput)
}

func (i GatewaySpecArgs) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return i.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (i GatewaySpecArgs) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecOutput).ToGatewaySpecPtrOutputWithContext(ctx)
}

// GatewaySpecPtrInput is an input type that accepts GatewaySpecArgs, GatewaySpecPtr and GatewaySpecPtrOutput values.
// You can construct a concrete instance of `GatewaySpecPtrInput` via:
//
//	        GatewaySpecArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecPtrInput interface {
	pulumi.Input

	ToGatewaySpecPtrOutput() GatewaySpecPtrOutput
	ToGatewaySpecPtrOutputWithContext(context.Context) GatewaySpecPtrOutput
}

type gatewaySpecPtrType GatewaySpecArgs

func GatewaySpecPtr(v *GatewaySpecArgs) GatewaySpecPtrInput {
	return (*gatewaySpecPtrType)(v)
}

func (*gatewaySpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpec)(nil)).Elem()
}

func (i *gatewaySpecPtrType) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return i.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecPtrType) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecOutput struct{ *pulumi.OutputState }

func (GatewaySpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpec)(nil)).Elem()
}

func (o GatewaySpecOutput) ToGatewaySpecOutput() GatewaySpecOutput {
	return o
}

func (o GatewaySpecOutput) ToGatewaySpecOutputWithContext(ctx context.Context) GatewaySpecOutput {
	return o
}

func (o GatewaySpecOutput) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return o.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (o GatewaySpecOutput) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpec) *GatewaySpec {
		return &v
	}).(GatewaySpecPtrOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecOutput) Addresses() GatewaySpecAddressesArrayOutput {
	return o.ApplyT(func(v GatewaySpec) []GatewaySpecAddresses { return v.Addresses }).(GatewaySpecAddressesArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpec) *string { return v.GatewayClassName }).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecOutput) Listeners() GatewaySpecListenersArrayOutput {
	return o.ApplyT(func(v GatewaySpec) []GatewaySpecListeners { return v.Listeners }).(GatewaySpecListenersArrayOutput)
}

type GatewaySpecPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpec)(nil)).Elem()
}

func (o GatewaySpecPtrOutput) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return o
}

func (o GatewaySpecPtrOutput) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return o
}

func (o GatewaySpecPtrOutput) Elem() GatewaySpecOutput {
	return o.ApplyT(func(v *GatewaySpec) GatewaySpec {
		if v != nil {
			return *v
		}
		var ret GatewaySpec
		return ret
	}).(GatewaySpecOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPtrOutput) Addresses() GatewaySpecAddressesArrayOutput {
	return o.ApplyT(func(v *GatewaySpec) []GatewaySpecAddresses {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewaySpecAddressesArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPtrOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpec) *string {
		if v == nil {
			return nil
		}
		return v.GatewayClassName
	}).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPtrOutput) Listeners() GatewaySpecListenersArrayOutput {
	return o.ApplyT(func(v *GatewaySpec) []GatewaySpecListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewaySpecListenersArrayOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddresses struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewaySpecAddressesInput is an input type that accepts GatewaySpecAddressesArgs and GatewaySpecAddressesOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesInput` via:
//
//	GatewaySpecAddressesArgs{...}
type GatewaySpecAddressesInput interface {
	pulumi.Input

	ToGatewaySpecAddressesOutput() GatewaySpecAddressesOutput
	ToGatewaySpecAddressesOutputWithContext(context.Context) GatewaySpecAddressesOutput
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewaySpecAddressesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddresses)(nil)).Elem()
}

func (i GatewaySpecAddressesArgs) ToGatewaySpecAddressesOutput() GatewaySpecAddressesOutput {
	return i.ToGatewaySpecAddressesOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesArgs) ToGatewaySpecAddressesOutputWithContext(ctx context.Context) GatewaySpecAddressesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesOutput)
}

// GatewaySpecAddressesArrayInput is an input type that accepts GatewaySpecAddressesArray and GatewaySpecAddressesArrayOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesArrayInput` via:
//
//	GatewaySpecAddressesArray{ GatewaySpecAddressesArgs{...} }
type GatewaySpecAddressesArrayInput interface {
	pulumi.Input

	ToGatewaySpecAddressesArrayOutput() GatewaySpecAddressesArrayOutput
	ToGatewaySpecAddressesArrayOutputWithContext(context.Context) GatewaySpecAddressesArrayOutput
}

type GatewaySpecAddressesArray []GatewaySpecAddressesInput

func (GatewaySpecAddressesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddresses)(nil)).Elem()
}

func (i GatewaySpecAddressesArray) ToGatewaySpecAddressesArrayOutput() GatewaySpecAddressesArrayOutput {
	return i.ToGatewaySpecAddressesArrayOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesArray) ToGatewaySpecAddressesArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesArrayOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddresses)(nil)).Elem()
}

func (o GatewaySpecAddressesOutput) ToGatewaySpecAddressesOutput() GatewaySpecAddressesOutput {
	return o
}

func (o GatewaySpecAddressesOutput) ToGatewaySpecAddressesOutputWithContext(ctx context.Context) GatewaySpecAddressesOutput {
	return o
}

// Type of the address.
func (o GatewaySpecAddressesOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddresses) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewaySpecAddressesOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddresses) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewaySpecAddressesArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddresses)(nil)).Elem()
}

func (o GatewaySpecAddressesArrayOutput) ToGatewaySpecAddressesArrayOutput() GatewaySpecAddressesArrayOutput {
	return o
}

func (o GatewaySpecAddressesArrayOutput) ToGatewaySpecAddressesArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesArrayOutput {
	return o
}

func (o GatewaySpecAddressesArrayOutput) Index(i pulumi.IntInput) GatewaySpecAddressesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecAddresses {
		return vs[0].([]GatewaySpecAddresses)[vs[1].(int)]
	}).(GatewaySpecAddressesOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesPatch struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewaySpecAddressesPatchInput is an input type that accepts GatewaySpecAddressesPatchArgs and GatewaySpecAddressesPatchOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesPatchInput` via:
//
//	GatewaySpecAddressesPatchArgs{...}
type GatewaySpecAddressesPatchInput interface {
	pulumi.Input

	ToGatewaySpecAddressesPatchOutput() GatewaySpecAddressesPatchOutput
	ToGatewaySpecAddressesPatchOutputWithContext(context.Context) GatewaySpecAddressesPatchOutput
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesPatchArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewaySpecAddressesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddressesPatch)(nil)).Elem()
}

func (i GatewaySpecAddressesPatchArgs) ToGatewaySpecAddressesPatchOutput() GatewaySpecAddressesPatchOutput {
	return i.ToGatewaySpecAddressesPatchOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesPatchArgs) ToGatewaySpecAddressesPatchOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesPatchOutput)
}

// GatewaySpecAddressesPatchArrayInput is an input type that accepts GatewaySpecAddressesPatchArray and GatewaySpecAddressesPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesPatchArrayInput` via:
//
//	GatewaySpecAddressesPatchArray{ GatewaySpecAddressesPatchArgs{...} }
type GatewaySpecAddressesPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecAddressesPatchArrayOutput() GatewaySpecAddressesPatchArrayOutput
	ToGatewaySpecAddressesPatchArrayOutputWithContext(context.Context) GatewaySpecAddressesPatchArrayOutput
}

type GatewaySpecAddressesPatchArray []GatewaySpecAddressesPatchInput

func (GatewaySpecAddressesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddressesPatch)(nil)).Elem()
}

func (i GatewaySpecAddressesPatchArray) ToGatewaySpecAddressesPatchArrayOutput() GatewaySpecAddressesPatchArrayOutput {
	return i.ToGatewaySpecAddressesPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesPatchArray) ToGatewaySpecAddressesPatchArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesPatchArrayOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddressesPatch)(nil)).Elem()
}

func (o GatewaySpecAddressesPatchOutput) ToGatewaySpecAddressesPatchOutput() GatewaySpecAddressesPatchOutput {
	return o
}

func (o GatewaySpecAddressesPatchOutput) ToGatewaySpecAddressesPatchOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchOutput {
	return o
}

// Type of the address.
func (o GatewaySpecAddressesPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddressesPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewaySpecAddressesPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddressesPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewaySpecAddressesPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddressesPatch)(nil)).Elem()
}

func (o GatewaySpecAddressesPatchArrayOutput) ToGatewaySpecAddressesPatchArrayOutput() GatewaySpecAddressesPatchArrayOutput {
	return o
}

func (o GatewaySpecAddressesPatchArrayOutput) ToGatewaySpecAddressesPatchArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchArrayOutput {
	return o
}

func (o GatewaySpecAddressesPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecAddressesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecAddressesPatch {
		return vs[0].([]GatewaySpecAddressesPatch)[vs[1].(int)]
	}).(GatewaySpecAddressesPatchOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListeners struct {
	AllowedRoutes *GatewaySpecListenersAllowedRoutes `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port *int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol *string                  `pulumi:"protocol"`
	Tls      *GatewaySpecListenersTls `pulumi:"tls"`
}

// GatewaySpecListenersInput is an input type that accepts GatewaySpecListenersArgs and GatewaySpecListenersOutput values.
// You can construct a concrete instance of `GatewaySpecListenersInput` via:
//
//	GatewaySpecListenersArgs{...}
type GatewaySpecListenersInput interface {
	pulumi.Input

	ToGatewaySpecListenersOutput() GatewaySpecListenersOutput
	ToGatewaySpecListenersOutputWithContext(context.Context) GatewaySpecListenersOutput
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersArgs struct {
	AllowedRoutes GatewaySpecListenersAllowedRoutesPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol pulumi.StringPtrInput           `pulumi:"protocol"`
	Tls      GatewaySpecListenersTlsPtrInput `pulumi:"tls"`
}

func (GatewaySpecListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListeners)(nil)).Elem()
}

func (i GatewaySpecListenersArgs) ToGatewaySpecListenersOutput() GatewaySpecListenersOutput {
	return i.ToGatewaySpecListenersOutputWithContext(context.Background())
}

func (i GatewaySpecListenersArgs) ToGatewaySpecListenersOutputWithContext(ctx context.Context) GatewaySpecListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersOutput)
}

// GatewaySpecListenersArrayInput is an input type that accepts GatewaySpecListenersArray and GatewaySpecListenersArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersArrayInput` via:
//
//	GatewaySpecListenersArray{ GatewaySpecListenersArgs{...} }
type GatewaySpecListenersArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput
	ToGatewaySpecListenersArrayOutputWithContext(context.Context) GatewaySpecListenersArrayOutput
}

type GatewaySpecListenersArray []GatewaySpecListenersInput

func (GatewaySpecListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListeners)(nil)).Elem()
}

func (i GatewaySpecListenersArray) ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput {
	return i.ToGatewaySpecListenersArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersArray) ToGatewaySpecListenersArrayOutputWithContext(ctx context.Context) GatewaySpecListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersArrayOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListeners)(nil)).Elem()
}

func (o GatewaySpecListenersOutput) ToGatewaySpecListenersOutput() GatewaySpecListenersOutput {
	return o
}

func (o GatewaySpecListenersOutput) ToGatewaySpecListenersOutputWithContext(ctx context.Context) GatewaySpecListenersOutput {
	return o
}

func (o GatewaySpecListenersOutput) AllowedRoutes() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *GatewaySpecListenersAllowedRoutes { return v.AllowedRoutes }).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// Support: Core
func (o GatewaySpecListenersOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// Gateway.
//
// Support: Core
func (o GatewaySpecListenersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
//
// Support: Core
func (o GatewaySpecListenersOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
//
// Support: Core
func (o GatewaySpecListenersOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersOutput) Tls() GatewaySpecListenersTlsPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *GatewaySpecListenersTls { return v.Tls }).(GatewaySpecListenersTlsPtrOutput)
}

type GatewaySpecListenersArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListeners)(nil)).Elem()
}

func (o GatewaySpecListenersArrayOutput) ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput {
	return o
}

func (o GatewaySpecListenersArrayOutput) ToGatewaySpecListenersArrayOutputWithContext(ctx context.Context) GatewaySpecListenersArrayOutput {
	return o
}

func (o GatewaySpecListenersArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListeners {
		return vs[0].([]GatewaySpecListeners)[vs[1].(int)]
	}).(GatewaySpecListenersOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutes struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      []GatewaySpecListenersAllowedRoutesKinds     `pulumi:"kinds"`
	Namespaces *GatewaySpecListenersAllowedRoutesNamespaces `pulumi:"namespaces"`
}

// GatewaySpecListenersAllowedRoutesInput is an input type that accepts GatewaySpecListenersAllowedRoutesArgs and GatewaySpecListenersAllowedRoutesOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesInput` via:
//
//	GatewaySpecListenersAllowedRoutesArgs{...}
type GatewaySpecListenersAllowedRoutesInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput
	ToGatewaySpecListenersAllowedRoutesOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      GatewaySpecListenersAllowedRoutesKindsArrayInput    `pulumi:"kinds"`
	Namespaces GatewaySpecListenersAllowedRoutesNamespacesPtrInput `pulumi:"namespaces"`
}

func (GatewaySpecListenersAllowedRoutesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput {
	return i.ToGatewaySpecListenersAllowedRoutesOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesOutput)
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesOutput).ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesArgs, GatewaySpecListenersAllowedRoutesPtr and GatewaySpecListenersAllowedRoutesPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput
	ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPtrOutput
}

type gatewaySpecListenersAllowedRoutesPtrType GatewaySpecListenersAllowedRoutesArgs

func GatewaySpecListenersAllowedRoutesPtr(v *GatewaySpecListenersAllowedRoutesArgs) GatewaySpecListenersAllowedRoutesPtrInput {
	return (*gatewaySpecListenersAllowedRoutesPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesPtrType) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesPtrType) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutes {
		return &v
	}).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutes) []GatewaySpecListenersAllowedRoutesKinds { return v.Kinds }).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutesNamespaces {
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

type GatewaySpecListenersAllowedRoutesPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) Elem() GatewaySpecListenersAllowedRoutesOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) GatewaySpecListenersAllowedRoutes {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutes
		return ret
	}).(GatewaySpecListenersAllowedRoutesOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPtrOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) []GatewaySpecListenersAllowedRoutesKinds {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutesNamespaces {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewaySpecListenersAllowedRoutesKindsInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsArgs and GatewaySpecListenersAllowedRoutesKindsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsArgs{...}
type GatewaySpecListenersAllowedRoutesKindsInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput
	ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewaySpecListenersAllowedRoutesKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsArgs) ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsArgs) ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsOutput)
}

// GatewaySpecListenersAllowedRoutesKindsArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsArray and GatewaySpecListenersAllowedRoutesKindsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsArray{ GatewaySpecListenersAllowedRoutesKindsArgs{...} }
type GatewaySpecListenersAllowedRoutesKindsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput
	ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput
}

type GatewaySpecListenersAllowedRoutesKindsArray []GatewaySpecListenersAllowedRoutesKindsInput

func (GatewaySpecListenersAllowedRoutesKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsArray) ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsArray) ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsOutput) ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsOutput) ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsOutput {
	return o
}

// Group is the group of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKinds) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersAllowedRoutesKindsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesKinds {
		return vs[0].([]GatewaySpecListenersAllowedRoutesKinds)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesKindsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsPatch struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewaySpecListenersAllowedRoutesKindsPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsPatchArgs and GatewaySpecListenersAllowedRoutesKindsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsPatchArgs{...}
type GatewaySpecListenersAllowedRoutesKindsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsPatchOutput() GatewaySpecListenersAllowedRoutesKindsPatchOutput
	ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsPatchOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsPatchArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewaySpecListenersAllowedRoutesKindsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArgs) ToGatewaySpecListenersAllowedRoutesKindsPatchOutput() GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArgs) ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsPatchOutput)
}

// GatewaySpecListenersAllowedRoutesKindsPatchArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsPatchArray and GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsPatchArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsPatchArray{ GatewaySpecListenersAllowedRoutesKindsPatchArgs{...} }
type GatewaySpecListenersAllowedRoutesKindsPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutput() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput
	ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput
}

type GatewaySpecListenersAllowedRoutesKindsPatchArray []GatewaySpecListenersAllowedRoutesKindsPatchInput

func (GatewaySpecListenersAllowedRoutesKindsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArray) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutput() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArray) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchOutput() GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return o
}

// Group is the group of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKindsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKindsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutput() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesKindsPatch {
		return vs[0].([]GatewaySpecListenersAllowedRoutesKindsPatch)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesKindsPatchOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespaces struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     *string                                              `pulumi:"from"`
	Selector *GatewaySpecListenersAllowedRoutesNamespacesSelector `pulumi:"selector"`
}

// GatewaySpecListenersAllowedRoutesNamespacesInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesArgs and GatewaySpecListenersAllowedRoutesNamespacesOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     pulumi.StringPtrInput                                       `pulumi:"from"`
	Selector GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput `pulumi:"selector"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesOutput).ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesArgs, GatewaySpecListenersAllowedRoutesNamespacesPtr and GatewaySpecListenersAllowedRoutesNamespacesPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesPtrType GatewaySpecListenersAllowedRoutesNamespacesArgs

func GatewaySpecListenersAllowedRoutesNamespacesPtr(v *GatewaySpecListenersAllowedRoutesNamespacesArgs) GatewaySpecListenersAllowedRoutesNamespacesPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespaces {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespaces) *string { return v.From }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) GatewaySpecListenersAllowedRoutesNamespaces {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespaces
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesPatch struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     *string                                                   `pulumi:"from"`
	Selector *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch `pulumi:"selector"`
}

// GatewaySpecListenersAllowedRoutesNamespacesPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesPatchArgs and GatewaySpecListenersAllowedRoutesNamespacesPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesPatchArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     pulumi.StringPtrInput                                            `pulumi:"from"`
	Selector GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput `pulumi:"selector"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput).ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesPatchArgs, GatewaySpecListenersAllowedRoutesNamespacesPatchPtr and GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType GatewaySpecListenersAllowedRoutesNamespacesPatchArgs

func GatewaySpecListenersAllowedRoutesNamespacesPatchPtr(v *GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesPatch) *GatewaySpecListenersAllowedRoutesNamespacesPatch {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesPatch) *string { return v.From }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesPatch) *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesPatch) GatewaySpecListenersAllowedRoutesNamespacesPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesPatch
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesPatch) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesPatch) *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput).ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs, GatewaySpecListenersAllowedRoutesNamespacesSelectorPtr and GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs

func GatewaySpecListenersAllowedRoutesNamespacesSelectorPtr(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesSelector) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelector) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) GatewaySpecListenersAllowedRoutesNamespacesSelector {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesSelector
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{ GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...} }
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return vs[0].([]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray{ GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{...} }
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		return vs[0].([]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput).ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs, GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtr and GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs

func GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtr(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesPatch struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      []GatewaySpecListenersAllowedRoutesKindsPatch     `pulumi:"kinds"`
	Namespaces *GatewaySpecListenersAllowedRoutesNamespacesPatch `pulumi:"namespaces"`
}

// GatewaySpecListenersAllowedRoutesPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesPatchArgs and GatewaySpecListenersAllowedRoutesPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesPatchArgs{...}
type GatewaySpecListenersAllowedRoutesPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPatchOutput() GatewaySpecListenersAllowedRoutesPatchOutput
	ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPatchOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesPatchArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      GatewaySpecListenersAllowedRoutesKindsPatchArrayInput    `pulumi:"kinds"`
	Namespaces GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput `pulumi:"namespaces"`
}

func (GatewaySpecListenersAllowedRoutesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchOutput() GatewaySpecListenersAllowedRoutesPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPatchOutput)
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPatchOutput).ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesPatchPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesPatchArgs, GatewaySpecListenersAllowedRoutesPatchPtr and GatewaySpecListenersAllowedRoutesPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPatchPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput
	ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput
}

type gatewaySpecListenersAllowedRoutesPatchPtrType GatewaySpecListenersAllowedRoutesPatchArgs

func GatewaySpecListenersAllowedRoutesPatchPtr(v *GatewaySpecListenersAllowedRoutesPatchArgs) GatewaySpecListenersAllowedRoutesPatchPtrInput {
	return (*gatewaySpecListenersAllowedRoutesPatchPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesPatchPtrType) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesPatchPtrType) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPatchPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchOutput() GatewaySpecListenersAllowedRoutesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesPatch) *GatewaySpecListenersAllowedRoutesPatch {
		return &v
	}).(GatewaySpecListenersAllowedRoutesPatchPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPatchOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesPatch) []GatewaySpecListenersAllowedRoutesKindsPatch {
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesPatch) *GatewaySpecListenersAllowedRoutesNamespacesPatch {
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

type GatewaySpecListenersAllowedRoutesPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) Elem() GatewaySpecListenersAllowedRoutesPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesPatch) GatewaySpecListenersAllowedRoutesPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesPatch
		return ret
	}).(GatewaySpecListenersAllowedRoutesPatchOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesPatch) []GatewaySpecListenersAllowedRoutesKindsPatch {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesPatch) *GatewaySpecListenersAllowedRoutesNamespacesPatch {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersPatch struct {
	AllowedRoutes *GatewaySpecListenersAllowedRoutesPatch `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port *int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol *string                       `pulumi:"protocol"`
	Tls      *GatewaySpecListenersTlsPatch `pulumi:"tls"`
}

// GatewaySpecListenersPatchInput is an input type that accepts GatewaySpecListenersPatchArgs and GatewaySpecListenersPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersPatchInput` via:
//
//	GatewaySpecListenersPatchArgs{...}
type GatewaySpecListenersPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersPatchOutput() GatewaySpecListenersPatchOutput
	ToGatewaySpecListenersPatchOutputWithContext(context.Context) GatewaySpecListenersPatchOutput
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersPatchArgs struct {
	AllowedRoutes GatewaySpecListenersAllowedRoutesPatchPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol pulumi.StringPtrInput                `pulumi:"protocol"`
	Tls      GatewaySpecListenersTlsPatchPtrInput `pulumi:"tls"`
}

func (GatewaySpecListenersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersPatch)(nil)).Elem()
}

func (i GatewaySpecListenersPatchArgs) ToGatewaySpecListenersPatchOutput() GatewaySpecListenersPatchOutput {
	return i.ToGatewaySpecListenersPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersPatchArgs) ToGatewaySpecListenersPatchOutputWithContext(ctx context.Context) GatewaySpecListenersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersPatchOutput)
}

// GatewaySpecListenersPatchArrayInput is an input type that accepts GatewaySpecListenersPatchArray and GatewaySpecListenersPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersPatchArrayInput` via:
//
//	GatewaySpecListenersPatchArray{ GatewaySpecListenersPatchArgs{...} }
type GatewaySpecListenersPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersPatchArrayOutput() GatewaySpecListenersPatchArrayOutput
	ToGatewaySpecListenersPatchArrayOutputWithContext(context.Context) GatewaySpecListenersPatchArrayOutput
}

type GatewaySpecListenersPatchArray []GatewaySpecListenersPatchInput

func (GatewaySpecListenersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersPatch)(nil)).Elem()
}

func (i GatewaySpecListenersPatchArray) ToGatewaySpecListenersPatchArrayOutput() GatewaySpecListenersPatchArrayOutput {
	return i.ToGatewaySpecListenersPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersPatchArray) ToGatewaySpecListenersPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersPatchArrayOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersPatch)(nil)).Elem()
}

func (o GatewaySpecListenersPatchOutput) ToGatewaySpecListenersPatchOutput() GatewaySpecListenersPatchOutput {
	return o
}

func (o GatewaySpecListenersPatchOutput) ToGatewaySpecListenersPatchOutputWithContext(ctx context.Context) GatewaySpecListenersPatchOutput {
	return o
}

func (o GatewaySpecListenersPatchOutput) AllowedRoutes() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *GatewaySpecListenersAllowedRoutesPatch { return v.AllowedRoutes }).(GatewaySpecListenersAllowedRoutesPatchPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// Gateway.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersPatchOutput) Tls() GatewaySpecListenersTlsPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *GatewaySpecListenersTlsPatch { return v.Tls }).(GatewaySpecListenersTlsPatchPtrOutput)
}

type GatewaySpecListenersPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersPatch)(nil)).Elem()
}

func (o GatewaySpecListenersPatchArrayOutput) ToGatewaySpecListenersPatchArrayOutput() GatewaySpecListenersPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersPatchArrayOutput) ToGatewaySpecListenersPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersPatch {
		return vs[0].([]GatewaySpecListenersPatch)[vs[1].(int)]
	}).(GatewaySpecListenersPatchOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTls struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs []GatewaySpecListenersTlsCertificateRefs `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// GatewaySpecListenersTlsInput is an input type that accepts GatewaySpecListenersTlsArgs and GatewaySpecListenersTlsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsInput` via:
//
//	GatewaySpecListenersTlsArgs{...}
type GatewaySpecListenersTlsInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput
	ToGatewaySpecListenersTlsOutputWithContext(context.Context) GatewaySpecListenersTlsOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs GatewaySpecListenersTlsCertificateRefsArrayInput `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

func (GatewaySpecListenersTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTls)(nil)).Elem()
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput {
	return i.ToGatewaySpecListenersTlsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsOutput)
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return i.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsOutput).ToGatewaySpecListenersTlsPtrOutputWithContext(ctx)
}

// GatewaySpecListenersTlsPtrInput is an input type that accepts GatewaySpecListenersTlsArgs, GatewaySpecListenersTlsPtr and GatewaySpecListenersTlsPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPtrInput` via:
//
//	        GatewaySpecListenersTlsArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersTlsPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput
	ToGatewaySpecListenersTlsPtrOutputWithContext(context.Context) GatewaySpecListenersTlsPtrOutput
}

type gatewaySpecListenersTlsPtrType GatewaySpecListenersTlsArgs

func GatewaySpecListenersTlsPtr(v *GatewaySpecListenersTlsArgs) GatewaySpecListenersTlsPtrInput {
	return (*gatewaySpecListenersTlsPtrType)(v)
}

func (*gatewaySpecListenersTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTls)(nil)).Elem()
}

func (i *gatewaySpecListenersTlsPtrType) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return i.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersTlsPtrType) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTls)(nil)).Elem()
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput {
	return o
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsOutput {
	return o
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return o.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersTls) *GatewaySpecListenersTls {
		return &v
	}).(GatewaySpecListenersTlsPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) []GatewaySpecListenersTlsCertificateRefs { return v.CertificateRefs }).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersTlsPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTls)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPtrOutput) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPtrOutput) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPtrOutput) Elem() GatewaySpecListenersTlsOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) GatewaySpecListenersTls {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersTls
		return ret
	}).(GatewaySpecListenersTlsOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPtrOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) []GatewaySpecListenersTlsCertificateRefs {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// GatewaySpecListenersTlsCertificateRefsInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsArgs and GatewaySpecListenersTlsCertificateRefsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsArgs{...}
type GatewaySpecListenersTlsCertificateRefsInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput
	ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewaySpecListenersTlsCertificateRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsArgs) ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsArgs) ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsOutput)
}

// GatewaySpecListenersTlsCertificateRefsArrayInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsArray and GatewaySpecListenersTlsCertificateRefsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsArrayInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsArray{ GatewaySpecListenersTlsCertificateRefsArgs{...} }
type GatewaySpecListenersTlsCertificateRefsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput
	ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput
}

type GatewaySpecListenersTlsCertificateRefsArray []GatewaySpecListenersTlsCertificateRefsInput

func (GatewaySpecListenersTlsCertificateRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsArray) ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsArray) ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsOutput) ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsOutput) ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GatewaySpecListenersTlsCertificateRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o GatewaySpecListenersTlsCertificateRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewaySpecListenersTlsCertificateRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GatewaySpecListenersTlsCertificateRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersTlsCertificateRefsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersTlsCertificateRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersTlsCertificateRefs {
		return vs[0].([]GatewaySpecListenersTlsCertificateRefs)[vs[1].(int)]
	}).(GatewaySpecListenersTlsCertificateRefsOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// GatewaySpecListenersTlsCertificateRefsPatchInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsPatchArgs and GatewaySpecListenersTlsCertificateRefsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsPatchInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsPatchArgs{...}
type GatewaySpecListenersTlsCertificateRefsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsPatchOutput() GatewaySpecListenersTlsCertificateRefsPatchOutput
	ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsPatchOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewaySpecListenersTlsCertificateRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArgs) ToGatewaySpecListenersTlsCertificateRefsPatchOutput() GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArgs) ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsPatchOutput)
}

// GatewaySpecListenersTlsCertificateRefsPatchArrayInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsPatchArray and GatewaySpecListenersTlsCertificateRefsPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsPatchArrayInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsPatchArray{ GatewaySpecListenersTlsCertificateRefsPatchArgs{...} }
type GatewaySpecListenersTlsCertificateRefsPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutput() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput
	ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsPatchArrayOutput
}

type GatewaySpecListenersTlsCertificateRefsPatchArray []GatewaySpecListenersTlsCertificateRefsPatchInput

func (GatewaySpecListenersTlsCertificateRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArray) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutput() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArray) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) ToGatewaySpecListenersTlsCertificateRefsPatchOutput() GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersTlsCertificateRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutput() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersTlsCertificateRefsPatch {
		return vs[0].([]GatewaySpecListenersTlsCertificateRefsPatch)[vs[1].(int)]
	}).(GatewaySpecListenersTlsCertificateRefsPatchOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsPatch struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs []GatewaySpecListenersTlsCertificateRefsPatch `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// GatewaySpecListenersTlsPatchInput is an input type that accepts GatewaySpecListenersTlsPatchArgs and GatewaySpecListenersTlsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPatchInput` via:
//
//	GatewaySpecListenersTlsPatchArgs{...}
type GatewaySpecListenersTlsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPatchOutput() GatewaySpecListenersTlsPatchOutput
	ToGatewaySpecListenersTlsPatchOutputWithContext(context.Context) GatewaySpecListenersTlsPatchOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsPatchArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs GatewaySpecListenersTlsCertificateRefsPatchArrayInput `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

func (GatewaySpecListenersTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchOutput() GatewaySpecListenersTlsPatchOutput {
	return i.ToGatewaySpecListenersTlsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPatchOutput)
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return i.ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPatchOutput).ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersTlsPatchPtrInput is an input type that accepts GatewaySpecListenersTlsPatchArgs, GatewaySpecListenersTlsPatchPtr and GatewaySpecListenersTlsPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPatchPtrInput` via:
//
//	        GatewaySpecListenersTlsPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersTlsPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput
	ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Context) GatewaySpecListenersTlsPatchPtrOutput
}

type gatewaySpecListenersTlsPatchPtrType GatewaySpecListenersTlsPatchArgs

func GatewaySpecListenersTlsPatchPtr(v *GatewaySpecListenersTlsPatchArgs) GatewaySpecListenersTlsPatchPtrInput {
	return (*gatewaySpecListenersTlsPatchPtrType)(v)
}

func (*gatewaySpecListenersTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersTlsPatchPtrType) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return i.ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersTlsPatchPtrType) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPatchPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchOutput() GatewaySpecListenersTlsPatchOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return o.ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersTlsPatch) *GatewaySpecListenersTlsPatch {
		return &v
	}).(GatewaySpecListenersTlsPatchPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPatchOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsPatch) []GatewaySpecListenersTlsCertificateRefsPatch {
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPatchOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsPatch) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPatchOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsPatch) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPatchPtrOutput) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchPtrOutput) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchPtrOutput) Elem() GatewaySpecListenersTlsPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) GatewaySpecListenersTlsPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersTlsPatch
		return ret
	}).(GatewaySpecListenersTlsPatchOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPatchPtrOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) []GatewaySpecListenersTlsCertificateRefsPatch {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPatchPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPatchPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecPatch struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses []GatewaySpecAddressesPatch `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName *string `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners []GatewaySpecListenersPatch `pulumi:"listeners"`
}

// GatewaySpecPatchInput is an input type that accepts GatewaySpecPatchArgs and GatewaySpecPatchOutput values.
// You can construct a concrete instance of `GatewaySpecPatchInput` via:
//
//	GatewaySpecPatchArgs{...}
type GatewaySpecPatchInput interface {
	pulumi.Input

	ToGatewaySpecPatchOutput() GatewaySpecPatchOutput
	ToGatewaySpecPatchOutputWithContext(context.Context) GatewaySpecPatchOutput
}

// Spec defines the desired state of Gateway.
type GatewaySpecPatchArgs struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses GatewaySpecAddressesPatchArrayInput `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName pulumi.StringPtrInput `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners GatewaySpecListenersPatchArrayInput `pulumi:"listeners"`
}

func (GatewaySpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecPatch)(nil)).Elem()
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchOutput() GatewaySpecPatchOutput {
	return i.ToGatewaySpecPatchOutputWithContext(context.Background())
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchOutputWithContext(ctx context.Context) GatewaySpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPatchOutput)
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return i.ToGatewaySpecPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPatchOutput).ToGatewaySpecPatchPtrOutputWithContext(ctx)
}

// GatewaySpecPatchPtrInput is an input type that accepts GatewaySpecPatchArgs, GatewaySpecPatchPtr and GatewaySpecPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecPatchPtrInput` via:
//
//	        GatewaySpecPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput
	ToGatewaySpecPatchPtrOutputWithContext(context.Context) GatewaySpecPatchPtrOutput
}

type gatewaySpecPatchPtrType GatewaySpecPatchArgs

func GatewaySpecPatchPtr(v *GatewaySpecPatchArgs) GatewaySpecPatchPtrInput {
	return (*gatewaySpecPatchPtrType)(v)
}

func (*gatewaySpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecPatch)(nil)).Elem()
}

func (i *gatewaySpecPatchPtrType) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return i.ToGatewaySpecPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecPatchPtrType) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPatchPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecPatch)(nil)).Elem()
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchOutput() GatewaySpecPatchOutput {
	return o
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchOutputWithContext(ctx context.Context) GatewaySpecPatchOutput {
	return o
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return o.ToGatewaySpecPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecPatch) *GatewaySpecPatch {
		return &v
	}).(GatewaySpecPatchPtrOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPatchOutput) Addresses() GatewaySpecAddressesPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecPatch) []GatewaySpecAddressesPatch { return v.Addresses }).(GatewaySpecAddressesPatchArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPatchOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecPatch) *string { return v.GatewayClassName }).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPatchOutput) Listeners() GatewaySpecListenersPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecPatch) []GatewaySpecListenersPatch { return v.Listeners }).(GatewaySpecListenersPatchArrayOutput)
}

type GatewaySpecPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecPatch)(nil)).Elem()
}

func (o GatewaySpecPatchPtrOutput) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return o
}

func (o GatewaySpecPatchPtrOutput) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return o
}

func (o GatewaySpecPatchPtrOutput) Elem() GatewaySpecPatchOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) GatewaySpecPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecPatch
		return ret
	}).(GatewaySpecPatchOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPatchPtrOutput) Addresses() GatewaySpecAddressesPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) []GatewaySpecAddressesPatch {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewaySpecAddressesPatchArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPatchPtrOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.GatewayClassName
	}).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPatchPtrOutput) Listeners() GatewaySpecListenersPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) []GatewaySpecListenersPatch {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewaySpecListenersPatchArrayOutput)
}

// Status defines the current state of Gateway.
type GatewayStatus struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses []GatewayStatusAddresses `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions []GatewayStatusConditions `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []GatewayStatusListeners `pulumi:"listeners"`
}

// GatewayStatusInput is an input type that accepts GatewayStatusArgs and GatewayStatusOutput values.
// You can construct a concrete instance of `GatewayStatusInput` via:
//
//	GatewayStatusArgs{...}
type GatewayStatusInput interface {
	pulumi.Input

	ToGatewayStatusOutput() GatewayStatusOutput
	ToGatewayStatusOutputWithContext(context.Context) GatewayStatusOutput
}

// Status defines the current state of Gateway.
type GatewayStatusArgs struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses GatewayStatusAddressesArrayInput `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions GatewayStatusConditionsArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners GatewayStatusListenersArrayInput `pulumi:"listeners"`
}

func (GatewayStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatus)(nil)).Elem()
}

func (i GatewayStatusArgs) ToGatewayStatusOutput() GatewayStatusOutput {
	return i.ToGatewayStatusOutputWithContext(context.Background())
}

func (i GatewayStatusArgs) ToGatewayStatusOutputWithContext(ctx context.Context) GatewayStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusOutput)
}

func (i GatewayStatusArgs) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return i.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (i GatewayStatusArgs) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusOutput).ToGatewayStatusPtrOutputWithContext(ctx)
}

// GatewayStatusPtrInput is an input type that accepts GatewayStatusArgs, GatewayStatusPtr and GatewayStatusPtrOutput values.
// You can construct a concrete instance of `GatewayStatusPtrInput` via:
//
//	        GatewayStatusArgs{...}
//
//	or:
//
//	        nil
type GatewayStatusPtrInput interface {
	pulumi.Input

	ToGatewayStatusPtrOutput() GatewayStatusPtrOutput
	ToGatewayStatusPtrOutputWithContext(context.Context) GatewayStatusPtrOutput
}

type gatewayStatusPtrType GatewayStatusArgs

func GatewayStatusPtr(v *GatewayStatusArgs) GatewayStatusPtrInput {
	return (*gatewayStatusPtrType)(v)
}

func (*gatewayStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatus)(nil)).Elem()
}

func (i *gatewayStatusPtrType) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return i.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (i *gatewayStatusPtrType) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPtrOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusOutput struct{ *pulumi.OutputState }

func (GatewayStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatus)(nil)).Elem()
}

func (o GatewayStatusOutput) ToGatewayStatusOutput() GatewayStatusOutput {
	return o
}

func (o GatewayStatusOutput) ToGatewayStatusOutputWithContext(ctx context.Context) GatewayStatusOutput {
	return o
}

func (o GatewayStatusOutput) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return o.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (o GatewayStatusOutput) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayStatus) *GatewayStatus {
		return &v
	}).(GatewayStatusPtrOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusOutput) Addresses() GatewayStatusAddressesArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusAddresses { return v.Addresses }).(GatewayStatusAddressesArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusOutput) Conditions() GatewayStatusConditionsArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusConditions { return v.Conditions }).(GatewayStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusOutput) Listeners() GatewayStatusListenersArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusListeners { return v.Listeners }).(GatewayStatusListenersArrayOutput)
}

type GatewayStatusPtrOutput struct{ *pulumi.OutputState }

func (GatewayStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatus)(nil)).Elem()
}

func (o GatewayStatusPtrOutput) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return o
}

func (o GatewayStatusPtrOutput) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return o
}

func (o GatewayStatusPtrOutput) Elem() GatewayStatusOutput {
	return o.ApplyT(func(v *GatewayStatus) GatewayStatus {
		if v != nil {
			return *v
		}
		var ret GatewayStatus
		return ret
	}).(GatewayStatusOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPtrOutput) Addresses() GatewayStatusAddressesArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusAddresses {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewayStatusAddressesArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPtrOutput) Conditions() GatewayStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPtrOutput) Listeners() GatewayStatusListenersArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewayStatusListenersArrayOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddresses struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewayStatusAddressesInput is an input type that accepts GatewayStatusAddressesArgs and GatewayStatusAddressesOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesInput` via:
//
//	GatewayStatusAddressesArgs{...}
type GatewayStatusAddressesInput interface {
	pulumi.Input

	ToGatewayStatusAddressesOutput() GatewayStatusAddressesOutput
	ToGatewayStatusAddressesOutputWithContext(context.Context) GatewayStatusAddressesOutput
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewayStatusAddressesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddresses)(nil)).Elem()
}

func (i GatewayStatusAddressesArgs) ToGatewayStatusAddressesOutput() GatewayStatusAddressesOutput {
	return i.ToGatewayStatusAddressesOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesArgs) ToGatewayStatusAddressesOutputWithContext(ctx context.Context) GatewayStatusAddressesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesOutput)
}

// GatewayStatusAddressesArrayInput is an input type that accepts GatewayStatusAddressesArray and GatewayStatusAddressesArrayOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesArrayInput` via:
//
//	GatewayStatusAddressesArray{ GatewayStatusAddressesArgs{...} }
type GatewayStatusAddressesArrayInput interface {
	pulumi.Input

	ToGatewayStatusAddressesArrayOutput() GatewayStatusAddressesArrayOutput
	ToGatewayStatusAddressesArrayOutputWithContext(context.Context) GatewayStatusAddressesArrayOutput
}

type GatewayStatusAddressesArray []GatewayStatusAddressesInput

func (GatewayStatusAddressesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddresses)(nil)).Elem()
}

func (i GatewayStatusAddressesArray) ToGatewayStatusAddressesArrayOutput() GatewayStatusAddressesArrayOutput {
	return i.ToGatewayStatusAddressesArrayOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesArray) ToGatewayStatusAddressesArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesArrayOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddresses)(nil)).Elem()
}

func (o GatewayStatusAddressesOutput) ToGatewayStatusAddressesOutput() GatewayStatusAddressesOutput {
	return o
}

func (o GatewayStatusAddressesOutput) ToGatewayStatusAddressesOutputWithContext(ctx context.Context) GatewayStatusAddressesOutput {
	return o
}

// Type of the address.
func (o GatewayStatusAddressesOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddresses) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewayStatusAddressesOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddresses) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewayStatusAddressesArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddresses)(nil)).Elem()
}

func (o GatewayStatusAddressesArrayOutput) ToGatewayStatusAddressesArrayOutput() GatewayStatusAddressesArrayOutput {
	return o
}

func (o GatewayStatusAddressesArrayOutput) ToGatewayStatusAddressesArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesArrayOutput {
	return o
}

func (o GatewayStatusAddressesArrayOutput) Index(i pulumi.IntInput) GatewayStatusAddressesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusAddresses {
		return vs[0].([]GatewayStatusAddresses)[vs[1].(int)]
	}).(GatewayStatusAddressesOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesPatch struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewayStatusAddressesPatchInput is an input type that accepts GatewayStatusAddressesPatchArgs and GatewayStatusAddressesPatchOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesPatchInput` via:
//
//	GatewayStatusAddressesPatchArgs{...}
type GatewayStatusAddressesPatchInput interface {
	pulumi.Input

	ToGatewayStatusAddressesPatchOutput() GatewayStatusAddressesPatchOutput
	ToGatewayStatusAddressesPatchOutputWithContext(context.Context) GatewayStatusAddressesPatchOutput
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesPatchArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewayStatusAddressesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddressesPatch)(nil)).Elem()
}

func (i GatewayStatusAddressesPatchArgs) ToGatewayStatusAddressesPatchOutput() GatewayStatusAddressesPatchOutput {
	return i.ToGatewayStatusAddressesPatchOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesPatchArgs) ToGatewayStatusAddressesPatchOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesPatchOutput)
}

// GatewayStatusAddressesPatchArrayInput is an input type that accepts GatewayStatusAddressesPatchArray and GatewayStatusAddressesPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesPatchArrayInput` via:
//
//	GatewayStatusAddressesPatchArray{ GatewayStatusAddressesPatchArgs{...} }
type GatewayStatusAddressesPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusAddressesPatchArrayOutput() GatewayStatusAddressesPatchArrayOutput
	ToGatewayStatusAddressesPatchArrayOutputWithContext(context.Context) GatewayStatusAddressesPatchArrayOutput
}

type GatewayStatusAddressesPatchArray []GatewayStatusAddressesPatchInput

func (GatewayStatusAddressesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddressesPatch)(nil)).Elem()
}

func (i GatewayStatusAddressesPatchArray) ToGatewayStatusAddressesPatchArrayOutput() GatewayStatusAddressesPatchArrayOutput {
	return i.ToGatewayStatusAddressesPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesPatchArray) ToGatewayStatusAddressesPatchArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesPatchArrayOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddressesPatch)(nil)).Elem()
}

func (o GatewayStatusAddressesPatchOutput) ToGatewayStatusAddressesPatchOutput() GatewayStatusAddressesPatchOutput {
	return o
}

func (o GatewayStatusAddressesPatchOutput) ToGatewayStatusAddressesPatchOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchOutput {
	return o
}

// Type of the address.
func (o GatewayStatusAddressesPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddressesPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewayStatusAddressesPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddressesPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewayStatusAddressesPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddressesPatch)(nil)).Elem()
}

func (o GatewayStatusAddressesPatchArrayOutput) ToGatewayStatusAddressesPatchArrayOutput() GatewayStatusAddressesPatchArrayOutput {
	return o
}

func (o GatewayStatusAddressesPatchArrayOutput) ToGatewayStatusAddressesPatchArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchArrayOutput {
	return o
}

func (o GatewayStatusAddressesPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusAddressesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusAddressesPatch {
		return vs[0].([]GatewayStatusAddressesPatch)[vs[1].(int)]
	}).(GatewayStatusAddressesPatchOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusConditionsInput is an input type that accepts GatewayStatusConditionsArgs and GatewayStatusConditionsOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsInput` via:
//
//	GatewayStatusConditionsArgs{...}
type GatewayStatusConditionsInput interface {
	pulumi.Input

	ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput
	ToGatewayStatusConditionsOutputWithContext(context.Context) GatewayStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditions)(nil)).Elem()
}

func (i GatewayStatusConditionsArgs) ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput {
	return i.ToGatewayStatusConditionsOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsArgs) ToGatewayStatusConditionsOutputWithContext(ctx context.Context) GatewayStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsOutput)
}

// GatewayStatusConditionsArrayInput is an input type that accepts GatewayStatusConditionsArray and GatewayStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsArrayInput` via:
//
//	GatewayStatusConditionsArray{ GatewayStatusConditionsArgs{...} }
type GatewayStatusConditionsArrayInput interface {
	pulumi.Input

	ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput
	ToGatewayStatusConditionsArrayOutputWithContext(context.Context) GatewayStatusConditionsArrayOutput
}

type GatewayStatusConditionsArray []GatewayStatusConditionsInput

func (GatewayStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditions)(nil)).Elem()
}

func (i GatewayStatusConditionsArray) ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput {
	return i.ToGatewayStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsArray) ToGatewayStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditions)(nil)).Elem()
}

func (o GatewayStatusConditionsOutput) ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput {
	return o
}

func (o GatewayStatusConditionsOutput) ToGatewayStatusConditionsOutputWithContext(ctx context.Context) GatewayStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditions)(nil)).Elem()
}

func (o GatewayStatusConditionsArrayOutput) ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput {
	return o
}

func (o GatewayStatusConditionsArrayOutput) ToGatewayStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsArrayOutput {
	return o
}

func (o GatewayStatusConditionsArrayOutput) Index(i pulumi.IntInput) GatewayStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusConditions {
		return vs[0].([]GatewayStatusConditions)[vs[1].(int)]
	}).(GatewayStatusConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusConditionsPatchInput is an input type that accepts GatewayStatusConditionsPatchArgs and GatewayStatusConditionsPatchOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsPatchInput` via:
//
//	GatewayStatusConditionsPatchArgs{...}
type GatewayStatusConditionsPatchInput interface {
	pulumi.Input

	ToGatewayStatusConditionsPatchOutput() GatewayStatusConditionsPatchOutput
	ToGatewayStatusConditionsPatchOutputWithContext(context.Context) GatewayStatusConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusConditionsPatchArgs) ToGatewayStatusConditionsPatchOutput() GatewayStatusConditionsPatchOutput {
	return i.ToGatewayStatusConditionsPatchOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsPatchArgs) ToGatewayStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsPatchOutput)
}

// GatewayStatusConditionsPatchArrayInput is an input type that accepts GatewayStatusConditionsPatchArray and GatewayStatusConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsPatchArrayInput` via:
//
//	GatewayStatusConditionsPatchArray{ GatewayStatusConditionsPatchArgs{...} }
type GatewayStatusConditionsPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusConditionsPatchArrayOutput() GatewayStatusConditionsPatchArrayOutput
	ToGatewayStatusConditionsPatchArrayOutputWithContext(context.Context) GatewayStatusConditionsPatchArrayOutput
}

type GatewayStatusConditionsPatchArray []GatewayStatusConditionsPatchInput

func (GatewayStatusConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusConditionsPatchArray) ToGatewayStatusConditionsPatchArrayOutput() GatewayStatusConditionsPatchArrayOutput {
	return i.ToGatewayStatusConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsPatchArray) ToGatewayStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusConditionsPatchOutput) ToGatewayStatusConditionsPatchOutput() GatewayStatusConditionsPatchOutput {
	return o
}

func (o GatewayStatusConditionsPatchOutput) ToGatewayStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusConditionsPatchArrayOutput) ToGatewayStatusConditionsPatchArrayOutput() GatewayStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusConditionsPatchArrayOutput) ToGatewayStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusConditionsPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusConditionsPatch {
		return vs[0].([]GatewayStatusConditionsPatch)[vs[1].(int)]
	}).(GatewayStatusConditionsPatchOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListeners struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []GatewayStatusListenersConditions `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name *string `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []GatewayStatusListenersSupportedKinds `pulumi:"supportedKinds"`
}

// GatewayStatusListenersInput is an input type that accepts GatewayStatusListenersArgs and GatewayStatusListenersOutput values.
// You can construct a concrete instance of `GatewayStatusListenersInput` via:
//
//	GatewayStatusListenersArgs{...}
type GatewayStatusListenersInput interface {
	pulumi.Input

	ToGatewayStatusListenersOutput() GatewayStatusListenersOutput
	ToGatewayStatusListenersOutputWithContext(context.Context) GatewayStatusListenersOutput
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntPtrInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions GatewayStatusListenersConditionsArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds GatewayStatusListenersSupportedKindsArrayInput `pulumi:"supportedKinds"`
}

func (GatewayStatusListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListeners)(nil)).Elem()
}

func (i GatewayStatusListenersArgs) ToGatewayStatusListenersOutput() GatewayStatusListenersOutput {
	return i.ToGatewayStatusListenersOutputWithContext(context.Background())
}

func (i GatewayStatusListenersArgs) ToGatewayStatusListenersOutputWithContext(ctx context.Context) GatewayStatusListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersOutput)
}

// GatewayStatusListenersArrayInput is an input type that accepts GatewayStatusListenersArray and GatewayStatusListenersArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersArrayInput` via:
//
//	GatewayStatusListenersArray{ GatewayStatusListenersArgs{...} }
type GatewayStatusListenersArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput
	ToGatewayStatusListenersArrayOutputWithContext(context.Context) GatewayStatusListenersArrayOutput
}

type GatewayStatusListenersArray []GatewayStatusListenersInput

func (GatewayStatusListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListeners)(nil)).Elem()
}

func (i GatewayStatusListenersArray) ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput {
	return i.ToGatewayStatusListenersArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersArray) ToGatewayStatusListenersArrayOutputWithContext(ctx context.Context) GatewayStatusListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListeners)(nil)).Elem()
}

func (o GatewayStatusListenersOutput) ToGatewayStatusListenersOutput() GatewayStatusListenersOutput {
	return o
}

func (o GatewayStatusListenersOutput) ToGatewayStatusListenersOutputWithContext(ctx context.Context) GatewayStatusListenersOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o GatewayStatusListenersOutput) AttachedRoutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListeners) *int { return v.AttachedRoutes }).(pulumi.IntPtrOutput)
}

// Conditions describe the current condition of this listener.
func (o GatewayStatusListenersOutput) Conditions() GatewayStatusListenersConditionsArrayOutput {
	return o.ApplyT(func(v GatewayStatusListeners) []GatewayStatusListenersConditions { return v.Conditions }).(GatewayStatusListenersConditionsArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o GatewayStatusListenersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListeners) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o GatewayStatusListenersOutput) SupportedKinds() GatewayStatusListenersSupportedKindsArrayOutput {
	return o.ApplyT(func(v GatewayStatusListeners) []GatewayStatusListenersSupportedKinds { return v.SupportedKinds }).(GatewayStatusListenersSupportedKindsArrayOutput)
}

type GatewayStatusListenersArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListeners)(nil)).Elem()
}

func (o GatewayStatusListenersArrayOutput) ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput {
	return o
}

func (o GatewayStatusListenersArrayOutput) ToGatewayStatusListenersArrayOutputWithContext(ctx context.Context) GatewayStatusListenersArrayOutput {
	return o
}

func (o GatewayStatusListenersArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListeners {
		return vs[0].([]GatewayStatusListeners)[vs[1].(int)]
	}).(GatewayStatusListenersOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusListenersConditionsInput is an input type that accepts GatewayStatusListenersConditionsArgs and GatewayStatusListenersConditionsOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsInput` via:
//
//	GatewayStatusListenersConditionsArgs{...}
type GatewayStatusListenersConditionsInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput
	ToGatewayStatusListenersConditionsOutputWithContext(context.Context) GatewayStatusListenersConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusListenersConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditions)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsArgs) ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput {
	return i.ToGatewayStatusListenersConditionsOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsArgs) ToGatewayStatusListenersConditionsOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsOutput)
}

// GatewayStatusListenersConditionsArrayInput is an input type that accepts GatewayStatusListenersConditionsArray and GatewayStatusListenersConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsArrayInput` via:
//
//	GatewayStatusListenersConditionsArray{ GatewayStatusListenersConditionsArgs{...} }
type GatewayStatusListenersConditionsArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput
	ToGatewayStatusListenersConditionsArrayOutputWithContext(context.Context) GatewayStatusListenersConditionsArrayOutput
}

type GatewayStatusListenersConditionsArray []GatewayStatusListenersConditionsInput

func (GatewayStatusListenersConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditions)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsArray) ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput {
	return i.ToGatewayStatusListenersConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsArray) ToGatewayStatusListenersConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditions)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsOutput) ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput {
	return o
}

func (o GatewayStatusListenersConditionsOutput) ToGatewayStatusListenersConditionsOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusListenersConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusListenersConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusListenersConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusListenersConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusListenersConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusListenersConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditions)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsArrayOutput) ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsArrayOutput) ToGatewayStatusListenersConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersConditions {
		return vs[0].([]GatewayStatusListenersConditions)[vs[1].(int)]
	}).(GatewayStatusListenersConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusListenersConditionsPatchInput is an input type that accepts GatewayStatusListenersConditionsPatchArgs and GatewayStatusListenersConditionsPatchOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsPatchInput` via:
//
//	GatewayStatusListenersConditionsPatchArgs{...}
type GatewayStatusListenersConditionsPatchInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsPatchOutput() GatewayStatusListenersConditionsPatchOutput
	ToGatewayStatusListenersConditionsPatchOutputWithContext(context.Context) GatewayStatusListenersConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusListenersConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsPatchArgs) ToGatewayStatusListenersConditionsPatchOutput() GatewayStatusListenersConditionsPatchOutput {
	return i.ToGatewayStatusListenersConditionsPatchOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsPatchArgs) ToGatewayStatusListenersConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsPatchOutput)
}

// GatewayStatusListenersConditionsPatchArrayInput is an input type that accepts GatewayStatusListenersConditionsPatchArray and GatewayStatusListenersConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsPatchArrayInput` via:
//
//	GatewayStatusListenersConditionsPatchArray{ GatewayStatusListenersConditionsPatchArgs{...} }
type GatewayStatusListenersConditionsPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsPatchArrayOutput() GatewayStatusListenersConditionsPatchArrayOutput
	ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(context.Context) GatewayStatusListenersConditionsPatchArrayOutput
}

type GatewayStatusListenersConditionsPatchArray []GatewayStatusListenersConditionsPatchInput

func (GatewayStatusListenersConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsPatchArray) ToGatewayStatusListenersConditionsPatchArrayOutput() GatewayStatusListenersConditionsPatchArrayOutput {
	return i.ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsPatchArray) ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsPatchOutput) ToGatewayStatusListenersConditionsPatchOutput() GatewayStatusListenersConditionsPatchOutput {
	return o
}

func (o GatewayStatusListenersConditionsPatchOutput) ToGatewayStatusListenersConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusListenersConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusListenersConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusListenersConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusListenersConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusListenersConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusListenersConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsPatchArrayOutput) ToGatewayStatusListenersConditionsPatchArrayOutput() GatewayStatusListenersConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsPatchArrayOutput) ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersConditionsPatch {
		return vs[0].([]GatewayStatusListenersConditionsPatch)[vs[1].(int)]
	}).(GatewayStatusListenersConditionsPatchOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersPatch struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []GatewayStatusListenersConditionsPatch `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name *string `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []GatewayStatusListenersSupportedKindsPatch `pulumi:"supportedKinds"`
}

// GatewayStatusListenersPatchInput is an input type that accepts GatewayStatusListenersPatchArgs and GatewayStatusListenersPatchOutput values.
// You can construct a concrete instance of `GatewayStatusListenersPatchInput` via:
//
//	GatewayStatusListenersPatchArgs{...}
type GatewayStatusListenersPatchInput interface {
	pulumi.Input

	ToGatewayStatusListenersPatchOutput() GatewayStatusListenersPatchOutput
	ToGatewayStatusListenersPatchOutputWithContext(context.Context) GatewayStatusListenersPatchOutput
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersPatchArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntPtrInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions GatewayStatusListenersConditionsPatchArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds GatewayStatusListenersSupportedKindsPatchArrayInput `pulumi:"supportedKinds"`
}

func (GatewayStatusListenersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersPatch)(nil)).Elem()
}

func (i GatewayStatusListenersPatchArgs) ToGatewayStatusListenersPatchOutput() GatewayStatusListenersPatchOutput {
	return i.ToGatewayStatusListenersPatchOutputWithContext(context.Background())
}

func (i GatewayStatusListenersPatchArgs) ToGatewayStatusListenersPatchOutputWithContext(ctx context.Context) GatewayStatusListenersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersPatchOutput)
}

// GatewayStatusListenersPatchArrayInput is an input type that accepts GatewayStatusListenersPatchArray and GatewayStatusListenersPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersPatchArrayInput` via:
//
//	GatewayStatusListenersPatchArray{ GatewayStatusListenersPatchArgs{...} }
type GatewayStatusListenersPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersPatchArrayOutput() GatewayStatusListenersPatchArrayOutput
	ToGatewayStatusListenersPatchArrayOutputWithContext(context.Context) GatewayStatusListenersPatchArrayOutput
}

type GatewayStatusListenersPatchArray []GatewayStatusListenersPatchInput

func (GatewayStatusListenersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersPatch)(nil)).Elem()
}

func (i GatewayStatusListenersPatchArray) ToGatewayStatusListenersPatchArrayOutput() GatewayStatusListenersPatchArrayOutput {
	return i.ToGatewayStatusListenersPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersPatchArray) ToGatewayStatusListenersPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersPatchArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersPatch)(nil)).Elem()
}

func (o GatewayStatusListenersPatchOutput) ToGatewayStatusListenersPatchOutput() GatewayStatusListenersPatchOutput {
	return o
}

func (o GatewayStatusListenersPatchOutput) ToGatewayStatusListenersPatchOutputWithContext(ctx context.Context) GatewayStatusListenersPatchOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o GatewayStatusListenersPatchOutput) AttachedRoutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) *int { return v.AttachedRoutes }).(pulumi.IntPtrOutput)
}

// Conditions describe the current condition of this listener.
func (o GatewayStatusListenersPatchOutput) Conditions() GatewayStatusListenersConditionsPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) []GatewayStatusListenersConditionsPatch { return v.Conditions }).(GatewayStatusListenersConditionsPatchArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o GatewayStatusListenersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o GatewayStatusListenersPatchOutput) SupportedKinds() GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) []GatewayStatusListenersSupportedKindsPatch {
		return v.SupportedKinds
	}).(GatewayStatusListenersSupportedKindsPatchArrayOutput)
}

type GatewayStatusListenersPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersPatch)(nil)).Elem()
}

func (o GatewayStatusListenersPatchArrayOutput) ToGatewayStatusListenersPatchArrayOutput() GatewayStatusListenersPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersPatchArrayOutput) ToGatewayStatusListenersPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersPatch {
		return vs[0].([]GatewayStatusListenersPatch)[vs[1].(int)]
	}).(GatewayStatusListenersPatchOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewayStatusListenersSupportedKindsInput is an input type that accepts GatewayStatusListenersSupportedKindsArgs and GatewayStatusListenersSupportedKindsOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsInput` via:
//
//	GatewayStatusListenersSupportedKindsArgs{...}
type GatewayStatusListenersSupportedKindsInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput
	ToGatewayStatusListenersSupportedKindsOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewayStatusListenersSupportedKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsArgs) ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput {
	return i.ToGatewayStatusListenersSupportedKindsOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsArgs) ToGatewayStatusListenersSupportedKindsOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsOutput)
}

// GatewayStatusListenersSupportedKindsArrayInput is an input type that accepts GatewayStatusListenersSupportedKindsArray and GatewayStatusListenersSupportedKindsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsArrayInput` via:
//
//	GatewayStatusListenersSupportedKindsArray{ GatewayStatusListenersSupportedKindsArgs{...} }
type GatewayStatusListenersSupportedKindsArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput
	ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsArrayOutput
}

type GatewayStatusListenersSupportedKindsArray []GatewayStatusListenersSupportedKindsInput

func (GatewayStatusListenersSupportedKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsArray) ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput {
	return i.ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsArray) ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsOutput) ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsOutput) ToGatewayStatusListenersSupportedKindsOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsOutput {
	return o
}

// Group is the group of the Route.
func (o GatewayStatusListenersSupportedKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewayStatusListenersSupportedKindsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKinds) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersSupportedKindsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersSupportedKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersSupportedKinds {
		return vs[0].([]GatewayStatusListenersSupportedKinds)[vs[1].(int)]
	}).(GatewayStatusListenersSupportedKindsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsPatch struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewayStatusListenersSupportedKindsPatchInput is an input type that accepts GatewayStatusListenersSupportedKindsPatchArgs and GatewayStatusListenersSupportedKindsPatchOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsPatchInput` via:
//
//	GatewayStatusListenersSupportedKindsPatchArgs{...}
type GatewayStatusListenersSupportedKindsPatchInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsPatchOutput() GatewayStatusListenersSupportedKindsPatchOutput
	ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsPatchOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsPatchArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewayStatusListenersSupportedKindsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsPatchArgs) ToGatewayStatusListenersSupportedKindsPatchOutput() GatewayStatusListenersSupportedKindsPatchOutput {
	return i.ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsPatchArgs) ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsPatchOutput)
}

// GatewayStatusListenersSupportedKindsPatchArrayInput is an input type that accepts GatewayStatusListenersSupportedKindsPatchArray and GatewayStatusListenersSupportedKindsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsPatchArrayInput` via:
//
//	GatewayStatusListenersSupportedKindsPatchArray{ GatewayStatusListenersSupportedKindsPatchArgs{...} }
type GatewayStatusListenersSupportedKindsPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsPatchArrayOutput() GatewayStatusListenersSupportedKindsPatchArrayOutput
	ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsPatchArrayOutput
}

type GatewayStatusListenersSupportedKindsPatchArray []GatewayStatusListenersSupportedKindsPatchInput

func (GatewayStatusListenersSupportedKindsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsPatchArray) ToGatewayStatusListenersSupportedKindsPatchArrayOutput() GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return i.ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsPatchArray) ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsPatchArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsPatchOutput) ToGatewayStatusListenersSupportedKindsPatchOutput() GatewayStatusListenersSupportedKindsPatchOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsPatchOutput) ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchOutput {
	return o
}

// Group is the group of the Route.
func (o GatewayStatusListenersSupportedKindsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKindsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewayStatusListenersSupportedKindsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKindsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersSupportedKindsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsPatchArrayOutput) ToGatewayStatusListenersSupportedKindsPatchArrayOutput() GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsPatchArrayOutput) ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersSupportedKindsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersSupportedKindsPatch {
		return vs[0].([]GatewayStatusListenersSupportedKindsPatch)[vs[1].(int)]
	}).(GatewayStatusListenersSupportedKindsPatchOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusPatch struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses []GatewayStatusAddressesPatch `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions []GatewayStatusConditionsPatch `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []GatewayStatusListenersPatch `pulumi:"listeners"`
}

// GatewayStatusPatchInput is an input type that accepts GatewayStatusPatchArgs and GatewayStatusPatchOutput values.
// You can construct a concrete instance of `GatewayStatusPatchInput` via:
//
//	GatewayStatusPatchArgs{...}
type GatewayStatusPatchInput interface {
	pulumi.Input

	ToGatewayStatusPatchOutput() GatewayStatusPatchOutput
	ToGatewayStatusPatchOutputWithContext(context.Context) GatewayStatusPatchOutput
}

// Status defines the current state of Gateway.
type GatewayStatusPatchArgs struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses GatewayStatusAddressesPatchArrayInput `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions GatewayStatusConditionsPatchArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners GatewayStatusListenersPatchArrayInput `pulumi:"listeners"`
}

func (GatewayStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusPatch)(nil)).Elem()
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchOutput() GatewayStatusPatchOutput {
	return i.ToGatewayStatusPatchOutputWithContext(context.Background())
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchOutputWithContext(ctx context.Context) GatewayStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPatchOutput)
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return i.ToGatewayStatusPatchPtrOutputWithContext(context.Background())
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPatchOutput).ToGatewayStatusPatchPtrOutputWithContext(ctx)
}

// GatewayStatusPatchPtrInput is an input type that accepts GatewayStatusPatchArgs, GatewayStatusPatchPtr and GatewayStatusPatchPtrOutput values.
// You can construct a concrete instance of `GatewayStatusPatchPtrInput` via:
//
//	        GatewayStatusPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayStatusPatchPtrInput interface {
	pulumi.Input

	ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput
	ToGatewayStatusPatchPtrOutputWithContext(context.Context) GatewayStatusPatchPtrOutput
}

type gatewayStatusPatchPtrType GatewayStatusPatchArgs

func GatewayStatusPatchPtr(v *GatewayStatusPatchArgs) GatewayStatusPatchPtrInput {
	return (*gatewayStatusPatchPtrType)(v)
}

func (*gatewayStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatusPatch)(nil)).Elem()
}

func (i *gatewayStatusPatchPtrType) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return i.ToGatewayStatusPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayStatusPatchPtrType) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPatchPtrOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusPatch)(nil)).Elem()
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchOutput() GatewayStatusPatchOutput {
	return o
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchOutputWithContext(ctx context.Context) GatewayStatusPatchOutput {
	return o
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return o.ToGatewayStatusPatchPtrOutputWithContext(context.Background())
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayStatusPatch) *GatewayStatusPatch {
		return &v
	}).(GatewayStatusPatchPtrOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPatchOutput) Addresses() GatewayStatusAddressesPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusPatch) []GatewayStatusAddressesPatch { return v.Addresses }).(GatewayStatusAddressesPatchArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPatchOutput) Conditions() GatewayStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusPatch) []GatewayStatusConditionsPatch { return v.Conditions }).(GatewayStatusConditionsPatchArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPatchOutput) Listeners() GatewayStatusListenersPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusPatch) []GatewayStatusListenersPatch { return v.Listeners }).(GatewayStatusListenersPatchArrayOutput)
}

type GatewayStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatusPatch)(nil)).Elem()
}

func (o GatewayStatusPatchPtrOutput) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return o
}

func (o GatewayStatusPatchPtrOutput) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return o
}

func (o GatewayStatusPatchPtrOutput) Elem() GatewayStatusPatchOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) GatewayStatusPatch {
		if v != nil {
			return *v
		}
		var ret GatewayStatusPatch
		return ret
	}).(GatewayStatusPatchOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPatchPtrOutput) Addresses() GatewayStatusAddressesPatchArrayOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) []GatewayStatusAddressesPatch {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewayStatusAddressesPatchArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPatchPtrOutput) Conditions() GatewayStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) []GatewayStatusConditionsPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayStatusConditionsPatchArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPatchPtrOutput) Listeners() GatewayStatusListenersPatchArrayOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) []GatewayStatusListenersPatch {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewayStatusListenersPatchArrayOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *HTTPRouteSpec     `pulumi:"spec"`
	Status   *HTTPRouteStatus   `pulumi:"status"`
}

// HTTPRouteTypeInput is an input type that accepts HTTPRouteTypeArgs and HTTPRouteTypeOutput values.
// You can construct a concrete instance of `HTTPRouteTypeInput` via:
//
//	HTTPRouteTypeArgs{...}
type HTTPRouteTypeInput interface {
	pulumi.Input

	ToHTTPRouteTypeOutput() HTTPRouteTypeOutput
	ToHTTPRouteTypeOutputWithContext(context.Context) HTTPRouteTypeOutput
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     HTTPRouteSpecPtrInput     `pulumi:"spec"`
	Status   HTTPRouteStatusPtrInput   `pulumi:"status"`
}

func (HTTPRouteTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteType)(nil)).Elem()
}

func (i HTTPRouteTypeArgs) ToHTTPRouteTypeOutput() HTTPRouteTypeOutput {
	return i.ToHTTPRouteTypeOutputWithContext(context.Background())
}

func (i HTTPRouteTypeArgs) ToHTTPRouteTypeOutputWithContext(ctx context.Context) HTTPRouteTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteTypeOutput)
}

// HTTPRouteTypeArrayInput is an input type that accepts HTTPRouteTypeArray and HTTPRouteTypeArrayOutput values.
// You can construct a concrete instance of `HTTPRouteTypeArrayInput` via:
//
//	HTTPRouteTypeArray{ HTTPRouteTypeArgs{...} }
type HTTPRouteTypeArrayInput interface {
	pulumi.Input

	ToHTTPRouteTypeArrayOutput() HTTPRouteTypeArrayOutput
	ToHTTPRouteTypeArrayOutputWithContext(context.Context) HTTPRouteTypeArrayOutput
}

type HTTPRouteTypeArray []HTTPRouteTypeInput

func (HTTPRouteTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteType)(nil)).Elem()
}

func (i HTTPRouteTypeArray) ToHTTPRouteTypeArrayOutput() HTTPRouteTypeArrayOutput {
	return i.ToHTTPRouteTypeArrayOutputWithContext(context.Background())
}

func (i HTTPRouteTypeArray) ToHTTPRouteTypeArrayOutputWithContext(ctx context.Context) HTTPRouteTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteTypeArrayOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteTypeOutput struct{ *pulumi.OutputState }

func (HTTPRouteTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteType)(nil)).Elem()
}

func (o HTTPRouteTypeOutput) ToHTTPRouteTypeOutput() HTTPRouteTypeOutput {
	return o
}

func (o HTTPRouteTypeOutput) ToHTTPRouteTypeOutputWithContext(ctx context.Context) HTTPRouteTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o HTTPRouteTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRouteTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o HTTPRouteTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o HTTPRouteTypeOutput) Spec() HTTPRouteSpecPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *HTTPRouteSpec { return v.Spec }).(HTTPRouteSpecPtrOutput)
}

func (o HTTPRouteTypeOutput) Status() HTTPRouteStatusPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *HTTPRouteStatus { return v.Status }).(HTTPRouteStatusPtrOutput)
}

type HTTPRouteTypeArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteType)(nil)).Elem()
}

func (o HTTPRouteTypeArrayOutput) ToHTTPRouteTypeArrayOutput() HTTPRouteTypeArrayOutput {
	return o
}

func (o HTTPRouteTypeArrayOutput) ToHTTPRouteTypeArrayOutputWithContext(ctx context.Context) HTTPRouteTypeArrayOutput {
	return o
}

func (o HTTPRouteTypeArrayOutput) Index(i pulumi.IntInput) HTTPRouteTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteType {
		return vs[0].([]HTTPRouteType)[vs[1].(int)]
	}).(HTTPRouteTypeOutput)
}

// HTTPRouteList is a list of HTTPRoute
type HTTPRouteListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []HTTPRouteType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// HTTPRouteListTypeInput is an input type that accepts HTTPRouteListTypeArgs and HTTPRouteListTypeOutput values.
// You can construct a concrete instance of `HTTPRouteListTypeInput` via:
//
//	HTTPRouteListTypeArgs{...}
type HTTPRouteListTypeInput interface {
	pulumi.Input

	ToHTTPRouteListTypeOutput() HTTPRouteListTypeOutput
	ToHTTPRouteListTypeOutputWithContext(context.Context) HTTPRouteListTypeOutput
}

// HTTPRouteList is a list of HTTPRoute
type HTTPRouteListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items HTTPRouteTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (HTTPRouteListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteListType)(nil)).Elem()
}

func (i HTTPRouteListTypeArgs) ToHTTPRouteListTypeOutput() HTTPRouteListTypeOutput {
	return i.ToHTTPRouteListTypeOutputWithContext(context.Background())
}

func (i HTTPRouteListTypeArgs) ToHTTPRouteListTypeOutputWithContext(ctx context.Context) HTTPRouteListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteListTypeOutput)
}

// HTTPRouteList is a list of HTTPRoute
type HTTPRouteListTypeOutput struct{ *pulumi.OutputState }

func (HTTPRouteListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteListType)(nil)).Elem()
}

func (o HTTPRouteListTypeOutput) ToHTTPRouteListTypeOutput() HTTPRouteListTypeOutput {
	return o
}

func (o HTTPRouteListTypeOutput) ToHTTPRouteListTypeOutputWithContext(ctx context.Context) HTTPRouteListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o HTTPRouteListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o HTTPRouteListTypeOutput) Items() HTTPRouteTypeArrayOutput {
	return o.ApplyT(func(v HTTPRouteListType) []HTTPRouteType { return v.Items }).(HTTPRouteTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRouteListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRouteListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v HTTPRouteListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRoutePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *HTTPRouteSpecPatch     `pulumi:"spec"`
	Status   *HTTPRouteStatusPatch   `pulumi:"status"`
}

// HTTPRoutePatchTypeInput is an input type that accepts HTTPRoutePatchTypeArgs and HTTPRoutePatchTypeOutput values.
// You can construct a concrete instance of `HTTPRoutePatchTypeInput` via:
//
//	HTTPRoutePatchTypeArgs{...}
type HTTPRoutePatchTypeInput interface {
	pulumi.Input

	ToHTTPRoutePatchTypeOutput() HTTPRoutePatchTypeOutput
	ToHTTPRoutePatchTypeOutputWithContext(context.Context) HTTPRoutePatchTypeOutput
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRoutePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     HTTPRouteSpecPatchPtrInput     `pulumi:"spec"`
	Status   HTTPRouteStatusPatchPtrInput   `pulumi:"status"`
}

func (HTTPRoutePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRoutePatchType)(nil)).Elem()
}

func (i HTTPRoutePatchTypeArgs) ToHTTPRoutePatchTypeOutput() HTTPRoutePatchTypeOutput {
	return i.ToHTTPRoutePatchTypeOutputWithContext(context.Background())
}

func (i HTTPRoutePatchTypeArgs) ToHTTPRoutePatchTypeOutputWithContext(ctx context.Context) HTTPRoutePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRoutePatchTypeOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRoutePatchTypeOutput struct{ *pulumi.OutputState }

func (HTTPRoutePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRoutePatchType)(nil)).Elem()
}

func (o HTTPRoutePatchTypeOutput) ToHTTPRoutePatchTypeOutput() HTTPRoutePatchTypeOutput {
	return o
}

func (o HTTPRoutePatchTypeOutput) ToHTTPRoutePatchTypeOutputWithContext(ctx context.Context) HTTPRoutePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o HTTPRoutePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRoutePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o HTTPRoutePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o HTTPRoutePatchTypeOutput) Spec() HTTPRouteSpecPatchPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *HTTPRouteSpecPatch { return v.Spec }).(HTTPRouteSpecPatchPtrOutput)
}

func (o HTTPRoutePatchTypeOutput) Status() HTTPRouteStatusPatchPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *HTTPRouteStatusPatch { return v.Status }).(HTTPRouteStatusPatchPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpec struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []HTTPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules []HTTPRouteSpecRules `pulumi:"rules"`
}

// HTTPRouteSpecInput is an input type that accepts HTTPRouteSpecArgs and HTTPRouteSpecOutput values.
// You can construct a concrete instance of `HTTPRouteSpecInput` via:
//
//	HTTPRouteSpecArgs{...}
type HTTPRouteSpecInput interface {
	pulumi.Input

	ToHTTPRouteSpecOutput() HTTPRouteSpecOutput
	ToHTTPRouteSpecOutputWithContext(context.Context) HTTPRouteSpecOutput
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecArgs struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs HTTPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules HTTPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (HTTPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpec)(nil)).Elem()
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecOutput() HTTPRouteSpecOutput {
	return i.ToHTTPRouteSpecOutputWithContext(context.Background())
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecOutputWithContext(ctx context.Context) HTTPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecOutput)
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return i.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecOutput).ToHTTPRouteSpecPtrOutputWithContext(ctx)
}

// HTTPRouteSpecPtrInput is an input type that accepts HTTPRouteSpecArgs, HTTPRouteSpecPtr and HTTPRouteSpecPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPtrInput` via:
//
//	        HTTPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput
	ToHTTPRouteSpecPtrOutputWithContext(context.Context) HTTPRouteSpecPtrOutput
}

type httprouteSpecPtrType HTTPRouteSpecArgs

func HTTPRouteSpecPtr(v *HTTPRouteSpecArgs) HTTPRouteSpecPtrInput {
	return (*httprouteSpecPtrType)(v)
}

func (*httprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpec)(nil)).Elem()
}

func (i *httprouteSpecPtrType) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return i.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecPtrType) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpec)(nil)).Elem()
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecOutput() HTTPRouteSpecOutput {
	return o
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecOutputWithContext(ctx context.Context) HTTPRouteSpecOutput {
	return o
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return o.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpec) *HTTPRouteSpec {
		return &v
	}).(HTTPRouteSpecPtrOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecOutput) ParentRefs() HTTPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []HTTPRouteSpecParentRefs { return v.ParentRefs }).(HTTPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecOutput) Rules() HTTPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []HTTPRouteSpecRules { return v.Rules }).(HTTPRouteSpecRulesArrayOutput)
}

type HTTPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpec)(nil)).Elem()
}

func (o HTTPRouteSpecPtrOutput) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return o
}

func (o HTTPRouteSpecPtrOutput) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return o
}

func (o HTTPRouteSpecPtrOutput) Elem() HTTPRouteSpecOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) HTTPRouteSpec {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpec
		return ret
	}).(HTTPRouteSpecOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPtrOutput) ParentRefs() HTTPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []HTTPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(HTTPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPtrOutput) Rules() HTTPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []HTTPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(HTTPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteSpecParentRefsInput is an input type that accepts HTTPRouteSpecParentRefsArgs and HTTPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsInput` via:
//
//	HTTPRouteSpecParentRefsArgs{...}
type HTTPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput
	ToHTTPRouteSpecParentRefsOutputWithContext(context.Context) HTTPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsArgs) ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput {
	return i.ToHTTPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsArgs) ToHTTPRouteSpecParentRefsOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsOutput)
}

// HTTPRouteSpecParentRefsArrayInput is an input type that accepts HTTPRouteSpecParentRefsArray and HTTPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsArrayInput` via:
//
//	HTTPRouteSpecParentRefsArray{ HTTPRouteSpecParentRefsArgs{...} }
type HTTPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput
	ToHTTPRouteSpecParentRefsArrayOutputWithContext(context.Context) HTTPRouteSpecParentRefsArrayOutput
}

type HTTPRouteSpecParentRefsArray []HTTPRouteSpecParentRefsInput

func (HTTPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsArray) ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput {
	return i.ToHTTPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsArray) ToHTTPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsOutput) ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput {
	return o
}

func (o HTTPRouteSpecParentRefsOutput) ToHTTPRouteSpecParentRefsOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsArrayOutput) ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsArrayOutput) ToHTTPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecParentRefs {
		return vs[0].([]HTTPRouteSpecParentRefs)[vs[1].(int)]
	}).(HTTPRouteSpecParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteSpecParentRefsPatchInput is an input type that accepts HTTPRouteSpecParentRefsPatchArgs and HTTPRouteSpecParentRefsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsPatchInput` via:
//
//	HTTPRouteSpecParentRefsPatchArgs{...}
type HTTPRouteSpecParentRefsPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsPatchOutput() HTTPRouteSpecParentRefsPatchOutput
	ToHTTPRouteSpecParentRefsPatchOutputWithContext(context.Context) HTTPRouteSpecParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteSpecParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsPatchArgs) ToHTTPRouteSpecParentRefsPatchOutput() HTTPRouteSpecParentRefsPatchOutput {
	return i.ToHTTPRouteSpecParentRefsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsPatchArgs) ToHTTPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsPatchOutput)
}

// HTTPRouteSpecParentRefsPatchArrayInput is an input type that accepts HTTPRouteSpecParentRefsPatchArray and HTTPRouteSpecParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsPatchArrayInput` via:
//
//	HTTPRouteSpecParentRefsPatchArray{ HTTPRouteSpecParentRefsPatchArgs{...} }
type HTTPRouteSpecParentRefsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsPatchArrayOutput() HTTPRouteSpecParentRefsPatchArrayOutput
	ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(context.Context) HTTPRouteSpecParentRefsPatchArrayOutput
}

type HTTPRouteSpecParentRefsPatchArray []HTTPRouteSpecParentRefsPatchInput

func (HTTPRouteSpecParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsPatchArray) ToHTTPRouteSpecParentRefsPatchArrayOutput() HTTPRouteSpecParentRefsPatchArrayOutput {
	return i.ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsPatchArray) ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsPatchOutput) ToHTTPRouteSpecParentRefsPatchOutput() HTTPRouteSpecParentRefsPatchOutput {
	return o
}

func (o HTTPRouteSpecParentRefsPatchOutput) ToHTTPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteSpecParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteSpecParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsPatchArrayOutput) ToHTTPRouteSpecParentRefsPatchArrayOutput() HTTPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsPatchArrayOutput) ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecParentRefsPatch {
		return vs[0].([]HTTPRouteSpecParentRefsPatch)[vs[1].(int)]
	}).(HTTPRouteSpecParentRefsPatchOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecPatch struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []HTTPRouteSpecParentRefsPatch `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules []HTTPRouteSpecRulesPatch `pulumi:"rules"`
}

// HTTPRouteSpecPatchInput is an input type that accepts HTTPRouteSpecPatchArgs and HTTPRouteSpecPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPatchInput` via:
//
//	HTTPRouteSpecPatchArgs{...}
type HTTPRouteSpecPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecPatchOutput() HTTPRouteSpecPatchOutput
	ToHTTPRouteSpecPatchOutputWithContext(context.Context) HTTPRouteSpecPatchOutput
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecPatchArgs struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs HTTPRouteSpecParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules HTTPRouteSpecRulesPatchArrayInput `pulumi:"rules"`
}

func (HTTPRouteSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecPatch)(nil)).Elem()
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchOutput() HTTPRouteSpecPatchOutput {
	return i.ToHTTPRouteSpecPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchOutputWithContext(ctx context.Context) HTTPRouteSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPatchOutput)
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return i.ToHTTPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPatchOutput).ToHTTPRouteSpecPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecPatchPtrInput is an input type that accepts HTTPRouteSpecPatchArgs, HTTPRouteSpecPatchPtr and HTTPRouteSpecPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPatchPtrInput` via:
//
//	        HTTPRouteSpecPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput
	ToHTTPRouteSpecPatchPtrOutputWithContext(context.Context) HTTPRouteSpecPatchPtrOutput
}

type httprouteSpecPatchPtrType HTTPRouteSpecPatchArgs

func HTTPRouteSpecPatchPtr(v *HTTPRouteSpecPatchArgs) HTTPRouteSpecPatchPtrInput {
	return (*httprouteSpecPatchPtrType)(v)
}

func (*httprouteSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecPatch)(nil)).Elem()
}

func (i *httprouteSpecPatchPtrType) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return i.ToHTTPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecPatchPtrType) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPatchPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecPatch)(nil)).Elem()
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchOutput() HTTPRouteSpecPatchOutput {
	return o
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchOutputWithContext(ctx context.Context) HTTPRouteSpecPatchOutput {
	return o
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return o.ToHTTPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecPatch) *HTTPRouteSpecPatch {
		return &v
	}).(HTTPRouteSpecPatchPtrOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPatchOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecPatch) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPatchOutput) ParentRefs() HTTPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecPatch) []HTTPRouteSpecParentRefsPatch { return v.ParentRefs }).(HTTPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPatchOutput) Rules() HTTPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecPatch) []HTTPRouteSpecRulesPatch { return v.Rules }).(HTTPRouteSpecRulesPatchArrayOutput)
}

type HTTPRouteSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecPatch)(nil)).Elem()
}

func (o HTTPRouteSpecPatchPtrOutput) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecPatchPtrOutput) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecPatchPtrOutput) Elem() HTTPRouteSpecPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) HTTPRouteSpecPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecPatch
		return ret
	}).(HTTPRouteSpecPatchOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPatchPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPatchPtrOutput) ParentRefs() HTTPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) []HTTPRouteSpecParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(HTTPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPatchPtrOutput) Rules() HTTPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) []HTTPRouteSpecRulesPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(HTTPRouteSpecRulesPatchArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []HTTPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []HTTPRouteSpecRulesFilters `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches []HTTPRouteSpecRulesMatches `pulumi:"matches"`
}

// HTTPRouteSpecRulesInput is an input type that accepts HTTPRouteSpecRulesArgs and HTTPRouteSpecRulesOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesInput` via:
//
//	HTTPRouteSpecRulesArgs{...}
type HTTPRouteSpecRulesInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput
	ToHTTPRouteSpecRulesOutputWithContext(context.Context) HTTPRouteSpecRulesOutput
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs HTTPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters HTTPRouteSpecRulesFiltersArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches HTTPRouteSpecRulesMatchesArrayInput `pulumi:"matches"`
}

func (HTTPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRules)(nil)).Elem()
}

func (i HTTPRouteSpecRulesArgs) ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput {
	return i.ToHTTPRouteSpecRulesOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesArgs) ToHTTPRouteSpecRulesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesOutput)
}

// HTTPRouteSpecRulesArrayInput is an input type that accepts HTTPRouteSpecRulesArray and HTTPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesArrayInput` via:
//
//	HTTPRouteSpecRulesArray{ HTTPRouteSpecRulesArgs{...} }
type HTTPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput
	ToHTTPRouteSpecRulesArrayOutputWithContext(context.Context) HTTPRouteSpecRulesArrayOutput
}

type HTTPRouteSpecRulesArray []HTTPRouteSpecRulesInput

func (HTTPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRules)(nil)).Elem()
}

func (i HTTPRouteSpecRulesArray) ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput {
	return i.ToHTTPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesArray) ToHTTPRouteSpecRulesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRules)(nil)).Elem()
}

func (o HTTPRouteSpecRulesOutput) ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput {
	return o
}

func (o HTTPRouteSpecRulesOutput) ToHTTPRouteSpecRulesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive a 500 status code.
//
// See the HTTPBackendRef definition for the rules about what makes a single
// HTTPBackendRef invalid.
//
// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive a 500 status code.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic must receive a 500. Implementations may
// choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o HTTPRouteSpecRulesOutput) BackendRefs() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesBackendRefs { return v.BackendRefs }).(HTTPRouteSpecRulesBackendRefsArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// Wherever possible, implementations SHOULD implement filters in the order
// they are specified.
//
// Implementations MAY choose to implement this ordering strictly, rejecting
// any combination or order of filters that can not be supported. If implementations
// choose a strict interpretation of filter ordering, they MUST clearly document
// that behavior.
//
// To reject an invalid combination or order of filters, implementations SHOULD
// consider the Route Rules with this configuration invalid. If all Route Rules
// in a Route are invalid, the entire Route would be considered invalid. If only
// a portion of Route Rules are invalid, implementations MUST set the
// "PartiallyInvalid" condition for the Route.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// All filters are expected to be compatible with each other except for the
// URLRewrite and RequestRedirect filters, which may not be combined. If an
// implementation can not support other combinations of filters, they must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o HTTPRouteSpecRulesOutput) Filters() HTTPRouteSpecRulesFiltersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesFilters { return v.Filters }).(HTTPRouteSpecRulesFiltersArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// HTTP requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, a request must satisfy
// EITHER of the two conditions:
//
// - path prefixed with `/foo` AND contains the header `version: v2`
// - path prefix of `/v2/foo`
//
// See the documentation for HTTPRouteMatch on how to specify multiple
// match conditions that should be ANDed together.
//
// If no matches are specified, the default is a prefix
// path match on "/", which has the effect of matching every
// HTTP request.
//
// Proxy or Load Balancer routing configuration generated from HTTPRoutes
// MUST prioritize matches based on the following criteria, continuing on
// ties. Across all rules specified on applicable Routes, precedence must be
// given to the match having:
//
// * "Exact" path match.
// * "Prefix" path match with largest number of characters.
// * Method match.
// * Largest number of header matches.
// * Largest number of query param matches.
//
// Note: The precedence of RegularExpression path matches are implementation-specific.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within an HTTPRoute, matching precedence MUST be granted
// to the FIRST matching rule (in list order) with a match meeting the above
// criteria.
//
// When no rules matching a request have been successfully attached to the
// parent a request is coming from, a HTTP 404 status code MUST be returned.
func (o HTTPRouteSpecRulesOutput) Matches() HTTPRouteSpecRulesMatchesArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesMatches { return v.Matches }).(HTTPRouteSpecRulesMatchesArrayOutput)
}

type HTTPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRules)(nil)).Elem()
}

func (o HTTPRouteSpecRulesArrayOutput) ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesArrayOutput) ToHTTPRouteSpecRulesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRules {
		return vs[0].([]HTTPRouteSpecRules)[vs[1].(int)]
	}).(HTTPRouteSpecRulesOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters []HTTPRouteSpecRulesBackendRefsFilters `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// HTTPRouteSpecRulesBackendRefsInput is an input type that accepts HTTPRouteSpecRulesBackendRefsArgs and HTTPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsInput` via:
//
//	HTTPRouteSpecRulesBackendRefsArgs{...}
type HTTPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput
	ToHTTPRouteSpecRulesBackendRefsOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsOutput
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsArgs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters HTTPRouteSpecRulesBackendRefsFiltersArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (HTTPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsArgs) ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsArgs) ToHTTPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsOutput)
}

// HTTPRouteSpecRulesBackendRefsArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsArray and HTTPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsArray{ HTTPRouteSpecRulesBackendRefsArgs{...} }
type HTTPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput
	ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput
}

type HTTPRouteSpecRulesBackendRefsArray []HTTPRouteSpecRulesBackendRefsInput

func (HTTPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsArray) ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsArray) ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsArrayOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsOutput) ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsOutput) ToHTTPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsOutput {
	return o
}

// Filters defined at this level should be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in HTTPRouteRule.)
func (o HTTPRouteSpecRulesBackendRefsOutput) Filters() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) []HTTPRouteSpecRulesBackendRefsFilters { return v.Filters }).(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o HTTPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefs {
		return vs[0].([]HTTPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFilters struct {
	ExtensionRef           *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                                         `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesBackendRefsFiltersInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersArgs and HTTPRouteSpecRulesBackendRefsFiltersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersArgs struct {
	ExtensionRef           HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                                  `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArgs) ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArgs) ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersArray and HTTPRouteSpecRulesBackendRefsFiltersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersArray{ HTTPRouteSpecRulesBackendRefsFiltersArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersArray []HTTPRouteSpecRulesBackendRefsFiltersInput

func (HTTPRouteSpecRulesBackendRefsFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArray) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArray) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ExtensionRef() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestMirror() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestRedirect() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ResponseHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) UrlRewrite() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		return v.UrlRewrite
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFilters {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFilters)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput).ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs, HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtr and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs

func HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtr(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersExtensionRef
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersPatch struct {
	ExtensionRef           *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                                              `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesBackendRefsFiltersPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersPatchArgs struct {
	ExtensionRef           HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                                       `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersPatchArray and HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersPatchArray []HTTPRouteSpecRulesBackendRefsFiltersPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ExtensionRef() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) RequestHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) RequestMirror() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) RequestRedirect() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ResponseHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) UrlRewrite() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch {
		return v.UrlRewrite
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirror struct {
	BackendRef *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs struct {
	BackendRef HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirror
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch struct {
	BackendRef *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs struct {
	BackendRef HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                                  `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                           `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                                       `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                                `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput).ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs, HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs

func HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                             `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath `pulumi:"path"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                                      `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                                  `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch `pulumi:"path"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                                           `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsPatch struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters []HTTPRouteSpecRulesBackendRefsFiltersPatch `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// HTTPRouteSpecRulesBackendRefsPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsPatchArgs and HTTPRouteSpecRulesBackendRefsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsPatchOutput() HTTPRouteSpecRulesBackendRefsPatchOutput
	ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsPatchOutput
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsPatchArgs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (HTTPRouteSpecRulesBackendRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsPatchArgs) ToHTTPRouteSpecRulesBackendRefsPatchOutput() HTTPRouteSpecRulesBackendRefsPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsPatchArgs) ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsPatchArray and HTTPRouteSpecRulesBackendRefsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsPatchArray{ HTTPRouteSpecRulesBackendRefsPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsPatchArrayOutput() HTTPRouteSpecRulesBackendRefsPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsPatchArray []HTTPRouteSpecRulesBackendRefsPatchInput

func (HTTPRouteSpecRulesBackendRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsPatchArray) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutput() HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsPatchArray) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsPatchOutput) ToHTTPRouteSpecRulesBackendRefsPatchOutput() HTTPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsPatchOutput) ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

// Filters defined at this level should be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in HTTPRouteRule.)
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Filters() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) []HTTPRouteSpecRulesBackendRefsFiltersPatch {
		return v.Filters
	}).(HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutput() HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsPatchOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFilters struct {
	ExtensionRef           *HTTPRouteSpecRulesFiltersExtensionRef           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesFiltersRequestHeaderModifier  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesFiltersRequestMirror          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesFiltersRequestRedirect        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                              `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesFiltersUrlRewrite `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesFiltersInput is an input type that accepts HTTPRouteSpecRulesFiltersArgs and HTTPRouteSpecRulesFiltersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersInput` via:
//
//	HTTPRouteSpecRulesFiltersArgs{...}
type HTTPRouteSpecRulesFiltersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput
	ToHTTPRouteSpecRulesFiltersOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersArgs struct {
	ExtensionRef           HTTPRouteSpecRulesFiltersExtensionRefPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesFiltersRequestMirrorPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesFiltersRequestRedirectPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                       `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesFiltersUrlRewritePtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersArgs) ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput {
	return i.ToHTTPRouteSpecRulesFiltersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersArgs) ToHTTPRouteSpecRulesFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersOutput)
}

// HTTPRouteSpecRulesFiltersArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersArray and HTTPRouteSpecRulesFiltersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersArray{ HTTPRouteSpecRulesFiltersArgs{...} }
type HTTPRouteSpecRulesFiltersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput
	ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersArrayOutput
}

type HTTPRouteSpecRulesFiltersArray []HTTPRouteSpecRulesFiltersInput

func (HTTPRouteSpecRulesFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersArray) ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersArray) ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersOutput) ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersOutput) ToHTTPRouteSpecRulesFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersOutput) ExtensionRef() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersExtensionRef { return v.ExtensionRef }).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) RequestHeaderModifier() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) RequestMirror() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestMirror { return v.RequestMirror }).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) RequestRedirect() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestRedirect { return v.RequestRedirect }).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) ResponseHeaderModifier() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) UrlRewrite() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersUrlRewrite { return v.UrlRewrite }).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

type HTTPRouteSpecRulesFiltersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFilters {
		return vs[0].([]HTTPRouteSpecRulesFilters)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesFiltersExtensionRefInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefArgs and HTTPRouteSpecRulesFiltersExtensionRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefInput` via:
//
//	HTTPRouteSpecRulesFiltersExtensionRefArgs{...}
type HTTPRouteSpecRulesFiltersExtensionRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefOutput)
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefOutput).ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersExtensionRefPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefArgs, HTTPRouteSpecRulesFiltersExtensionRefPtr and HTTPRouteSpecRulesFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput
}

type httprouteSpecRulesFiltersExtensionRefPtrType HTTPRouteSpecRulesFiltersExtensionRefArgs

func HTTPRouteSpecRulesFiltersExtensionRefPtr(v *HTTPRouteSpecRulesFiltersExtensionRefArgs) HTTPRouteSpecRulesFiltersExtensionRefPtrInput {
	return (*httprouteSpecRulesFiltersExtensionRefPtrType)(v)
}

func (*httprouteSpecRulesFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersExtensionRef) *HTTPRouteSpecRulesFiltersExtensionRef {
		return &v
	}).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Elem() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) HTTPRouteSpecRulesFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersExtensionRef
		return ret
	}).(HTTPRouteSpecRulesFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesFiltersExtensionRefPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefPatchArgs and HTTPRouteSpecRulesFiltersExtensionRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{...}
type HTTPRouteSpecRulesFiltersExtensionRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput).ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefPatchArgs, HTTPRouteSpecRulesFiltersExtensionRefPatchPtr and HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput
}

type httprouteSpecRulesFiltersExtensionRefPatchPtrType HTTPRouteSpecRulesFiltersExtensionRefPatchArgs

func HTTPRouteSpecRulesFiltersExtensionRefPatchPtr(v *HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput {
	return (*httprouteSpecRulesFiltersExtensionRefPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersExtensionRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersExtensionRefPatch) *HTTPRouteSpecRulesFiltersExtensionRefPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) HTTPRouteSpecRulesFiltersExtensionRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersExtensionRefPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersPatch struct {
	ExtensionRef           *HTTPRouteSpecRulesFiltersExtensionRefPatch           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesFiltersRequestMirrorPatch          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesFiltersRequestRedirectPatch        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                                   `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesFiltersUrlRewritePatch `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesFiltersPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersPatchArgs and HTTPRouteSpecRulesFiltersPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersPatchArgs{...}
type HTTPRouteSpecRulesFiltersPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersPatchOutput() HTTPRouteSpecRulesFiltersPatchOutput
	ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersPatchOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersPatchArgs struct {
	ExtensionRef           HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                            `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesFiltersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersPatchArgs) ToHTTPRouteSpecRulesFiltersPatchOutput() HTTPRouteSpecRulesFiltersPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersPatchArgs) ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersPatchOutput)
}

// HTTPRouteSpecRulesFiltersPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersPatchArray and HTTPRouteSpecRulesFiltersPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersPatchArray{ HTTPRouteSpecRulesFiltersPatchArgs{...} }
type HTTPRouteSpecRulesFiltersPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersPatchArrayOutput() HTTPRouteSpecRulesFiltersPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersPatchArray []HTTPRouteSpecRulesFiltersPatchInput

func (HTTPRouteSpecRulesFiltersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersPatchArray) ToHTTPRouteSpecRulesFiltersPatchArrayOutput() HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersPatchArray) ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersPatchArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ToHTTPRouteSpecRulesFiltersPatchOutput() HTTPRouteSpecRulesFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ExtensionRef() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersExtensionRefPatch {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) RequestHeaderModifier() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) RequestMirror() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersRequestMirrorPatch {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) RequestRedirect() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPatch {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ResponseHeaderModifier() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) UrlRewrite() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersUrlRewritePatch { return v.UrlRewrite }).(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput)
}

type HTTPRouteSpecRulesFiltersPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersPatchArrayOutput) ToHTTPRouteSpecRulesFiltersPatchArrayOutput() HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchArrayOutput) ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput).ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs, HTTPRouteSpecRulesFiltersRequestHeaderModifierPtr and HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
}

type httprouteSpecRulesFiltersRequestHeaderModifierPtrType HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs

func HTTPRouteSpecRulesFiltersRequestHeaderModifierPtr(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput {
	return (*httprouteSpecRulesFiltersRequestHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestHeaderModifier) *HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput).ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs, HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtr and HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs

func HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtr(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirror struct {
	BackendRef *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorArgs and HTTPRouteSpecRulesFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorArgs struct {
	BackendRef HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorArgs, HTTPRouteSpecRulesFiltersRequestMirrorPtr and HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorPtrType HTTPRouteSpecRulesFiltersRequestMirrorArgs

func HTTPRouteSpecRulesFiltersRequestMirrorPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorArgs) HTTPRouteSpecRulesFiltersRequestMirrorPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirror {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirror) HTTPRouteSpecRulesFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirror
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs, HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtr and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs

func HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorBackendRef
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs, HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtr and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs

func HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorPatch struct {
	BackendRef *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs and HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs struct {
	BackendRef HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs, HTTPRouteSpecRulesFiltersRequestMirrorPatchPtr and HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorPatchPtrType HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs

func HTTPRouteSpecRulesFiltersRequestMirrorPatchPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorPatch) *HTTPRouteSpecRulesFiltersRequestMirrorPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorPatch) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorPatch) HTTPRouteSpecRulesFiltersRequestMirrorPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorPatch) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirect struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                       `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersRequestRedirectPath `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectArgs and HTTPRouteSpecRulesFiltersRequestRedirectOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectArgs, HTTPRouteSpecRulesFiltersRequestRedirectPtr and HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPtrType HTTPRouteSpecRulesFiltersRequestRedirectArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectArgs) HTTPRouteSpecRulesFiltersRequestRedirectPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirect {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) HTTPRouteSpecRulesFiltersRequestRedirect {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirect
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectPatch struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                            `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs and HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                     `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs, HTTPRouteSpecRulesFiltersRequestRedirectPatchPtr and HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPatchPtrType HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPatchPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) HTTPRouteSpecRulesFiltersRequestRedirectPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathArgs and HTTPRouteSpecRulesFiltersRequestRedirectPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathArgs, HTTPRouteSpecRulesFiltersRequestRedirectPathPtr and HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPathPtrType HTTPRouteSpecRulesFiltersRequestRedirectPathArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPathPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPathPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPath) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) HTTPRouteSpecRulesFiltersRequestRedirectPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPath
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs and HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs, HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtr and HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPathPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput).ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs, HTTPRouteSpecRulesFiltersResponseHeaderModifierPtr and HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
}

type httprouteSpecRulesFiltersResponseHeaderModifierPtrType HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs

func HTTPRouteSpecRulesFiltersResponseHeaderModifierPtr(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput {
	return (*httprouteSpecRulesFiltersResponseHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersResponseHeaderModifier) *HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersResponseHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput).ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs, HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtr and HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs

func HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtr(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewrite struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                  `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersUrlRewritePath `pulumi:"path"`
}

// HTTPRouteSpecRulesFiltersUrlRewriteInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewriteArgs and HTTPRouteSpecRulesFiltersUrlRewriteOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewriteInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewriteArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewriteInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput
	ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewriteArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                           `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesFiltersUrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewriteOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewriteOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewriteArgs, HTTPRouteSpecRulesFiltersUrlRewritePtr and HTTPRouteSpecRulesFiltersUrlRewritePtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewriteArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePtrType HTTPRouteSpecRulesFiltersUrlRewriteArgs

func HTTPRouteSpecRulesFiltersUrlRewritePtr(v *HTTPRouteSpecRulesFiltersUrlRewriteArgs) HTTPRouteSpecRulesFiltersUrlRewritePtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewriteOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewrite {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewrite) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewritePath { return v.Path }).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) HTTPRouteSpecRulesFiltersUrlRewrite {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewrite
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewriteOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewritePath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePatch struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                       `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersUrlRewritePathPatch `pulumi:"path"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePatchInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePatchArgs and HTTPRouteSpecRulesFiltersUrlRewritePatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePatchInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePatchArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                                `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePatchArgs, HTTPRouteSpecRulesFiltersUrlRewritePatchPtr and HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePatchPtrType HTTPRouteSpecRulesFiltersUrlRewritePatchArgs

func HTTPRouteSpecRulesFiltersUrlRewritePatchPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePatch) *HTTPRouteSpecRulesFiltersUrlRewritePatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePatch) *HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePatch) HTTPRouteSpecRulesFiltersUrlRewritePatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePatch
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePatch) *HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePathInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathArgs and HTTPRouteSpecRulesFiltersUrlRewritePathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePathArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathArgs, HTTPRouteSpecRulesFiltersUrlRewritePathPtr and HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePathPtrType HTTPRouteSpecRulesFiltersUrlRewritePathArgs

func HTTPRouteSpecRulesFiltersUrlRewritePathPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePathArgs) HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePathPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePath) *HTTPRouteSpecRulesFiltersUrlRewritePath {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) HTTPRouteSpecRulesFiltersUrlRewritePath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePath
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs and HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs, HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtr and HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePathPatchPtrType HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs

func HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePathPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePathPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatches struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers []HTTPRouteSpecRulesMatchesHeaders `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method *string                        `pulumi:"method"`
	Path   *HTTPRouteSpecRulesMatchesPath `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams []HTTPRouteSpecRulesMatchesQueryParams `pulumi:"queryParams"`
}

// HTTPRouteSpecRulesMatchesInput is an input type that accepts HTTPRouteSpecRulesMatchesArgs and HTTPRouteSpecRulesMatchesOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesInput` via:
//
//	HTTPRouteSpecRulesMatchesArgs{...}
type HTTPRouteSpecRulesMatchesInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput
	ToHTTPRouteSpecRulesMatchesOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesOutput
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesArgs struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers HTTPRouteSpecRulesMatchesHeadersArrayInput `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method pulumi.StringPtrInput                 `pulumi:"method"`
	Path   HTTPRouteSpecRulesMatchesPathPtrInput `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams HTTPRouteSpecRulesMatchesQueryParamsArrayInput `pulumi:"queryParams"`
}

func (HTTPRouteSpecRulesMatchesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesArgs) ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput {
	return i.ToHTTPRouteSpecRulesMatchesOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesArgs) ToHTTPRouteSpecRulesMatchesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesOutput)
}

// HTTPRouteSpecRulesMatchesArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesArray and HTTPRouteSpecRulesMatchesArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesArray{ HTTPRouteSpecRulesMatchesArgs{...} }
type HTTPRouteSpecRulesMatchesArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput
	ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesArrayOutput
}

type HTTPRouteSpecRulesMatchesArray []HTTPRouteSpecRulesMatchesInput

func (HTTPRouteSpecRulesMatchesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesArray) ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesArray) ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesArrayOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesOutput) ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesOutput) ToHTTPRouteSpecRulesMatchesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesOutput {
	return o
}

// Headers specifies HTTP request header matchers. Multiple match values are
// ANDed together, meaning, a request must match all the specified headers
// to select the route.
func (o HTTPRouteSpecRulesMatchesOutput) Headers() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) []HTTPRouteSpecRulesMatchesHeaders { return v.Headers }).(HTTPRouteSpecRulesMatchesHeadersArrayOutput)
}

// Method specifies HTTP method matcher.
// When specified, this route will be matched only if the request has the
// specified method.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) *string { return v.Method }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesMatchesOutput) Path() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) *HTTPRouteSpecRulesMatchesPath { return v.Path }).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// QueryParams specifies HTTP query parameter matchers. Multiple match
// values are ANDed together, meaning, a request must match all the
// specified query parameters to select the route.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesOutput) QueryParams() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) []HTTPRouteSpecRulesMatchesQueryParams { return v.QueryParams }).(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput)
}

type HTTPRouteSpecRulesMatchesArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatches {
		return vs[0].([]HTTPRouteSpecRulesMatches)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeaders struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesHeadersInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersArgs and HTTPRouteSpecRulesMatchesHeadersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersArgs{...}
type HTTPRouteSpecRulesMatchesHeadersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput
	ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersOutput
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersArgs) ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersArgs) ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersOutput)
}

// HTTPRouteSpecRulesMatchesHeadersArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersArray and HTTPRouteSpecRulesMatchesHeadersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersArray{ HTTPRouteSpecRulesMatchesHeadersArgs{...} }
type HTTPRouteSpecRulesMatchesHeadersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput
	ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput
}

type HTTPRouteSpecRulesMatchesHeadersArray []HTTPRouteSpecRulesMatchesHeadersInput

func (HTTPRouteSpecRulesMatchesHeadersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersArray) ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersArray) ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersArrayOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersOutput) ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersOutput) ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
//
// When a header is repeated in an HTTP request, it is
// implementation-specific behavior as to how this is represented.
// Generally, proxies should follow the guidance from the RFC:
// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
// processing a repeated header, with special handling for "Set-Cookie".
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the header.
//
// Support: Core (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression HeaderMatchType has implementation-specific
// conformance, implementations can support POSIX, PCRE or any other dialects
// of regular expressions. Please read the implementation's documentation to
// determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesHeadersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesHeadersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesHeaders {
		return vs[0].([]HTTPRouteSpecRulesMatchesHeaders)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesHeadersOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesHeadersPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersPatchArgs and HTTPRouteSpecRulesMatchesHeadersPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersPatchArgs{...}
type HTTPRouteSpecRulesMatchesHeadersPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersPatchOutput() HTTPRouteSpecRulesMatchesHeadersPatchOutput
	ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersPatchOutput
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesHeadersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArgs) ToHTTPRouteSpecRulesMatchesHeadersPatchOutput() HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArgs) ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersPatchOutput)
}

// HTTPRouteSpecRulesMatchesHeadersPatchArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersPatchArray and HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersPatchArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersPatchArray{ HTTPRouteSpecRulesMatchesHeadersPatchArgs{...} }
type HTTPRouteSpecRulesMatchesHeadersPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutput() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput
	ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput
}

type HTTPRouteSpecRulesMatchesHeadersPatchArray []HTTPRouteSpecRulesMatchesHeadersPatchInput

func (HTTPRouteSpecRulesMatchesHeadersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArray) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutput() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArray) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchOutput() HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
//
// When a header is repeated in an HTTP request, it is
// implementation-specific behavior as to how this is represented.
// Generally, proxies should follow the guidance from the RFC:
// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
// processing a repeated header, with special handling for "Set-Cookie".
func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeadersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the header.
//
// Support: Core (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression HeaderMatchType has implementation-specific
// conformance, implementations can support POSIX, PCRE or any other dialects
// of regular expressions. Please read the implementation's documentation to
// determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeadersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeadersPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutput() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesHeadersPatch {
		return vs[0].([]HTTPRouteSpecRulesMatchesHeadersPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesHeadersPatchOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesPatch struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers []HTTPRouteSpecRulesMatchesHeadersPatch `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method *string                             `pulumi:"method"`
	Path   *HTTPRouteSpecRulesMatchesPathPatch `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams []HTTPRouteSpecRulesMatchesQueryParamsPatch `pulumi:"queryParams"`
}

// HTTPRouteSpecRulesMatchesPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesPatchArgs and HTTPRouteSpecRulesMatchesPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesPatchArgs{...}
type HTTPRouteSpecRulesMatchesPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPatchOutput() HTTPRouteSpecRulesMatchesPatchOutput
	ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPatchOutput
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesPatchArgs struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers HTTPRouteSpecRulesMatchesHeadersPatchArrayInput `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method pulumi.StringPtrInput                      `pulumi:"method"`
	Path   HTTPRouteSpecRulesMatchesPathPatchPtrInput `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput `pulumi:"queryParams"`
}

func (HTTPRouteSpecRulesMatchesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPatchArgs) ToHTTPRouteSpecRulesMatchesPatchOutput() HTTPRouteSpecRulesMatchesPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPatchArgs) ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPatchOutput)
}

// HTTPRouteSpecRulesMatchesPatchArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesPatchArray and HTTPRouteSpecRulesMatchesPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPatchArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesPatchArray{ HTTPRouteSpecRulesMatchesPatchArgs{...} }
type HTTPRouteSpecRulesMatchesPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPatchArrayOutput() HTTPRouteSpecRulesMatchesPatchArrayOutput
	ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPatchArrayOutput
}

type HTTPRouteSpecRulesMatchesPatchArray []HTTPRouteSpecRulesMatchesPatchInput

func (HTTPRouteSpecRulesMatchesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPatchArray) ToHTTPRouteSpecRulesMatchesPatchArrayOutput() HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPatchArray) ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPatchArrayOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPatchOutput) ToHTTPRouteSpecRulesMatchesPatchOutput() HTTPRouteSpecRulesMatchesPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPatchOutput) ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchOutput {
	return o
}

// Headers specifies HTTP request header matchers. Multiple match values are
// ANDed together, meaning, a request must match all the specified headers
// to select the route.
func (o HTTPRouteSpecRulesMatchesPatchOutput) Headers() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) []HTTPRouteSpecRulesMatchesHeadersPatch { return v.Headers }).(HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput)
}

// Method specifies HTTP method matcher.
// When specified, this route will be matched only if the request has the
// specified method.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesPatchOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) *string { return v.Method }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesMatchesPatchOutput) Path() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) *HTTPRouteSpecRulesMatchesPathPatch { return v.Path }).(HTTPRouteSpecRulesMatchesPathPatchPtrOutput)
}

// QueryParams specifies HTTP query parameter matchers. Multiple match
// values are ANDed together, meaning, a request must match all the
// specified query parameters to select the route.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesPatchOutput) QueryParams() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) []HTTPRouteSpecRulesMatchesQueryParamsPatch {
		return v.QueryParams
	}).(HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput)
}

type HTTPRouteSpecRulesMatchesPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPatchArrayOutput) ToHTTPRouteSpecRulesMatchesPatchArrayOutput() HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPatchArrayOutput) ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesPatch {
		return vs[0].([]HTTPRouteSpecRulesMatchesPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesPatchOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPath struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesPathInput is an input type that accepts HTTPRouteSpecRulesMatchesPathArgs and HTTPRouteSpecRulesMatchesPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathInput` via:
//
//	HTTPRouteSpecRulesMatchesPathArgs{...}
type HTTPRouteSpecRulesMatchesPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput
	ToHTTPRouteSpecRulesMatchesPathOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathOutput
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathArgs struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathOutput)
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathOutput).ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesMatchesPathPtrInput is an input type that accepts HTTPRouteSpecRulesMatchesPathArgs, HTTPRouteSpecRulesMatchesPathPtr and HTTPRouteSpecRulesMatchesPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPtrInput` via:
//
//	        HTTPRouteSpecRulesMatchesPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesMatchesPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput
	ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput
}

type httprouteSpecRulesMatchesPathPtrType HTTPRouteSpecRulesMatchesPathArgs

func HTTPRouteSpecRulesMatchesPathPtr(v *HTTPRouteSpecRulesMatchesPathArgs) HTTPRouteSpecRulesMatchesPathPtrInput {
	return (*httprouteSpecRulesMatchesPathPtrType)(v)
}

func (*httprouteSpecRulesMatchesPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (i *httprouteSpecRulesMatchesPathPtrType) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesMatchesPathPtrType) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesMatchesPath) *HTTPRouteSpecRulesMatchesPath {
		return &v
	}).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPath) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Elem() HTTPRouteSpecRulesMatchesPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) HTTPRouteSpecRulesMatchesPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesMatchesPath
		return ret
	}).(HTTPRouteSpecRulesMatchesPathOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathPatch struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesPathPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesPathPatchArgs and HTTPRouteSpecRulesMatchesPathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesPathPatchArgs{...}
type HTTPRouteSpecRulesMatchesPathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPatchOutput() HTTPRouteSpecRulesMatchesPathPatchOutput
	ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPatchOutput
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathPatchArgs struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesPathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchOutput() HTTPRouteSpecRulesMatchesPathPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPatchOutput)
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPatchOutput).ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesMatchesPathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesMatchesPathPatchArgs, HTTPRouteSpecRulesMatchesPathPatchPtr and HTTPRouteSpecRulesMatchesPathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesMatchesPathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesMatchesPathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput
	ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput
}

type httprouteSpecRulesMatchesPathPatchPtrType HTTPRouteSpecRulesMatchesPathPatchArgs

func HTTPRouteSpecRulesMatchesPathPatchPtr(v *HTTPRouteSpecRulesMatchesPathPatchArgs) HTTPRouteSpecRulesMatchesPathPatchPtrInput {
	return (*httprouteSpecRulesMatchesPathPatchPtrType)(v)
}

func (*httprouteSpecRulesMatchesPathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesMatchesPathPatchPtrType) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesMatchesPathPatchPtrType) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPatchPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchOutput() HTTPRouteSpecRulesMatchesPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesMatchesPathPatch) *HTTPRouteSpecRulesMatchesPathPatch {
		return &v
	}).(HTTPRouteSpecRulesMatchesPathPatchPtrOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPathPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesPathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) Elem() HTTPRouteSpecRulesMatchesPathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPathPatch) HTTPRouteSpecRulesMatchesPathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesMatchesPathPatch
		return ret
	}).(HTTPRouteSpecRulesMatchesPathPatchOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParams struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesQueryParamsInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsArgs and HTTPRouteSpecRulesMatchesQueryParamsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsArgs{...}
type HTTPRouteSpecRulesMatchesQueryParamsInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsArgs struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesQueryParamsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArgs) ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArgs) ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsOutput)
}

// HTTPRouteSpecRulesMatchesQueryParamsArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsArray and HTTPRouteSpecRulesMatchesQueryParamsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsArray{ HTTPRouteSpecRulesMatchesQueryParamsArgs{...} }
type HTTPRouteSpecRulesMatchesQueryParamsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput
}

type HTTPRouteSpecRulesMatchesQueryParamsArray []HTTPRouteSpecRulesMatchesQueryParamsInput

func (HTTPRouteSpecRulesMatchesQueryParamsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArray) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArray) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return o
}

// Name is the name of the HTTP query param to be matched. This must be an
// exact string match. (See
// https://tools.ietf.org/html/rfc7230#section-2.7.3).
//
// If multiple entries specify equivalent query param names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent query param name MUST be ignored.
//
// If a query param is repeated in an HTTP request, the behavior is
// purposely left undefined, since different data planes have different
// capabilities. However, it is *recommended* that implementations should
// match against the first value of the param if the data plane supports it,
// as this behavior is expected in other load balancing contexts outside of
// the Gateway API.
//
// Users SHOULD NOT route traffic based on repeated query params to guard
// themselves against potential differences in the implementations.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the query parameter.
//
// Support: Extended (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression QueryParamMatchType has Implementation-specific
// conformance, implementations can support POSIX, PCRE or any other
// dialects of regular expressions. Please read the implementation's
// documentation to determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP query param to be matched.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesQueryParamsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesQueryParams {
		return vs[0].([]HTTPRouteSpecRulesMatchesQueryParams)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesQueryParamsOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsPatch struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesQueryParamsPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsPatchArgs and HTTPRouteSpecRulesMatchesQueryParamsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsPatchArgs{...}
type HTTPRouteSpecRulesMatchesQueryParamsPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsPatchArgs struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesQueryParamsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArgs) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArgs) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsPatchOutput)
}

// HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsPatchArray and HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsPatchArray{ HTTPRouteSpecRulesMatchesQueryParamsPatchArgs{...} }
type HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput
}

type HTTPRouteSpecRulesMatchesQueryParamsPatchArray []HTTPRouteSpecRulesMatchesQueryParamsPatchInput

func (HTTPRouteSpecRulesMatchesQueryParamsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArray) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArray) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return o
}

// Name is the name of the HTTP query param to be matched. This must be an
// exact string match. (See
// https://tools.ietf.org/html/rfc7230#section-2.7.3).
//
// If multiple entries specify equivalent query param names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent query param name MUST be ignored.
//
// If a query param is repeated in an HTTP request, the behavior is
// purposely left undefined, since different data planes have different
// capabilities. However, it is *recommended* that implementations should
// match against the first value of the param if the data plane supports it,
// as this behavior is expected in other load balancing contexts outside of
// the Gateway API.
//
// Users SHOULD NOT route traffic based on repeated query params to guard
// themselves against potential differences in the implementations.
func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParamsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the query parameter.
//
// Support: Extended (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression QueryParamMatchType has Implementation-specific
// conformance, implementations can support POSIX, PCRE or any other
// dialects of regular expressions. Please read the implementation's
// documentation to determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParamsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP query param to be matched.
func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParamsPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesQueryParamsPatch {
		return vs[0].([]HTTPRouteSpecRulesMatchesQueryParamsPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesQueryParamsPatchOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesPatch struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []HTTPRouteSpecRulesBackendRefsPatch `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []HTTPRouteSpecRulesFiltersPatch `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches []HTTPRouteSpecRulesMatchesPatch `pulumi:"matches"`
}

// HTTPRouteSpecRulesPatchInput is an input type that accepts HTTPRouteSpecRulesPatchArgs and HTTPRouteSpecRulesPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesPatchInput` via:
//
//	HTTPRouteSpecRulesPatchArgs{...}
type HTTPRouteSpecRulesPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesPatchOutput() HTTPRouteSpecRulesPatchOutput
	ToHTTPRouteSpecRulesPatchOutputWithContext(context.Context) HTTPRouteSpecRulesPatchOutput
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesPatchArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs HTTPRouteSpecRulesBackendRefsPatchArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters HTTPRouteSpecRulesFiltersPatchArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches HTTPRouteSpecRulesMatchesPatchArrayInput `pulumi:"matches"`
}

func (HTTPRouteSpecRulesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesPatchArgs) ToHTTPRouteSpecRulesPatchOutput() HTTPRouteSpecRulesPatchOutput {
	return i.ToHTTPRouteSpecRulesPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesPatchArgs) ToHTTPRouteSpecRulesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesPatchOutput)
}

// HTTPRouteSpecRulesPatchArrayInput is an input type that accepts HTTPRouteSpecRulesPatchArray and HTTPRouteSpecRulesPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesPatchArrayInput` via:
//
//	HTTPRouteSpecRulesPatchArray{ HTTPRouteSpecRulesPatchArgs{...} }
type HTTPRouteSpecRulesPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesPatchArrayOutput() HTTPRouteSpecRulesPatchArrayOutput
	ToHTTPRouteSpecRulesPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesPatchArrayOutput
}

type HTTPRouteSpecRulesPatchArray []HTTPRouteSpecRulesPatchInput

func (HTTPRouteSpecRulesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesPatchArray) ToHTTPRouteSpecRulesPatchArrayOutput() HTTPRouteSpecRulesPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesPatchArray) ToHTTPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesPatchArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesPatchOutput) ToHTTPRouteSpecRulesPatchOutput() HTTPRouteSpecRulesPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesPatchOutput) ToHTTPRouteSpecRulesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive a 500 status code.
//
// See the HTTPBackendRef definition for the rules about what makes a single
// HTTPBackendRef invalid.
//
// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive a 500 status code.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic must receive a 500. Implementations may
// choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o HTTPRouteSpecRulesPatchOutput) BackendRefs() HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesPatch) []HTTPRouteSpecRulesBackendRefsPatch { return v.BackendRefs }).(HTTPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// Wherever possible, implementations SHOULD implement filters in the order
// they are specified.
//
// Implementations MAY choose to implement this ordering strictly, rejecting
// any combination or order of filters that can not be supported. If implementations
// choose a strict interpretation of filter ordering, they MUST clearly document
// that behavior.
//
// To reject an invalid combination or order of filters, implementations SHOULD
// consider the Route Rules with this configuration invalid. If all Route Rules
// in a Route are invalid, the entire Route would be considered invalid. If only
// a portion of Route Rules are invalid, implementations MUST set the
// "PartiallyInvalid" condition for the Route.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// All filters are expected to be compatible with each other except for the
// URLRewrite and RequestRedirect filters, which may not be combined. If an
// implementation can not support other combinations of filters, they must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o HTTPRouteSpecRulesPatchOutput) Filters() HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesPatch) []HTTPRouteSpecRulesFiltersPatch { return v.Filters }).(HTTPRouteSpecRulesFiltersPatchArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// HTTP requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, a request must satisfy
// EITHER of the two conditions:
//
// - path prefixed with `/foo` AND contains the header `version: v2`
// - path prefix of `/v2/foo`
//
// See the documentation for HTTPRouteMatch on how to specify multiple
// match conditions that should be ANDed together.
//
// If no matches are specified, the default is a prefix
// path match on "/", which has the effect of matching every
// HTTP request.
//
// Proxy or Load Balancer routing configuration generated from HTTPRoutes
// MUST prioritize matches based on the following criteria, continuing on
// ties. Across all rules specified on applicable Routes, precedence must be
// given to the match having:
//
// * "Exact" path match.
// * "Prefix" path match with largest number of characters.
// * Method match.
// * Largest number of header matches.
// * Largest number of query param matches.
//
// Note: The precedence of RegularExpression path matches are implementation-specific.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within an HTTPRoute, matching precedence MUST be granted
// to the FIRST matching rule (in list order) with a match meeting the above
// criteria.
//
// When no rules matching a request have been successfully attached to the
// parent a request is coming from, a HTTP 404 status code MUST be returned.
func (o HTTPRouteSpecRulesPatchOutput) Matches() HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesPatch) []HTTPRouteSpecRulesMatchesPatch { return v.Matches }).(HTTPRouteSpecRulesMatchesPatchArrayOutput)
}

type HTTPRouteSpecRulesPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesPatchArrayOutput) ToHTTPRouteSpecRulesPatchArrayOutput() HTTPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesPatchArrayOutput) ToHTTPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesPatch {
		return vs[0].([]HTTPRouteSpecRulesPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesPatchOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []HTTPRouteStatusParents `pulumi:"parents"`
}

// HTTPRouteStatusInput is an input type that accepts HTTPRouteStatusArgs and HTTPRouteStatusOutput values.
// You can construct a concrete instance of `HTTPRouteStatusInput` via:
//
//	HTTPRouteStatusArgs{...}
type HTTPRouteStatusInput interface {
	pulumi.Input

	ToHTTPRouteStatusOutput() HTTPRouteStatusOutput
	ToHTTPRouteStatusOutputWithContext(context.Context) HTTPRouteStatusOutput
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents HTTPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (HTTPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatus)(nil)).Elem()
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusOutput() HTTPRouteStatusOutput {
	return i.ToHTTPRouteStatusOutputWithContext(context.Background())
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusOutputWithContext(ctx context.Context) HTTPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusOutput)
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return i.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusOutput).ToHTTPRouteStatusPtrOutputWithContext(ctx)
}

// HTTPRouteStatusPtrInput is an input type that accepts HTTPRouteStatusArgs, HTTPRouteStatusPtr and HTTPRouteStatusPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPtrInput` via:
//
//	        HTTPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput
	ToHTTPRouteStatusPtrOutputWithContext(context.Context) HTTPRouteStatusPtrOutput
}

type httprouteStatusPtrType HTTPRouteStatusArgs

func HTTPRouteStatusPtr(v *HTTPRouteStatusArgs) HTTPRouteStatusPtrInput {
	return (*httprouteStatusPtrType)(v)
}

func (*httprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatus)(nil)).Elem()
}

func (i *httprouteStatusPtrType) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return i.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusPtrType) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPtrOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatus)(nil)).Elem()
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusOutput() HTTPRouteStatusOutput {
	return o
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusOutputWithContext(ctx context.Context) HTTPRouteStatusOutput {
	return o
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return o.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatus) *HTTPRouteStatus {
		return &v
	}).(HTTPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusOutput) Parents() HTTPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatus) []HTTPRouteStatusParents { return v.Parents }).(HTTPRouteStatusParentsArrayOutput)
}

type HTTPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatus)(nil)).Elem()
}

func (o HTTPRouteStatusPtrOutput) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return o
}

func (o HTTPRouteStatusPtrOutput) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return o
}

func (o HTTPRouteStatusPtrOutput) Elem() HTTPRouteStatusOutput {
	return o.ApplyT(func(v *HTTPRouteStatus) HTTPRouteStatus {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatus
		return ret
	}).(HTTPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPtrOutput) Parents() HTTPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *HTTPRouteStatus) []HTTPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(HTTPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []HTTPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                          `pulumi:"controllerName"`
	ParentRef      *HTTPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// HTTPRouteStatusParentsInput is an input type that accepts HTTPRouteStatusParentsArgs and HTTPRouteStatusParentsOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsInput` via:
//
//	HTTPRouteStatusParentsArgs{...}
type HTTPRouteStatusParentsInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput
	ToHTTPRouteStatusParentsOutputWithContext(context.Context) HTTPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions HTTPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                   `pulumi:"controllerName"`
	ParentRef      HTTPRouteStatusParentsParentRefPtrInput `pulumi:"parentRef"`
}

func (HTTPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParents)(nil)).Elem()
}

func (i HTTPRouteStatusParentsArgs) ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput {
	return i.ToHTTPRouteStatusParentsOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsArgs) ToHTTPRouteStatusParentsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsOutput)
}

// HTTPRouteStatusParentsArrayInput is an input type that accepts HTTPRouteStatusParentsArray and HTTPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsArrayInput` via:
//
//	HTTPRouteStatusParentsArray{ HTTPRouteStatusParentsArgs{...} }
type HTTPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput
	ToHTTPRouteStatusParentsArrayOutputWithContext(context.Context) HTTPRouteStatusParentsArrayOutput
}

type HTTPRouteStatusParentsArray []HTTPRouteStatusParentsInput

func (HTTPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParents)(nil)).Elem()
}

func (i HTTPRouteStatusParentsArray) ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput {
	return i.ToHTTPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsArray) ToHTTPRouteStatusParentsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParents)(nil)).Elem()
}

func (o HTTPRouteStatusParentsOutput) ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput {
	return o
}

func (o HTTPRouteStatusParentsOutput) ToHTTPRouteStatusParentsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o HTTPRouteStatusParentsOutput) Conditions() HTTPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) []HTTPRouteStatusParentsConditions { return v.Conditions }).(HTTPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o HTTPRouteStatusParentsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteStatusParentsOutput) ParentRef() HTTPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) *HTTPRouteStatusParentsParentRef { return v.ParentRef }).(HTTPRouteStatusParentsParentRefPtrOutput)
}

type HTTPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParents)(nil)).Elem()
}

func (o HTTPRouteStatusParentsArrayOutput) ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsArrayOutput) ToHTTPRouteStatusParentsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParents {
		return vs[0].([]HTTPRouteStatusParents)[vs[1].(int)]
	}).(HTTPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// HTTPRouteStatusParentsConditionsInput is an input type that accepts HTTPRouteStatusParentsConditionsArgs and HTTPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsInput` via:
//
//	HTTPRouteStatusParentsConditionsArgs{...}
type HTTPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput
	ToHTTPRouteStatusParentsConditionsOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsArgs) ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput {
	return i.ToHTTPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsArgs) ToHTTPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsOutput)
}

// HTTPRouteStatusParentsConditionsArrayInput is an input type that accepts HTTPRouteStatusParentsConditionsArray and HTTPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsArrayInput` via:
//
//	HTTPRouteStatusParentsConditionsArray{ HTTPRouteStatusParentsConditionsArgs{...} }
type HTTPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput
	ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsArrayOutput
}

type HTTPRouteStatusParentsConditionsArray []HTTPRouteStatusParentsConditionsInput

func (HTTPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsArray) ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput {
	return i.ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsArray) ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsOutput) ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsOutput) ToHTTPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o HTTPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o HTTPRouteStatusParentsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o HTTPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o HTTPRouteStatusParentsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o HTTPRouteStatusParentsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o HTTPRouteStatusParentsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsConditions {
		return vs[0].([]HTTPRouteStatusParentsConditions)[vs[1].(int)]
	}).(HTTPRouteStatusParentsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// HTTPRouteStatusParentsConditionsPatchInput is an input type that accepts HTTPRouteStatusParentsConditionsPatchArgs and HTTPRouteStatusParentsConditionsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsPatchInput` via:
//
//	HTTPRouteStatusParentsConditionsPatchArgs{...}
type HTTPRouteStatusParentsConditionsPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsPatchOutput() HTTPRouteStatusParentsConditionsPatchOutput
	ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteStatusParentsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsPatchArgs) ToHTTPRouteStatusParentsConditionsPatchOutput() HTTPRouteStatusParentsConditionsPatchOutput {
	return i.ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsPatchArgs) ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsPatchOutput)
}

// HTTPRouteStatusParentsConditionsPatchArrayInput is an input type that accepts HTTPRouteStatusParentsConditionsPatchArray and HTTPRouteStatusParentsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsPatchArrayInput` via:
//
//	HTTPRouteStatusParentsConditionsPatchArray{ HTTPRouteStatusParentsConditionsPatchArgs{...} }
type HTTPRouteStatusParentsConditionsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsPatchArrayOutput() HTTPRouteStatusParentsConditionsPatchArrayOutput
	ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsPatchArrayOutput
}

type HTTPRouteStatusParentsConditionsPatchArray []HTTPRouteStatusParentsConditionsPatchInput

func (HTTPRouteStatusParentsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsPatchArray) ToHTTPRouteStatusParentsConditionsPatchArrayOutput() HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return i.ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsPatchArray) ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsPatchOutput) ToHTTPRouteStatusParentsConditionsPatchOutput() HTTPRouteStatusParentsConditionsPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsPatchOutput) ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o HTTPRouteStatusParentsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o HTTPRouteStatusParentsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o HTTPRouteStatusParentsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o HTTPRouteStatusParentsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o HTTPRouteStatusParentsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o HTTPRouteStatusParentsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsPatchArrayOutput) ToHTTPRouteStatusParentsConditionsPatchArrayOutput() HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsPatchArrayOutput) ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsConditionsPatch {
		return vs[0].([]HTTPRouteStatusParentsConditionsPatch)[vs[1].(int)]
	}).(HTTPRouteStatusParentsConditionsPatchOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteStatusParentsParentRefInput is an input type that accepts HTTPRouteStatusParentsParentRefArgs and HTTPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefInput` via:
//
//	HTTPRouteStatusParentsParentRefArgs{...}
type HTTPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput
	ToHTTPRouteStatusParentsParentRefOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput {
	return i.ToHTTPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefOutput)
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefOutput).ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx)
}

// HTTPRouteStatusParentsParentRefPtrInput is an input type that accepts HTTPRouteStatusParentsParentRefArgs, HTTPRouteStatusParentsParentRefPtr and HTTPRouteStatusParentsParentRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefPtrInput` via:
//
//	        HTTPRouteStatusParentsParentRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusParentsParentRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput
	ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefPtrOutput
}

type httprouteStatusParentsParentRefPtrType HTTPRouteStatusParentsParentRefArgs

func HTTPRouteStatusParentsParentRefPtr(v *HTTPRouteStatusParentsParentRefArgs) HTTPRouteStatusParentsParentRefPtrInput {
	return (*httprouteStatusParentsParentRefPtrType)(v)
}

func (*httprouteStatusParentsParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i *httprouteStatusParentsParentRefPtrType) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusParentsParentRefPtrType) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return o.ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatusParentsParentRef) *HTTPRouteStatusParentsParentRef {
		return &v
	}).(HTTPRouteStatusParentsParentRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsParentRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefPtrOutput) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPtrOutput) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPtrOutput) Elem() HTTPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) HTTPRouteStatusParentsParentRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatusParentsParentRef
		return ret
	}).(HTTPRouteStatusParentsParentRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteStatusParentsParentRefPatchInput is an input type that accepts HTTPRouteStatusParentsParentRefPatchArgs and HTTPRouteStatusParentsParentRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefPatchInput` via:
//
//	HTTPRouteStatusParentsParentRefPatchArgs{...}
type HTTPRouteStatusParentsParentRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefPatchOutput() HTTPRouteStatusParentsParentRefPatchOutput
	ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefPatchOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteStatusParentsParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchOutput() HTTPRouteStatusParentsParentRefPatchOutput {
	return i.ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPatchOutput)
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPatchOutput).ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteStatusParentsParentRefPatchPtrInput is an input type that accepts HTTPRouteStatusParentsParentRefPatchArgs, HTTPRouteStatusParentsParentRefPatchPtr and HTTPRouteStatusParentsParentRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefPatchPtrInput` via:
//
//	        HTTPRouteStatusParentsParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusParentsParentRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput
	ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput
}

type httprouteStatusParentsParentRefPatchPtrType HTTPRouteStatusParentsParentRefPatchArgs

func HTTPRouteStatusParentsParentRefPatchPtr(v *HTTPRouteStatusParentsParentRefPatchArgs) HTTPRouteStatusParentsParentRefPatchPtrInput {
	return (*httprouteStatusParentsParentRefPatchPtrType)(v)
}

func (*httprouteStatusParentsParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i *httprouteStatusParentsParentRefPatchPtrType) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusParentsParentRefPatchPtrType) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPatchPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchOutput() HTTPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatusParentsParentRefPatch) *HTTPRouteStatusParentsParentRefPatch {
		return &v
	}).(HTTPRouteStatusParentsParentRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Elem() HTTPRouteStatusParentsParentRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) HTTPRouteStatusParentsParentRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatusParentsParentRefPatch
		return ret
	}).(HTTPRouteStatusParentsParentRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsPatch struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []HTTPRouteStatusParentsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                               `pulumi:"controllerName"`
	ParentRef      *HTTPRouteStatusParentsParentRefPatch `pulumi:"parentRef"`
}

// HTTPRouteStatusParentsPatchInput is an input type that accepts HTTPRouteStatusParentsPatchArgs and HTTPRouteStatusParentsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsPatchInput` via:
//
//	HTTPRouteStatusParentsPatchArgs{...}
type HTTPRouteStatusParentsPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsPatchOutput() HTTPRouteStatusParentsPatchOutput
	ToHTTPRouteStatusParentsPatchOutputWithContext(context.Context) HTTPRouteStatusParentsPatchOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsPatchArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions HTTPRouteStatusParentsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                        `pulumi:"controllerName"`
	ParentRef      HTTPRouteStatusParentsParentRefPatchPtrInput `pulumi:"parentRef"`
}

func (HTTPRouteStatusParentsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsPatchArgs) ToHTTPRouteStatusParentsPatchOutput() HTTPRouteStatusParentsPatchOutput {
	return i.ToHTTPRouteStatusParentsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsPatchArgs) ToHTTPRouteStatusParentsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsPatchOutput)
}

// HTTPRouteStatusParentsPatchArrayInput is an input type that accepts HTTPRouteStatusParentsPatchArray and HTTPRouteStatusParentsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsPatchArrayInput` via:
//
//	HTTPRouteStatusParentsPatchArray{ HTTPRouteStatusParentsPatchArgs{...} }
type HTTPRouteStatusParentsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsPatchArrayOutput() HTTPRouteStatusParentsPatchArrayOutput
	ToHTTPRouteStatusParentsPatchArrayOutputWithContext(context.Context) HTTPRouteStatusParentsPatchArrayOutput
}

type HTTPRouteStatusParentsPatchArray []HTTPRouteStatusParentsPatchInput

func (HTTPRouteStatusParentsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsPatchArray) ToHTTPRouteStatusParentsPatchArrayOutput() HTTPRouteStatusParentsPatchArrayOutput {
	return i.ToHTTPRouteStatusParentsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsPatchArray) ToHTTPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsPatchArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsPatchOutput) ToHTTPRouteStatusParentsPatchOutput() HTTPRouteStatusParentsPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsPatchOutput) ToHTTPRouteStatusParentsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o HTTPRouteStatusParentsPatchOutput) Conditions() HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsPatch) []HTTPRouteStatusParentsConditionsPatch { return v.Conditions }).(HTTPRouteStatusParentsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o HTTPRouteStatusParentsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteStatusParentsPatchOutput) ParentRef() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsPatch) *HTTPRouteStatusParentsParentRefPatch { return v.ParentRef }).(HTTPRouteStatusParentsParentRefPatchPtrOutput)
}

type HTTPRouteStatusParentsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsPatchArrayOutput) ToHTTPRouteStatusParentsPatchArrayOutput() HTTPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsPatchArrayOutput) ToHTTPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsPatch {
		return vs[0].([]HTTPRouteStatusParentsPatch)[vs[1].(int)]
	}).(HTTPRouteStatusParentsPatchOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusPatch struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []HTTPRouteStatusParentsPatch `pulumi:"parents"`
}

// HTTPRouteStatusPatchInput is an input type that accepts HTTPRouteStatusPatchArgs and HTTPRouteStatusPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPatchInput` via:
//
//	HTTPRouteStatusPatchArgs{...}
type HTTPRouteStatusPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusPatchOutput() HTTPRouteStatusPatchOutput
	ToHTTPRouteStatusPatchOutputWithContext(context.Context) HTTPRouteStatusPatchOutput
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusPatchArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents HTTPRouteStatusParentsPatchArrayInput `pulumi:"parents"`
}

func (HTTPRouteStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusPatch)(nil)).Elem()
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchOutput() HTTPRouteStatusPatchOutput {
	return i.ToHTTPRouteStatusPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchOutputWithContext(ctx context.Context) HTTPRouteStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPatchOutput)
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return i.ToHTTPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPatchOutput).ToHTTPRouteStatusPatchPtrOutputWithContext(ctx)
}

// HTTPRouteStatusPatchPtrInput is an input type that accepts HTTPRouteStatusPatchArgs, HTTPRouteStatusPatchPtr and HTTPRouteStatusPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPatchPtrInput` via:
//
//	        HTTPRouteStatusPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput
	ToHTTPRouteStatusPatchPtrOutputWithContext(context.Context) HTTPRouteStatusPatchPtrOutput
}

type httprouteStatusPatchPtrType HTTPRouteStatusPatchArgs

func HTTPRouteStatusPatchPtr(v *HTTPRouteStatusPatchArgs) HTTPRouteStatusPatchPtrInput {
	return (*httprouteStatusPatchPtrType)(v)
}

func (*httprouteStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusPatch)(nil)).Elem()
}

func (i *httprouteStatusPatchPtrType) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return i.ToHTTPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusPatchPtrType) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPatchPtrOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusPatch)(nil)).Elem()
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchOutput() HTTPRouteStatusPatchOutput {
	return o
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchOutputWithContext(ctx context.Context) HTTPRouteStatusPatchOutput {
	return o
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return o.ToHTTPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatusPatch) *HTTPRouteStatusPatch {
		return &v
	}).(HTTPRouteStatusPatchPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPatchOutput) Parents() HTTPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusPatch) []HTTPRouteStatusParentsPatch { return v.Parents }).(HTTPRouteStatusParentsPatchArrayOutput)
}

type HTTPRouteStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusPatch)(nil)).Elem()
}

func (o HTTPRouteStatusPatchPtrOutput) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusPatchPtrOutput) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusPatchPtrOutput) Elem() HTTPRouteStatusPatchOutput {
	return o.ApplyT(func(v *HTTPRouteStatusPatch) HTTPRouteStatusPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatusPatch
		return ret
	}).(HTTPRouteStatusPatchOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPatchPtrOutput) Parents() HTTPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteStatusPatch) []HTTPRouteStatusParentsPatch {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(HTTPRouteStatusParentsPatchArrayOutput)
}

// ReferenceGrant identifies kinds of resources in other namespaces that are
// trusted to reference the specified kinds of resources in the same namespace
// as the policy.
//
// Each ReferenceGrant can be used to represent a unique trust relationship.
// Additional Reference Grants can be used to add to the set of trusted
// sources of inbound references for the namespace they are defined within.
//
// All cross-namespace references in Gateway API (with the exception of cross-namespace
// Gateway-route attachment) require a ReferenceGrant.
//
// ReferenceGrant is a form of runtime verification allowing users to assert
// which cross-namespace object references are permitted. Implementations that
// support ReferenceGrant MUST NOT permit cross-namespace references which have
// no grant, and MUST respond to the removal of a grant by revoking the access
// that the grant allowed.
type ReferenceGrantType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta  `pulumi:"metadata"`
	Spec     *ReferenceGrantSpec `pulumi:"spec"`
}

// ReferenceGrantTypeInput is an input type that accepts ReferenceGrantTypeArgs and ReferenceGrantTypeOutput values.
// You can construct a concrete instance of `ReferenceGrantTypeInput` via:
//
//	ReferenceGrantTypeArgs{...}
type ReferenceGrantTypeInput interface {
	pulumi.Input

	ToReferenceGrantTypeOutput() ReferenceGrantTypeOutput
	ToReferenceGrantTypeOutputWithContext(context.Context) ReferenceGrantTypeOutput
}

// ReferenceGrant identifies kinds of resources in other namespaces that are
// trusted to reference the specified kinds of resources in the same namespace
// as the policy.
//
// Each ReferenceGrant can be used to represent a unique trust relationship.
// Additional Reference Grants can be used to add to the set of trusted
// sources of inbound references for the namespace they are defined within.
//
// All cross-namespace references in Gateway API (with the exception of cross-namespace
// Gateway-route attachment) require a ReferenceGrant.
//
// ReferenceGrant is a form of runtime verification allowing users to assert
// which cross-namespace object references are permitted. Implementations that
// support ReferenceGrant MUST NOT permit cross-namespace references which have
// no grant, and MUST respond to the removal of a grant by revoking the access
// that the grant allowed.
type ReferenceGrantTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput  `pulumi:"metadata"`
	Spec     ReferenceGrantSpecPtrInput `pulumi:"spec"`
}

func (ReferenceGrantTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantType)(nil)).Elem()
}

func (i ReferenceGrantTypeArgs) ToReferenceGrantTypeOutput() ReferenceGrantTypeOutput {
	return i.ToReferenceGrantTypeOutputWithContext(context.Background())
}

func (i ReferenceGrantTypeArgs) ToReferenceGrantTypeOutputWithContext(ctx context.Context) ReferenceGrantTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantTypeOutput)
}

// ReferenceGrantTypeArrayInput is an input type that accepts ReferenceGrantTypeArray and ReferenceGrantTypeArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantTypeArrayInput` via:
//
//	ReferenceGrantTypeArray{ ReferenceGrantTypeArgs{...} }
type ReferenceGrantTypeArrayInput interface {
	pulumi.Input

	ToReferenceGrantTypeArrayOutput() ReferenceGrantTypeArrayOutput
	ToReferenceGrantTypeArrayOutputWithContext(context.Context) ReferenceGrantTypeArrayOutput
}

type ReferenceGrantTypeArray []ReferenceGrantTypeInput

func (ReferenceGrantTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantType)(nil)).Elem()
}

func (i ReferenceGrantTypeArray) ToReferenceGrantTypeArrayOutput() ReferenceGrantTypeArrayOutput {
	return i.ToReferenceGrantTypeArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantTypeArray) ToReferenceGrantTypeArrayOutputWithContext(ctx context.Context) ReferenceGrantTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantTypeArrayOutput)
}

// ReferenceGrant identifies kinds of resources in other namespaces that are
// trusted to reference the specified kinds of resources in the same namespace
// as the policy.
//
// Each ReferenceGrant can be used to represent a unique trust relationship.
// Additional Reference Grants can be used to add to the set of trusted
// sources of inbound references for the namespace they are defined within.
//
// All cross-namespace references in Gateway API (with the exception of cross-namespace
// Gateway-route attachment) require a ReferenceGrant.
//
// ReferenceGrant is a form of runtime verification allowing users to assert
// which cross-namespace object references are permitted. Implementations that
// support ReferenceGrant MUST NOT permit cross-namespace references which have
// no grant, and MUST respond to the removal of a grant by revoking the access
// that the grant allowed.
type ReferenceGrantTypeOutput struct{ *pulumi.OutputState }

func (ReferenceGrantTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantType)(nil)).Elem()
}

func (o ReferenceGrantTypeOutput) ToReferenceGrantTypeOutput() ReferenceGrantTypeOutput {
	return o
}

func (o ReferenceGrantTypeOutput) ToReferenceGrantTypeOutputWithContext(ctx context.Context) ReferenceGrantTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ReferenceGrantTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ReferenceGrantTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ReferenceGrantTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ReferenceGrantType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o ReferenceGrantTypeOutput) Spec() ReferenceGrantSpecPtrOutput {
	return o.ApplyT(func(v ReferenceGrantType) *ReferenceGrantSpec { return v.Spec }).(ReferenceGrantSpecPtrOutput)
}

type ReferenceGrantTypeArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantType)(nil)).Elem()
}

func (o ReferenceGrantTypeArrayOutput) ToReferenceGrantTypeArrayOutput() ReferenceGrantTypeArrayOutput {
	return o
}

func (o ReferenceGrantTypeArrayOutput) ToReferenceGrantTypeArrayOutputWithContext(ctx context.Context) ReferenceGrantTypeArrayOutput {
	return o
}

func (o ReferenceGrantTypeArrayOutput) Index(i pulumi.IntInput) ReferenceGrantTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantType {
		return vs[0].([]ReferenceGrantType)[vs[1].(int)]
	}).(ReferenceGrantTypeOutput)
}

// ReferenceGrantList is a list of ReferenceGrant
type ReferenceGrantListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of referencegrants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []ReferenceGrantType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ReferenceGrantListTypeInput is an input type that accepts ReferenceGrantListTypeArgs and ReferenceGrantListTypeOutput values.
// You can construct a concrete instance of `ReferenceGrantListTypeInput` via:
//
//	ReferenceGrantListTypeArgs{...}
type ReferenceGrantListTypeInput interface {
	pulumi.Input

	ToReferenceGrantListTypeOutput() ReferenceGrantListTypeOutput
	ToReferenceGrantListTypeOutputWithContext(context.Context) ReferenceGrantListTypeOutput
}

// ReferenceGrantList is a list of ReferenceGrant
type ReferenceGrantListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of referencegrants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items ReferenceGrantTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ReferenceGrantListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantListType)(nil)).Elem()
}

func (i ReferenceGrantListTypeArgs) ToReferenceGrantListTypeOutput() ReferenceGrantListTypeOutput {
	return i.ToReferenceGrantListTypeOutputWithContext(context.Background())
}

func (i ReferenceGrantListTypeArgs) ToReferenceGrantListTypeOutputWithContext(ctx context.Context) ReferenceGrantListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantListTypeOutput)
}

// ReferenceGrantList is a list of ReferenceGrant
type ReferenceGrantListTypeOutput struct{ *pulumi.OutputState }

func (ReferenceGrantListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantListType)(nil)).Elem()
}

func (o ReferenceGrantListTypeOutput) ToReferenceGrantListTypeOutput() ReferenceGrantListTypeOutput {
	return o
}

func (o ReferenceGrantListTypeOutput) ToReferenceGrantListTypeOutputWithContext(ctx context.Context) ReferenceGrantListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ReferenceGrantListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of referencegrants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o ReferenceGrantListTypeOutput) Items() ReferenceGrantTypeArrayOutput {
	return o.ApplyT(func(v ReferenceGrantListType) []ReferenceGrantType { return v.Items }).(ReferenceGrantTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ReferenceGrantListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ReferenceGrantListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ReferenceGrantListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ReferenceGrant identifies kinds of resources in other namespaces that are
// trusted to reference the specified kinds of resources in the same namespace
// as the policy.
//
// Each ReferenceGrant can be used to represent a unique trust relationship.
// Additional Reference Grants can be used to add to the set of trusted
// sources of inbound references for the namespace they are defined within.
//
// All cross-namespace references in Gateway API (with the exception of cross-namespace
// Gateway-route attachment) require a ReferenceGrant.
//
// ReferenceGrant is a form of runtime verification allowing users to assert
// which cross-namespace object references are permitted. Implementations that
// support ReferenceGrant MUST NOT permit cross-namespace references which have
// no grant, and MUST respond to the removal of a grant by revoking the access
// that the grant allowed.
type ReferenceGrantPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch  `pulumi:"metadata"`
	Spec     *ReferenceGrantSpecPatch `pulumi:"spec"`
}

// ReferenceGrantPatchTypeInput is an input type that accepts ReferenceGrantPatchTypeArgs and ReferenceGrantPatchTypeOutput values.
// You can construct a concrete instance of `ReferenceGrantPatchTypeInput` via:
//
//	ReferenceGrantPatchTypeArgs{...}
type ReferenceGrantPatchTypeInput interface {
	pulumi.Input

	ToReferenceGrantPatchTypeOutput() ReferenceGrantPatchTypeOutput
	ToReferenceGrantPatchTypeOutputWithContext(context.Context) ReferenceGrantPatchTypeOutput
}

// ReferenceGrant identifies kinds of resources in other namespaces that are
// trusted to reference the specified kinds of resources in the same namespace
// as the policy.
//
// Each ReferenceGrant can be used to represent a unique trust relationship.
// Additional Reference Grants can be used to add to the set of trusted
// sources of inbound references for the namespace they are defined within.
//
// All cross-namespace references in Gateway API (with the exception of cross-namespace
// Gateway-route attachment) require a ReferenceGrant.
//
// ReferenceGrant is a form of runtime verification allowing users to assert
// which cross-namespace object references are permitted. Implementations that
// support ReferenceGrant MUST NOT permit cross-namespace references which have
// no grant, and MUST respond to the removal of a grant by revoking the access
// that the grant allowed.
type ReferenceGrantPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput  `pulumi:"metadata"`
	Spec     ReferenceGrantSpecPatchPtrInput `pulumi:"spec"`
}

func (ReferenceGrantPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantPatchType)(nil)).Elem()
}

func (i ReferenceGrantPatchTypeArgs) ToReferenceGrantPatchTypeOutput() ReferenceGrantPatchTypeOutput {
	return i.ToReferenceGrantPatchTypeOutputWithContext(context.Background())
}

func (i ReferenceGrantPatchTypeArgs) ToReferenceGrantPatchTypeOutputWithContext(ctx context.Context) ReferenceGrantPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantPatchTypeOutput)
}

// ReferenceGrant identifies kinds of resources in other namespaces that are
// trusted to reference the specified kinds of resources in the same namespace
// as the policy.
//
// Each ReferenceGrant can be used to represent a unique trust relationship.
// Additional Reference Grants can be used to add to the set of trusted
// sources of inbound references for the namespace they are defined within.
//
// All cross-namespace references in Gateway API (with the exception of cross-namespace
// Gateway-route attachment) require a ReferenceGrant.
//
// ReferenceGrant is a form of runtime verification allowing users to assert
// which cross-namespace object references are permitted. Implementations that
// support ReferenceGrant MUST NOT permit cross-namespace references which have
// no grant, and MUST respond to the removal of a grant by revoking the access
// that the grant allowed.
type ReferenceGrantPatchTypeOutput struct{ *pulumi.OutputState }

func (ReferenceGrantPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantPatchType)(nil)).Elem()
}

func (o ReferenceGrantPatchTypeOutput) ToReferenceGrantPatchTypeOutput() ReferenceGrantPatchTypeOutput {
	return o
}

func (o ReferenceGrantPatchTypeOutput) ToReferenceGrantPatchTypeOutputWithContext(ctx context.Context) ReferenceGrantPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ReferenceGrantPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ReferenceGrantPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ReferenceGrantPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ReferenceGrantPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o ReferenceGrantPatchTypeOutput) Spec() ReferenceGrantSpecPatchPtrOutput {
	return o.ApplyT(func(v ReferenceGrantPatchType) *ReferenceGrantSpecPatch { return v.Spec }).(ReferenceGrantSpecPatchPtrOutput)
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpec struct {
	// From describes the trusted namespaces and kinds that can reference the
	// resources described in "To". Each entry in this list MUST be considered
	// to be an additional place that references can be valid from, or to put
	// this another way, entries MUST be combined using OR.
	//
	// Support: Core
	From []ReferenceGrantSpecFrom `pulumi:"from"`
	// To describes the resources that may be referenced by the resources
	// described in "From". Each entry in this list MUST be considered to be an
	// additional place that references can be valid to, or to put this another
	// way, entries MUST be combined using OR.
	//
	// Support: Core
	To []ReferenceGrantSpecTo `pulumi:"to"`
}

// ReferenceGrantSpecInput is an input type that accepts ReferenceGrantSpecArgs and ReferenceGrantSpecOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecInput` via:
//
//	ReferenceGrantSpecArgs{...}
type ReferenceGrantSpecInput interface {
	pulumi.Input

	ToReferenceGrantSpecOutput() ReferenceGrantSpecOutput
	ToReferenceGrantSpecOutputWithContext(context.Context) ReferenceGrantSpecOutput
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecArgs struct {
	// From describes the trusted namespaces and kinds that can reference the
	// resources described in "To". Each entry in this list MUST be considered
	// to be an additional place that references can be valid from, or to put
	// this another way, entries MUST be combined using OR.
	//
	// Support: Core
	From ReferenceGrantSpecFromArrayInput `pulumi:"from"`
	// To describes the resources that may be referenced by the resources
	// described in "From". Each entry in this list MUST be considered to be an
	// additional place that references can be valid to, or to put this another
	// way, entries MUST be combined using OR.
	//
	// Support: Core
	To ReferenceGrantSpecToArrayInput `pulumi:"to"`
}

func (ReferenceGrantSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpec)(nil)).Elem()
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecOutput() ReferenceGrantSpecOutput {
	return i.ToReferenceGrantSpecOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecOutputWithContext(ctx context.Context) ReferenceGrantSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecOutput)
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return i.ToReferenceGrantSpecPtrOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecOutput).ToReferenceGrantSpecPtrOutputWithContext(ctx)
}

// ReferenceGrantSpecPtrInput is an input type that accepts ReferenceGrantSpecArgs, ReferenceGrantSpecPtr and ReferenceGrantSpecPtrOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecPtrInput` via:
//
//	        ReferenceGrantSpecArgs{...}
//
//	or:
//
//	        nil
type ReferenceGrantSpecPtrInput interface {
	pulumi.Input

	ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput
	ToReferenceGrantSpecPtrOutputWithContext(context.Context) ReferenceGrantSpecPtrOutput
}

type referenceGrantSpecPtrType ReferenceGrantSpecArgs

func ReferenceGrantSpecPtr(v *ReferenceGrantSpecArgs) ReferenceGrantSpecPtrInput {
	return (*referenceGrantSpecPtrType)(v)
}

func (*referenceGrantSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReferenceGrantSpec)(nil)).Elem()
}

func (i *referenceGrantSpecPtrType) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return i.ToReferenceGrantSpecPtrOutputWithContext(context.Background())
}

func (i *referenceGrantSpecPtrType) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecPtrOutput)
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpec)(nil)).Elem()
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecOutput() ReferenceGrantSpecOutput {
	return o
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecOutputWithContext(ctx context.Context) ReferenceGrantSpecOutput {
	return o
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return o.ToReferenceGrantSpecPtrOutputWithContext(context.Background())
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReferenceGrantSpec) *ReferenceGrantSpec {
		return &v
	}).(ReferenceGrantSpecPtrOutput)
}

// From describes the trusted namespaces and kinds that can reference the
// resources described in "To". Each entry in this list MUST be considered
// to be an additional place that references can be valid from, or to put
// this another way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecOutput) From() ReferenceGrantSpecFromArrayOutput {
	return o.ApplyT(func(v ReferenceGrantSpec) []ReferenceGrantSpecFrom { return v.From }).(ReferenceGrantSpecFromArrayOutput)
}

// To describes the resources that may be referenced by the resources
// described in "From". Each entry in this list MUST be considered to be an
// additional place that references can be valid to, or to put this another
// way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecOutput) To() ReferenceGrantSpecToArrayOutput {
	return o.ApplyT(func(v ReferenceGrantSpec) []ReferenceGrantSpecTo { return v.To }).(ReferenceGrantSpecToArrayOutput)
}

type ReferenceGrantSpecPtrOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReferenceGrantSpec)(nil)).Elem()
}

func (o ReferenceGrantSpecPtrOutput) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return o
}

func (o ReferenceGrantSpecPtrOutput) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return o
}

func (o ReferenceGrantSpecPtrOutput) Elem() ReferenceGrantSpecOutput {
	return o.ApplyT(func(v *ReferenceGrantSpec) ReferenceGrantSpec {
		if v != nil {
			return *v
		}
		var ret ReferenceGrantSpec
		return ret
	}).(ReferenceGrantSpecOutput)
}

// From describes the trusted namespaces and kinds that can reference the
// resources described in "To". Each entry in this list MUST be considered
// to be an additional place that references can be valid from, or to put
// this another way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecPtrOutput) From() ReferenceGrantSpecFromArrayOutput {
	return o.ApplyT(func(v *ReferenceGrantSpec) []ReferenceGrantSpecFrom {
		if v == nil {
			return nil
		}
		return v.From
	}).(ReferenceGrantSpecFromArrayOutput)
}

// To describes the resources that may be referenced by the resources
// described in "From". Each entry in this list MUST be considered to be an
// additional place that references can be valid to, or to put this another
// way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecPtrOutput) To() ReferenceGrantSpecToArrayOutput {
	return o.ApplyT(func(v *ReferenceGrantSpec) []ReferenceGrantSpecTo {
		if v == nil {
			return nil
		}
		return v.To
	}).(ReferenceGrantSpecToArrayOutput)
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFrom struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field.
	//
	// When used to permit a SecretObjectReference:
	//
	// * Gateway
	//
	// When used to permit a BackendObjectReference:
	//
	// * GRPCRoute
	// * HTTPRoute
	// * TCPRoute
	// * TLSRoute
	// * UDPRoute
	Kind *string `pulumi:"kind"`
	// Namespace is the namespace of the referent.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// ReferenceGrantSpecFromInput is an input type that accepts ReferenceGrantSpecFromArgs and ReferenceGrantSpecFromOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecFromInput` via:
//
//	ReferenceGrantSpecFromArgs{...}
type ReferenceGrantSpecFromInput interface {
	pulumi.Input

	ToReferenceGrantSpecFromOutput() ReferenceGrantSpecFromOutput
	ToReferenceGrantSpecFromOutputWithContext(context.Context) ReferenceGrantSpecFromOutput
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromArgs struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field.
	//
	// When used to permit a SecretObjectReference:
	//
	// * Gateway
	//
	// When used to permit a BackendObjectReference:
	//
	// * GRPCRoute
	// * HTTPRoute
	// * TCPRoute
	// * TLSRoute
	// * UDPRoute
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Namespace is the namespace of the referent.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (ReferenceGrantSpecFromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecFrom)(nil)).Elem()
}

func (i ReferenceGrantSpecFromArgs) ToReferenceGrantSpecFromOutput() ReferenceGrantSpecFromOutput {
	return i.ToReferenceGrantSpecFromOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecFromArgs) ToReferenceGrantSpecFromOutputWithContext(ctx context.Context) ReferenceGrantSpecFromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecFromOutput)
}

// ReferenceGrantSpecFromArrayInput is an input type that accepts ReferenceGrantSpecFromArray and ReferenceGrantSpecFromArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecFromArrayInput` via:
//
//	ReferenceGrantSpecFromArray{ ReferenceGrantSpecFromArgs{...} }
type ReferenceGrantSpecFromArrayInput interface {
	pulumi.Input

	ToReferenceGrantSpecFromArrayOutput() ReferenceGrantSpecFromArrayOutput
	ToReferenceGrantSpecFromArrayOutputWithContext(context.Context) ReferenceGrantSpecFromArrayOutput
}

type ReferenceGrantSpecFromArray []ReferenceGrantSpecFromInput

func (ReferenceGrantSpecFromArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecFrom)(nil)).Elem()
}

func (i ReferenceGrantSpecFromArray) ToReferenceGrantSpecFromArrayOutput() ReferenceGrantSpecFromArrayOutput {
	return i.ToReferenceGrantSpecFromArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecFromArray) ToReferenceGrantSpecFromArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecFromArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecFromArrayOutput)
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecFromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecFrom)(nil)).Elem()
}

func (o ReferenceGrantSpecFromOutput) ToReferenceGrantSpecFromOutput() ReferenceGrantSpecFromOutput {
	return o
}

func (o ReferenceGrantSpecFromOutput) ToReferenceGrantSpecFromOutputWithContext(ctx context.Context) ReferenceGrantSpecFromOutput {
	return o
}

// Group is the group of the referent.
// When empty, the Kubernetes core API group is inferred.
//
// Support: Core
func (o ReferenceGrantSpecFromOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFrom) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the referent. Although implementations may support
// additional resources, the following types are part of the "Core"
// support level for this field.
//
// When used to permit a SecretObjectReference:
//
// * Gateway
//
// When used to permit a BackendObjectReference:
//
// * GRPCRoute
// * HTTPRoute
// * TCPRoute
// * TLSRoute
// * UDPRoute
func (o ReferenceGrantSpecFromOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFrom) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
//
// Support: Core
func (o ReferenceGrantSpecFromOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFrom) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ReferenceGrantSpecFromArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecFromArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecFrom)(nil)).Elem()
}

func (o ReferenceGrantSpecFromArrayOutput) ToReferenceGrantSpecFromArrayOutput() ReferenceGrantSpecFromArrayOutput {
	return o
}

func (o ReferenceGrantSpecFromArrayOutput) ToReferenceGrantSpecFromArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecFromArrayOutput {
	return o
}

func (o ReferenceGrantSpecFromArrayOutput) Index(i pulumi.IntInput) ReferenceGrantSpecFromOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantSpecFrom {
		return vs[0].([]ReferenceGrantSpecFrom)[vs[1].(int)]
	}).(ReferenceGrantSpecFromOutput)
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromPatch struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field.
	//
	// When used to permit a SecretObjectReference:
	//
	// * Gateway
	//
	// When used to permit a BackendObjectReference:
	//
	// * GRPCRoute
	// * HTTPRoute
	// * TCPRoute
	// * TLSRoute
	// * UDPRoute
	Kind *string `pulumi:"kind"`
	// Namespace is the namespace of the referent.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// ReferenceGrantSpecFromPatchInput is an input type that accepts ReferenceGrantSpecFromPatchArgs and ReferenceGrantSpecFromPatchOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecFromPatchInput` via:
//
//	ReferenceGrantSpecFromPatchArgs{...}
type ReferenceGrantSpecFromPatchInput interface {
	pulumi.Input

	ToReferenceGrantSpecFromPatchOutput() ReferenceGrantSpecFromPatchOutput
	ToReferenceGrantSpecFromPatchOutputWithContext(context.Context) ReferenceGrantSpecFromPatchOutput
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromPatchArgs struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field.
	//
	// When used to permit a SecretObjectReference:
	//
	// * Gateway
	//
	// When used to permit a BackendObjectReference:
	//
	// * GRPCRoute
	// * HTTPRoute
	// * TCPRoute
	// * TLSRoute
	// * UDPRoute
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Namespace is the namespace of the referent.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (ReferenceGrantSpecFromPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecFromPatch)(nil)).Elem()
}

func (i ReferenceGrantSpecFromPatchArgs) ToReferenceGrantSpecFromPatchOutput() ReferenceGrantSpecFromPatchOutput {
	return i.ToReferenceGrantSpecFromPatchOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecFromPatchArgs) ToReferenceGrantSpecFromPatchOutputWithContext(ctx context.Context) ReferenceGrantSpecFromPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecFromPatchOutput)
}

// ReferenceGrantSpecFromPatchArrayInput is an input type that accepts ReferenceGrantSpecFromPatchArray and ReferenceGrantSpecFromPatchArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecFromPatchArrayInput` via:
//
//	ReferenceGrantSpecFromPatchArray{ ReferenceGrantSpecFromPatchArgs{...} }
type ReferenceGrantSpecFromPatchArrayInput interface {
	pulumi.Input

	ToReferenceGrantSpecFromPatchArrayOutput() ReferenceGrantSpecFromPatchArrayOutput
	ToReferenceGrantSpecFromPatchArrayOutputWithContext(context.Context) ReferenceGrantSpecFromPatchArrayOutput
}

type ReferenceGrantSpecFromPatchArray []ReferenceGrantSpecFromPatchInput

func (ReferenceGrantSpecFromPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecFromPatch)(nil)).Elem()
}

func (i ReferenceGrantSpecFromPatchArray) ToReferenceGrantSpecFromPatchArrayOutput() ReferenceGrantSpecFromPatchArrayOutput {
	return i.ToReferenceGrantSpecFromPatchArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecFromPatchArray) ToReferenceGrantSpecFromPatchArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecFromPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecFromPatchArrayOutput)
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromPatchOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecFromPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecFromPatch)(nil)).Elem()
}

func (o ReferenceGrantSpecFromPatchOutput) ToReferenceGrantSpecFromPatchOutput() ReferenceGrantSpecFromPatchOutput {
	return o
}

func (o ReferenceGrantSpecFromPatchOutput) ToReferenceGrantSpecFromPatchOutputWithContext(ctx context.Context) ReferenceGrantSpecFromPatchOutput {
	return o
}

// Group is the group of the referent.
// When empty, the Kubernetes core API group is inferred.
//
// Support: Core
func (o ReferenceGrantSpecFromPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFromPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the referent. Although implementations may support
// additional resources, the following types are part of the "Core"
// support level for this field.
//
// When used to permit a SecretObjectReference:
//
// * Gateway
//
// When used to permit a BackendObjectReference:
//
// * GRPCRoute
// * HTTPRoute
// * TCPRoute
// * TLSRoute
// * UDPRoute
func (o ReferenceGrantSpecFromPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFromPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
//
// Support: Core
func (o ReferenceGrantSpecFromPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFromPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ReferenceGrantSpecFromPatchArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecFromPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecFromPatch)(nil)).Elem()
}

func (o ReferenceGrantSpecFromPatchArrayOutput) ToReferenceGrantSpecFromPatchArrayOutput() ReferenceGrantSpecFromPatchArrayOutput {
	return o
}

func (o ReferenceGrantSpecFromPatchArrayOutput) ToReferenceGrantSpecFromPatchArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecFromPatchArrayOutput {
	return o
}

func (o ReferenceGrantSpecFromPatchArrayOutput) Index(i pulumi.IntInput) ReferenceGrantSpecFromPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantSpecFromPatch {
		return vs[0].([]ReferenceGrantSpecFromPatch)[vs[1].(int)]
	}).(ReferenceGrantSpecFromPatchOutput)
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecPatch struct {
	// From describes the trusted namespaces and kinds that can reference the
	// resources described in "To". Each entry in this list MUST be considered
	// to be an additional place that references can be valid from, or to put
	// this another way, entries MUST be combined using OR.
	//
	// Support: Core
	From []ReferenceGrantSpecFromPatch `pulumi:"from"`
	// To describes the resources that may be referenced by the resources
	// described in "From". Each entry in this list MUST be considered to be an
	// additional place that references can be valid to, or to put this another
	// way, entries MUST be combined using OR.
	//
	// Support: Core
	To []ReferenceGrantSpecToPatch `pulumi:"to"`
}

// ReferenceGrantSpecPatchInput is an input type that accepts ReferenceGrantSpecPatchArgs and ReferenceGrantSpecPatchOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecPatchInput` via:
//
//	ReferenceGrantSpecPatchArgs{...}
type ReferenceGrantSpecPatchInput interface {
	pulumi.Input

	ToReferenceGrantSpecPatchOutput() ReferenceGrantSpecPatchOutput
	ToReferenceGrantSpecPatchOutputWithContext(context.Context) ReferenceGrantSpecPatchOutput
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecPatchArgs struct {
	// From describes the trusted namespaces and kinds that can reference the
	// resources described in "To". Each entry in this list MUST be considered
	// to be an additional place that references can be valid from, or to put
	// this another way, entries MUST be combined using OR.
	//
	// Support: Core
	From ReferenceGrantSpecFromPatchArrayInput `pulumi:"from"`
	// To describes the resources that may be referenced by the resources
	// described in "From". Each entry in this list MUST be considered to be an
	// additional place that references can be valid to, or to put this another
	// way, entries MUST be combined using OR.
	//
	// Support: Core
	To ReferenceGrantSpecToPatchArrayInput `pulumi:"to"`
}

func (ReferenceGrantSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecPatch)(nil)).Elem()
}

func (i ReferenceGrantSpecPatchArgs) ToReferenceGrantSpecPatchOutput() ReferenceGrantSpecPatchOutput {
	return i.ToReferenceGrantSpecPatchOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecPatchArgs) ToReferenceGrantSpecPatchOutputWithContext(ctx context.Context) ReferenceGrantSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecPatchOutput)
}

func (i ReferenceGrantSpecPatchArgs) ToReferenceGrantSpecPatchPtrOutput() ReferenceGrantSpecPatchPtrOutput {
	return i.ToReferenceGrantSpecPatchPtrOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecPatchArgs) ToReferenceGrantSpecPatchPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecPatchOutput).ToReferenceGrantSpecPatchPtrOutputWithContext(ctx)
}

// ReferenceGrantSpecPatchPtrInput is an input type that accepts ReferenceGrantSpecPatchArgs, ReferenceGrantSpecPatchPtr and ReferenceGrantSpecPatchPtrOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecPatchPtrInput` via:
//
//	        ReferenceGrantSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ReferenceGrantSpecPatchPtrInput interface {
	pulumi.Input

	ToReferenceGrantSpecPatchPtrOutput() ReferenceGrantSpecPatchPtrOutput
	ToReferenceGrantSpecPatchPtrOutputWithContext(context.Context) ReferenceGrantSpecPatchPtrOutput
}

type referenceGrantSpecPatchPtrType ReferenceGrantSpecPatchArgs

func ReferenceGrantSpecPatchPtr(v *ReferenceGrantSpecPatchArgs) ReferenceGrantSpecPatchPtrInput {
	return (*referenceGrantSpecPatchPtrType)(v)
}

func (*referenceGrantSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReferenceGrantSpecPatch)(nil)).Elem()
}

func (i *referenceGrantSpecPatchPtrType) ToReferenceGrantSpecPatchPtrOutput() ReferenceGrantSpecPatchPtrOutput {
	return i.ToReferenceGrantSpecPatchPtrOutputWithContext(context.Background())
}

func (i *referenceGrantSpecPatchPtrType) ToReferenceGrantSpecPatchPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecPatchPtrOutput)
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecPatchOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecPatch)(nil)).Elem()
}

func (o ReferenceGrantSpecPatchOutput) ToReferenceGrantSpecPatchOutput() ReferenceGrantSpecPatchOutput {
	return o
}

func (o ReferenceGrantSpecPatchOutput) ToReferenceGrantSpecPatchOutputWithContext(ctx context.Context) ReferenceGrantSpecPatchOutput {
	return o
}

func (o ReferenceGrantSpecPatchOutput) ToReferenceGrantSpecPatchPtrOutput() ReferenceGrantSpecPatchPtrOutput {
	return o.ToReferenceGrantSpecPatchPtrOutputWithContext(context.Background())
}

func (o ReferenceGrantSpecPatchOutput) ToReferenceGrantSpecPatchPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReferenceGrantSpecPatch) *ReferenceGrantSpecPatch {
		return &v
	}).(ReferenceGrantSpecPatchPtrOutput)
}

// From describes the trusted namespaces and kinds that can reference the
// resources described in "To". Each entry in this list MUST be considered
// to be an additional place that references can be valid from, or to put
// this another way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecPatchOutput) From() ReferenceGrantSpecFromPatchArrayOutput {
	return o.ApplyT(func(v ReferenceGrantSpecPatch) []ReferenceGrantSpecFromPatch { return v.From }).(ReferenceGrantSpecFromPatchArrayOutput)
}

// To describes the resources that may be referenced by the resources
// described in "From". Each entry in this list MUST be considered to be an
// additional place that references can be valid to, or to put this another
// way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecPatchOutput) To() ReferenceGrantSpecToPatchArrayOutput {
	return o.ApplyT(func(v ReferenceGrantSpecPatch) []ReferenceGrantSpecToPatch { return v.To }).(ReferenceGrantSpecToPatchArrayOutput)
}

type ReferenceGrantSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReferenceGrantSpecPatch)(nil)).Elem()
}

func (o ReferenceGrantSpecPatchPtrOutput) ToReferenceGrantSpecPatchPtrOutput() ReferenceGrantSpecPatchPtrOutput {
	return o
}

func (o ReferenceGrantSpecPatchPtrOutput) ToReferenceGrantSpecPatchPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPatchPtrOutput {
	return o
}

func (o ReferenceGrantSpecPatchPtrOutput) Elem() ReferenceGrantSpecPatchOutput {
	return o.ApplyT(func(v *ReferenceGrantSpecPatch) ReferenceGrantSpecPatch {
		if v != nil {
			return *v
		}
		var ret ReferenceGrantSpecPatch
		return ret
	}).(ReferenceGrantSpecPatchOutput)
}

// From describes the trusted namespaces and kinds that can reference the
// resources described in "To". Each entry in this list MUST be considered
// to be an additional place that references can be valid from, or to put
// this another way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecPatchPtrOutput) From() ReferenceGrantSpecFromPatchArrayOutput {
	return o.ApplyT(func(v *ReferenceGrantSpecPatch) []ReferenceGrantSpecFromPatch {
		if v == nil {
			return nil
		}
		return v.From
	}).(ReferenceGrantSpecFromPatchArrayOutput)
}

// To describes the resources that may be referenced by the resources
// described in "From". Each entry in this list MUST be considered to be an
// additional place that references can be valid to, or to put this another
// way, entries MUST be combined using OR.
//
// Support: Core
func (o ReferenceGrantSpecPatchPtrOutput) To() ReferenceGrantSpecToPatchArrayOutput {
	return o.ApplyT(func(v *ReferenceGrantSpecPatch) []ReferenceGrantSpecToPatch {
		if v == nil {
			return nil
		}
		return v.To
	}).(ReferenceGrantSpecToPatchArrayOutput)
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the
// references.
type ReferenceGrantSpecTo struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field:
	//
	// * Secret when used to permit a SecretObjectReference
	// * Service when used to permit a BackendObjectReference
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent. When unspecified, this policy
	// refers to all resources of the specified Group and Kind in the local
	// namespace.
	Name *string `pulumi:"name"`
}

// ReferenceGrantSpecToInput is an input type that accepts ReferenceGrantSpecToArgs and ReferenceGrantSpecToOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecToInput` via:
//
//	ReferenceGrantSpecToArgs{...}
type ReferenceGrantSpecToInput interface {
	pulumi.Input

	ToReferenceGrantSpecToOutput() ReferenceGrantSpecToOutput
	ToReferenceGrantSpecToOutputWithContext(context.Context) ReferenceGrantSpecToOutput
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the
// references.
type ReferenceGrantSpecToArgs struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field:
	//
	// * Secret when used to permit a SecretObjectReference
	// * Service when used to permit a BackendObjectReference
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent. When unspecified, this policy
	// refers to all resources of the specified Group and Kind in the local
	// namespace.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ReferenceGrantSpecToArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecTo)(nil)).Elem()
}

func (i ReferenceGrantSpecToArgs) ToReferenceGrantSpecToOutput() ReferenceGrantSpecToOutput {
	return i.ToReferenceGrantSpecToOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecToArgs) ToReferenceGrantSpecToOutputWithContext(ctx context.Context) ReferenceGrantSpecToOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecToOutput)
}

// ReferenceGrantSpecToArrayInput is an input type that accepts ReferenceGrantSpecToArray and ReferenceGrantSpecToArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecToArrayInput` via:
//
//	ReferenceGrantSpecToArray{ ReferenceGrantSpecToArgs{...} }
type ReferenceGrantSpecToArrayInput interface {
	pulumi.Input

	ToReferenceGrantSpecToArrayOutput() ReferenceGrantSpecToArrayOutput
	ToReferenceGrantSpecToArrayOutputWithContext(context.Context) ReferenceGrantSpecToArrayOutput
}

type ReferenceGrantSpecToArray []ReferenceGrantSpecToInput

func (ReferenceGrantSpecToArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecTo)(nil)).Elem()
}

func (i ReferenceGrantSpecToArray) ToReferenceGrantSpecToArrayOutput() ReferenceGrantSpecToArrayOutput {
	return i.ToReferenceGrantSpecToArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecToArray) ToReferenceGrantSpecToArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecToArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecToArrayOutput)
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the
// references.
type ReferenceGrantSpecToOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecToOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecTo)(nil)).Elem()
}

func (o ReferenceGrantSpecToOutput) ToReferenceGrantSpecToOutput() ReferenceGrantSpecToOutput {
	return o
}

func (o ReferenceGrantSpecToOutput) ToReferenceGrantSpecToOutputWithContext(ctx context.Context) ReferenceGrantSpecToOutput {
	return o
}

// Group is the group of the referent.
// When empty, the Kubernetes core API group is inferred.
//
// Support: Core
func (o ReferenceGrantSpecToOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecTo) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the referent. Although implementations may support
// additional resources, the following types are part of the "Core"
// support level for this field:
//
// * Secret when used to permit a SecretObjectReference
// * Service when used to permit a BackendObjectReference
func (o ReferenceGrantSpecToOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecTo) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent. When unspecified, this policy
// refers to all resources of the specified Group and Kind in the local
// namespace.
func (o ReferenceGrantSpecToOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecTo) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ReferenceGrantSpecToArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecToArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecTo)(nil)).Elem()
}

func (o ReferenceGrantSpecToArrayOutput) ToReferenceGrantSpecToArrayOutput() ReferenceGrantSpecToArrayOutput {
	return o
}

func (o ReferenceGrantSpecToArrayOutput) ToReferenceGrantSpecToArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecToArrayOutput {
	return o
}

func (o ReferenceGrantSpecToArrayOutput) Index(i pulumi.IntInput) ReferenceGrantSpecToOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantSpecTo {
		return vs[0].([]ReferenceGrantSpecTo)[vs[1].(int)]
	}).(ReferenceGrantSpecToOutput)
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the
// references.
type ReferenceGrantSpecToPatch struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field:
	//
	// * Secret when used to permit a SecretObjectReference
	// * Service when used to permit a BackendObjectReference
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent. When unspecified, this policy
	// refers to all resources of the specified Group and Kind in the local
	// namespace.
	Name *string `pulumi:"name"`
}

// ReferenceGrantSpecToPatchInput is an input type that accepts ReferenceGrantSpecToPatchArgs and ReferenceGrantSpecToPatchOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecToPatchInput` via:
//
//	ReferenceGrantSpecToPatchArgs{...}
type ReferenceGrantSpecToPatchInput interface {
	pulumi.Input

	ToReferenceGrantSpecToPatchOutput() ReferenceGrantSpecToPatchOutput
	ToReferenceGrantSpecToPatchOutputWithContext(context.Context) ReferenceGrantSpecToPatchOutput
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the
// references.
type ReferenceGrantSpecToPatchArgs struct {
	// Group is the group of the referent.
	// When empty, the Kubernetes core API group is inferred.
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support
	// additional resources, the following types are part of the "Core"
	// support level for this field:
	//
	// * Secret when used to permit a SecretObjectReference
	// * Service when used to permit a BackendObjectReference
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent. When unspecified, this policy
	// refers to all resources of the specified Group and Kind in the local
	// namespace.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ReferenceGrantSpecToPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecToPatch)(nil)).Elem()
}

func (i ReferenceGrantSpecToPatchArgs) ToReferenceGrantSpecToPatchOutput() ReferenceGrantSpecToPatchOutput {
	return i.ToReferenceGrantSpecToPatchOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecToPatchArgs) ToReferenceGrantSpecToPatchOutputWithContext(ctx context.Context) ReferenceGrantSpecToPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecToPatchOutput)
}

// ReferenceGrantSpecToPatchArrayInput is an input type that accepts ReferenceGrantSpecToPatchArray and ReferenceGrantSpecToPatchArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecToPatchArrayInput` via:
//
//	ReferenceGrantSpecToPatchArray{ ReferenceGrantSpecToPatchArgs{...} }
type ReferenceGrantSpecToPatchArrayInput interface {
	pulumi.Input

	ToReferenceGrantSpecToPatchArrayOutput() ReferenceGrantSpecToPatchArrayOutput
	ToReferenceGrantSpecToPatchArrayOutputWithContext(context.Context) ReferenceGrantSpecToPatchArrayOutput
}

type ReferenceGrantSpecToPatchArray []ReferenceGrantSpecToPatchInput

func (ReferenceGrantSpecToPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecToPatch)(nil)).Elem()
}

func (i ReferenceGrantSpecToPatchArray) ToReferenceGrantSpecToPatchArrayOutput() ReferenceGrantSpecToPatchArrayOutput {
	return i.ToReferenceGrantSpecToPatchArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecToPatchArray) ToReferenceGrantSpecToPatchArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecToPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecToPatchArrayOutput)
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the
// references.
type ReferenceGrantSpecToPatchOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecToPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecToPatch)(nil)).Elem()
}

func (o ReferenceGrantSpecToPatchOutput) ToReferenceGrantSpecToPatchOutput() ReferenceGrantSpecToPatchOutput {
	return o
}

func (o ReferenceGrantSpecToPatchOutput) ToReferenceGrantSpecToPatchOutputWithContext(ctx context.Context) ReferenceGrantSpecToPatchOutput {
	return o
}

// Group is the group of the referent.
// When empty, the Kubernetes core API group is inferred.
//
// Support: Core
func (o ReferenceGrantSpecToPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecToPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the referent. Although implementations may support
// additional resources, the following types are part of the "Core"
// support level for this field:
//
// * Secret when used to permit a SecretObjectReference
// * Service when used to permit a BackendObjectReference
func (o ReferenceGrantSpecToPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecToPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent. When unspecified, this policy
// refers to all resources of the specified Group and Kind in the local
// namespace.
func (o ReferenceGrantSpecToPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecToPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ReferenceGrantSpecToPatchArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecToPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecToPatch)(nil)).Elem()
}

func (o ReferenceGrantSpecToPatchArrayOutput) ToReferenceGrantSpecToPatchArrayOutput() ReferenceGrantSpecToPatchArrayOutput {
	return o
}

func (o ReferenceGrantSpecToPatchArrayOutput) ToReferenceGrantSpecToPatchArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecToPatchArrayOutput {
	return o
}

func (o ReferenceGrantSpecToPatchArrayOutput) Index(i pulumi.IntInput) ReferenceGrantSpecToPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantSpecToPatch {
		return vs[0].([]ReferenceGrantSpecToPatch)[vs[1].(int)]
	}).(ReferenceGrantSpecToPatchOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayTypeInput)(nil)).Elem(), GatewayTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayTypeArrayInput)(nil)).Elem(), GatewayTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassTypeInput)(nil)).Elem(), GatewayClassTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassTypeArrayInput)(nil)).Elem(), GatewayClassTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassListTypeInput)(nil)).Elem(), GatewayClassListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassPatchTypeInput)(nil)).Elem(), GatewayClassPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecInput)(nil)).Elem(), GatewayClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPtrInput)(nil)).Elem(), GatewayClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefInput)(nil)).Elem(), GatewayClassSpecParametersRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPtrInput)(nil)).Elem(), GatewayClassSpecParametersRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPatchInput)(nil)).Elem(), GatewayClassSpecParametersRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPatchPtrInput)(nil)).Elem(), GatewayClassSpecParametersRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPatchInput)(nil)).Elem(), GatewayClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPatchPtrInput)(nil)).Elem(), GatewayClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusInput)(nil)).Elem(), GatewayClassStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPtrInput)(nil)).Elem(), GatewayClassStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsInput)(nil)).Elem(), GatewayClassStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsArrayInput)(nil)).Elem(), GatewayClassStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsPatchInput)(nil)).Elem(), GatewayClassStatusConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsPatchArrayInput)(nil)).Elem(), GatewayClassStatusConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPatchInput)(nil)).Elem(), GatewayClassStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPatchPtrInput)(nil)).Elem(), GatewayClassStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayListTypeInput)(nil)).Elem(), GatewayListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayPatchTypeInput)(nil)).Elem(), GatewayPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecInput)(nil)).Elem(), GatewaySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPtrInput)(nil)).Elem(), GatewaySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesInput)(nil)).Elem(), GatewaySpecAddressesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesArrayInput)(nil)).Elem(), GatewaySpecAddressesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesPatchInput)(nil)).Elem(), GatewaySpecAddressesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesPatchArrayInput)(nil)).Elem(), GatewaySpecAddressesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersInput)(nil)).Elem(), GatewaySpecListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersArrayInput)(nil)).Elem(), GatewaySpecListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatchArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatchPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersPatchInput)(nil)).Elem(), GatewaySpecListenersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersPatchArrayInput)(nil)).Elem(), GatewaySpecListenersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsInput)(nil)).Elem(), GatewaySpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPtrInput)(nil)).Elem(), GatewaySpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsArrayInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatchInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatchArrayInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPatchInput)(nil)).Elem(), GatewaySpecListenersTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPatchPtrInput)(nil)).Elem(), GatewaySpecListenersTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPatchInput)(nil)).Elem(), GatewaySpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPatchPtrInput)(nil)).Elem(), GatewaySpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusInput)(nil)).Elem(), GatewayStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPtrInput)(nil)).Elem(), GatewayStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesInput)(nil)).Elem(), GatewayStatusAddressesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesArrayInput)(nil)).Elem(), GatewayStatusAddressesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesPatchInput)(nil)).Elem(), GatewayStatusAddressesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesPatchArrayInput)(nil)).Elem(), GatewayStatusAddressesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsInput)(nil)).Elem(), GatewayStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsArrayInput)(nil)).Elem(), GatewayStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsPatchInput)(nil)).Elem(), GatewayStatusConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsPatchArrayInput)(nil)).Elem(), GatewayStatusConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersInput)(nil)).Elem(), GatewayStatusListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersArrayInput)(nil)).Elem(), GatewayStatusListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsInput)(nil)).Elem(), GatewayStatusListenersConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsArrayInput)(nil)).Elem(), GatewayStatusListenersConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsPatchInput)(nil)).Elem(), GatewayStatusListenersConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsPatchArrayInput)(nil)).Elem(), GatewayStatusListenersConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersPatchInput)(nil)).Elem(), GatewayStatusListenersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersPatchArrayInput)(nil)).Elem(), GatewayStatusListenersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsArrayInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatchInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatchArrayInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPatchInput)(nil)).Elem(), GatewayStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPatchPtrInput)(nil)).Elem(), GatewayStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteTypeInput)(nil)).Elem(), HTTPRouteTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteTypeArrayInput)(nil)).Elem(), HTTPRouteTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteListTypeInput)(nil)).Elem(), HTTPRouteListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRoutePatchTypeInput)(nil)).Elem(), HTTPRoutePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecInput)(nil)).Elem(), HTTPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPtrInput)(nil)).Elem(), HTTPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsInput)(nil)).Elem(), HTTPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsArrayInput)(nil)).Elem(), HTTPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsPatchInput)(nil)).Elem(), HTTPRouteSpecParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsPatchArrayInput)(nil)).Elem(), HTTPRouteSpecParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPatchInput)(nil)).Elem(), HTTPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPatchPtrInput)(nil)).Elem(), HTTPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesInput)(nil)).Elem(), HTTPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesArrayInput)(nil)).Elem(), HTTPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewriteInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesPatchInput)(nil)).Elem(), HTTPRouteSpecRulesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusInput)(nil)).Elem(), HTTPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPtrInput)(nil)).Elem(), HTTPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsInput)(nil)).Elem(), HTTPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsArrayInput)(nil)).Elem(), HTTPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatchInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatchArrayInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefPtrInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatchInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatchPtrInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsPatchInput)(nil)).Elem(), HTTPRouteStatusParentsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsPatchArrayInput)(nil)).Elem(), HTTPRouteStatusParentsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPatchInput)(nil)).Elem(), HTTPRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPatchPtrInput)(nil)).Elem(), HTTPRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantTypeInput)(nil)).Elem(), ReferenceGrantTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantTypeArrayInput)(nil)).Elem(), ReferenceGrantTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantListTypeInput)(nil)).Elem(), ReferenceGrantListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantPatchTypeInput)(nil)).Elem(), ReferenceGrantPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecInput)(nil)).Elem(), ReferenceGrantSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecPtrInput)(nil)).Elem(), ReferenceGrantSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecFromInput)(nil)).Elem(), ReferenceGrantSpecFromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecFromArrayInput)(nil)).Elem(), ReferenceGrantSpecFromArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecFromPatchInput)(nil)).Elem(), ReferenceGrantSpecFromPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecFromPatchArrayInput)(nil)).Elem(), ReferenceGrantSpecFromPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecPatchInput)(nil)).Elem(), ReferenceGrantSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecPatchPtrInput)(nil)).Elem(), ReferenceGrantSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecToInput)(nil)).Elem(), ReferenceGrantSpecToArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecToArrayInput)(nil)).Elem(), ReferenceGrantSpecToArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecToPatchInput)(nil)).Elem(), ReferenceGrantSpecToPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecToPatchArrayInput)(nil)).Elem(), ReferenceGrantSpecToPatchArray{})
	pulumi.RegisterOutputType(GatewayTypeOutput{})
	pulumi.RegisterOutputType(GatewayTypeArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassTypeOutput{})
	pulumi.RegisterOutputType(GatewayClassTypeArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassListTypeOutput{})
	pulumi.RegisterOutputType(GatewayClassPatchTypeOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayListTypeOutput{})
	pulumi.RegisterOutputType(GatewayPatchTypeOutput{})
	pulumi.RegisterOutputType(GatewaySpecOutput{})
	pulumi.RegisterOutputType(GatewaySpecPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayStatusOutput{})
	pulumi.RegisterOutputType(GatewayStatusPtrOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteTypeOutput{})
	pulumi.RegisterOutputType(HTTPRouteTypeArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteListTypeOutput{})
	pulumi.RegisterOutputType(HTTPRoutePatchTypeOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewriteOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(ReferenceGrantTypeOutput{})
	pulumi.RegisterOutputType(ReferenceGrantTypeArrayOutput{})
	pulumi.RegisterOutputType(ReferenceGrantListTypeOutput{})
	pulumi.RegisterOutputType(ReferenceGrantPatchTypeOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecPtrOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecFromOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecFromArrayOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecFromPatchOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecFromPatchArrayOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecPatchOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecToOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecToArrayOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecToPatchOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecToPatchArrayOutput{})
}
