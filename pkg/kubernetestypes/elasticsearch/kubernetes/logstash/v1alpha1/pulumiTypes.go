// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Logstash is the Schema for the logstashes API
type LogstashType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *LogstashSpec      `pulumi:"spec"`
	Status   *LogstashStatus    `pulumi:"status"`
}

// LogstashTypeInput is an input type that accepts LogstashTypeArgs and LogstashTypeOutput values.
// You can construct a concrete instance of `LogstashTypeInput` via:
//
//	LogstashTypeArgs{...}
type LogstashTypeInput interface {
	pulumi.Input

	ToLogstashTypeOutput() LogstashTypeOutput
	ToLogstashTypeOutputWithContext(context.Context) LogstashTypeOutput
}

// Logstash is the Schema for the logstashes API
type LogstashTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     LogstashSpecPtrInput      `pulumi:"spec"`
	Status   LogstashStatusPtrInput    `pulumi:"status"`
}

func (LogstashTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashType)(nil)).Elem()
}

func (i LogstashTypeArgs) ToLogstashTypeOutput() LogstashTypeOutput {
	return i.ToLogstashTypeOutputWithContext(context.Background())
}

func (i LogstashTypeArgs) ToLogstashTypeOutputWithContext(ctx context.Context) LogstashTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashTypeOutput)
}

// LogstashTypeArrayInput is an input type that accepts LogstashTypeArray and LogstashTypeArrayOutput values.
// You can construct a concrete instance of `LogstashTypeArrayInput` via:
//
//	LogstashTypeArray{ LogstashTypeArgs{...} }
type LogstashTypeArrayInput interface {
	pulumi.Input

	ToLogstashTypeArrayOutput() LogstashTypeArrayOutput
	ToLogstashTypeArrayOutputWithContext(context.Context) LogstashTypeArrayOutput
}

type LogstashTypeArray []LogstashTypeInput

func (LogstashTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashType)(nil)).Elem()
}

func (i LogstashTypeArray) ToLogstashTypeArrayOutput() LogstashTypeArrayOutput {
	return i.ToLogstashTypeArrayOutputWithContext(context.Background())
}

func (i LogstashTypeArray) ToLogstashTypeArrayOutputWithContext(ctx context.Context) LogstashTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashTypeArrayOutput)
}

// Logstash is the Schema for the logstashes API
type LogstashTypeOutput struct{ *pulumi.OutputState }

func (LogstashTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashType)(nil)).Elem()
}

func (o LogstashTypeOutput) ToLogstashTypeOutput() LogstashTypeOutput {
	return o
}

func (o LogstashTypeOutput) ToLogstashTypeOutputWithContext(ctx context.Context) LogstashTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o LogstashTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o LogstashTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v LogstashType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o LogstashTypeOutput) Spec() LogstashSpecPtrOutput {
	return o.ApplyT(func(v LogstashType) *LogstashSpec { return v.Spec }).(LogstashSpecPtrOutput)
}

func (o LogstashTypeOutput) Status() LogstashStatusPtrOutput {
	return o.ApplyT(func(v LogstashType) *LogstashStatus { return v.Status }).(LogstashStatusPtrOutput)
}

type LogstashTypeArrayOutput struct{ *pulumi.OutputState }

func (LogstashTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashType)(nil)).Elem()
}

func (o LogstashTypeArrayOutput) ToLogstashTypeArrayOutput() LogstashTypeArrayOutput {
	return o
}

func (o LogstashTypeArrayOutput) ToLogstashTypeArrayOutputWithContext(ctx context.Context) LogstashTypeArrayOutput {
	return o
}

func (o LogstashTypeArrayOutput) Index(i pulumi.IntInput) LogstashTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashType {
		return vs[0].([]LogstashType)[vs[1].(int)]
	}).(LogstashTypeOutput)
}

// LogstashList is a list of Logstash
type LogstashListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of logstashes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []LogstashType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// LogstashListTypeInput is an input type that accepts LogstashListTypeArgs and LogstashListTypeOutput values.
// You can construct a concrete instance of `LogstashListTypeInput` via:
//
//	LogstashListTypeArgs{...}
type LogstashListTypeInput interface {
	pulumi.Input

	ToLogstashListTypeOutput() LogstashListTypeOutput
	ToLogstashListTypeOutputWithContext(context.Context) LogstashListTypeOutput
}

// LogstashList is a list of Logstash
type LogstashListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of logstashes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items LogstashTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (LogstashListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashListType)(nil)).Elem()
}

func (i LogstashListTypeArgs) ToLogstashListTypeOutput() LogstashListTypeOutput {
	return i.ToLogstashListTypeOutputWithContext(context.Background())
}

func (i LogstashListTypeArgs) ToLogstashListTypeOutputWithContext(ctx context.Context) LogstashListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashListTypeOutput)
}

// LogstashList is a list of Logstash
type LogstashListTypeOutput struct{ *pulumi.OutputState }

func (LogstashListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashListType)(nil)).Elem()
}

func (o LogstashListTypeOutput) ToLogstashListTypeOutput() LogstashListTypeOutput {
	return o
}

func (o LogstashListTypeOutput) ToLogstashListTypeOutputWithContext(ctx context.Context) LogstashListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o LogstashListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of logstashes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o LogstashListTypeOutput) Items() LogstashTypeArrayOutput {
	return o.ApplyT(func(v LogstashListType) []LogstashType { return v.Items }).(LogstashTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v LogstashListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Logstash is the Schema for the logstashes API
type LogstashPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *LogstashSpecPatch      `pulumi:"spec"`
	Status   *LogstashStatusPatch    `pulumi:"status"`
}

// LogstashPatchTypeInput is an input type that accepts LogstashPatchTypeArgs and LogstashPatchTypeOutput values.
// You can construct a concrete instance of `LogstashPatchTypeInput` via:
//
//	LogstashPatchTypeArgs{...}
type LogstashPatchTypeInput interface {
	pulumi.Input

	ToLogstashPatchTypeOutput() LogstashPatchTypeOutput
	ToLogstashPatchTypeOutputWithContext(context.Context) LogstashPatchTypeOutput
}

// Logstash is the Schema for the logstashes API
type LogstashPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     LogstashSpecPatchPtrInput      `pulumi:"spec"`
	Status   LogstashStatusPatchPtrInput    `pulumi:"status"`
}

func (LogstashPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashPatchType)(nil)).Elem()
}

func (i LogstashPatchTypeArgs) ToLogstashPatchTypeOutput() LogstashPatchTypeOutput {
	return i.ToLogstashPatchTypeOutputWithContext(context.Background())
}

func (i LogstashPatchTypeArgs) ToLogstashPatchTypeOutputWithContext(ctx context.Context) LogstashPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashPatchTypeOutput)
}

// Logstash is the Schema for the logstashes API
type LogstashPatchTypeOutput struct{ *pulumi.OutputState }

func (LogstashPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashPatchType)(nil)).Elem()
}

func (o LogstashPatchTypeOutput) ToLogstashPatchTypeOutput() LogstashPatchTypeOutput {
	return o
}

func (o LogstashPatchTypeOutput) ToLogstashPatchTypeOutputWithContext(ctx context.Context) LogstashPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o LogstashPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o LogstashPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v LogstashPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o LogstashPatchTypeOutput) Spec() LogstashSpecPatchPtrOutput {
	return o.ApplyT(func(v LogstashPatchType) *LogstashSpecPatch { return v.Spec }).(LogstashSpecPatchPtrOutput)
}

func (o LogstashPatchTypeOutput) Status() LogstashStatusPatchPtrOutput {
	return o.ApplyT(func(v LogstashPatchType) *LogstashStatusPatch { return v.Status }).(LogstashStatusPatchPtrOutput)
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpec struct {
	// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config    map[string]interface{} `pulumi:"config"`
	ConfigRef *LogstashSpecConfigRef `pulumi:"configRef"`
	Count     *int                   `pulumi:"count"`
	// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
	ElasticsearchRefs []LogstashSpecElasticsearchRefs `pulumi:"elasticsearchRefs"`
	// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
	Image      *string                 `pulumi:"image"`
	Monitoring *LogstashSpecMonitoring `pulumi:"monitoring"`
	// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
	Pipelines    map[string]interface{}    `pulumi:"pipelines"`
	PipelinesRef *LogstashSpecPipelinesRef `pulumi:"pipelinesRef"`
	// PodTemplate provides customisation options for the Logstash pods.
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
	// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings []LogstashSpecSecureSettings `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
	// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
	// be opened up for other services: Beats, TCP, UDP, etc, inputs.
	Services       []LogstashSpecServices      `pulumi:"services"`
	UpdateStrategy *LogstashSpecUpdateStrategy `pulumi:"updateStrategy"`
	// Version of the Logstash.
	Version *string `pulumi:"version"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates []LogstashSpecVolumeClaimTemplates `pulumi:"volumeClaimTemplates"`
}

// LogstashSpecInput is an input type that accepts LogstashSpecArgs and LogstashSpecOutput values.
// You can construct a concrete instance of `LogstashSpecInput` via:
//
//	LogstashSpecArgs{...}
type LogstashSpecInput interface {
	pulumi.Input

	ToLogstashSpecOutput() LogstashSpecOutput
	ToLogstashSpecOutputWithContext(context.Context) LogstashSpecOutput
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecArgs struct {
	// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config    pulumi.MapInput               `pulumi:"config"`
	ConfigRef LogstashSpecConfigRefPtrInput `pulumi:"configRef"`
	Count     pulumi.IntPtrInput            `pulumi:"count"`
	// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
	ElasticsearchRefs LogstashSpecElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
	// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
	Image      pulumi.StringPtrInput          `pulumi:"image"`
	Monitoring LogstashSpecMonitoringPtrInput `pulumi:"monitoring"`
	// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
	Pipelines    pulumi.MapInput                  `pulumi:"pipelines"`
	PipelinesRef LogstashSpecPipelinesRefPtrInput `pulumi:"pipelinesRef"`
	// PodTemplate provides customisation options for the Logstash pods.
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
	// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings LogstashSpecSecureSettingsArrayInput `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
	// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
	// be opened up for other services: Beats, TCP, UDP, etc, inputs.
	Services       LogstashSpecServicesArrayInput     `pulumi:"services"`
	UpdateStrategy LogstashSpecUpdateStrategyPtrInput `pulumi:"updateStrategy"`
	// Version of the Logstash.
	Version pulumi.StringPtrInput `pulumi:"version"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates LogstashSpecVolumeClaimTemplatesArrayInput `pulumi:"volumeClaimTemplates"`
}

func (LogstashSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpec)(nil)).Elem()
}

func (i LogstashSpecArgs) ToLogstashSpecOutput() LogstashSpecOutput {
	return i.ToLogstashSpecOutputWithContext(context.Background())
}

func (i LogstashSpecArgs) ToLogstashSpecOutputWithContext(ctx context.Context) LogstashSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecOutput)
}

func (i LogstashSpecArgs) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return i.ToLogstashSpecPtrOutputWithContext(context.Background())
}

func (i LogstashSpecArgs) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecOutput).ToLogstashSpecPtrOutputWithContext(ctx)
}

// LogstashSpecPtrInput is an input type that accepts LogstashSpecArgs, LogstashSpecPtr and LogstashSpecPtrOutput values.
// You can construct a concrete instance of `LogstashSpecPtrInput` via:
//
//	        LogstashSpecArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecPtrInput interface {
	pulumi.Input

	ToLogstashSpecPtrOutput() LogstashSpecPtrOutput
	ToLogstashSpecPtrOutputWithContext(context.Context) LogstashSpecPtrOutput
}

type logstashSpecPtrType LogstashSpecArgs

func LogstashSpecPtr(v *LogstashSpecArgs) LogstashSpecPtrInput {
	return (*logstashSpecPtrType)(v)
}

func (*logstashSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpec)(nil)).Elem()
}

func (i *logstashSpecPtrType) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return i.ToLogstashSpecPtrOutputWithContext(context.Background())
}

func (i *logstashSpecPtrType) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPtrOutput)
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecOutput struct{ *pulumi.OutputState }

func (LogstashSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpec)(nil)).Elem()
}

func (o LogstashSpecOutput) ToLogstashSpecOutput() LogstashSpecOutput {
	return o
}

func (o LogstashSpecOutput) ToLogstashSpecOutputWithContext(ctx context.Context) LogstashSpecOutput {
	return o
}

func (o LogstashSpecOutput) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return o.ToLogstashSpecPtrOutputWithContext(context.Background())
}

func (o LogstashSpecOutput) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpec) *LogstashSpec {
		return &v
	}).(LogstashSpecPtrOutput)
}

// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o LogstashSpecOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpec) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

func (o LogstashSpecOutput) ConfigRef() LogstashSpecConfigRefPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecConfigRef { return v.ConfigRef }).(LogstashSpecConfigRefPtrOutput)
}

func (o LogstashSpecOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
func (o LogstashSpecOutput) ElasticsearchRefs() LogstashSpecElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecElasticsearchRefs { return v.ElasticsearchRefs }).(LogstashSpecElasticsearchRefsArrayOutput)
}

// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
func (o LogstashSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecOutput) Monitoring() LogstashSpecMonitoringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecMonitoring { return v.Monitoring }).(LogstashSpecMonitoringPtrOutput)
}

// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
func (o LogstashSpecOutput) Pipelines() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpec) map[string]interface{} { return v.Pipelines }).(pulumi.MapOutput)
}

func (o LogstashSpecOutput) PipelinesRef() LogstashSpecPipelinesRefPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecPipelinesRef { return v.PipelinesRef }).(LogstashSpecPipelinesRefPtrOutput)
}

// PodTemplate provides customisation options for the Logstash pods.
func (o LogstashSpecOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpec) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
func (o LogstashSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o LogstashSpecOutput) SecureSettings() LogstashSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecSecureSettings { return v.SecureSettings }).(LogstashSpecSecureSettingsArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o LogstashSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
// be opened up for other services: Beats, TCP, UDP, etc, inputs.
func (o LogstashSpecOutput) Services() LogstashSpecServicesArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecServices { return v.Services }).(LogstashSpecServicesArrayOutput)
}

func (o LogstashSpecOutput) UpdateStrategy() LogstashSpecUpdateStrategyPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecUpdateStrategy { return v.UpdateStrategy }).(LogstashSpecUpdateStrategyPtrOutput)
}

// Version of the Logstash.
func (o LogstashSpecOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *string { return v.Version }).(pulumi.StringPtrOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o LogstashSpecOutput) VolumeClaimTemplates() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecVolumeClaimTemplates { return v.VolumeClaimTemplates }).(LogstashSpecVolumeClaimTemplatesArrayOutput)
}

type LogstashSpecPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpec)(nil)).Elem()
}

func (o LogstashSpecPtrOutput) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return o
}

func (o LogstashSpecPtrOutput) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return o
}

func (o LogstashSpecPtrOutput) Elem() LogstashSpecOutput {
	return o.ApplyT(func(v *LogstashSpec) LogstashSpec {
		if v != nil {
			return *v
		}
		var ret LogstashSpec
		return ret
	}).(LogstashSpecOutput)
}

// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o LogstashSpecPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

func (o LogstashSpecPtrOutput) ConfigRef() LogstashSpecConfigRefPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecConfigRef {
		if v == nil {
			return nil
		}
		return v.ConfigRef
	}).(LogstashSpecConfigRefPtrOutput)
}

func (o LogstashSpecPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
func (o LogstashSpecPtrOutput) ElasticsearchRefs() LogstashSpecElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecElasticsearchRefsArrayOutput)
}

// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
func (o LogstashSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecPtrOutput) Monitoring() LogstashSpecMonitoringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecMonitoring {
		if v == nil {
			return nil
		}
		return v.Monitoring
	}).(LogstashSpecMonitoringPtrOutput)
}

// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
func (o LogstashSpecPtrOutput) Pipelines() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Pipelines
	}).(pulumi.MapOutput)
}

func (o LogstashSpecPtrOutput) PipelinesRef() LogstashSpecPipelinesRefPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecPipelinesRef {
		if v == nil {
			return nil
		}
		return v.PipelinesRef
	}).(LogstashSpecPipelinesRefPtrOutput)
}

// PodTemplate provides customisation options for the Logstash pods.
func (o LogstashSpecPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
func (o LogstashSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o LogstashSpecPtrOutput) SecureSettings() LogstashSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecSecureSettings {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(LogstashSpecSecureSettingsArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o LogstashSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
// be opened up for other services: Beats, TCP, UDP, etc, inputs.
func (o LogstashSpecPtrOutput) Services() LogstashSpecServicesArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecServices {
		if v == nil {
			return nil
		}
		return v.Services
	}).(LogstashSpecServicesArrayOutput)
}

func (o LogstashSpecPtrOutput) UpdateStrategy() LogstashSpecUpdateStrategyPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecUpdateStrategy {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(LogstashSpecUpdateStrategyPtrOutput)
}

// Version of the Logstash.
func (o LogstashSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o LogstashSpecPtrOutput) VolumeClaimTemplates() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecVolumeClaimTemplates {
		if v == nil {
			return nil
		}
		return v.VolumeClaimTemplates
	}).(LogstashSpecVolumeClaimTemplatesArrayOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRef struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecConfigRefInput is an input type that accepts LogstashSpecConfigRefArgs and LogstashSpecConfigRefOutput values.
// You can construct a concrete instance of `LogstashSpecConfigRefInput` via:
//
//	LogstashSpecConfigRefArgs{...}
type LogstashSpecConfigRefInput interface {
	pulumi.Input

	ToLogstashSpecConfigRefOutput() LogstashSpecConfigRefOutput
	ToLogstashSpecConfigRefOutputWithContext(context.Context) LogstashSpecConfigRefOutput
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecConfigRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecConfigRef)(nil)).Elem()
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefOutput() LogstashSpecConfigRefOutput {
	return i.ToLogstashSpecConfigRefOutputWithContext(context.Background())
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefOutputWithContext(ctx context.Context) LogstashSpecConfigRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefOutput)
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return i.ToLogstashSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefOutput).ToLogstashSpecConfigRefPtrOutputWithContext(ctx)
}

// LogstashSpecConfigRefPtrInput is an input type that accepts LogstashSpecConfigRefArgs, LogstashSpecConfigRefPtr and LogstashSpecConfigRefPtrOutput values.
// You can construct a concrete instance of `LogstashSpecConfigRefPtrInput` via:
//
//	        LogstashSpecConfigRefArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecConfigRefPtrInput interface {
	pulumi.Input

	ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput
	ToLogstashSpecConfigRefPtrOutputWithContext(context.Context) LogstashSpecConfigRefPtrOutput
}

type logstashSpecConfigRefPtrType LogstashSpecConfigRefArgs

func LogstashSpecConfigRefPtr(v *LogstashSpecConfigRefArgs) LogstashSpecConfigRefPtrInput {
	return (*logstashSpecConfigRefPtrType)(v)
}

func (*logstashSpecConfigRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecConfigRef)(nil)).Elem()
}

func (i *logstashSpecConfigRefPtrType) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return i.ToLogstashSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i *logstashSpecConfigRefPtrType) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefOutput struct{ *pulumi.OutputState }

func (LogstashSpecConfigRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecConfigRef)(nil)).Elem()
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefOutput() LogstashSpecConfigRefOutput {
	return o
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefOutputWithContext(ctx context.Context) LogstashSpecConfigRefOutput {
	return o
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return o.ToLogstashSpecConfigRefPtrOutputWithContext(context.Background())
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecConfigRef) *LogstashSpecConfigRef {
		return &v
	}).(LogstashSpecConfigRefPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecConfigRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecConfigRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecConfigRefPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecConfigRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecConfigRef)(nil)).Elem()
}

func (o LogstashSpecConfigRefPtrOutput) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return o
}

func (o LogstashSpecConfigRefPtrOutput) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return o
}

func (o LogstashSpecConfigRefPtrOutput) Elem() LogstashSpecConfigRefOutput {
	return o.ApplyT(func(v *LogstashSpecConfigRef) LogstashSpecConfigRef {
		if v != nil {
			return *v
		}
		var ret LogstashSpecConfigRef
		return ret
	}).(LogstashSpecConfigRefOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecConfigRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecConfigRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefPatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecConfigRefPatchInput is an input type that accepts LogstashSpecConfigRefPatchArgs and LogstashSpecConfigRefPatchOutput values.
// You can construct a concrete instance of `LogstashSpecConfigRefPatchInput` via:
//
//	LogstashSpecConfigRefPatchArgs{...}
type LogstashSpecConfigRefPatchInput interface {
	pulumi.Input

	ToLogstashSpecConfigRefPatchOutput() LogstashSpecConfigRefPatchOutput
	ToLogstashSpecConfigRefPatchOutputWithContext(context.Context) LogstashSpecConfigRefPatchOutput
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefPatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecConfigRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecConfigRefPatch)(nil)).Elem()
}

func (i LogstashSpecConfigRefPatchArgs) ToLogstashSpecConfigRefPatchOutput() LogstashSpecConfigRefPatchOutput {
	return i.ToLogstashSpecConfigRefPatchOutputWithContext(context.Background())
}

func (i LogstashSpecConfigRefPatchArgs) ToLogstashSpecConfigRefPatchOutputWithContext(ctx context.Context) LogstashSpecConfigRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefPatchOutput)
}

func (i LogstashSpecConfigRefPatchArgs) ToLogstashSpecConfigRefPatchPtrOutput() LogstashSpecConfigRefPatchPtrOutput {
	return i.ToLogstashSpecConfigRefPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecConfigRefPatchArgs) ToLogstashSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefPatchOutput).ToLogstashSpecConfigRefPatchPtrOutputWithContext(ctx)
}

// LogstashSpecConfigRefPatchPtrInput is an input type that accepts LogstashSpecConfigRefPatchArgs, LogstashSpecConfigRefPatchPtr and LogstashSpecConfigRefPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecConfigRefPatchPtrInput` via:
//
//	        LogstashSpecConfigRefPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecConfigRefPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecConfigRefPatchPtrOutput() LogstashSpecConfigRefPatchPtrOutput
	ToLogstashSpecConfigRefPatchPtrOutputWithContext(context.Context) LogstashSpecConfigRefPatchPtrOutput
}

type logstashSpecConfigRefPatchPtrType LogstashSpecConfigRefPatchArgs

func LogstashSpecConfigRefPatchPtr(v *LogstashSpecConfigRefPatchArgs) LogstashSpecConfigRefPatchPtrInput {
	return (*logstashSpecConfigRefPatchPtrType)(v)
}

func (*logstashSpecConfigRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecConfigRefPatch)(nil)).Elem()
}

func (i *logstashSpecConfigRefPatchPtrType) ToLogstashSpecConfigRefPatchPtrOutput() LogstashSpecConfigRefPatchPtrOutput {
	return i.ToLogstashSpecConfigRefPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecConfigRefPatchPtrType) ToLogstashSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefPatchPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecConfigRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecConfigRefPatch)(nil)).Elem()
}

func (o LogstashSpecConfigRefPatchOutput) ToLogstashSpecConfigRefPatchOutput() LogstashSpecConfigRefPatchOutput {
	return o
}

func (o LogstashSpecConfigRefPatchOutput) ToLogstashSpecConfigRefPatchOutputWithContext(ctx context.Context) LogstashSpecConfigRefPatchOutput {
	return o
}

func (o LogstashSpecConfigRefPatchOutput) ToLogstashSpecConfigRefPatchPtrOutput() LogstashSpecConfigRefPatchPtrOutput {
	return o.ToLogstashSpecConfigRefPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecConfigRefPatchOutput) ToLogstashSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecConfigRefPatch) *LogstashSpecConfigRefPatch {
		return &v
	}).(LogstashSpecConfigRefPatchPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecConfigRefPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecConfigRefPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecConfigRefPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecConfigRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecConfigRefPatch)(nil)).Elem()
}

func (o LogstashSpecConfigRefPatchPtrOutput) ToLogstashSpecConfigRefPatchPtrOutput() LogstashSpecConfigRefPatchPtrOutput {
	return o
}

func (o LogstashSpecConfigRefPatchPtrOutput) ToLogstashSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPatchPtrOutput {
	return o
}

func (o LogstashSpecConfigRefPatchPtrOutput) Elem() LogstashSpecConfigRefPatchOutput {
	return o.ApplyT(func(v *LogstashSpecConfigRefPatch) LogstashSpecConfigRefPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecConfigRefPatch
		return ret
	}).(LogstashSpecConfigRefPatchOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecConfigRefPatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecConfigRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefs struct {
	// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
	// configuration files, and will be used to identify "named clusters" in Logstash
	ClusterName *string `pulumi:"clusterName"`
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecElasticsearchRefsInput is an input type that accepts LogstashSpecElasticsearchRefsArgs and LogstashSpecElasticsearchRefsOutput values.
// You can construct a concrete instance of `LogstashSpecElasticsearchRefsInput` via:
//
//	LogstashSpecElasticsearchRefsArgs{...}
type LogstashSpecElasticsearchRefsInput interface {
	pulumi.Input

	ToLogstashSpecElasticsearchRefsOutput() LogstashSpecElasticsearchRefsOutput
	ToLogstashSpecElasticsearchRefsOutputWithContext(context.Context) LogstashSpecElasticsearchRefsOutput
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsArgs struct {
	// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
	// configuration files, and will be used to identify "named clusters" in Logstash
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecElasticsearchRefsArgs) ToLogstashSpecElasticsearchRefsOutput() LogstashSpecElasticsearchRefsOutput {
	return i.ToLogstashSpecElasticsearchRefsOutputWithContext(context.Background())
}

func (i LogstashSpecElasticsearchRefsArgs) ToLogstashSpecElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecElasticsearchRefsOutput)
}

// LogstashSpecElasticsearchRefsArrayInput is an input type that accepts LogstashSpecElasticsearchRefsArray and LogstashSpecElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecElasticsearchRefsArrayInput` via:
//
//	LogstashSpecElasticsearchRefsArray{ LogstashSpecElasticsearchRefsArgs{...} }
type LogstashSpecElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToLogstashSpecElasticsearchRefsArrayOutput() LogstashSpecElasticsearchRefsArrayOutput
	ToLogstashSpecElasticsearchRefsArrayOutputWithContext(context.Context) LogstashSpecElasticsearchRefsArrayOutput
}

type LogstashSpecElasticsearchRefsArray []LogstashSpecElasticsearchRefsInput

func (LogstashSpecElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecElasticsearchRefsArray) ToLogstashSpecElasticsearchRefsArrayOutput() LogstashSpecElasticsearchRefsArrayOutput {
	return i.ToLogstashSpecElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecElasticsearchRefsArray) ToLogstashSpecElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecElasticsearchRefsArrayOutput)
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (LogstashSpecElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecElasticsearchRefsOutput) ToLogstashSpecElasticsearchRefsOutput() LogstashSpecElasticsearchRefsOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsOutput) ToLogstashSpecElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsOutput {
	return o
}

// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
// configuration files, and will be used to identify "named clusters" in Logstash
func (o LogstashSpecElasticsearchRefsOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecElasticsearchRefsArrayOutput) ToLogstashSpecElasticsearchRefsArrayOutput() LogstashSpecElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsArrayOutput) ToLogstashSpecElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) LogstashSpecElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecElasticsearchRefs {
		return vs[0].([]LogstashSpecElasticsearchRefs)[vs[1].(int)]
	}).(LogstashSpecElasticsearchRefsOutput)
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsPatch struct {
	// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
	// configuration files, and will be used to identify "named clusters" in Logstash
	ClusterName *string `pulumi:"clusterName"`
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecElasticsearchRefsPatchInput is an input type that accepts LogstashSpecElasticsearchRefsPatchArgs and LogstashSpecElasticsearchRefsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecElasticsearchRefsPatchInput` via:
//
//	LogstashSpecElasticsearchRefsPatchArgs{...}
type LogstashSpecElasticsearchRefsPatchInput interface {
	pulumi.Input

	ToLogstashSpecElasticsearchRefsPatchOutput() LogstashSpecElasticsearchRefsPatchOutput
	ToLogstashSpecElasticsearchRefsPatchOutputWithContext(context.Context) LogstashSpecElasticsearchRefsPatchOutput
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsPatchArgs struct {
	// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
	// configuration files, and will be used to identify "named clusters" in Logstash
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecElasticsearchRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecElasticsearchRefsPatch)(nil)).Elem()
}

func (i LogstashSpecElasticsearchRefsPatchArgs) ToLogstashSpecElasticsearchRefsPatchOutput() LogstashSpecElasticsearchRefsPatchOutput {
	return i.ToLogstashSpecElasticsearchRefsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecElasticsearchRefsPatchArgs) ToLogstashSpecElasticsearchRefsPatchOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecElasticsearchRefsPatchOutput)
}

// LogstashSpecElasticsearchRefsPatchArrayInput is an input type that accepts LogstashSpecElasticsearchRefsPatchArray and LogstashSpecElasticsearchRefsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecElasticsearchRefsPatchArrayInput` via:
//
//	LogstashSpecElasticsearchRefsPatchArray{ LogstashSpecElasticsearchRefsPatchArgs{...} }
type LogstashSpecElasticsearchRefsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecElasticsearchRefsPatchArrayOutput() LogstashSpecElasticsearchRefsPatchArrayOutput
	ToLogstashSpecElasticsearchRefsPatchArrayOutputWithContext(context.Context) LogstashSpecElasticsearchRefsPatchArrayOutput
}

type LogstashSpecElasticsearchRefsPatchArray []LogstashSpecElasticsearchRefsPatchInput

func (LogstashSpecElasticsearchRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecElasticsearchRefsPatch)(nil)).Elem()
}

func (i LogstashSpecElasticsearchRefsPatchArray) ToLogstashSpecElasticsearchRefsPatchArrayOutput() LogstashSpecElasticsearchRefsPatchArrayOutput {
	return i.ToLogstashSpecElasticsearchRefsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecElasticsearchRefsPatchArray) ToLogstashSpecElasticsearchRefsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecElasticsearchRefsPatchArrayOutput)
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecElasticsearchRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecElasticsearchRefsPatch)(nil)).Elem()
}

func (o LogstashSpecElasticsearchRefsPatchOutput) ToLogstashSpecElasticsearchRefsPatchOutput() LogstashSpecElasticsearchRefsPatchOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsPatchOutput) ToLogstashSpecElasticsearchRefsPatchOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsPatchOutput {
	return o
}

// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
// configuration files, and will be used to identify "named clusters" in Logstash
func (o LogstashSpecElasticsearchRefsPatchOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefsPatch) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecElasticsearchRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecElasticsearchRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecElasticsearchRefsPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefsPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecElasticsearchRefsPatchOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefsPatch) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecElasticsearchRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecElasticsearchRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecElasticsearchRefsPatch)(nil)).Elem()
}

func (o LogstashSpecElasticsearchRefsPatchArrayOutput) ToLogstashSpecElasticsearchRefsPatchArrayOutput() LogstashSpecElasticsearchRefsPatchArrayOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsPatchArrayOutput) ToLogstashSpecElasticsearchRefsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsPatchArrayOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecElasticsearchRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecElasticsearchRefsPatch {
		return vs[0].([]LogstashSpecElasticsearchRefsPatch)[vs[1].(int)]
	}).(LogstashSpecElasticsearchRefsPatchOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoring struct {
	Logs    *LogstashSpecMonitoringLogs    `pulumi:"logs"`
	Metrics *LogstashSpecMonitoringMetrics `pulumi:"metrics"`
}

// LogstashSpecMonitoringInput is an input type that accepts LogstashSpecMonitoringArgs and LogstashSpecMonitoringOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringInput` via:
//
//	LogstashSpecMonitoringArgs{...}
type LogstashSpecMonitoringInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringOutput() LogstashSpecMonitoringOutput
	ToLogstashSpecMonitoringOutputWithContext(context.Context) LogstashSpecMonitoringOutput
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringArgs struct {
	Logs    LogstashSpecMonitoringLogsPtrInput    `pulumi:"logs"`
	Metrics LogstashSpecMonitoringMetricsPtrInput `pulumi:"metrics"`
}

func (LogstashSpecMonitoringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoring)(nil)).Elem()
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringOutput() LogstashSpecMonitoringOutput {
	return i.ToLogstashSpecMonitoringOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringOutputWithContext(ctx context.Context) LogstashSpecMonitoringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringOutput)
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return i.ToLogstashSpecMonitoringPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringOutput).ToLogstashSpecMonitoringPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringPtrInput is an input type that accepts LogstashSpecMonitoringArgs, LogstashSpecMonitoringPtr and LogstashSpecMonitoringPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringPtrInput` via:
//
//	        LogstashSpecMonitoringArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput
	ToLogstashSpecMonitoringPtrOutputWithContext(context.Context) LogstashSpecMonitoringPtrOutput
}

type logstashSpecMonitoringPtrType LogstashSpecMonitoringArgs

func LogstashSpecMonitoringPtr(v *LogstashSpecMonitoringArgs) LogstashSpecMonitoringPtrInput {
	return (*logstashSpecMonitoringPtrType)(v)
}

func (*logstashSpecMonitoringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoring)(nil)).Elem()
}

func (i *logstashSpecMonitoringPtrType) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return i.ToLogstashSpecMonitoringPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringPtrType) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringPtrOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoring)(nil)).Elem()
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringOutput() LogstashSpecMonitoringOutput {
	return o
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringOutputWithContext(ctx context.Context) LogstashSpecMonitoringOutput {
	return o
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return o.ToLogstashSpecMonitoringPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoring) *LogstashSpecMonitoring {
		return &v
	}).(LogstashSpecMonitoringPtrOutput)
}

func (o LogstashSpecMonitoringOutput) Logs() LogstashSpecMonitoringLogsPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoring) *LogstashSpecMonitoringLogs { return v.Logs }).(LogstashSpecMonitoringLogsPtrOutput)
}

func (o LogstashSpecMonitoringOutput) Metrics() LogstashSpecMonitoringMetricsPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoring) *LogstashSpecMonitoringMetrics { return v.Metrics }).(LogstashSpecMonitoringMetricsPtrOutput)
}

type LogstashSpecMonitoringPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoring)(nil)).Elem()
}

func (o LogstashSpecMonitoringPtrOutput) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return o
}

func (o LogstashSpecMonitoringPtrOutput) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return o
}

func (o LogstashSpecMonitoringPtrOutput) Elem() LogstashSpecMonitoringOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoring) LogstashSpecMonitoring {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoring
		return ret
	}).(LogstashSpecMonitoringOutput)
}

func (o LogstashSpecMonitoringPtrOutput) Logs() LogstashSpecMonitoringLogsPtrOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoring) *LogstashSpecMonitoringLogs {
		if v == nil {
			return nil
		}
		return v.Logs
	}).(LogstashSpecMonitoringLogsPtrOutput)
}

func (o LogstashSpecMonitoringPtrOutput) Metrics() LogstashSpecMonitoringMetricsPtrOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoring) *LogstashSpecMonitoringMetrics {
		if v == nil {
			return nil
		}
		return v.Metrics
	}).(LogstashSpecMonitoringMetricsPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []LogstashSpecMonitoringLogsElasticsearchRefs `pulumi:"elasticsearchRefs"`
}

// LogstashSpecMonitoringLogsInput is an input type that accepts LogstashSpecMonitoringLogsArgs and LogstashSpecMonitoringLogsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsInput` via:
//
//	LogstashSpecMonitoringLogsArgs{...}
type LogstashSpecMonitoringLogsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsOutput() LogstashSpecMonitoringLogsOutput
	ToLogstashSpecMonitoringLogsOutputWithContext(context.Context) LogstashSpecMonitoringLogsOutput
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs LogstashSpecMonitoringLogsElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
}

func (LogstashSpecMonitoringLogsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsOutput() LogstashSpecMonitoringLogsOutput {
	return i.ToLogstashSpecMonitoringLogsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsOutput)
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return i.ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsOutput).ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringLogsPtrInput is an input type that accepts LogstashSpecMonitoringLogsArgs, LogstashSpecMonitoringLogsPtr and LogstashSpecMonitoringLogsPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsPtrInput` via:
//
//	        LogstashSpecMonitoringLogsArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringLogsPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput
	ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Context) LogstashSpecMonitoringLogsPtrOutput
}

type logstashSpecMonitoringLogsPtrType LogstashSpecMonitoringLogsArgs

func LogstashSpecMonitoringLogsPtr(v *LogstashSpecMonitoringLogsArgs) LogstashSpecMonitoringLogsPtrInput {
	return (*logstashSpecMonitoringLogsPtrType)(v)
}

func (*logstashSpecMonitoringLogsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (i *logstashSpecMonitoringLogsPtrType) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return i.ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringLogsPtrType) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsOutput() LogstashSpecMonitoringLogsOutput {
	return o
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsOutput {
	return o
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return o.ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringLogs) *LogstashSpecMonitoringLogs {
		return &v
	}).(LogstashSpecMonitoringLogsPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringLogsOutput) ElasticsearchRefs() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogs) []LogstashSpecMonitoringLogsElasticsearchRefs {
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

type LogstashSpecMonitoringLogsPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsPtrOutput) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPtrOutput) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPtrOutput) Elem() LogstashSpecMonitoringLogsOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringLogs) LogstashSpecMonitoringLogs {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringLogs
		return ret
	}).(LogstashSpecMonitoringLogsOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringLogsPtrOutput) ElasticsearchRefs() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringLogs) []LogstashSpecMonitoringLogsElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecMonitoringLogsElasticsearchRefsInput is an input type that accepts LogstashSpecMonitoringLogsElasticsearchRefsArgs and LogstashSpecMonitoringLogsElasticsearchRefsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsElasticsearchRefsInput` via:
//
//	LogstashSpecMonitoringLogsElasticsearchRefsArgs{...}
type LogstashSpecMonitoringLogsElasticsearchRefsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsElasticsearchRefsOutput() LogstashSpecMonitoringLogsElasticsearchRefsOutput
	ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(context.Context) LogstashSpecMonitoringLogsElasticsearchRefsOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecMonitoringLogsElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArgs) ToLogstashSpecMonitoringLogsElasticsearchRefsOutput() LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return i.ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArgs) ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsElasticsearchRefsOutput)
}

// LogstashSpecMonitoringLogsElasticsearchRefsArrayInput is an input type that accepts LogstashSpecMonitoringLogsElasticsearchRefsArray and LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsElasticsearchRefsArrayInput` via:
//
//	LogstashSpecMonitoringLogsElasticsearchRefsArray{ LogstashSpecMonitoringLogsElasticsearchRefsArgs{...} }
type LogstashSpecMonitoringLogsElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput
	ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(context.Context) LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput
}

type LogstashSpecMonitoringLogsElasticsearchRefsArray []LogstashSpecMonitoringLogsElasticsearchRefsInput

func (LogstashSpecMonitoringLogsElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArray) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return i.ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArray) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsOutput() LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecMonitoringLogsElasticsearchRefs {
		return vs[0].([]LogstashSpecMonitoringLogsElasticsearchRefs)[vs[1].(int)]
	}).(LogstashSpecMonitoringLogsElasticsearchRefsOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsPatch struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecMonitoringLogsElasticsearchRefsPatchInput is an input type that accepts LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs and LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsElasticsearchRefsPatchInput` via:
//
//	LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs{...}
type LogstashSpecMonitoringLogsElasticsearchRefsPatchInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutput() LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput
	ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutputWithContext(context.Context) LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutput() LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput {
	return i.ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput)
}

// LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayInput is an input type that accepts LogstashSpecMonitoringLogsElasticsearchRefsPatchArray and LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayInput` via:
//
//	LogstashSpecMonitoringLogsElasticsearchRefsPatchArray{ LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs{...} }
type LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput
	ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutputWithContext(context.Context) LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput
}

type LogstashSpecMonitoringLogsElasticsearchRefsPatchArray []LogstashSpecMonitoringLogsElasticsearchRefsPatchInput

func (LogstashSpecMonitoringLogsElasticsearchRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringLogsElasticsearchRefsPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsPatchArray) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput {
	return i.ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsPatchArray) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutput() LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefsPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefsPatch) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringLogsElasticsearchRefsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecMonitoringLogsElasticsearchRefsPatch {
		return vs[0].([]LogstashSpecMonitoringLogsElasticsearchRefsPatch)[vs[1].(int)]
	}).(LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsPatch struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []LogstashSpecMonitoringLogsElasticsearchRefsPatch `pulumi:"elasticsearchRefs"`
}

// LogstashSpecMonitoringLogsPatchInput is an input type that accepts LogstashSpecMonitoringLogsPatchArgs and LogstashSpecMonitoringLogsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsPatchInput` via:
//
//	LogstashSpecMonitoringLogsPatchArgs{...}
type LogstashSpecMonitoringLogsPatchInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsPatchOutput() LogstashSpecMonitoringLogsPatchOutput
	ToLogstashSpecMonitoringLogsPatchOutputWithContext(context.Context) LogstashSpecMonitoringLogsPatchOutput
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsPatchArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayInput `pulumi:"elasticsearchRefs"`
}

func (LogstashSpecMonitoringLogsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsPatchArgs) ToLogstashSpecMonitoringLogsPatchOutput() LogstashSpecMonitoringLogsPatchOutput {
	return i.ToLogstashSpecMonitoringLogsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsPatchArgs) ToLogstashSpecMonitoringLogsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsPatchOutput)
}

func (i LogstashSpecMonitoringLogsPatchArgs) ToLogstashSpecMonitoringLogsPatchPtrOutput() LogstashSpecMonitoringLogsPatchPtrOutput {
	return i.ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsPatchArgs) ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsPatchOutput).ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringLogsPatchPtrInput is an input type that accepts LogstashSpecMonitoringLogsPatchArgs, LogstashSpecMonitoringLogsPatchPtr and LogstashSpecMonitoringLogsPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsPatchPtrInput` via:
//
//	        LogstashSpecMonitoringLogsPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringLogsPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsPatchPtrOutput() LogstashSpecMonitoringLogsPatchPtrOutput
	ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(context.Context) LogstashSpecMonitoringLogsPatchPtrOutput
}

type logstashSpecMonitoringLogsPatchPtrType LogstashSpecMonitoringLogsPatchArgs

func LogstashSpecMonitoringLogsPatchPtr(v *LogstashSpecMonitoringLogsPatchArgs) LogstashSpecMonitoringLogsPatchPtrInput {
	return (*logstashSpecMonitoringLogsPatchPtrType)(v)
}

func (*logstashSpecMonitoringLogsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringLogsPatch)(nil)).Elem()
}

func (i *logstashSpecMonitoringLogsPatchPtrType) ToLogstashSpecMonitoringLogsPatchPtrOutput() LogstashSpecMonitoringLogsPatchPtrOutput {
	return i.ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringLogsPatchPtrType) ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsPatchPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsPatchOutput) ToLogstashSpecMonitoringLogsPatchOutput() LogstashSpecMonitoringLogsPatchOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPatchOutput) ToLogstashSpecMonitoringLogsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPatchOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPatchOutput) ToLogstashSpecMonitoringLogsPatchPtrOutput() LogstashSpecMonitoringLogsPatchPtrOutput {
	return o.ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringLogsPatchOutput) ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringLogsPatch) *LogstashSpecMonitoringLogsPatch {
		return &v
	}).(LogstashSpecMonitoringLogsPatchPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringLogsPatchOutput) ElasticsearchRefs() LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsPatch) []LogstashSpecMonitoringLogsElasticsearchRefsPatch {
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput)
}

type LogstashSpecMonitoringLogsPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringLogsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsPatchPtrOutput) ToLogstashSpecMonitoringLogsPatchPtrOutput() LogstashSpecMonitoringLogsPatchPtrOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPatchPtrOutput) ToLogstashSpecMonitoringLogsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPatchPtrOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPatchPtrOutput) Elem() LogstashSpecMonitoringLogsPatchOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringLogsPatch) LogstashSpecMonitoringLogsPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringLogsPatch
		return ret
	}).(LogstashSpecMonitoringLogsPatchOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringLogsPatchPtrOutput) ElasticsearchRefs() LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringLogsPatch) []LogstashSpecMonitoringLogsElasticsearchRefsPatch {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetrics struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []LogstashSpecMonitoringMetricsElasticsearchRefs `pulumi:"elasticsearchRefs"`
}

// LogstashSpecMonitoringMetricsInput is an input type that accepts LogstashSpecMonitoringMetricsArgs and LogstashSpecMonitoringMetricsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsInput` via:
//
//	LogstashSpecMonitoringMetricsArgs{...}
type LogstashSpecMonitoringMetricsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsOutput() LogstashSpecMonitoringMetricsOutput
	ToLogstashSpecMonitoringMetricsOutputWithContext(context.Context) LogstashSpecMonitoringMetricsOutput
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
}

func (LogstashSpecMonitoringMetricsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsOutput() LogstashSpecMonitoringMetricsOutput {
	return i.ToLogstashSpecMonitoringMetricsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsOutput)
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return i.ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsOutput).ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringMetricsPtrInput is an input type that accepts LogstashSpecMonitoringMetricsArgs, LogstashSpecMonitoringMetricsPtr and LogstashSpecMonitoringMetricsPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsPtrInput` via:
//
//	        LogstashSpecMonitoringMetricsArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringMetricsPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput
	ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Context) LogstashSpecMonitoringMetricsPtrOutput
}

type logstashSpecMonitoringMetricsPtrType LogstashSpecMonitoringMetricsArgs

func LogstashSpecMonitoringMetricsPtr(v *LogstashSpecMonitoringMetricsArgs) LogstashSpecMonitoringMetricsPtrInput {
	return (*logstashSpecMonitoringMetricsPtrType)(v)
}

func (*logstashSpecMonitoringMetricsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (i *logstashSpecMonitoringMetricsPtrType) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return i.ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringMetricsPtrType) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsOutput() LogstashSpecMonitoringMetricsOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return o.ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringMetrics) *LogstashSpecMonitoringMetrics {
		return &v
	}).(LogstashSpecMonitoringMetricsPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringMetricsOutput) ElasticsearchRefs() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetrics) []LogstashSpecMonitoringMetricsElasticsearchRefs {
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

type LogstashSpecMonitoringMetricsPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsPtrOutput) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPtrOutput) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPtrOutput) Elem() LogstashSpecMonitoringMetricsOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringMetrics) LogstashSpecMonitoringMetrics {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringMetrics
		return ret
	}).(LogstashSpecMonitoringMetricsOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringMetricsPtrOutput) ElasticsearchRefs() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringMetrics) []LogstashSpecMonitoringMetricsElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecMonitoringMetricsElasticsearchRefsInput is an input type that accepts LogstashSpecMonitoringMetricsElasticsearchRefsArgs and LogstashSpecMonitoringMetricsElasticsearchRefsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsElasticsearchRefsInput` via:
//
//	LogstashSpecMonitoringMetricsElasticsearchRefsArgs{...}
type LogstashSpecMonitoringMetricsElasticsearchRefsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsElasticsearchRefsOutput() LogstashSpecMonitoringMetricsElasticsearchRefsOutput
	ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecMonitoringMetricsElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArgs) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutput() LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return i.ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArgs) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsElasticsearchRefsOutput)
}

// LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput is an input type that accepts LogstashSpecMonitoringMetricsElasticsearchRefsArray and LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput` via:
//
//	LogstashSpecMonitoringMetricsElasticsearchRefsArray{ LogstashSpecMonitoringMetricsElasticsearchRefsArgs{...} }
type LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput
	ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput
}

type LogstashSpecMonitoringMetricsElasticsearchRefsArray []LogstashSpecMonitoringMetricsElasticsearchRefsInput

func (LogstashSpecMonitoringMetricsElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArray) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return i.ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArray) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutput() LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecMonitoringMetricsElasticsearchRefs {
		return vs[0].([]LogstashSpecMonitoringMetricsElasticsearchRefs)[vs[1].(int)]
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsPatch struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecMonitoringMetricsElasticsearchRefsPatchInput is an input type that accepts LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs and LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsElasticsearchRefsPatchInput` via:
//
//	LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs{...}
type LogstashSpecMonitoringMetricsElasticsearchRefsPatchInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput() LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput
	ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutputWithContext(context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput() LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput {
	return i.ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput)
}

// LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayInput is an input type that accepts LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray and LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayInput` via:
//
//	LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray{ LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs{...} }
type LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput
	ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutputWithContext(context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput
}

type LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray []LogstashSpecMonitoringMetricsElasticsearchRefsPatchInput

func (LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringMetricsElasticsearchRefsPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput {
	return i.ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput() LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefsPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefsPatch) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringMetricsElasticsearchRefsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecMonitoringMetricsElasticsearchRefsPatch {
		return vs[0].([]LogstashSpecMonitoringMetricsElasticsearchRefsPatch)[vs[1].(int)]
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsPatch struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []LogstashSpecMonitoringMetricsElasticsearchRefsPatch `pulumi:"elasticsearchRefs"`
}

// LogstashSpecMonitoringMetricsPatchInput is an input type that accepts LogstashSpecMonitoringMetricsPatchArgs and LogstashSpecMonitoringMetricsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsPatchInput` via:
//
//	LogstashSpecMonitoringMetricsPatchArgs{...}
type LogstashSpecMonitoringMetricsPatchInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsPatchOutput() LogstashSpecMonitoringMetricsPatchOutput
	ToLogstashSpecMonitoringMetricsPatchOutputWithContext(context.Context) LogstashSpecMonitoringMetricsPatchOutput
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsPatchArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayInput `pulumi:"elasticsearchRefs"`
}

func (LogstashSpecMonitoringMetricsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsPatchArgs) ToLogstashSpecMonitoringMetricsPatchOutput() LogstashSpecMonitoringMetricsPatchOutput {
	return i.ToLogstashSpecMonitoringMetricsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsPatchArgs) ToLogstashSpecMonitoringMetricsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsPatchOutput)
}

func (i LogstashSpecMonitoringMetricsPatchArgs) ToLogstashSpecMonitoringMetricsPatchPtrOutput() LogstashSpecMonitoringMetricsPatchPtrOutput {
	return i.ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsPatchArgs) ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsPatchOutput).ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringMetricsPatchPtrInput is an input type that accepts LogstashSpecMonitoringMetricsPatchArgs, LogstashSpecMonitoringMetricsPatchPtr and LogstashSpecMonitoringMetricsPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsPatchPtrInput` via:
//
//	        LogstashSpecMonitoringMetricsPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringMetricsPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsPatchPtrOutput() LogstashSpecMonitoringMetricsPatchPtrOutput
	ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(context.Context) LogstashSpecMonitoringMetricsPatchPtrOutput
}

type logstashSpecMonitoringMetricsPatchPtrType LogstashSpecMonitoringMetricsPatchArgs

func LogstashSpecMonitoringMetricsPatchPtr(v *LogstashSpecMonitoringMetricsPatchArgs) LogstashSpecMonitoringMetricsPatchPtrInput {
	return (*logstashSpecMonitoringMetricsPatchPtrType)(v)
}

func (*logstashSpecMonitoringMetricsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringMetricsPatch)(nil)).Elem()
}

func (i *logstashSpecMonitoringMetricsPatchPtrType) ToLogstashSpecMonitoringMetricsPatchPtrOutput() LogstashSpecMonitoringMetricsPatchPtrOutput {
	return i.ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringMetricsPatchPtrType) ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsPatchPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsPatchOutput) ToLogstashSpecMonitoringMetricsPatchOutput() LogstashSpecMonitoringMetricsPatchOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPatchOutput) ToLogstashSpecMonitoringMetricsPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPatchOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPatchOutput) ToLogstashSpecMonitoringMetricsPatchPtrOutput() LogstashSpecMonitoringMetricsPatchPtrOutput {
	return o.ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringMetricsPatchOutput) ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringMetricsPatch) *LogstashSpecMonitoringMetricsPatch {
		return &v
	}).(LogstashSpecMonitoringMetricsPatchPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringMetricsPatchOutput) ElasticsearchRefs() LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsPatch) []LogstashSpecMonitoringMetricsElasticsearchRefsPatch {
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput)
}

type LogstashSpecMonitoringMetricsPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringMetricsPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsPatchPtrOutput) ToLogstashSpecMonitoringMetricsPatchPtrOutput() LogstashSpecMonitoringMetricsPatchPtrOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPatchPtrOutput) ToLogstashSpecMonitoringMetricsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPatchPtrOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPatchPtrOutput) Elem() LogstashSpecMonitoringMetricsPatchOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringMetricsPatch) LogstashSpecMonitoringMetricsPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringMetricsPatch
		return ret
	}).(LogstashSpecMonitoringMetricsPatchOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringMetricsPatchPtrOutput) ElasticsearchRefs() LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringMetricsPatch) []LogstashSpecMonitoringMetricsElasticsearchRefsPatch {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringPatch struct {
	Logs    *LogstashSpecMonitoringLogsPatch    `pulumi:"logs"`
	Metrics *LogstashSpecMonitoringMetricsPatch `pulumi:"metrics"`
}

// LogstashSpecMonitoringPatchInput is an input type that accepts LogstashSpecMonitoringPatchArgs and LogstashSpecMonitoringPatchOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringPatchInput` via:
//
//	LogstashSpecMonitoringPatchArgs{...}
type LogstashSpecMonitoringPatchInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringPatchOutput() LogstashSpecMonitoringPatchOutput
	ToLogstashSpecMonitoringPatchOutputWithContext(context.Context) LogstashSpecMonitoringPatchOutput
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringPatchArgs struct {
	Logs    LogstashSpecMonitoringLogsPatchPtrInput    `pulumi:"logs"`
	Metrics LogstashSpecMonitoringMetricsPatchPtrInput `pulumi:"metrics"`
}

func (LogstashSpecMonitoringPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringPatch)(nil)).Elem()
}

func (i LogstashSpecMonitoringPatchArgs) ToLogstashSpecMonitoringPatchOutput() LogstashSpecMonitoringPatchOutput {
	return i.ToLogstashSpecMonitoringPatchOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringPatchArgs) ToLogstashSpecMonitoringPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringPatchOutput)
}

func (i LogstashSpecMonitoringPatchArgs) ToLogstashSpecMonitoringPatchPtrOutput() LogstashSpecMonitoringPatchPtrOutput {
	return i.ToLogstashSpecMonitoringPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringPatchArgs) ToLogstashSpecMonitoringPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringPatchOutput).ToLogstashSpecMonitoringPatchPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringPatchPtrInput is an input type that accepts LogstashSpecMonitoringPatchArgs, LogstashSpecMonitoringPatchPtr and LogstashSpecMonitoringPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringPatchPtrInput` via:
//
//	        LogstashSpecMonitoringPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringPatchPtrOutput() LogstashSpecMonitoringPatchPtrOutput
	ToLogstashSpecMonitoringPatchPtrOutputWithContext(context.Context) LogstashSpecMonitoringPatchPtrOutput
}

type logstashSpecMonitoringPatchPtrType LogstashSpecMonitoringPatchArgs

func LogstashSpecMonitoringPatchPtr(v *LogstashSpecMonitoringPatchArgs) LogstashSpecMonitoringPatchPtrInput {
	return (*logstashSpecMonitoringPatchPtrType)(v)
}

func (*logstashSpecMonitoringPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringPatch)(nil)).Elem()
}

func (i *logstashSpecMonitoringPatchPtrType) ToLogstashSpecMonitoringPatchPtrOutput() LogstashSpecMonitoringPatchPtrOutput {
	return i.ToLogstashSpecMonitoringPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringPatchPtrType) ToLogstashSpecMonitoringPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringPatchPtrOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringPatchOutput) ToLogstashSpecMonitoringPatchOutput() LogstashSpecMonitoringPatchOutput {
	return o
}

func (o LogstashSpecMonitoringPatchOutput) ToLogstashSpecMonitoringPatchOutputWithContext(ctx context.Context) LogstashSpecMonitoringPatchOutput {
	return o
}

func (o LogstashSpecMonitoringPatchOutput) ToLogstashSpecMonitoringPatchPtrOutput() LogstashSpecMonitoringPatchPtrOutput {
	return o.ToLogstashSpecMonitoringPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringPatchOutput) ToLogstashSpecMonitoringPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringPatch) *LogstashSpecMonitoringPatch {
		return &v
	}).(LogstashSpecMonitoringPatchPtrOutput)
}

func (o LogstashSpecMonitoringPatchOutput) Logs() LogstashSpecMonitoringLogsPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringPatch) *LogstashSpecMonitoringLogsPatch { return v.Logs }).(LogstashSpecMonitoringLogsPatchPtrOutput)
}

func (o LogstashSpecMonitoringPatchOutput) Metrics() LogstashSpecMonitoringMetricsPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringPatch) *LogstashSpecMonitoringMetricsPatch { return v.Metrics }).(LogstashSpecMonitoringMetricsPatchPtrOutput)
}

type LogstashSpecMonitoringPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringPatch)(nil)).Elem()
}

func (o LogstashSpecMonitoringPatchPtrOutput) ToLogstashSpecMonitoringPatchPtrOutput() LogstashSpecMonitoringPatchPtrOutput {
	return o
}

func (o LogstashSpecMonitoringPatchPtrOutput) ToLogstashSpecMonitoringPatchPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPatchPtrOutput {
	return o
}

func (o LogstashSpecMonitoringPatchPtrOutput) Elem() LogstashSpecMonitoringPatchOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringPatch) LogstashSpecMonitoringPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringPatch
		return ret
	}).(LogstashSpecMonitoringPatchOutput)
}

func (o LogstashSpecMonitoringPatchPtrOutput) Logs() LogstashSpecMonitoringLogsPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringPatch) *LogstashSpecMonitoringLogsPatch {
		if v == nil {
			return nil
		}
		return v.Logs
	}).(LogstashSpecMonitoringLogsPatchPtrOutput)
}

func (o LogstashSpecMonitoringPatchPtrOutput) Metrics() LogstashSpecMonitoringMetricsPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringPatch) *LogstashSpecMonitoringMetricsPatch {
		if v == nil {
			return nil
		}
		return v.Metrics
	}).(LogstashSpecMonitoringMetricsPatchPtrOutput)
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecPatch struct {
	// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config    map[string]interface{}      `pulumi:"config"`
	ConfigRef *LogstashSpecConfigRefPatch `pulumi:"configRef"`
	Count     *int                        `pulumi:"count"`
	// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
	ElasticsearchRefs []LogstashSpecElasticsearchRefsPatch `pulumi:"elasticsearchRefs"`
	// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
	Image      *string                      `pulumi:"image"`
	Monitoring *LogstashSpecMonitoringPatch `pulumi:"monitoring"`
	// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
	Pipelines    map[string]interface{}         `pulumi:"pipelines"`
	PipelinesRef *LogstashSpecPipelinesRefPatch `pulumi:"pipelinesRef"`
	// PodTemplate provides customisation options for the Logstash pods.
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
	// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings []LogstashSpecSecureSettingsPatch `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
	// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
	// be opened up for other services: Beats, TCP, UDP, etc, inputs.
	Services       []LogstashSpecServicesPatch      `pulumi:"services"`
	UpdateStrategy *LogstashSpecUpdateStrategyPatch `pulumi:"updateStrategy"`
	// Version of the Logstash.
	Version *string `pulumi:"version"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates []LogstashSpecVolumeClaimTemplatesPatch `pulumi:"volumeClaimTemplates"`
}

// LogstashSpecPatchInput is an input type that accepts LogstashSpecPatchArgs and LogstashSpecPatchOutput values.
// You can construct a concrete instance of `LogstashSpecPatchInput` via:
//
//	LogstashSpecPatchArgs{...}
type LogstashSpecPatchInput interface {
	pulumi.Input

	ToLogstashSpecPatchOutput() LogstashSpecPatchOutput
	ToLogstashSpecPatchOutputWithContext(context.Context) LogstashSpecPatchOutput
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecPatchArgs struct {
	// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config    pulumi.MapInput                    `pulumi:"config"`
	ConfigRef LogstashSpecConfigRefPatchPtrInput `pulumi:"configRef"`
	Count     pulumi.IntPtrInput                 `pulumi:"count"`
	// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
	ElasticsearchRefs LogstashSpecElasticsearchRefsPatchArrayInput `pulumi:"elasticsearchRefs"`
	// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
	Image      pulumi.StringPtrInput               `pulumi:"image"`
	Monitoring LogstashSpecMonitoringPatchPtrInput `pulumi:"monitoring"`
	// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
	Pipelines    pulumi.MapInput                       `pulumi:"pipelines"`
	PipelinesRef LogstashSpecPipelinesRefPatchPtrInput `pulumi:"pipelinesRef"`
	// PodTemplate provides customisation options for the Logstash pods.
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
	// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings LogstashSpecSecureSettingsPatchArrayInput `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
	// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
	// be opened up for other services: Beats, TCP, UDP, etc, inputs.
	Services       LogstashSpecServicesPatchArrayInput     `pulumi:"services"`
	UpdateStrategy LogstashSpecUpdateStrategyPatchPtrInput `pulumi:"updateStrategy"`
	// Version of the Logstash.
	Version pulumi.StringPtrInput `pulumi:"version"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates LogstashSpecVolumeClaimTemplatesPatchArrayInput `pulumi:"volumeClaimTemplates"`
}

func (LogstashSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPatch)(nil)).Elem()
}

func (i LogstashSpecPatchArgs) ToLogstashSpecPatchOutput() LogstashSpecPatchOutput {
	return i.ToLogstashSpecPatchOutputWithContext(context.Background())
}

func (i LogstashSpecPatchArgs) ToLogstashSpecPatchOutputWithContext(ctx context.Context) LogstashSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPatchOutput)
}

func (i LogstashSpecPatchArgs) ToLogstashSpecPatchPtrOutput() LogstashSpecPatchPtrOutput {
	return i.ToLogstashSpecPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecPatchArgs) ToLogstashSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPatchOutput).ToLogstashSpecPatchPtrOutputWithContext(ctx)
}

// LogstashSpecPatchPtrInput is an input type that accepts LogstashSpecPatchArgs, LogstashSpecPatchPtr and LogstashSpecPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecPatchPtrInput` via:
//
//	        LogstashSpecPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecPatchPtrOutput() LogstashSpecPatchPtrOutput
	ToLogstashSpecPatchPtrOutputWithContext(context.Context) LogstashSpecPatchPtrOutput
}

type logstashSpecPatchPtrType LogstashSpecPatchArgs

func LogstashSpecPatchPtr(v *LogstashSpecPatchArgs) LogstashSpecPatchPtrInput {
	return (*logstashSpecPatchPtrType)(v)
}

func (*logstashSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPatch)(nil)).Elem()
}

func (i *logstashSpecPatchPtrType) ToLogstashSpecPatchPtrOutput() LogstashSpecPatchPtrOutput {
	return i.ToLogstashSpecPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecPatchPtrType) ToLogstashSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPatchPtrOutput)
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPatch)(nil)).Elem()
}

func (o LogstashSpecPatchOutput) ToLogstashSpecPatchOutput() LogstashSpecPatchOutput {
	return o
}

func (o LogstashSpecPatchOutput) ToLogstashSpecPatchOutputWithContext(ctx context.Context) LogstashSpecPatchOutput {
	return o
}

func (o LogstashSpecPatchOutput) ToLogstashSpecPatchPtrOutput() LogstashSpecPatchPtrOutput {
	return o.ToLogstashSpecPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecPatchOutput) ToLogstashSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecPatch) *LogstashSpecPatch {
		return &v
	}).(LogstashSpecPatchPtrOutput)
}

// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o LogstashSpecPatchOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecPatch) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

func (o LogstashSpecPatchOutput) ConfigRef() LogstashSpecConfigRefPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *LogstashSpecConfigRefPatch { return v.ConfigRef }).(LogstashSpecConfigRefPatchPtrOutput)
}

func (o LogstashSpecPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
func (o LogstashSpecPatchOutput) ElasticsearchRefs() LogstashSpecElasticsearchRefsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecPatch) []LogstashSpecElasticsearchRefsPatch { return v.ElasticsearchRefs }).(LogstashSpecElasticsearchRefsPatchArrayOutput)
}

// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
func (o LogstashSpecPatchOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *string { return v.Image }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecPatchOutput) Monitoring() LogstashSpecMonitoringPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *LogstashSpecMonitoringPatch { return v.Monitoring }).(LogstashSpecMonitoringPatchPtrOutput)
}

// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
func (o LogstashSpecPatchOutput) Pipelines() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecPatch) map[string]interface{} { return v.Pipelines }).(pulumi.MapOutput)
}

func (o LogstashSpecPatchOutput) PipelinesRef() LogstashSpecPipelinesRefPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *LogstashSpecPipelinesRefPatch { return v.PipelinesRef }).(LogstashSpecPipelinesRefPatchPtrOutput)
}

// PodTemplate provides customisation options for the Logstash pods.
func (o LogstashSpecPatchOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecPatch) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
func (o LogstashSpecPatchOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o LogstashSpecPatchOutput) SecureSettings() LogstashSpecSecureSettingsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecPatch) []LogstashSpecSecureSettingsPatch { return v.SecureSettings }).(LogstashSpecSecureSettingsPatchArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o LogstashSpecPatchOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
// be opened up for other services: Beats, TCP, UDP, etc, inputs.
func (o LogstashSpecPatchOutput) Services() LogstashSpecServicesPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecPatch) []LogstashSpecServicesPatch { return v.Services }).(LogstashSpecServicesPatchArrayOutput)
}

func (o LogstashSpecPatchOutput) UpdateStrategy() LogstashSpecUpdateStrategyPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *LogstashSpecUpdateStrategyPatch { return v.UpdateStrategy }).(LogstashSpecUpdateStrategyPatchPtrOutput)
}

// Version of the Logstash.
func (o LogstashSpecPatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecPatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o LogstashSpecPatchOutput) VolumeClaimTemplates() LogstashSpecVolumeClaimTemplatesPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecPatch) []LogstashSpecVolumeClaimTemplatesPatch { return v.VolumeClaimTemplates }).(LogstashSpecVolumeClaimTemplatesPatchArrayOutput)
}

type LogstashSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPatch)(nil)).Elem()
}

func (o LogstashSpecPatchPtrOutput) ToLogstashSpecPatchPtrOutput() LogstashSpecPatchPtrOutput {
	return o
}

func (o LogstashSpecPatchPtrOutput) ToLogstashSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPatchPtrOutput {
	return o
}

func (o LogstashSpecPatchPtrOutput) Elem() LogstashSpecPatchOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) LogstashSpecPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecPatch
		return ret
	}).(LogstashSpecPatchOutput)
}

// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o LogstashSpecPatchPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

func (o LogstashSpecPatchPtrOutput) ConfigRef() LogstashSpecConfigRefPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *LogstashSpecConfigRefPatch {
		if v == nil {
			return nil
		}
		return v.ConfigRef
	}).(LogstashSpecConfigRefPatchPtrOutput)
}

func (o LogstashSpecPatchPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
func (o LogstashSpecPatchPtrOutput) ElasticsearchRefs() LogstashSpecElasticsearchRefsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) []LogstashSpecElasticsearchRefsPatch {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecElasticsearchRefsPatchArrayOutput)
}

// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
func (o LogstashSpecPatchPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecPatchPtrOutput) Monitoring() LogstashSpecMonitoringPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *LogstashSpecMonitoringPatch {
		if v == nil {
			return nil
		}
		return v.Monitoring
	}).(LogstashSpecMonitoringPatchPtrOutput)
}

// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
func (o LogstashSpecPatchPtrOutput) Pipelines() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Pipelines
	}).(pulumi.MapOutput)
}

func (o LogstashSpecPatchPtrOutput) PipelinesRef() LogstashSpecPipelinesRefPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *LogstashSpecPipelinesRefPatch {
		if v == nil {
			return nil
		}
		return v.PipelinesRef
	}).(LogstashSpecPipelinesRefPatchPtrOutput)
}

// PodTemplate provides customisation options for the Logstash pods.
func (o LogstashSpecPatchPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
func (o LogstashSpecPatchPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o LogstashSpecPatchPtrOutput) SecureSettings() LogstashSpecSecureSettingsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) []LogstashSpecSecureSettingsPatch {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(LogstashSpecSecureSettingsPatchArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o LogstashSpecPatchPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
// be opened up for other services: Beats, TCP, UDP, etc, inputs.
func (o LogstashSpecPatchPtrOutput) Services() LogstashSpecServicesPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) []LogstashSpecServicesPatch {
		if v == nil {
			return nil
		}
		return v.Services
	}).(LogstashSpecServicesPatchArrayOutput)
}

func (o LogstashSpecPatchPtrOutput) UpdateStrategy() LogstashSpecUpdateStrategyPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *LogstashSpecUpdateStrategyPatch {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(LogstashSpecUpdateStrategyPatchPtrOutput)
}

// Version of the Logstash.
func (o LogstashSpecPatchPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o LogstashSpecPatchPtrOutput) VolumeClaimTemplates() LogstashSpecVolumeClaimTemplatesPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecPatch) []LogstashSpecVolumeClaimTemplatesPatch {
		if v == nil {
			return nil
		}
		return v.VolumeClaimTemplates
	}).(LogstashSpecVolumeClaimTemplatesPatchArrayOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRef struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecPipelinesRefInput is an input type that accepts LogstashSpecPipelinesRefArgs and LogstashSpecPipelinesRefOutput values.
// You can construct a concrete instance of `LogstashSpecPipelinesRefInput` via:
//
//	LogstashSpecPipelinesRefArgs{...}
type LogstashSpecPipelinesRefInput interface {
	pulumi.Input

	ToLogstashSpecPipelinesRefOutput() LogstashSpecPipelinesRefOutput
	ToLogstashSpecPipelinesRefOutputWithContext(context.Context) LogstashSpecPipelinesRefOutput
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecPipelinesRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPipelinesRef)(nil)).Elem()
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefOutput() LogstashSpecPipelinesRefOutput {
	return i.ToLogstashSpecPipelinesRefOutputWithContext(context.Background())
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefOutput)
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return i.ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Background())
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefOutput).ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx)
}

// LogstashSpecPipelinesRefPtrInput is an input type that accepts LogstashSpecPipelinesRefArgs, LogstashSpecPipelinesRefPtr and LogstashSpecPipelinesRefPtrOutput values.
// You can construct a concrete instance of `LogstashSpecPipelinesRefPtrInput` via:
//
//	        LogstashSpecPipelinesRefArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecPipelinesRefPtrInput interface {
	pulumi.Input

	ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput
	ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Context) LogstashSpecPipelinesRefPtrOutput
}

type logstashSpecPipelinesRefPtrType LogstashSpecPipelinesRefArgs

func LogstashSpecPipelinesRefPtr(v *LogstashSpecPipelinesRefArgs) LogstashSpecPipelinesRefPtrInput {
	return (*logstashSpecPipelinesRefPtrType)(v)
}

func (*logstashSpecPipelinesRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPipelinesRef)(nil)).Elem()
}

func (i *logstashSpecPipelinesRefPtrType) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return i.ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Background())
}

func (i *logstashSpecPipelinesRefPtrType) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefPtrOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefOutput struct{ *pulumi.OutputState }

func (LogstashSpecPipelinesRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPipelinesRef)(nil)).Elem()
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefOutput() LogstashSpecPipelinesRefOutput {
	return o
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefOutput {
	return o
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return o.ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Background())
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecPipelinesRef) *LogstashSpecPipelinesRef {
		return &v
	}).(LogstashSpecPipelinesRefPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecPipelinesRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecPipelinesRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecPipelinesRefPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecPipelinesRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPipelinesRef)(nil)).Elem()
}

func (o LogstashSpecPipelinesRefPtrOutput) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return o
}

func (o LogstashSpecPipelinesRefPtrOutput) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return o
}

func (o LogstashSpecPipelinesRefPtrOutput) Elem() LogstashSpecPipelinesRefOutput {
	return o.ApplyT(func(v *LogstashSpecPipelinesRef) LogstashSpecPipelinesRef {
		if v != nil {
			return *v
		}
		var ret LogstashSpecPipelinesRef
		return ret
	}).(LogstashSpecPipelinesRefOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecPipelinesRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPipelinesRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefPatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecPipelinesRefPatchInput is an input type that accepts LogstashSpecPipelinesRefPatchArgs and LogstashSpecPipelinesRefPatchOutput values.
// You can construct a concrete instance of `LogstashSpecPipelinesRefPatchInput` via:
//
//	LogstashSpecPipelinesRefPatchArgs{...}
type LogstashSpecPipelinesRefPatchInput interface {
	pulumi.Input

	ToLogstashSpecPipelinesRefPatchOutput() LogstashSpecPipelinesRefPatchOutput
	ToLogstashSpecPipelinesRefPatchOutputWithContext(context.Context) LogstashSpecPipelinesRefPatchOutput
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefPatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecPipelinesRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPipelinesRefPatch)(nil)).Elem()
}

func (i LogstashSpecPipelinesRefPatchArgs) ToLogstashSpecPipelinesRefPatchOutput() LogstashSpecPipelinesRefPatchOutput {
	return i.ToLogstashSpecPipelinesRefPatchOutputWithContext(context.Background())
}

func (i LogstashSpecPipelinesRefPatchArgs) ToLogstashSpecPipelinesRefPatchOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefPatchOutput)
}

func (i LogstashSpecPipelinesRefPatchArgs) ToLogstashSpecPipelinesRefPatchPtrOutput() LogstashSpecPipelinesRefPatchPtrOutput {
	return i.ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecPipelinesRefPatchArgs) ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefPatchOutput).ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(ctx)
}

// LogstashSpecPipelinesRefPatchPtrInput is an input type that accepts LogstashSpecPipelinesRefPatchArgs, LogstashSpecPipelinesRefPatchPtr and LogstashSpecPipelinesRefPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecPipelinesRefPatchPtrInput` via:
//
//	        LogstashSpecPipelinesRefPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecPipelinesRefPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecPipelinesRefPatchPtrOutput() LogstashSpecPipelinesRefPatchPtrOutput
	ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(context.Context) LogstashSpecPipelinesRefPatchPtrOutput
}

type logstashSpecPipelinesRefPatchPtrType LogstashSpecPipelinesRefPatchArgs

func LogstashSpecPipelinesRefPatchPtr(v *LogstashSpecPipelinesRefPatchArgs) LogstashSpecPipelinesRefPatchPtrInput {
	return (*logstashSpecPipelinesRefPatchPtrType)(v)
}

func (*logstashSpecPipelinesRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPipelinesRefPatch)(nil)).Elem()
}

func (i *logstashSpecPipelinesRefPatchPtrType) ToLogstashSpecPipelinesRefPatchPtrOutput() LogstashSpecPipelinesRefPatchPtrOutput {
	return i.ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecPipelinesRefPatchPtrType) ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefPatchPtrOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecPipelinesRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPipelinesRefPatch)(nil)).Elem()
}

func (o LogstashSpecPipelinesRefPatchOutput) ToLogstashSpecPipelinesRefPatchOutput() LogstashSpecPipelinesRefPatchOutput {
	return o
}

func (o LogstashSpecPipelinesRefPatchOutput) ToLogstashSpecPipelinesRefPatchOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPatchOutput {
	return o
}

func (o LogstashSpecPipelinesRefPatchOutput) ToLogstashSpecPipelinesRefPatchPtrOutput() LogstashSpecPipelinesRefPatchPtrOutput {
	return o.ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecPipelinesRefPatchOutput) ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecPipelinesRefPatch) *LogstashSpecPipelinesRefPatch {
		return &v
	}).(LogstashSpecPipelinesRefPatchPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecPipelinesRefPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecPipelinesRefPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecPipelinesRefPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecPipelinesRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPipelinesRefPatch)(nil)).Elem()
}

func (o LogstashSpecPipelinesRefPatchPtrOutput) ToLogstashSpecPipelinesRefPatchPtrOutput() LogstashSpecPipelinesRefPatchPtrOutput {
	return o
}

func (o LogstashSpecPipelinesRefPatchPtrOutput) ToLogstashSpecPipelinesRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPatchPtrOutput {
	return o
}

func (o LogstashSpecPipelinesRefPatchPtrOutput) Elem() LogstashSpecPipelinesRefPatchOutput {
	return o.ApplyT(func(v *LogstashSpecPipelinesRefPatch) LogstashSpecPipelinesRefPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecPipelinesRefPatch
		return ret
	}).(LogstashSpecPipelinesRefPatchOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecPipelinesRefPatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPipelinesRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettings struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []LogstashSpecSecureSettingsEntries `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecSecureSettingsInput is an input type that accepts LogstashSpecSecureSettingsArgs and LogstashSpecSecureSettingsOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsInput` via:
//
//	LogstashSpecSecureSettingsArgs{...}
type LogstashSpecSecureSettingsInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsOutput() LogstashSpecSecureSettingsOutput
	ToLogstashSpecSecureSettingsOutputWithContext(context.Context) LogstashSpecSecureSettingsOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries LogstashSpecSecureSettingsEntriesArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecSecureSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettings)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsArgs) ToLogstashSpecSecureSettingsOutput() LogstashSpecSecureSettingsOutput {
	return i.ToLogstashSpecSecureSettingsOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsArgs) ToLogstashSpecSecureSettingsOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsOutput)
}

// LogstashSpecSecureSettingsArrayInput is an input type that accepts LogstashSpecSecureSettingsArray and LogstashSpecSecureSettingsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsArrayInput` via:
//
//	LogstashSpecSecureSettingsArray{ LogstashSpecSecureSettingsArgs{...} }
type LogstashSpecSecureSettingsArrayInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsArrayOutput() LogstashSpecSecureSettingsArrayOutput
	ToLogstashSpecSecureSettingsArrayOutputWithContext(context.Context) LogstashSpecSecureSettingsArrayOutput
}

type LogstashSpecSecureSettingsArray []LogstashSpecSecureSettingsInput

func (LogstashSpecSecureSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettings)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsArray) ToLogstashSpecSecureSettingsArrayOutput() LogstashSpecSecureSettingsArrayOutput {
	return i.ToLogstashSpecSecureSettingsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsArray) ToLogstashSpecSecureSettingsArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettings)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsOutput) ToLogstashSpecSecureSettingsOutput() LogstashSpecSecureSettingsOutput {
	return o
}

func (o LogstashSpecSecureSettingsOutput) ToLogstashSpecSecureSettingsOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o LogstashSpecSecureSettingsOutput) Entries() LogstashSpecSecureSettingsEntriesArrayOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettings) []LogstashSpecSecureSettingsEntries { return v.Entries }).(LogstashSpecSecureSettingsEntriesArrayOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecSecureSettingsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettings) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecSecureSettingsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettings)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsArrayOutput) ToLogstashSpecSecureSettingsArrayOutput() LogstashSpecSecureSettingsArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsArrayOutput) ToLogstashSpecSecureSettingsArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsArrayOutput) Index(i pulumi.IntInput) LogstashSpecSecureSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecSecureSettings {
		return vs[0].([]LogstashSpecSecureSettings)[vs[1].(int)]
	}).(LogstashSpecSecureSettingsOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntries struct {
	// Key is the key contained in the secret.
	Key *string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// LogstashSpecSecureSettingsEntriesInput is an input type that accepts LogstashSpecSecureSettingsEntriesArgs and LogstashSpecSecureSettingsEntriesOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsEntriesInput` via:
//
//	LogstashSpecSecureSettingsEntriesArgs{...}
type LogstashSpecSecureSettingsEntriesInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsEntriesOutput() LogstashSpecSecureSettingsEntriesOutput
	ToLogstashSpecSecureSettingsEntriesOutputWithContext(context.Context) LogstashSpecSecureSettingsEntriesOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (LogstashSpecSecureSettingsEntriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsEntriesArgs) ToLogstashSpecSecureSettingsEntriesOutput() LogstashSpecSecureSettingsEntriesOutput {
	return i.ToLogstashSpecSecureSettingsEntriesOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsEntriesArgs) ToLogstashSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsEntriesOutput)
}

// LogstashSpecSecureSettingsEntriesArrayInput is an input type that accepts LogstashSpecSecureSettingsEntriesArray and LogstashSpecSecureSettingsEntriesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsEntriesArrayInput` via:
//
//	LogstashSpecSecureSettingsEntriesArray{ LogstashSpecSecureSettingsEntriesArgs{...} }
type LogstashSpecSecureSettingsEntriesArrayInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsEntriesArrayOutput() LogstashSpecSecureSettingsEntriesArrayOutput
	ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(context.Context) LogstashSpecSecureSettingsEntriesArrayOutput
}

type LogstashSpecSecureSettingsEntriesArray []LogstashSpecSecureSettingsEntriesInput

func (LogstashSpecSecureSettingsEntriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsEntriesArray) ToLogstashSpecSecureSettingsEntriesArrayOutput() LogstashSpecSecureSettingsEntriesArrayOutput {
	return i.ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsEntriesArray) ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsEntriesArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsEntriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsEntriesOutput) ToLogstashSpecSecureSettingsEntriesOutput() LogstashSpecSecureSettingsEntriesOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesOutput) ToLogstashSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesOutput {
	return o
}

// Key is the key contained in the secret.
func (o LogstashSpecSecureSettingsEntriesOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsEntries) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o LogstashSpecSecureSettingsEntriesOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsEntries) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type LogstashSpecSecureSettingsEntriesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsEntriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsEntriesArrayOutput) ToLogstashSpecSecureSettingsEntriesArrayOutput() LogstashSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesArrayOutput) ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesArrayOutput) Index(i pulumi.IntInput) LogstashSpecSecureSettingsEntriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecSecureSettingsEntries {
		return vs[0].([]LogstashSpecSecureSettingsEntries)[vs[1].(int)]
	}).(LogstashSpecSecureSettingsEntriesOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesPatch struct {
	// Key is the key contained in the secret.
	Key *string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// LogstashSpecSecureSettingsEntriesPatchInput is an input type that accepts LogstashSpecSecureSettingsEntriesPatchArgs and LogstashSpecSecureSettingsEntriesPatchOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsEntriesPatchInput` via:
//
//	LogstashSpecSecureSettingsEntriesPatchArgs{...}
type LogstashSpecSecureSettingsEntriesPatchInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsEntriesPatchOutput() LogstashSpecSecureSettingsEntriesPatchOutput
	ToLogstashSpecSecureSettingsEntriesPatchOutputWithContext(context.Context) LogstashSpecSecureSettingsEntriesPatchOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesPatchArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (LogstashSpecSecureSettingsEntriesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsEntriesPatchArgs) ToLogstashSpecSecureSettingsEntriesPatchOutput() LogstashSpecSecureSettingsEntriesPatchOutput {
	return i.ToLogstashSpecSecureSettingsEntriesPatchOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsEntriesPatchArgs) ToLogstashSpecSecureSettingsEntriesPatchOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsEntriesPatchOutput)
}

// LogstashSpecSecureSettingsEntriesPatchArrayInput is an input type that accepts LogstashSpecSecureSettingsEntriesPatchArray and LogstashSpecSecureSettingsEntriesPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsEntriesPatchArrayInput` via:
//
//	LogstashSpecSecureSettingsEntriesPatchArray{ LogstashSpecSecureSettingsEntriesPatchArgs{...} }
type LogstashSpecSecureSettingsEntriesPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsEntriesPatchArrayOutput() LogstashSpecSecureSettingsEntriesPatchArrayOutput
	ToLogstashSpecSecureSettingsEntriesPatchArrayOutputWithContext(context.Context) LogstashSpecSecureSettingsEntriesPatchArrayOutput
}

type LogstashSpecSecureSettingsEntriesPatchArray []LogstashSpecSecureSettingsEntriesPatchInput

func (LogstashSpecSecureSettingsEntriesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsEntriesPatchArray) ToLogstashSpecSecureSettingsEntriesPatchArrayOutput() LogstashSpecSecureSettingsEntriesPatchArrayOutput {
	return i.ToLogstashSpecSecureSettingsEntriesPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsEntriesPatchArray) ToLogstashSpecSecureSettingsEntriesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsEntriesPatchArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsEntriesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsEntriesPatchOutput) ToLogstashSpecSecureSettingsEntriesPatchOutput() LogstashSpecSecureSettingsEntriesPatchOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesPatchOutput) ToLogstashSpecSecureSettingsEntriesPatchOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesPatchOutput {
	return o
}

// Key is the key contained in the secret.
func (o LogstashSpecSecureSettingsEntriesPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsEntriesPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o LogstashSpecSecureSettingsEntriesPatchOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsEntriesPatch) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type LogstashSpecSecureSettingsEntriesPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsEntriesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsEntriesPatchArrayOutput) ToLogstashSpecSecureSettingsEntriesPatchArrayOutput() LogstashSpecSecureSettingsEntriesPatchArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesPatchArrayOutput) ToLogstashSpecSecureSettingsEntriesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesPatchArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecSecureSettingsEntriesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecSecureSettingsEntriesPatch {
		return vs[0].([]LogstashSpecSecureSettingsEntriesPatch)[vs[1].(int)]
	}).(LogstashSpecSecureSettingsEntriesPatchOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsPatch struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []LogstashSpecSecureSettingsEntriesPatch `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecSecureSettingsPatchInput is an input type that accepts LogstashSpecSecureSettingsPatchArgs and LogstashSpecSecureSettingsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsPatchInput` via:
//
//	LogstashSpecSecureSettingsPatchArgs{...}
type LogstashSpecSecureSettingsPatchInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsPatchOutput() LogstashSpecSecureSettingsPatchOutput
	ToLogstashSpecSecureSettingsPatchOutputWithContext(context.Context) LogstashSpecSecureSettingsPatchOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsPatchArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries LogstashSpecSecureSettingsEntriesPatchArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecSecureSettingsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsPatch)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsPatchArgs) ToLogstashSpecSecureSettingsPatchOutput() LogstashSpecSecureSettingsPatchOutput {
	return i.ToLogstashSpecSecureSettingsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsPatchArgs) ToLogstashSpecSecureSettingsPatchOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsPatchOutput)
}

// LogstashSpecSecureSettingsPatchArrayInput is an input type that accepts LogstashSpecSecureSettingsPatchArray and LogstashSpecSecureSettingsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsPatchArrayInput` via:
//
//	LogstashSpecSecureSettingsPatchArray{ LogstashSpecSecureSettingsPatchArgs{...} }
type LogstashSpecSecureSettingsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsPatchArrayOutput() LogstashSpecSecureSettingsPatchArrayOutput
	ToLogstashSpecSecureSettingsPatchArrayOutputWithContext(context.Context) LogstashSpecSecureSettingsPatchArrayOutput
}

type LogstashSpecSecureSettingsPatchArray []LogstashSpecSecureSettingsPatchInput

func (LogstashSpecSecureSettingsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsPatch)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsPatchArray) ToLogstashSpecSecureSettingsPatchArrayOutput() LogstashSpecSecureSettingsPatchArrayOutput {
	return i.ToLogstashSpecSecureSettingsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsPatchArray) ToLogstashSpecSecureSettingsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsPatchArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsPatch)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsPatchOutput) ToLogstashSpecSecureSettingsPatchOutput() LogstashSpecSecureSettingsPatchOutput {
	return o
}

func (o LogstashSpecSecureSettingsPatchOutput) ToLogstashSpecSecureSettingsPatchOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsPatchOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o LogstashSpecSecureSettingsPatchOutput) Entries() LogstashSpecSecureSettingsEntriesPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsPatch) []LogstashSpecSecureSettingsEntriesPatch { return v.Entries }).(LogstashSpecSecureSettingsEntriesPatchArrayOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecSecureSettingsPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecSecureSettingsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsPatch)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsPatchArrayOutput) ToLogstashSpecSecureSettingsPatchArrayOutput() LogstashSpecSecureSettingsPatchArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsPatchArrayOutput) ToLogstashSpecSecureSettingsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsPatchArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecSecureSettingsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecSecureSettingsPatch {
		return vs[0].([]LogstashSpecSecureSettingsPatch)[vs[1].(int)]
	}).(LogstashSpecSecureSettingsPatchOutput)
}

type LogstashSpecServices struct {
	Name    *string                      `pulumi:"name"`
	Service *LogstashSpecServicesService `pulumi:"service"`
	Tls     *LogstashSpecServicesTls     `pulumi:"tls"`
}

// LogstashSpecServicesInput is an input type that accepts LogstashSpecServicesArgs and LogstashSpecServicesOutput values.
// You can construct a concrete instance of `LogstashSpecServicesInput` via:
//
//	LogstashSpecServicesArgs{...}
type LogstashSpecServicesInput interface {
	pulumi.Input

	ToLogstashSpecServicesOutput() LogstashSpecServicesOutput
	ToLogstashSpecServicesOutputWithContext(context.Context) LogstashSpecServicesOutput
}

type LogstashSpecServicesArgs struct {
	Name    pulumi.StringPtrInput               `pulumi:"name"`
	Service LogstashSpecServicesServicePtrInput `pulumi:"service"`
	Tls     LogstashSpecServicesTlsPtrInput     `pulumi:"tls"`
}

func (LogstashSpecServicesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServices)(nil)).Elem()
}

func (i LogstashSpecServicesArgs) ToLogstashSpecServicesOutput() LogstashSpecServicesOutput {
	return i.ToLogstashSpecServicesOutputWithContext(context.Background())
}

func (i LogstashSpecServicesArgs) ToLogstashSpecServicesOutputWithContext(ctx context.Context) LogstashSpecServicesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesOutput)
}

// LogstashSpecServicesArrayInput is an input type that accepts LogstashSpecServicesArray and LogstashSpecServicesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesArrayInput` via:
//
//	LogstashSpecServicesArray{ LogstashSpecServicesArgs{...} }
type LogstashSpecServicesArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesArrayOutput() LogstashSpecServicesArrayOutput
	ToLogstashSpecServicesArrayOutputWithContext(context.Context) LogstashSpecServicesArrayOutput
}

type LogstashSpecServicesArray []LogstashSpecServicesInput

func (LogstashSpecServicesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServices)(nil)).Elem()
}

func (i LogstashSpecServicesArray) ToLogstashSpecServicesArrayOutput() LogstashSpecServicesArrayOutput {
	return i.ToLogstashSpecServicesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesArray) ToLogstashSpecServicesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesArrayOutput)
}

type LogstashSpecServicesOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServices)(nil)).Elem()
}

func (o LogstashSpecServicesOutput) ToLogstashSpecServicesOutput() LogstashSpecServicesOutput {
	return o
}

func (o LogstashSpecServicesOutput) ToLogstashSpecServicesOutputWithContext(ctx context.Context) LogstashSpecServicesOutput {
	return o
}

func (o LogstashSpecServicesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServices) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesOutput) Service() LogstashSpecServicesServicePtrOutput {
	return o.ApplyT(func(v LogstashSpecServices) *LogstashSpecServicesService { return v.Service }).(LogstashSpecServicesServicePtrOutput)
}

func (o LogstashSpecServicesOutput) Tls() LogstashSpecServicesTlsPtrOutput {
	return o.ApplyT(func(v LogstashSpecServices) *LogstashSpecServicesTls { return v.Tls }).(LogstashSpecServicesTlsPtrOutput)
}

type LogstashSpecServicesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServices)(nil)).Elem()
}

func (o LogstashSpecServicesArrayOutput) ToLogstashSpecServicesArrayOutput() LogstashSpecServicesArrayOutput {
	return o
}

func (o LogstashSpecServicesArrayOutput) ToLogstashSpecServicesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesArrayOutput {
	return o
}

func (o LogstashSpecServicesArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServices {
		return vs[0].([]LogstashSpecServices)[vs[1].(int)]
	}).(LogstashSpecServicesOutput)
}

type LogstashSpecServicesPatch struct {
	Name    *string                           `pulumi:"name"`
	Service *LogstashSpecServicesServicePatch `pulumi:"service"`
	Tls     *LogstashSpecServicesTlsPatch     `pulumi:"tls"`
}

// LogstashSpecServicesPatchInput is an input type that accepts LogstashSpecServicesPatchArgs and LogstashSpecServicesPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesPatchInput` via:
//
//	LogstashSpecServicesPatchArgs{...}
type LogstashSpecServicesPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesPatchOutput() LogstashSpecServicesPatchOutput
	ToLogstashSpecServicesPatchOutputWithContext(context.Context) LogstashSpecServicesPatchOutput
}

type LogstashSpecServicesPatchArgs struct {
	Name    pulumi.StringPtrInput                    `pulumi:"name"`
	Service LogstashSpecServicesServicePatchPtrInput `pulumi:"service"`
	Tls     LogstashSpecServicesTlsPatchPtrInput     `pulumi:"tls"`
}

func (LogstashSpecServicesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesPatch)(nil)).Elem()
}

func (i LogstashSpecServicesPatchArgs) ToLogstashSpecServicesPatchOutput() LogstashSpecServicesPatchOutput {
	return i.ToLogstashSpecServicesPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesPatchArgs) ToLogstashSpecServicesPatchOutputWithContext(ctx context.Context) LogstashSpecServicesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesPatchOutput)
}

// LogstashSpecServicesPatchArrayInput is an input type that accepts LogstashSpecServicesPatchArray and LogstashSpecServicesPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesPatchArrayInput` via:
//
//	LogstashSpecServicesPatchArray{ LogstashSpecServicesPatchArgs{...} }
type LogstashSpecServicesPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesPatchArrayOutput() LogstashSpecServicesPatchArrayOutput
	ToLogstashSpecServicesPatchArrayOutputWithContext(context.Context) LogstashSpecServicesPatchArrayOutput
}

type LogstashSpecServicesPatchArray []LogstashSpecServicesPatchInput

func (LogstashSpecServicesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesPatch)(nil)).Elem()
}

func (i LogstashSpecServicesPatchArray) ToLogstashSpecServicesPatchArrayOutput() LogstashSpecServicesPatchArrayOutput {
	return i.ToLogstashSpecServicesPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesPatchArray) ToLogstashSpecServicesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecServicesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesPatchArrayOutput)
}

type LogstashSpecServicesPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesPatch)(nil)).Elem()
}

func (o LogstashSpecServicesPatchOutput) ToLogstashSpecServicesPatchOutput() LogstashSpecServicesPatchOutput {
	return o
}

func (o LogstashSpecServicesPatchOutput) ToLogstashSpecServicesPatchOutputWithContext(ctx context.Context) LogstashSpecServicesPatchOutput {
	return o
}

func (o LogstashSpecServicesPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesPatchOutput) Service() LogstashSpecServicesServicePatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesPatch) *LogstashSpecServicesServicePatch { return v.Service }).(LogstashSpecServicesServicePatchPtrOutput)
}

func (o LogstashSpecServicesPatchOutput) Tls() LogstashSpecServicesTlsPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesPatch) *LogstashSpecServicesTlsPatch { return v.Tls }).(LogstashSpecServicesTlsPatchPtrOutput)
}

type LogstashSpecServicesPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesPatch)(nil)).Elem()
}

func (o LogstashSpecServicesPatchArrayOutput) ToLogstashSpecServicesPatchArrayOutput() LogstashSpecServicesPatchArrayOutput {
	return o
}

func (o LogstashSpecServicesPatchArrayOutput) ToLogstashSpecServicesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecServicesPatchArrayOutput {
	return o
}

func (o LogstashSpecServicesPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesPatch {
		return vs[0].([]LogstashSpecServicesPatch)[vs[1].(int)]
	}).(LogstashSpecServicesPatchOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesService struct {
	Metadata *LogstashSpecServicesServiceMetadata `pulumi:"metadata"`
	Spec     *LogstashSpecServicesServiceSpec     `pulumi:"spec"`
}

// LogstashSpecServicesServiceInput is an input type that accepts LogstashSpecServicesServiceArgs and LogstashSpecServicesServiceOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceInput` via:
//
//	LogstashSpecServicesServiceArgs{...}
type LogstashSpecServicesServiceInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceOutput() LogstashSpecServicesServiceOutput
	ToLogstashSpecServicesServiceOutputWithContext(context.Context) LogstashSpecServicesServiceOutput
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServiceArgs struct {
	Metadata LogstashSpecServicesServiceMetadataPtrInput `pulumi:"metadata"`
	Spec     LogstashSpecServicesServiceSpecPtrInput     `pulumi:"spec"`
}

func (LogstashSpecServicesServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesService)(nil)).Elem()
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServiceOutput() LogstashSpecServicesServiceOutput {
	return i.ToLogstashSpecServicesServiceOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServiceOutputWithContext(ctx context.Context) LogstashSpecServicesServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceOutput)
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return i.ToLogstashSpecServicesServicePtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceOutput).ToLogstashSpecServicesServicePtrOutputWithContext(ctx)
}

// LogstashSpecServicesServicePtrInput is an input type that accepts LogstashSpecServicesServiceArgs, LogstashSpecServicesServicePtr and LogstashSpecServicesServicePtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServicePtrInput` via:
//
//	        LogstashSpecServicesServiceArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServicePtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput
	ToLogstashSpecServicesServicePtrOutputWithContext(context.Context) LogstashSpecServicesServicePtrOutput
}

type logstashSpecServicesServicePtrType LogstashSpecServicesServiceArgs

func LogstashSpecServicesServicePtr(v *LogstashSpecServicesServiceArgs) LogstashSpecServicesServicePtrInput {
	return (*logstashSpecServicesServicePtrType)(v)
}

func (*logstashSpecServicesServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesService)(nil)).Elem()
}

func (i *logstashSpecServicesServicePtrType) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return i.ToLogstashSpecServicesServicePtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServicePtrType) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServicePtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServiceOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesService)(nil)).Elem()
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServiceOutput() LogstashSpecServicesServiceOutput {
	return o
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServiceOutputWithContext(ctx context.Context) LogstashSpecServicesServiceOutput {
	return o
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return o.ToLogstashSpecServicesServicePtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesService) *LogstashSpecServicesService {
		return &v
	}).(LogstashSpecServicesServicePtrOutput)
}

func (o LogstashSpecServicesServiceOutput) Metadata() LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesService) *LogstashSpecServicesServiceMetadata { return v.Metadata }).(LogstashSpecServicesServiceMetadataPtrOutput)
}

func (o LogstashSpecServicesServiceOutput) Spec() LogstashSpecServicesServiceSpecPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesService) *LogstashSpecServicesServiceSpec { return v.Spec }).(LogstashSpecServicesServiceSpecPtrOutput)
}

type LogstashSpecServicesServicePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesService)(nil)).Elem()
}

func (o LogstashSpecServicesServicePtrOutput) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return o
}

func (o LogstashSpecServicesServicePtrOutput) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return o
}

func (o LogstashSpecServicesServicePtrOutput) Elem() LogstashSpecServicesServiceOutput {
	return o.ApplyT(func(v *LogstashSpecServicesService) LogstashSpecServicesService {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesService
		return ret
	}).(LogstashSpecServicesServiceOutput)
}

func (o LogstashSpecServicesServicePtrOutput) Metadata() LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesService) *LogstashSpecServicesServiceMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(LogstashSpecServicesServiceMetadataPtrOutput)
}

func (o LogstashSpecServicesServicePtrOutput) Spec() LogstashSpecServicesServiceSpecPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesService) *LogstashSpecServicesServiceSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(LogstashSpecServicesServiceSpecPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// LogstashSpecServicesServiceMetadataInput is an input type that accepts LogstashSpecServicesServiceMetadataArgs and LogstashSpecServicesServiceMetadataOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceMetadataInput` via:
//
//	LogstashSpecServicesServiceMetadataArgs{...}
type LogstashSpecServicesServiceMetadataInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceMetadataOutput() LogstashSpecServicesServiceMetadataOutput
	ToLogstashSpecServicesServiceMetadataOutputWithContext(context.Context) LogstashSpecServicesServiceMetadataOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (LogstashSpecServicesServiceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataOutput() LogstashSpecServicesServiceMetadataOutput {
	return i.ToLogstashSpecServicesServiceMetadataOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataOutput)
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return i.ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataOutput).ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceMetadataPtrInput is an input type that accepts LogstashSpecServicesServiceMetadataArgs, LogstashSpecServicesServiceMetadataPtr and LogstashSpecServicesServiceMetadataPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceMetadataPtrInput` via:
//
//	        LogstashSpecServicesServiceMetadataArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceMetadataPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput
	ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Context) LogstashSpecServicesServiceMetadataPtrOutput
}

type logstashSpecServicesServiceMetadataPtrType LogstashSpecServicesServiceMetadataArgs

func LogstashSpecServicesServiceMetadataPtr(v *LogstashSpecServicesServiceMetadataArgs) LogstashSpecServicesServiceMetadataPtrInput {
	return (*logstashSpecServicesServiceMetadataPtrType)(v)
}

func (*logstashSpecServicesServiceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (i *logstashSpecServicesServiceMetadataPtrType) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return i.ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceMetadataPtrType) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataOutput() LogstashSpecServicesServiceMetadataOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceMetadata) *LogstashSpecServicesServiceMetadata {
		return &v
	}).(LogstashSpecServicesServiceMetadataPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceMetadataPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Elem() LogstashSpecServicesServiceMetadataOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) LogstashSpecServicesServiceMetadata {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceMetadata
		return ret
	}).(LogstashSpecServicesServiceMetadataOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// LogstashSpecServicesServiceMetadataPatchInput is an input type that accepts LogstashSpecServicesServiceMetadataPatchArgs and LogstashSpecServicesServiceMetadataPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceMetadataPatchInput` via:
//
//	LogstashSpecServicesServiceMetadataPatchArgs{...}
type LogstashSpecServicesServiceMetadataPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceMetadataPatchOutput() LogstashSpecServicesServiceMetadataPatchOutput
	ToLogstashSpecServicesServiceMetadataPatchOutputWithContext(context.Context) LogstashSpecServicesServiceMetadataPatchOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (LogstashSpecServicesServiceMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceMetadataPatch)(nil)).Elem()
}

func (i LogstashSpecServicesServiceMetadataPatchArgs) ToLogstashSpecServicesServiceMetadataPatchOutput() LogstashSpecServicesServiceMetadataPatchOutput {
	return i.ToLogstashSpecServicesServiceMetadataPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceMetadataPatchArgs) ToLogstashSpecServicesServiceMetadataPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataPatchOutput)
}

func (i LogstashSpecServicesServiceMetadataPatchArgs) ToLogstashSpecServicesServiceMetadataPatchPtrOutput() LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceMetadataPatchArgs) ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataPatchOutput).ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceMetadataPatchPtrInput is an input type that accepts LogstashSpecServicesServiceMetadataPatchArgs, LogstashSpecServicesServiceMetadataPatchPtr and LogstashSpecServicesServiceMetadataPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceMetadataPatchPtrInput` via:
//
//	        LogstashSpecServicesServiceMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceMetadataPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceMetadataPatchPtrOutput() LogstashSpecServicesServiceMetadataPatchPtrOutput
	ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(context.Context) LogstashSpecServicesServiceMetadataPatchPtrOutput
}

type logstashSpecServicesServiceMetadataPatchPtrType LogstashSpecServicesServiceMetadataPatchArgs

func LogstashSpecServicesServiceMetadataPatchPtr(v *LogstashSpecServicesServiceMetadataPatchArgs) LogstashSpecServicesServiceMetadataPatchPtrInput {
	return (*logstashSpecServicesServiceMetadataPatchPtrType)(v)
}

func (*logstashSpecServicesServiceMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceMetadataPatch)(nil)).Elem()
}

func (i *logstashSpecServicesServiceMetadataPatchPtrType) ToLogstashSpecServicesServiceMetadataPatchPtrOutput() LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceMetadataPatchPtrType) ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataPatchPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceMetadataPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) ToLogstashSpecServicesServiceMetadataPatchOutput() LogstashSpecServicesServiceMetadataPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) ToLogstashSpecServicesServiceMetadataPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) ToLogstashSpecServicesServiceMetadataPatchPtrOutput() LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return o.ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceMetadataPatch) *LogstashSpecServicesServiceMetadataPatch {
		return &v
	}).(LogstashSpecServicesServiceMetadataPatchPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadataPatch) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceMetadataPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) ToLogstashSpecServicesServiceMetadataPatchPtrOutput() LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) ToLogstashSpecServicesServiceMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) Elem() LogstashSpecServicesServiceMetadataPatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadataPatch) LogstashSpecServicesServiceMetadataPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceMetadataPatch
		return ret
	}).(LogstashSpecServicesServiceMetadataPatchOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServicePatch struct {
	Metadata *LogstashSpecServicesServiceMetadataPatch `pulumi:"metadata"`
	Spec     *LogstashSpecServicesServiceSpecPatch     `pulumi:"spec"`
}

// LogstashSpecServicesServicePatchInput is an input type that accepts LogstashSpecServicesServicePatchArgs and LogstashSpecServicesServicePatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServicePatchInput` via:
//
//	LogstashSpecServicesServicePatchArgs{...}
type LogstashSpecServicesServicePatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesServicePatchOutput() LogstashSpecServicesServicePatchOutput
	ToLogstashSpecServicesServicePatchOutputWithContext(context.Context) LogstashSpecServicesServicePatchOutput
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServicePatchArgs struct {
	Metadata LogstashSpecServicesServiceMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     LogstashSpecServicesServiceSpecPatchPtrInput     `pulumi:"spec"`
}

func (LogstashSpecServicesServicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServicePatch)(nil)).Elem()
}

func (i LogstashSpecServicesServicePatchArgs) ToLogstashSpecServicesServicePatchOutput() LogstashSpecServicesServicePatchOutput {
	return i.ToLogstashSpecServicesServicePatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServicePatchArgs) ToLogstashSpecServicesServicePatchOutputWithContext(ctx context.Context) LogstashSpecServicesServicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServicePatchOutput)
}

func (i LogstashSpecServicesServicePatchArgs) ToLogstashSpecServicesServicePatchPtrOutput() LogstashSpecServicesServicePatchPtrOutput {
	return i.ToLogstashSpecServicesServicePatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServicePatchArgs) ToLogstashSpecServicesServicePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServicePatchOutput).ToLogstashSpecServicesServicePatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServicePatchPtrInput is an input type that accepts LogstashSpecServicesServicePatchArgs, LogstashSpecServicesServicePatchPtr and LogstashSpecServicesServicePatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServicePatchPtrInput` via:
//
//	        LogstashSpecServicesServicePatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServicePatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServicePatchPtrOutput() LogstashSpecServicesServicePatchPtrOutput
	ToLogstashSpecServicesServicePatchPtrOutputWithContext(context.Context) LogstashSpecServicesServicePatchPtrOutput
}

type logstashSpecServicesServicePatchPtrType LogstashSpecServicesServicePatchArgs

func LogstashSpecServicesServicePatchPtr(v *LogstashSpecServicesServicePatchArgs) LogstashSpecServicesServicePatchPtrInput {
	return (*logstashSpecServicesServicePatchPtrType)(v)
}

func (*logstashSpecServicesServicePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServicePatch)(nil)).Elem()
}

func (i *logstashSpecServicesServicePatchPtrType) ToLogstashSpecServicesServicePatchPtrOutput() LogstashSpecServicesServicePatchPtrOutput {
	return i.ToLogstashSpecServicesServicePatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServicePatchPtrType) ToLogstashSpecServicesServicePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServicePatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServicePatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServicePatch)(nil)).Elem()
}

func (o LogstashSpecServicesServicePatchOutput) ToLogstashSpecServicesServicePatchOutput() LogstashSpecServicesServicePatchOutput {
	return o
}

func (o LogstashSpecServicesServicePatchOutput) ToLogstashSpecServicesServicePatchOutputWithContext(ctx context.Context) LogstashSpecServicesServicePatchOutput {
	return o
}

func (o LogstashSpecServicesServicePatchOutput) ToLogstashSpecServicesServicePatchPtrOutput() LogstashSpecServicesServicePatchPtrOutput {
	return o.ToLogstashSpecServicesServicePatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServicePatchOutput) ToLogstashSpecServicesServicePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServicePatch) *LogstashSpecServicesServicePatch {
		return &v
	}).(LogstashSpecServicesServicePatchPtrOutput)
}

func (o LogstashSpecServicesServicePatchOutput) Metadata() LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServicePatch) *LogstashSpecServicesServiceMetadataPatch { return v.Metadata }).(LogstashSpecServicesServiceMetadataPatchPtrOutput)
}

func (o LogstashSpecServicesServicePatchOutput) Spec() LogstashSpecServicesServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServicePatch) *LogstashSpecServicesServiceSpecPatch { return v.Spec }).(LogstashSpecServicesServiceSpecPatchPtrOutput)
}

type LogstashSpecServicesServicePatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServicePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServicePatch)(nil)).Elem()
}

func (o LogstashSpecServicesServicePatchPtrOutput) ToLogstashSpecServicesServicePatchPtrOutput() LogstashSpecServicesServicePatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServicePatchPtrOutput) ToLogstashSpecServicesServicePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServicePatchPtrOutput) Elem() LogstashSpecServicesServicePatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServicePatch) LogstashSpecServicesServicePatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServicePatch
		return ret
	}).(LogstashSpecServicesServicePatchOutput)
}

func (o LogstashSpecServicesServicePatchPtrOutput) Metadata() LogstashSpecServicesServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServicePatch) *LogstashSpecServicesServiceMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(LogstashSpecServicesServiceMetadataPatchPtrOutput)
}

func (o LogstashSpecServicesServicePatchPtrOutput) Spec() LogstashSpecServicesServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServicePatch) *LogstashSpecServicesServiceSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(LogstashSpecServicesServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpec struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []LogstashSpecServicesServiceSpecPorts `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                               `pulumi:"sessionAffinity"`
	SessionAffinityConfig *LogstashSpecServicesServiceSpecSessionAffinityConfig `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// LogstashSpecServicesServiceSpecInput is an input type that accepts LogstashSpecServicesServiceSpecArgs and LogstashSpecServicesServiceSpecOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecInput` via:
//
//	LogstashSpecServicesServiceSpecArgs{...}
type LogstashSpecServicesServiceSpecInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecOutput() LogstashSpecServicesServiceSpecOutput
	ToLogstashSpecServicesServiceSpecOutputWithContext(context.Context) LogstashSpecServicesServiceSpecOutput
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports LogstashSpecServicesServiceSpecPortsArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                        `pulumi:"sessionAffinity"`
	SessionAffinityConfig LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecServicesServiceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecOutput() LogstashSpecServicesServiceSpecOutput {
	return i.ToLogstashSpecServicesServiceSpecOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecOutput)
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecOutput).ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecPtrInput is an input type that accepts LogstashSpecServicesServiceSpecArgs, LogstashSpecServicesServiceSpecPtr and LogstashSpecServicesServiceSpecPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput
	ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPtrOutput
}

type logstashSpecServicesServiceSpecPtrType LogstashSpecServicesServiceSpecArgs

func LogstashSpecServicesServiceSpecPtr(v *LogstashSpecServicesServiceSpecArgs) LogstashSpecServicesServiceSpecPtrInput {
	return (*logstashSpecServicesServiceSpecPtrType)(v)
}

func (*logstashSpecServicesServiceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecPtrType) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecPtrType) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPtrOutput)
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecOutput() LogstashSpecServicesServiceSpecOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpec) *LogstashSpecServicesServiceSpec {
		return &v
	}).(LogstashSpecServicesServiceSpecPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o LogstashSpecServicesServiceSpecOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o LogstashSpecServicesServiceSpecOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o LogstashSpecServicesServiceSpecOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o LogstashSpecServicesServiceSpecOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o LogstashSpecServicesServiceSpecOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o LogstashSpecServicesServiceSpecOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o LogstashSpecServicesServiceSpecOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o LogstashSpecServicesServiceSpecOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o LogstashSpecServicesServiceSpecOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o LogstashSpecServicesServiceSpecOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o LogstashSpecServicesServiceSpecOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) Ports() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []LogstashSpecServicesServiceSpecPorts { return v.Ports }).(LogstashSpecServicesServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o LogstashSpecServicesServiceSpecOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o LogstashSpecServicesServiceSpecOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceSpecOutput) SessionAffinityConfig() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *LogstashSpecServicesServiceSpecSessionAffinityConfig {
		return v.SessionAffinityConfig
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o LogstashSpecServicesServiceSpecOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o LogstashSpecServicesServiceSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceSpecPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPtrOutput) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPtrOutput) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPtrOutput) Elem() LogstashSpecServicesServiceSpecOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) LogstashSpecServicesServiceSpec {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpec
		return ret
	}).(LogstashSpecServicesServiceSpecOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o LogstashSpecServicesServiceSpecPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o LogstashSpecServicesServiceSpecPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o LogstashSpecServicesServiceSpecPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o LogstashSpecServicesServiceSpecPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o LogstashSpecServicesServiceSpecPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o LogstashSpecServicesServiceSpecPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o LogstashSpecServicesServiceSpecPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o LogstashSpecServicesServiceSpecPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o LogstashSpecServicesServiceSpecPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o LogstashSpecServicesServiceSpecPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o LogstashSpecServicesServiceSpecPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) Ports() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []LogstashSpecServicesServiceSpecPorts {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(LogstashSpecServicesServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o LogstashSpecServicesServiceSpecPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o LogstashSpecServicesServiceSpecPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceSpecPtrOutput) SessionAffinityConfig() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *LogstashSpecServicesServiceSpecSessionAffinityConfig {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o LogstashSpecServicesServiceSpecPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o LogstashSpecServicesServiceSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecPatch struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []LogstashSpecServicesServiceSpecPortsPatch `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                                    `pulumi:"sessionAffinity"`
	SessionAffinityConfig *LogstashSpecServicesServiceSpecSessionAffinityConfigPatch `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// LogstashSpecServicesServiceSpecPatchInput is an input type that accepts LogstashSpecServicesServiceSpecPatchArgs and LogstashSpecServicesServiceSpecPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPatchInput` via:
//
//	LogstashSpecServicesServiceSpecPatchArgs{...}
type LogstashSpecServicesServiceSpecPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPatchOutput() LogstashSpecServicesServiceSpecPatchOutput
	ToLogstashSpecServicesServiceSpecPatchOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPatchOutput
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecPatchArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports LogstashSpecServicesServiceSpecPortsPatchArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                             `pulumi:"sessionAffinity"`
	SessionAffinityConfig LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecServicesServiceSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPatch)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPatchArgs) ToLogstashSpecServicesServiceSpecPatchOutput() LogstashSpecServicesServiceSpecPatchOutput {
	return i.ToLogstashSpecServicesServiceSpecPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPatchArgs) ToLogstashSpecServicesServiceSpecPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPatchOutput)
}

func (i LogstashSpecServicesServiceSpecPatchArgs) ToLogstashSpecServicesServiceSpecPatchPtrOutput() LogstashSpecServicesServiceSpecPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPatchArgs) ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPatchOutput).ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecPatchPtrInput is an input type that accepts LogstashSpecServicesServiceSpecPatchArgs, LogstashSpecServicesServiceSpecPatchPtr and LogstashSpecServicesServiceSpecPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPatchPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPatchPtrOutput() LogstashSpecServicesServiceSpecPatchPtrOutput
	ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPatchPtrOutput
}

type logstashSpecServicesServiceSpecPatchPtrType LogstashSpecServicesServiceSpecPatchArgs

func LogstashSpecServicesServiceSpecPatchPtr(v *LogstashSpecServicesServiceSpecPatchArgs) LogstashSpecServicesServiceSpecPatchPtrInput {
	return (*logstashSpecServicesServiceSpecPatchPtrType)(v)
}

func (*logstashSpecServicesServiceSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecPatch)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecPatchPtrType) ToLogstashSpecServicesServiceSpecPatchPtrOutput() LogstashSpecServicesServiceSpecPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecPatchPtrType) ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPatchOutput) ToLogstashSpecServicesServiceSpecPatchOutput() LogstashSpecServicesServiceSpecPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPatchOutput) ToLogstashSpecServicesServiceSpecPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPatchOutput) ToLogstashSpecServicesServiceSpecPatchPtrOutput() LogstashSpecServicesServiceSpecPatchPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecPatchOutput) ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecPatch) *LogstashSpecServicesServiceSpecPatch {
		return &v
	}).(LogstashSpecServicesServiceSpecPatchPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o LogstashSpecServicesServiceSpecPatchOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o LogstashSpecServicesServiceSpecPatchOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o LogstashSpecServicesServiceSpecPatchOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o LogstashSpecServicesServiceSpecPatchOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o LogstashSpecServicesServiceSpecPatchOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o LogstashSpecServicesServiceSpecPatchOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o LogstashSpecServicesServiceSpecPatchOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o LogstashSpecServicesServiceSpecPatchOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o LogstashSpecServicesServiceSpecPatchOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o LogstashSpecServicesServiceSpecPatchOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o LogstashSpecServicesServiceSpecPatchOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchOutput) Ports() LogstashSpecServicesServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) []LogstashSpecServicesServiceSpecPortsPatch {
		return v.Ports
	}).(LogstashSpecServicesServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o LogstashSpecServicesServiceSpecPatchOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o LogstashSpecServicesServiceSpecPatchOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceSpecPatchOutput) SessionAffinityConfig() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *LogstashSpecServicesServiceSpecSessionAffinityConfigPatch {
		return v.SessionAffinityConfig
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o LogstashSpecServicesServiceSpecPatchOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o LogstashSpecServicesServiceSpecPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ToLogstashSpecServicesServiceSpecPatchPtrOutput() LogstashSpecServicesServiceSpecPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ToLogstashSpecServicesServiceSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPatchPtrOutput) Elem() LogstashSpecServicesServiceSpecPatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) LogstashSpecServicesServiceSpecPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecPatch
		return ret
	}).(LogstashSpecServicesServiceSpecPatchOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) Ports() LogstashSpecServicesServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) []LogstashSpecServicesServiceSpecPortsPatch {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(LogstashSpecServicesServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceSpecPatchPtrOutput) SessionAffinityConfig() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *LogstashSpecServicesServiceSpecSessionAffinityConfigPatch {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o LogstashSpecServicesServiceSpecPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPorts struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// LogstashSpecServicesServiceSpecPortsInput is an input type that accepts LogstashSpecServicesServiceSpecPortsArgs and LogstashSpecServicesServiceSpecPortsOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPortsInput` via:
//
//	LogstashSpecServicesServiceSpecPortsArgs{...}
type LogstashSpecServicesServiceSpecPortsInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPortsOutput() LogstashSpecServicesServiceSpecPortsOutput
	ToLogstashSpecServicesServiceSpecPortsOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPortsOutput
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (LogstashSpecServicesServiceSpecPortsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPortsArgs) ToLogstashSpecServicesServiceSpecPortsOutput() LogstashSpecServicesServiceSpecPortsOutput {
	return i.ToLogstashSpecServicesServiceSpecPortsOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPortsArgs) ToLogstashSpecServicesServiceSpecPortsOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPortsOutput)
}

// LogstashSpecServicesServiceSpecPortsArrayInput is an input type that accepts LogstashSpecServicesServiceSpecPortsArray and LogstashSpecServicesServiceSpecPortsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPortsArrayInput` via:
//
//	LogstashSpecServicesServiceSpecPortsArray{ LogstashSpecServicesServiceSpecPortsArgs{...} }
type LogstashSpecServicesServiceSpecPortsArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPortsArrayOutput() LogstashSpecServicesServiceSpecPortsArrayOutput
	ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPortsArrayOutput
}

type LogstashSpecServicesServiceSpecPortsArray []LogstashSpecServicesServiceSpecPortsInput

func (LogstashSpecServicesServiceSpecPortsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPortsArray) ToLogstashSpecServicesServiceSpecPortsArrayOutput() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return i.ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPortsArray) ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPortsArrayOutput)
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPortsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPortsOutput) ToLogstashSpecServicesServiceSpecPortsOutput() LogstashSpecServicesServiceSpecPortsOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsOutput) ToLogstashSpecServicesServiceSpecPortsOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o LogstashSpecServicesServiceSpecPortsOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o LogstashSpecServicesServiceSpecPortsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o LogstashSpecServicesServiceSpecPortsOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o LogstashSpecServicesServiceSpecPortsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o LogstashSpecServicesServiceSpecPortsOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o LogstashSpecServicesServiceSpecPortsOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type LogstashSpecServicesServiceSpecPortsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPortsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPortsArrayOutput) ToLogstashSpecServicesServiceSpecPortsArrayOutput() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsArrayOutput) ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesServiceSpecPortsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesServiceSpecPorts {
		return vs[0].([]LogstashSpecServicesServiceSpecPorts)[vs[1].(int)]
	}).(LogstashSpecServicesServiceSpecPortsOutput)
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsPatch struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// LogstashSpecServicesServiceSpecPortsPatchInput is an input type that accepts LogstashSpecServicesServiceSpecPortsPatchArgs and LogstashSpecServicesServiceSpecPortsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPortsPatchInput` via:
//
//	LogstashSpecServicesServiceSpecPortsPatchArgs{...}
type LogstashSpecServicesServiceSpecPortsPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPortsPatchOutput() LogstashSpecServicesServiceSpecPortsPatchOutput
	ToLogstashSpecServicesServiceSpecPortsPatchOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPortsPatchOutput
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsPatchArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (LogstashSpecServicesServiceSpecPortsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsPatch)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPortsPatchArgs) ToLogstashSpecServicesServiceSpecPortsPatchOutput() LogstashSpecServicesServiceSpecPortsPatchOutput {
	return i.ToLogstashSpecServicesServiceSpecPortsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPortsPatchArgs) ToLogstashSpecServicesServiceSpecPortsPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPortsPatchOutput)
}

// LogstashSpecServicesServiceSpecPortsPatchArrayInput is an input type that accepts LogstashSpecServicesServiceSpecPortsPatchArray and LogstashSpecServicesServiceSpecPortsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPortsPatchArrayInput` via:
//
//	LogstashSpecServicesServiceSpecPortsPatchArray{ LogstashSpecServicesServiceSpecPortsPatchArgs{...} }
type LogstashSpecServicesServiceSpecPortsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPortsPatchArrayOutput() LogstashSpecServicesServiceSpecPortsPatchArrayOutput
	ToLogstashSpecServicesServiceSpecPortsPatchArrayOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPortsPatchArrayOutput
}

type LogstashSpecServicesServiceSpecPortsPatchArray []LogstashSpecServicesServiceSpecPortsPatchInput

func (LogstashSpecServicesServiceSpecPortsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesServiceSpecPortsPatch)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPortsPatchArray) ToLogstashSpecServicesServiceSpecPortsPatchArrayOutput() LogstashSpecServicesServiceSpecPortsPatchArrayOutput {
	return i.ToLogstashSpecServicesServiceSpecPortsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPortsPatchArray) ToLogstashSpecServicesServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPortsPatchArrayOutput)
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPortsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPortsPatchOutput) ToLogstashSpecServicesServiceSpecPortsPatchOutput() LogstashSpecServicesServiceSpecPortsPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsPatchOutput) ToLogstashSpecServicesServiceSpecPortsPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsPatchOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o LogstashSpecServicesServiceSpecPortsPatchOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPortsPatch) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o LogstashSpecServicesServiceSpecPortsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPortsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o LogstashSpecServicesServiceSpecPortsPatchOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPortsPatch) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o LogstashSpecServicesServiceSpecPortsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPortsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o LogstashSpecServicesServiceSpecPortsPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPortsPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o LogstashSpecServicesServiceSpecPortsPatchOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPortsPatch) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type LogstashSpecServicesServiceSpecPortsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPortsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesServiceSpecPortsPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPortsPatchArrayOutput) ToLogstashSpecServicesServiceSpecPortsPatchArrayOutput() LogstashSpecServicesServiceSpecPortsPatchArrayOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsPatchArrayOutput) ToLogstashSpecServicesServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsPatchArrayOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesServiceSpecPortsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesServiceSpecPortsPatch {
		return vs[0].([]LogstashSpecServicesServiceSpecPortsPatch)[vs[1].(int)]
	}).(LogstashSpecServicesServiceSpecPortsPatchOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfig struct {
	ClientIP *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP `pulumi:"clientIP"`
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigArgs and LogstashSpecServicesServiceSpecSessionAffinityConfigOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigInput` via:
//
//	LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{...}
type LogstashSpecServicesServiceSpecSessionAffinityConfigInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigArgs struct {
	ClientIP LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrInput `pulumi:"clientIP"`
}

func (LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput)
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput).ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigArgs, LogstashSpecServicesServiceSpecSessionAffinityConfigPtr and LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput
}

type logstashSpecServicesServiceSpecSessionAffinityConfigPtrType LogstashSpecServicesServiceSpecSessionAffinityConfigArgs

func LogstashSpecServicesServiceSpecSessionAffinityConfigPtr(v *LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput {
	return (*logstashSpecServicesServiceSpecSessionAffinityConfigPtrType)(v)
}

func (*logstashSpecServicesServiceSpecSessionAffinityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecSessionAffinityConfig) *LogstashSpecServicesServiceSpecSessionAffinityConfig {
		return &v
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ClientIP() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecSessionAffinityConfig) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP {
		return v.ClientIP
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

type LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) Elem() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfig) LogstashSpecServicesServiceSpecSessionAffinityConfig {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecSessionAffinityConfig
		return ret
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput)
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ClientIP() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfig) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs and LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPInput` via:
//
//	LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs{...}
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput)
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput).ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs, LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtr and LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput
}

type logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrType LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs

func LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtr(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrInput {
	return (*logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrType)(v)
}

func (*logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP {
		return &v
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput) Elem() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP
		return ret
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIP) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs and LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchInput` via:
//
//	LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput).ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs, LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtr and LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
}

type logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrType LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs

func LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtr(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrInput {
	return (*logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrType)(v)
}

func (*logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch {
		return &v
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch) *int {
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) Elem() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch
		return ret
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigPatch struct {
	ClientIP *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch `pulumi:"clientIP"`
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigPatchInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs and LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigPatchInput` via:
//
//	LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs{...}
type LogstashSpecServicesServiceSpecSessionAffinityConfigPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs struct {
	ClientIP LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrInput `pulumi:"clientIP"`
}

func (LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput)
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput).ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs, LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtr and LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput
}

type logstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrType LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs

func LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtr(v *LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrInput {
	return (*logstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrType)(v)
}

func (*logstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecSessionAffinityConfigPatch) *LogstashSpecServicesServiceSpecSessionAffinityConfigPatch {
		return &v
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput)
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput) ClientIP() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecSessionAffinityConfigPatch) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch {
		return v.ClientIP
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

type LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput) Elem() LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigPatch) LogstashSpecServicesServiceSpecSessionAffinityConfigPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecSessionAffinityConfigPatch
		return ret
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput)
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput) ClientIP() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigPatch) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatch {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTls struct {
	Certificate           *LogstashSpecServicesTlsCertificate           `pulumi:"certificate"`
	SelfSignedCertificate *LogstashSpecServicesTlsSelfSignedCertificate `pulumi:"selfSignedCertificate"`
}

// LogstashSpecServicesTlsInput is an input type that accepts LogstashSpecServicesTlsArgs and LogstashSpecServicesTlsOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsInput` via:
//
//	LogstashSpecServicesTlsArgs{...}
type LogstashSpecServicesTlsInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsOutput() LogstashSpecServicesTlsOutput
	ToLogstashSpecServicesTlsOutputWithContext(context.Context) LogstashSpecServicesTlsOutput
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsArgs struct {
	Certificate           LogstashSpecServicesTlsCertificatePtrInput           `pulumi:"certificate"`
	SelfSignedCertificate LogstashSpecServicesTlsSelfSignedCertificatePtrInput `pulumi:"selfSignedCertificate"`
}

func (LogstashSpecServicesTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTls)(nil)).Elem()
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsOutput() LogstashSpecServicesTlsOutput {
	return i.ToLogstashSpecServicesTlsOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsOutputWithContext(ctx context.Context) LogstashSpecServicesTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsOutput)
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return i.ToLogstashSpecServicesTlsPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsOutput).ToLogstashSpecServicesTlsPtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsPtrInput is an input type that accepts LogstashSpecServicesTlsArgs, LogstashSpecServicesTlsPtr and LogstashSpecServicesTlsPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsPtrInput` via:
//
//	        LogstashSpecServicesTlsArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput
	ToLogstashSpecServicesTlsPtrOutputWithContext(context.Context) LogstashSpecServicesTlsPtrOutput
}

type logstashSpecServicesTlsPtrType LogstashSpecServicesTlsArgs

func LogstashSpecServicesTlsPtr(v *LogstashSpecServicesTlsArgs) LogstashSpecServicesTlsPtrInput {
	return (*logstashSpecServicesTlsPtrType)(v)
}

func (*logstashSpecServicesTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTls)(nil)).Elem()
}

func (i *logstashSpecServicesTlsPtrType) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return i.ToLogstashSpecServicesTlsPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsPtrType) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTls)(nil)).Elem()
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsOutput() LogstashSpecServicesTlsOutput {
	return o
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsOutputWithContext(ctx context.Context) LogstashSpecServicesTlsOutput {
	return o
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return o.ToLogstashSpecServicesTlsPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTls) *LogstashSpecServicesTls {
		return &v
	}).(LogstashSpecServicesTlsPtrOutput)
}

func (o LogstashSpecServicesTlsOutput) Certificate() LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTls) *LogstashSpecServicesTlsCertificate { return v.Certificate }).(LogstashSpecServicesTlsCertificatePtrOutput)
}

func (o LogstashSpecServicesTlsOutput) SelfSignedCertificate() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTls) *LogstashSpecServicesTlsSelfSignedCertificate {
		return v.SelfSignedCertificate
	}).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

type LogstashSpecServicesTlsPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTls)(nil)).Elem()
}

func (o LogstashSpecServicesTlsPtrOutput) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsPtrOutput) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsPtrOutput) Elem() LogstashSpecServicesTlsOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTls) LogstashSpecServicesTls {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTls
		return ret
	}).(LogstashSpecServicesTlsOutput)
}

func (o LogstashSpecServicesTlsPtrOutput) Certificate() LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTls) *LogstashSpecServicesTlsCertificate {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(LogstashSpecServicesTlsCertificatePtrOutput)
}

func (o LogstashSpecServicesTlsPtrOutput) SelfSignedCertificate() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTls) *LogstashSpecServicesTlsSelfSignedCertificate {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificate struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecServicesTlsCertificateInput is an input type that accepts LogstashSpecServicesTlsCertificateArgs and LogstashSpecServicesTlsCertificateOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsCertificateInput` via:
//
//	LogstashSpecServicesTlsCertificateArgs{...}
type LogstashSpecServicesTlsCertificateInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsCertificateOutput() LogstashSpecServicesTlsCertificateOutput
	ToLogstashSpecServicesTlsCertificateOutputWithContext(context.Context) LogstashSpecServicesTlsCertificateOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificateArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecServicesTlsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificateOutput() LogstashSpecServicesTlsCertificateOutput {
	return i.ToLogstashSpecServicesTlsCertificateOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificateOutput)
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificateOutput).ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsCertificatePtrInput is an input type that accepts LogstashSpecServicesTlsCertificateArgs, LogstashSpecServicesTlsCertificatePtr and LogstashSpecServicesTlsCertificatePtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsCertificatePtrInput` via:
//
//	        LogstashSpecServicesTlsCertificateArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsCertificatePtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput
	ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Context) LogstashSpecServicesTlsCertificatePtrOutput
}

type logstashSpecServicesTlsCertificatePtrType LogstashSpecServicesTlsCertificateArgs

func LogstashSpecServicesTlsCertificatePtr(v *LogstashSpecServicesTlsCertificateArgs) LogstashSpecServicesTlsCertificatePtrInput {
	return (*logstashSpecServicesTlsCertificatePtrType)(v)
}

func (*logstashSpecServicesTlsCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (i *logstashSpecServicesTlsCertificatePtrType) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsCertificatePtrType) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificateOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificateOutput() LogstashSpecServicesTlsCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsCertificate) *LogstashSpecServicesTlsCertificate {
		return &v
	}).(LogstashSpecServicesTlsCertificatePtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecServicesTlsCertificateOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsCertificate) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesTlsCertificatePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsCertificatePtrOutput) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePtrOutput) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePtrOutput) Elem() LogstashSpecServicesTlsCertificateOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsCertificate) LogstashSpecServicesTlsCertificate {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsCertificate
		return ret
	}).(LogstashSpecServicesTlsCertificateOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecServicesTlsCertificatePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsCertificate) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificatePatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecServicesTlsCertificatePatchInput is an input type that accepts LogstashSpecServicesTlsCertificatePatchArgs and LogstashSpecServicesTlsCertificatePatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsCertificatePatchInput` via:
//
//	LogstashSpecServicesTlsCertificatePatchArgs{...}
type LogstashSpecServicesTlsCertificatePatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsCertificatePatchOutput() LogstashSpecServicesTlsCertificatePatchOutput
	ToLogstashSpecServicesTlsCertificatePatchOutputWithContext(context.Context) LogstashSpecServicesTlsCertificatePatchOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificatePatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecServicesTlsCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsCertificatePatch)(nil)).Elem()
}

func (i LogstashSpecServicesTlsCertificatePatchArgs) ToLogstashSpecServicesTlsCertificatePatchOutput() LogstashSpecServicesTlsCertificatePatchOutput {
	return i.ToLogstashSpecServicesTlsCertificatePatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsCertificatePatchArgs) ToLogstashSpecServicesTlsCertificatePatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificatePatchOutput)
}

func (i LogstashSpecServicesTlsCertificatePatchArgs) ToLogstashSpecServicesTlsCertificatePatchPtrOutput() LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return i.ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsCertificatePatchArgs) ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificatePatchOutput).ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsCertificatePatchPtrInput is an input type that accepts LogstashSpecServicesTlsCertificatePatchArgs, LogstashSpecServicesTlsCertificatePatchPtr and LogstashSpecServicesTlsCertificatePatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsCertificatePatchPtrInput` via:
//
//	        LogstashSpecServicesTlsCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsCertificatePatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsCertificatePatchPtrOutput() LogstashSpecServicesTlsCertificatePatchPtrOutput
	ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(context.Context) LogstashSpecServicesTlsCertificatePatchPtrOutput
}

type logstashSpecServicesTlsCertificatePatchPtrType LogstashSpecServicesTlsCertificatePatchArgs

func LogstashSpecServicesTlsCertificatePatchPtr(v *LogstashSpecServicesTlsCertificatePatchArgs) LogstashSpecServicesTlsCertificatePatchPtrInput {
	return (*logstashSpecServicesTlsCertificatePatchPtrType)(v)
}

func (*logstashSpecServicesTlsCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsCertificatePatch)(nil)).Elem()
}

func (i *logstashSpecServicesTlsCertificatePatchPtrType) ToLogstashSpecServicesTlsCertificatePatchPtrOutput() LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return i.ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsCertificatePatchPtrType) ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificatePatchPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificatePatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsCertificatePatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsCertificatePatchOutput) ToLogstashSpecServicesTlsCertificatePatchOutput() LogstashSpecServicesTlsCertificatePatchOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePatchOutput) ToLogstashSpecServicesTlsCertificatePatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePatchOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePatchOutput) ToLogstashSpecServicesTlsCertificatePatchPtrOutput() LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return o.ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsCertificatePatchOutput) ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsCertificatePatch) *LogstashSpecServicesTlsCertificatePatch {
		return &v
	}).(LogstashSpecServicesTlsCertificatePatchPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecServicesTlsCertificatePatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsCertificatePatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesTlsCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsCertificatePatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsCertificatePatchPtrOutput) ToLogstashSpecServicesTlsCertificatePatchPtrOutput() LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePatchPtrOutput) ToLogstashSpecServicesTlsCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePatchPtrOutput) Elem() LogstashSpecServicesTlsCertificatePatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsCertificatePatch) LogstashSpecServicesTlsCertificatePatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsCertificatePatch
		return ret
	}).(LogstashSpecServicesTlsCertificatePatchOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecServicesTlsCertificatePatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsCertificatePatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsPatch struct {
	Certificate           *LogstashSpecServicesTlsCertificatePatch           `pulumi:"certificate"`
	SelfSignedCertificate *LogstashSpecServicesTlsSelfSignedCertificatePatch `pulumi:"selfSignedCertificate"`
}

// LogstashSpecServicesTlsPatchInput is an input type that accepts LogstashSpecServicesTlsPatchArgs and LogstashSpecServicesTlsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsPatchInput` via:
//
//	LogstashSpecServicesTlsPatchArgs{...}
type LogstashSpecServicesTlsPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsPatchOutput() LogstashSpecServicesTlsPatchOutput
	ToLogstashSpecServicesTlsPatchOutputWithContext(context.Context) LogstashSpecServicesTlsPatchOutput
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsPatchArgs struct {
	Certificate           LogstashSpecServicesTlsCertificatePatchPtrInput           `pulumi:"certificate"`
	SelfSignedCertificate LogstashSpecServicesTlsSelfSignedCertificatePatchPtrInput `pulumi:"selfSignedCertificate"`
}

func (LogstashSpecServicesTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsPatch)(nil)).Elem()
}

func (i LogstashSpecServicesTlsPatchArgs) ToLogstashSpecServicesTlsPatchOutput() LogstashSpecServicesTlsPatchOutput {
	return i.ToLogstashSpecServicesTlsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsPatchArgs) ToLogstashSpecServicesTlsPatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsPatchOutput)
}

func (i LogstashSpecServicesTlsPatchArgs) ToLogstashSpecServicesTlsPatchPtrOutput() LogstashSpecServicesTlsPatchPtrOutput {
	return i.ToLogstashSpecServicesTlsPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsPatchArgs) ToLogstashSpecServicesTlsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsPatchOutput).ToLogstashSpecServicesTlsPatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsPatchPtrInput is an input type that accepts LogstashSpecServicesTlsPatchArgs, LogstashSpecServicesTlsPatchPtr and LogstashSpecServicesTlsPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsPatchPtrInput` via:
//
//	        LogstashSpecServicesTlsPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsPatchPtrOutput() LogstashSpecServicesTlsPatchPtrOutput
	ToLogstashSpecServicesTlsPatchPtrOutputWithContext(context.Context) LogstashSpecServicesTlsPatchPtrOutput
}

type logstashSpecServicesTlsPatchPtrType LogstashSpecServicesTlsPatchArgs

func LogstashSpecServicesTlsPatchPtr(v *LogstashSpecServicesTlsPatchArgs) LogstashSpecServicesTlsPatchPtrInput {
	return (*logstashSpecServicesTlsPatchPtrType)(v)
}

func (*logstashSpecServicesTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsPatch)(nil)).Elem()
}

func (i *logstashSpecServicesTlsPatchPtrType) ToLogstashSpecServicesTlsPatchPtrOutput() LogstashSpecServicesTlsPatchPtrOutput {
	return i.ToLogstashSpecServicesTlsPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsPatchPtrType) ToLogstashSpecServicesTlsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsPatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsPatchOutput) ToLogstashSpecServicesTlsPatchOutput() LogstashSpecServicesTlsPatchOutput {
	return o
}

func (o LogstashSpecServicesTlsPatchOutput) ToLogstashSpecServicesTlsPatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPatchOutput {
	return o
}

func (o LogstashSpecServicesTlsPatchOutput) ToLogstashSpecServicesTlsPatchPtrOutput() LogstashSpecServicesTlsPatchPtrOutput {
	return o.ToLogstashSpecServicesTlsPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsPatchOutput) ToLogstashSpecServicesTlsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsPatch) *LogstashSpecServicesTlsPatch {
		return &v
	}).(LogstashSpecServicesTlsPatchPtrOutput)
}

func (o LogstashSpecServicesTlsPatchOutput) Certificate() LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsPatch) *LogstashSpecServicesTlsCertificatePatch { return v.Certificate }).(LogstashSpecServicesTlsCertificatePatchPtrOutput)
}

func (o LogstashSpecServicesTlsPatchOutput) SelfSignedCertificate() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsPatch) *LogstashSpecServicesTlsSelfSignedCertificatePatch {
		return v.SelfSignedCertificate
	}).(LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput)
}

type LogstashSpecServicesTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsPatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsPatchPtrOutput) ToLogstashSpecServicesTlsPatchPtrOutput() LogstashSpecServicesTlsPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsPatchPtrOutput) ToLogstashSpecServicesTlsPatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPatchPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsPatchPtrOutput) Elem() LogstashSpecServicesTlsPatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsPatch) LogstashSpecServicesTlsPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsPatch
		return ret
	}).(LogstashSpecServicesTlsPatchOutput)
}

func (o LogstashSpecServicesTlsPatchPtrOutput) Certificate() LogstashSpecServicesTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsPatch) *LogstashSpecServicesTlsCertificatePatch {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(LogstashSpecServicesTlsCertificatePatchPtrOutput)
}

func (o LogstashSpecServicesTlsPatchPtrOutput) SelfSignedCertificate() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsPatch) *LogstashSpecServicesTlsSelfSignedCertificatePatch {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificate struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames `pulumi:"subjectAltNames"`
}

// LogstashSpecServicesTlsSelfSignedCertificateInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateArgs and LogstashSpecServicesTlsSelfSignedCertificateOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateArgs{...}
type LogstashSpecServicesTlsSelfSignedCertificateInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateOutput() LogstashSpecServicesTlsSelfSignedCertificateOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificateArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput `pulumi:"subjectAltNames"`
}

func (LogstashSpecServicesTlsSelfSignedCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificateOutput() LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateOutput)
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateOutput).ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsSelfSignedCertificatePtrInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateArgs, LogstashSpecServicesTlsSelfSignedCertificatePtr and LogstashSpecServicesTlsSelfSignedCertificatePtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificatePtrInput` via:
//
//	        LogstashSpecServicesTlsSelfSignedCertificateArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsSelfSignedCertificatePtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput
	ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput
}

type logstashSpecServicesTlsSelfSignedCertificatePtrType LogstashSpecServicesTlsSelfSignedCertificateArgs

func LogstashSpecServicesTlsSelfSignedCertificatePtr(v *LogstashSpecServicesTlsSelfSignedCertificateArgs) LogstashSpecServicesTlsSelfSignedCertificatePtrInput {
	return (*logstashSpecServicesTlsSelfSignedCertificatePtrType)(v)
}

func (*logstashSpecServicesTlsSelfSignedCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (i *logstashSpecServicesTlsSelfSignedCertificatePtrType) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsSelfSignedCertificatePtrType) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificateOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificateOutput() LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsSelfSignedCertificate) *LogstashSpecServicesTlsSelfSignedCertificate {
		return &v
	}).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificate) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) SubjectAltNames() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificate) []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames {
		return v.SubjectAltNames
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

type LogstashSpecServicesTlsSelfSignedCertificatePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) Elem() LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificate) LogstashSpecServicesTlsSelfSignedCertificate {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsSelfSignedCertificate
		return ret
	}).(LogstashSpecServicesTlsSelfSignedCertificateOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificate) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) SubjectAltNames() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificate) []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificatePatch struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch `pulumi:"subjectAltNames"`
}

// LogstashSpecServicesTlsSelfSignedCertificatePatchInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificatePatchArgs and LogstashSpecServicesTlsSelfSignedCertificatePatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificatePatchInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificatePatchArgs{...}
type LogstashSpecServicesTlsSelfSignedCertificatePatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchOutput
	ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificatePatchArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput `pulumi:"subjectAltNames"`
}

func (LogstashSpecServicesTlsSelfSignedCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificatePatchArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificatePatchArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificatePatchOutput)
}

func (i LogstashSpecServicesTlsSelfSignedCertificatePatchArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificatePatchArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificatePatchOutput).ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsSelfSignedCertificatePatchPtrInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificatePatchArgs, LogstashSpecServicesTlsSelfSignedCertificatePatchPtr and LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificatePatchPtrInput` via:
//
//	        LogstashSpecServicesTlsSelfSignedCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsSelfSignedCertificatePatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput
	ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput
}

type logstashSpecServicesTlsSelfSignedCertificatePatchPtrType LogstashSpecServicesTlsSelfSignedCertificatePatchArgs

func LogstashSpecServicesTlsSelfSignedCertificatePatchPtr(v *LogstashSpecServicesTlsSelfSignedCertificatePatchArgs) LogstashSpecServicesTlsSelfSignedCertificatePatchPtrInput {
	return (*logstashSpecServicesTlsSelfSignedCertificatePatchPtrType)(v)
}

func (*logstashSpecServicesTlsSelfSignedCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i *logstashSpecServicesTlsSelfSignedCertificatePatchPtrType) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsSelfSignedCertificatePatchPtrType) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificatePatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return o.ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsSelfSignedCertificatePatch) *LogstashSpecServicesTlsSelfSignedCertificatePatch {
		return &v
	}).(LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificatePatch) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o LogstashSpecServicesTlsSelfSignedCertificatePatchOutput) SubjectAltNames() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificatePatch) []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch {
		return v.SubjectAltNames
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

type LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput) Elem() LogstashSpecServicesTlsSelfSignedCertificatePatchOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificatePatch) LogstashSpecServicesTlsSelfSignedCertificatePatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsSelfSignedCertificatePatch
		return ret
	}).(LogstashSpecServicesTlsSelfSignedCertificatePatchOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificatePatch) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput) SubjectAltNames() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificatePatch) []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs and LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs{...}
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray and LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray{ LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs{...} }
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput
}

type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames {
		return vs[0].([]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)[vs[1].(int)]
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs and LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...}
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray and LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray{ LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...} }
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
}

type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchInput

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch {
		return vs[0].([]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatch)[vs[1].(int)]
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategy struct {
	RollingUpdate *LogstashSpecUpdateStrategyRollingUpdate `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy.
	// Default is RollingUpdate.
	Type *string `pulumi:"type"`
}

// LogstashSpecUpdateStrategyInput is an input type that accepts LogstashSpecUpdateStrategyArgs and LogstashSpecUpdateStrategyOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyInput` via:
//
//	LogstashSpecUpdateStrategyArgs{...}
type LogstashSpecUpdateStrategyInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyOutput() LogstashSpecUpdateStrategyOutput
	ToLogstashSpecUpdateStrategyOutputWithContext(context.Context) LogstashSpecUpdateStrategyOutput
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyArgs struct {
	RollingUpdate LogstashSpecUpdateStrategyRollingUpdatePtrInput `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy.
	// Default is RollingUpdate.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecUpdateStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyOutput() LogstashSpecUpdateStrategyOutput {
	return i.ToLogstashSpecUpdateStrategyOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyOutput)
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return i.ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyOutput).ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx)
}

// LogstashSpecUpdateStrategyPtrInput is an input type that accepts LogstashSpecUpdateStrategyArgs, LogstashSpecUpdateStrategyPtr and LogstashSpecUpdateStrategyPtrOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyPtrInput` via:
//
//	        LogstashSpecUpdateStrategyArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecUpdateStrategyPtrInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput
	ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Context) LogstashSpecUpdateStrategyPtrOutput
}

type logstashSpecUpdateStrategyPtrType LogstashSpecUpdateStrategyArgs

func LogstashSpecUpdateStrategyPtr(v *LogstashSpecUpdateStrategyArgs) LogstashSpecUpdateStrategyPtrInput {
	return (*logstashSpecUpdateStrategyPtrType)(v)
}

func (*logstashSpecUpdateStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (i *logstashSpecUpdateStrategyPtrType) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return i.ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i *logstashSpecUpdateStrategyPtrType) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyPtrOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyOutput() LogstashSpecUpdateStrategyOutput {
	return o
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyOutput {
	return o
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return o.ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecUpdateStrategy) *LogstashSpecUpdateStrategy {
		return &v
	}).(LogstashSpecUpdateStrategyPtrOutput)
}

func (o LogstashSpecUpdateStrategyOutput) RollingUpdate() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategy) *LogstashSpecUpdateStrategyRollingUpdate { return v.RollingUpdate }).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy.
// Default is RollingUpdate.
func (o LogstashSpecUpdateStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecUpdateStrategyPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyPtrOutput) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPtrOutput) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPtrOutput) Elem() LogstashSpecUpdateStrategyOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategy) LogstashSpecUpdateStrategy {
		if v != nil {
			return *v
		}
		var ret LogstashSpecUpdateStrategy
		return ret
	}).(LogstashSpecUpdateStrategyOutput)
}

func (o LogstashSpecUpdateStrategyPtrOutput) RollingUpdate() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategy) *LogstashSpecUpdateStrategyRollingUpdate {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy.
// Default is RollingUpdate.
func (o LogstashSpecUpdateStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyPatch struct {
	RollingUpdate *LogstashSpecUpdateStrategyRollingUpdatePatch `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy.
	// Default is RollingUpdate.
	Type *string `pulumi:"type"`
}

// LogstashSpecUpdateStrategyPatchInput is an input type that accepts LogstashSpecUpdateStrategyPatchArgs and LogstashSpecUpdateStrategyPatchOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyPatchInput` via:
//
//	LogstashSpecUpdateStrategyPatchArgs{...}
type LogstashSpecUpdateStrategyPatchInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyPatchOutput() LogstashSpecUpdateStrategyPatchOutput
	ToLogstashSpecUpdateStrategyPatchOutputWithContext(context.Context) LogstashSpecUpdateStrategyPatchOutput
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyPatchArgs struct {
	RollingUpdate LogstashSpecUpdateStrategyRollingUpdatePatchPtrInput `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy.
	// Default is RollingUpdate.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecUpdateStrategyPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyPatch)(nil)).Elem()
}

func (i LogstashSpecUpdateStrategyPatchArgs) ToLogstashSpecUpdateStrategyPatchOutput() LogstashSpecUpdateStrategyPatchOutput {
	return i.ToLogstashSpecUpdateStrategyPatchOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyPatchArgs) ToLogstashSpecUpdateStrategyPatchOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyPatchOutput)
}

func (i LogstashSpecUpdateStrategyPatchArgs) ToLogstashSpecUpdateStrategyPatchPtrOutput() LogstashSpecUpdateStrategyPatchPtrOutput {
	return i.ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyPatchArgs) ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyPatchOutput).ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(ctx)
}

// LogstashSpecUpdateStrategyPatchPtrInput is an input type that accepts LogstashSpecUpdateStrategyPatchArgs, LogstashSpecUpdateStrategyPatchPtr and LogstashSpecUpdateStrategyPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyPatchPtrInput` via:
//
//	        LogstashSpecUpdateStrategyPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecUpdateStrategyPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyPatchPtrOutput() LogstashSpecUpdateStrategyPatchPtrOutput
	ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(context.Context) LogstashSpecUpdateStrategyPatchPtrOutput
}

type logstashSpecUpdateStrategyPatchPtrType LogstashSpecUpdateStrategyPatchArgs

func LogstashSpecUpdateStrategyPatchPtr(v *LogstashSpecUpdateStrategyPatchArgs) LogstashSpecUpdateStrategyPatchPtrInput {
	return (*logstashSpecUpdateStrategyPatchPtrType)(v)
}

func (*logstashSpecUpdateStrategyPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyPatch)(nil)).Elem()
}

func (i *logstashSpecUpdateStrategyPatchPtrType) ToLogstashSpecUpdateStrategyPatchPtrOutput() LogstashSpecUpdateStrategyPatchPtrOutput {
	return i.ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecUpdateStrategyPatchPtrType) ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyPatchPtrOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyPatch)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyPatchOutput) ToLogstashSpecUpdateStrategyPatchOutput() LogstashSpecUpdateStrategyPatchOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPatchOutput) ToLogstashSpecUpdateStrategyPatchOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPatchOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPatchOutput) ToLogstashSpecUpdateStrategyPatchPtrOutput() LogstashSpecUpdateStrategyPatchPtrOutput {
	return o.ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecUpdateStrategyPatchOutput) ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecUpdateStrategyPatch) *LogstashSpecUpdateStrategyPatch {
		return &v
	}).(LogstashSpecUpdateStrategyPatchPtrOutput)
}

func (o LogstashSpecUpdateStrategyPatchOutput) RollingUpdate() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyPatch) *LogstashSpecUpdateStrategyRollingUpdatePatch {
		return v.RollingUpdate
	}).(LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy.
// Default is RollingUpdate.
func (o LogstashSpecUpdateStrategyPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecUpdateStrategyPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyPatch)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyPatchPtrOutput) ToLogstashSpecUpdateStrategyPatchPtrOutput() LogstashSpecUpdateStrategyPatchPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPatchPtrOutput) ToLogstashSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPatchPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPatchPtrOutput) Elem() LogstashSpecUpdateStrategyPatchOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyPatch) LogstashSpecUpdateStrategyPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecUpdateStrategyPatch
		return ret
	}).(LogstashSpecUpdateStrategyPatchOutput)
}

func (o LogstashSpecUpdateStrategyPatchPtrOutput) RollingUpdate() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyPatch) *LogstashSpecUpdateStrategyRollingUpdatePatch {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy.
// Default is RollingUpdate.
func (o LogstashSpecUpdateStrategyPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdate struct {
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding up. This can not be 0.
	// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
	// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
	// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
	// will be counted towards MaxUnavailable.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// Partition indicates the ordinal at which the StatefulSet should be partitioned
	// for updates. During a rolling update, all pods from ordinal Replicas-1 to
	// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
	// This is helpful in being able to do a canary based deployment. The default value is 0.
	Partition *int `pulumi:"partition"`
}

// LogstashSpecUpdateStrategyRollingUpdateInput is an input type that accepts LogstashSpecUpdateStrategyRollingUpdateArgs and LogstashSpecUpdateStrategyRollingUpdateOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyRollingUpdateInput` via:
//
//	LogstashSpecUpdateStrategyRollingUpdateArgs{...}
type LogstashSpecUpdateStrategyRollingUpdateInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyRollingUpdateOutput() LogstashSpecUpdateStrategyRollingUpdateOutput
	ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(context.Context) LogstashSpecUpdateStrategyRollingUpdateOutput
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdateArgs struct {
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding up. This can not be 0.
	// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
	// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
	// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
	// will be counted towards MaxUnavailable.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// Partition indicates the ordinal at which the StatefulSet should be partitioned
	// for updates. During a rolling update, all pods from ordinal Replicas-1 to
	// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
	// This is helpful in being able to do a canary based deployment. The default value is 0.
	Partition pulumi.IntPtrInput `pulumi:"partition"`
}

func (LogstashSpecUpdateStrategyRollingUpdateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdateOutput() LogstashSpecUpdateStrategyRollingUpdateOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdateOutput)
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdateOutput).ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx)
}

// LogstashSpecUpdateStrategyRollingUpdatePtrInput is an input type that accepts LogstashSpecUpdateStrategyRollingUpdateArgs, LogstashSpecUpdateStrategyRollingUpdatePtr and LogstashSpecUpdateStrategyRollingUpdatePtrOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyRollingUpdatePtrInput` via:
//
//	        LogstashSpecUpdateStrategyRollingUpdateArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecUpdateStrategyRollingUpdatePtrInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput
	ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput
}

type logstashSpecUpdateStrategyRollingUpdatePtrType LogstashSpecUpdateStrategyRollingUpdateArgs

func LogstashSpecUpdateStrategyRollingUpdatePtr(v *LogstashSpecUpdateStrategyRollingUpdateArgs) LogstashSpecUpdateStrategyRollingUpdatePtrInput {
	return (*logstashSpecUpdateStrategyRollingUpdatePtrType)(v)
}

func (*logstashSpecUpdateStrategyRollingUpdatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (i *logstashSpecUpdateStrategyRollingUpdatePtrType) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i *logstashSpecUpdateStrategyRollingUpdatePtrType) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdateOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyRollingUpdateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdateOutput() LogstashSpecUpdateStrategyRollingUpdateOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdateOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecUpdateStrategyRollingUpdate) *LogstashSpecUpdateStrategyRollingUpdate {
		return &v
	}).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding up. This can not be 0.
// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
// will be counted towards MaxUnavailable.
func (o LogstashSpecUpdateStrategyRollingUpdateOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyRollingUpdate) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned
// for updates. During a rolling update, all pods from ordinal Replicas-1 to
// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
// This is helpful in being able to do a canary based deployment. The default value is 0.
func (o LogstashSpecUpdateStrategyRollingUpdateOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyRollingUpdate) *int { return v.Partition }).(pulumi.IntPtrOutput)
}

type LogstashSpecUpdateStrategyRollingUpdatePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyRollingUpdatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) Elem() LogstashSpecUpdateStrategyRollingUpdateOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdate) LogstashSpecUpdateStrategyRollingUpdate {
		if v != nil {
			return *v
		}
		var ret LogstashSpecUpdateStrategyRollingUpdate
		return ret
	}).(LogstashSpecUpdateStrategyRollingUpdateOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding up. This can not be 0.
// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
// will be counted towards MaxUnavailable.
func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdate) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned
// for updates. During a rolling update, all pods from ordinal Replicas-1 to
// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
// This is helpful in being able to do a canary based deployment. The default value is 0.
func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdate) *int {
		if v == nil {
			return nil
		}
		return v.Partition
	}).(pulumi.IntPtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdatePatch struct {
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding up. This can not be 0.
	// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
	// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
	// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
	// will be counted towards MaxUnavailable.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// Partition indicates the ordinal at which the StatefulSet should be partitioned
	// for updates. During a rolling update, all pods from ordinal Replicas-1 to
	// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
	// This is helpful in being able to do a canary based deployment. The default value is 0.
	Partition *int `pulumi:"partition"`
}

// LogstashSpecUpdateStrategyRollingUpdatePatchInput is an input type that accepts LogstashSpecUpdateStrategyRollingUpdatePatchArgs and LogstashSpecUpdateStrategyRollingUpdatePatchOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyRollingUpdatePatchInput` via:
//
//	LogstashSpecUpdateStrategyRollingUpdatePatchArgs{...}
type LogstashSpecUpdateStrategyRollingUpdatePatchInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyRollingUpdatePatchOutput() LogstashSpecUpdateStrategyRollingUpdatePatchOutput
	ToLogstashSpecUpdateStrategyRollingUpdatePatchOutputWithContext(context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchOutput
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdatePatchArgs struct {
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding up. This can not be 0.
	// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
	// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
	// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
	// will be counted towards MaxUnavailable.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// Partition indicates the ordinal at which the StatefulSet should be partitioned
	// for updates. During a rolling update, all pods from ordinal Replicas-1 to
	// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
	// This is helpful in being able to do a canary based deployment. The default value is 0.
	Partition pulumi.IntPtrInput `pulumi:"partition"`
}

func (LogstashSpecUpdateStrategyRollingUpdatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdatePatch)(nil)).Elem()
}

func (i LogstashSpecUpdateStrategyRollingUpdatePatchArgs) ToLogstashSpecUpdateStrategyRollingUpdatePatchOutput() LogstashSpecUpdateStrategyRollingUpdatePatchOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePatchOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyRollingUpdatePatchArgs) ToLogstashSpecUpdateStrategyRollingUpdatePatchOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdatePatchOutput)
}

func (i LogstashSpecUpdateStrategyRollingUpdatePatchArgs) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyRollingUpdatePatchArgs) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdatePatchOutput).ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(ctx)
}

// LogstashSpecUpdateStrategyRollingUpdatePatchPtrInput is an input type that accepts LogstashSpecUpdateStrategyRollingUpdatePatchArgs, LogstashSpecUpdateStrategyRollingUpdatePatchPtr and LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyRollingUpdatePatchPtrInput` via:
//
//	        LogstashSpecUpdateStrategyRollingUpdatePatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecUpdateStrategyRollingUpdatePatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput
	ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput
}

type logstashSpecUpdateStrategyRollingUpdatePatchPtrType LogstashSpecUpdateStrategyRollingUpdatePatchArgs

func LogstashSpecUpdateStrategyRollingUpdatePatchPtr(v *LogstashSpecUpdateStrategyRollingUpdatePatchArgs) LogstashSpecUpdateStrategyRollingUpdatePatchPtrInput {
	return (*logstashSpecUpdateStrategyRollingUpdatePatchPtrType)(v)
}

func (*logstashSpecUpdateStrategyRollingUpdatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyRollingUpdatePatch)(nil)).Elem()
}

func (i *logstashSpecUpdateStrategyRollingUpdatePatchPtrType) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecUpdateStrategyRollingUpdatePatchPtrType) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdatePatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyRollingUpdatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdatePatch)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchOutput) ToLogstashSpecUpdateStrategyRollingUpdatePatchOutput() LogstashSpecUpdateStrategyRollingUpdatePatchOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchOutput) ToLogstashSpecUpdateStrategyRollingUpdatePatchOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchOutput) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return o.ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchOutput) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecUpdateStrategyRollingUpdatePatch) *LogstashSpecUpdateStrategyRollingUpdatePatch {
		return &v
	}).(LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding up. This can not be 0.
// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
// will be counted towards MaxUnavailable.
func (o LogstashSpecUpdateStrategyRollingUpdatePatchOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyRollingUpdatePatch) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned
// for updates. During a rolling update, all pods from ordinal Replicas-1 to
// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
// This is helpful in being able to do a canary based deployment. The default value is 0.
func (o LogstashSpecUpdateStrategyRollingUpdatePatchOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyRollingUpdatePatch) *int { return v.Partition }).(pulumi.IntPtrOutput)
}

type LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyRollingUpdatePatch)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput() LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput) ToLogstashSpecUpdateStrategyRollingUpdatePatchPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput) Elem() LogstashSpecUpdateStrategyRollingUpdatePatchOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdatePatch) LogstashSpecUpdateStrategyRollingUpdatePatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecUpdateStrategyRollingUpdatePatch
		return ret
	}).(LogstashSpecUpdateStrategyRollingUpdatePatchOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding up. This can not be 0.
// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
// will be counted towards MaxUnavailable.
func (o LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdatePatch) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned
// for updates. During a rolling update, all pods from ordinal Replicas-1 to
// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
// This is helpful in being able to do a canary based deployment. The default value is 0.
func (o LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdatePatch) *int {
		if v == nil {
			return nil
		}
		return v.Partition
	}).(pulumi.IntPtrOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplates struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string                                   `pulumi:"kind"`
	Metadata *LogstashSpecVolumeClaimTemplatesMetadata `pulumi:"metadata"`
	Spec     *LogstashSpecVolumeClaimTemplatesSpec     `pulumi:"spec"`
	Status   *LogstashSpecVolumeClaimTemplatesStatus   `pulumi:"status"`
}

// LogstashSpecVolumeClaimTemplatesInput is an input type that accepts LogstashSpecVolumeClaimTemplatesArgs and LogstashSpecVolumeClaimTemplatesOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesInput` via:
//
//	LogstashSpecVolumeClaimTemplatesArgs{...}
type LogstashSpecVolumeClaimTemplatesInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesOutput() LogstashSpecVolumeClaimTemplatesOutput
	ToLogstashSpecVolumeClaimTemplatesOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesOutput
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesArgs struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput                            `pulumi:"kind"`
	Metadata LogstashSpecVolumeClaimTemplatesMetadataPtrInput `pulumi:"metadata"`
	Spec     LogstashSpecVolumeClaimTemplatesSpecPtrInput     `pulumi:"spec"`
	Status   LogstashSpecVolumeClaimTemplatesStatusPtrInput   `pulumi:"status"`
}

func (LogstashSpecVolumeClaimTemplatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesArgs) ToLogstashSpecVolumeClaimTemplatesOutput() LogstashSpecVolumeClaimTemplatesOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesArgs) ToLogstashSpecVolumeClaimTemplatesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesOutput)
}

// LogstashSpecVolumeClaimTemplatesArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesArray and LogstashSpecVolumeClaimTemplatesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesArray{ LogstashSpecVolumeClaimTemplatesArgs{...} }
type LogstashSpecVolumeClaimTemplatesArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesArrayOutput() LogstashSpecVolumeClaimTemplatesArrayOutput
	ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesArrayOutput
}

type LogstashSpecVolumeClaimTemplatesArray []LogstashSpecVolumeClaimTemplatesInput

func (LogstashSpecVolumeClaimTemplatesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesArray) ToLogstashSpecVolumeClaimTemplatesArrayOutput() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesArray) ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesArrayOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesOutput) ToLogstashSpecVolumeClaimTemplatesOutput() LogstashSpecVolumeClaimTemplatesOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesOutput) ToLogstashSpecVolumeClaimTemplatesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object.
// Servers should convert recognized schemas to the latest internal value, and
// may reject unrecognized values.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o LogstashSpecVolumeClaimTemplatesOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents.
// Servers may infer this from the endpoint the client submits requests to.
// Cannot be updated.
// In CamelCase.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashSpecVolumeClaimTemplatesOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesOutput) Metadata() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *LogstashSpecVolumeClaimTemplatesMetadata { return v.Metadata }).(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesOutput) Spec() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *LogstashSpecVolumeClaimTemplatesSpec { return v.Spec }).(LogstashSpecVolumeClaimTemplatesSpecPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesOutput) Status() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *LogstashSpecVolumeClaimTemplatesStatus { return v.Status }).(LogstashSpecVolumeClaimTemplatesStatusPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesArrayOutput) ToLogstashSpecVolumeClaimTemplatesArrayOutput() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesArrayOutput) ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplates {
		return vs[0].([]LogstashSpecVolumeClaimTemplates)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// LogstashSpecVolumeClaimTemplatesMetadataInput is an input type that accepts LogstashSpecVolumeClaimTemplatesMetadataArgs and LogstashSpecVolumeClaimTemplatesMetadataOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesMetadataInput` via:
//
//	LogstashSpecVolumeClaimTemplatesMetadataArgs{...}
type LogstashSpecVolumeClaimTemplatesMetadataInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesMetadataOutput() LogstashSpecVolumeClaimTemplatesMetadataOutput
	ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesMetadataOutput
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (LogstashSpecVolumeClaimTemplatesMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataOutput() LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataOutput)
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataOutput).ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesMetadataPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesMetadataArgs, LogstashSpecVolumeClaimTemplatesMetadataPtr and LogstashSpecVolumeClaimTemplatesMetadataPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesMetadataPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesMetadataArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesMetadataPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput
	ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput
}

type logstashSpecVolumeClaimTemplatesMetadataPtrType LogstashSpecVolumeClaimTemplatesMetadataArgs

func LogstashSpecVolumeClaimTemplatesMetadataPtr(v *LogstashSpecVolumeClaimTemplatesMetadataArgs) LogstashSpecVolumeClaimTemplatesMetadataPtrInput {
	return (*logstashSpecVolumeClaimTemplatesMetadataPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesMetadataPtrType) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesMetadataPtrType) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataOutput() LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesMetadata) *LogstashSpecVolumeClaimTemplatesMetadata {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesMetadataPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) LogstashSpecVolumeClaimTemplatesMetadata {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesMetadata
		return ret
	}).(LogstashSpecVolumeClaimTemplatesMetadataOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// LogstashSpecVolumeClaimTemplatesMetadataPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesMetadataPatchArgs and LogstashSpecVolumeClaimTemplatesMetadataPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesMetadataPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesMetadataPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesMetadataPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchOutput
	ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchOutput
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (LogstashSpecVolumeClaimTemplatesMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesMetadataPatchArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesMetadataPatchArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesMetadataPatchArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesMetadataPatchArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataPatchOutput).ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesMetadataPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesMetadataPatchArgs, LogstashSpecVolumeClaimTemplatesMetadataPatchPtr and LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesMetadataPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesMetadataPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesMetadataPatchPtrType LogstashSpecVolumeClaimTemplatesMetadataPatchArgs

func LogstashSpecVolumeClaimTemplatesMetadataPatchPtr(v *LogstashSpecVolumeClaimTemplatesMetadataPatchArgs) LogstashSpecVolumeClaimTemplatesMetadataPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesMetadataPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesMetadataPatchPtrType) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesMetadataPatchPtrType) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesMetadataPatch) *LogstashSpecVolumeClaimTemplatesMetadataPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadataPatch) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesMetadataPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadataPatch) LogstashSpecVolumeClaimTemplatesMetadataPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesMetadataPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesMetadataPatchOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesPatch struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string                                        `pulumi:"kind"`
	Metadata *LogstashSpecVolumeClaimTemplatesMetadataPatch `pulumi:"metadata"`
	Spec     *LogstashSpecVolumeClaimTemplatesSpecPatch     `pulumi:"spec"`
	Status   *LogstashSpecVolumeClaimTemplatesStatusPatch   `pulumi:"status"`
}

// LogstashSpecVolumeClaimTemplatesPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesPatchArgs and LogstashSpecVolumeClaimTemplatesPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesPatchOutput() LogstashSpecVolumeClaimTemplatesPatchOutput
	ToLogstashSpecVolumeClaimTemplatesPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesPatchOutput
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesPatchArgs struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput                                 `pulumi:"kind"`
	Metadata LogstashSpecVolumeClaimTemplatesMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     LogstashSpecVolumeClaimTemplatesSpecPatchPtrInput     `pulumi:"spec"`
	Status   LogstashSpecVolumeClaimTemplatesStatusPatchPtrInput   `pulumi:"status"`
}

func (LogstashSpecVolumeClaimTemplatesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesPatchArgs) ToLogstashSpecVolumeClaimTemplatesPatchOutput() LogstashSpecVolumeClaimTemplatesPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesPatchArgs) ToLogstashSpecVolumeClaimTemplatesPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesPatchOutput)
}

// LogstashSpecVolumeClaimTemplatesPatchArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesPatchArray and LogstashSpecVolumeClaimTemplatesPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesPatchArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesPatchArray{ LogstashSpecVolumeClaimTemplatesPatchArgs{...} }
type LogstashSpecVolumeClaimTemplatesPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesPatchArrayOutput() LogstashSpecVolumeClaimTemplatesPatchArrayOutput
	ToLogstashSpecVolumeClaimTemplatesPatchArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesPatchArrayOutput
}

type LogstashSpecVolumeClaimTemplatesPatchArray []LogstashSpecVolumeClaimTemplatesPatchInput

func (LogstashSpecVolumeClaimTemplatesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesPatchArray) ToLogstashSpecVolumeClaimTemplatesPatchArrayOutput() LogstashSpecVolumeClaimTemplatesPatchArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesPatchArray) ToLogstashSpecVolumeClaimTemplatesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesPatchArrayOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesPatchOutput) ToLogstashSpecVolumeClaimTemplatesPatchOutput() LogstashSpecVolumeClaimTemplatesPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesPatchOutput) ToLogstashSpecVolumeClaimTemplatesPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesPatchOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object.
// Servers should convert recognized schemas to the latest internal value, and
// may reject unrecognized values.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o LogstashSpecVolumeClaimTemplatesPatchOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesPatch) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents.
// Servers may infer this from the endpoint the client submits requests to.
// Cannot be updated.
// In CamelCase.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashSpecVolumeClaimTemplatesPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesPatchOutput) Metadata() LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesPatch) *LogstashSpecVolumeClaimTemplatesMetadataPatch {
		return v.Metadata
	}).(LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesPatchOutput) Spec() LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesPatch) *LogstashSpecVolumeClaimTemplatesSpecPatch {
		return v.Spec
	}).(LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesPatchOutput) Status() LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesPatch) *LogstashSpecVolumeClaimTemplatesStatusPatch {
		return v.Status
	}).(LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesPatchArrayOutput) ToLogstashSpecVolumeClaimTemplatesPatchArrayOutput() LogstashSpecVolumeClaimTemplatesPatchArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesPatchArrayOutput) ToLogstashSpecVolumeClaimTemplatesPatchArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesPatchArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesPatch {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesPatch)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesPatchOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpec struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   []string                                           `pulumi:"accessModes"`
	DataSource    *LogstashSpecVolumeClaimTemplatesSpecDataSource    `pulumi:"dataSource"`
	DataSourceRef *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef `pulumi:"dataSourceRef"`
	Resources     *LogstashSpecVolumeClaimTemplatesSpecResources     `pulumi:"resources"`
	Selector      *LogstashSpecVolumeClaimTemplatesSpecSelector      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName *string `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName *string `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName *string `pulumi:"volumeName"`
}

// LogstashSpecVolumeClaimTemplatesSpecInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecArgs and LogstashSpecVolumeClaimTemplatesSpecOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecOutput() LogstashSpecVolumeClaimTemplatesSpecOutput
	ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecOutput
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecArgs struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   pulumi.StringArrayInput                                   `pulumi:"accessModes"`
	DataSource    LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput    `pulumi:"dataSource"`
	DataSourceRef LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput `pulumi:"dataSourceRef"`
	Resources     LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput     `pulumi:"resources"`
	Selector      LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName pulumi.StringPtrInput `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName pulumi.StringPtrInput `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode pulumi.StringPtrInput `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
}

func (LogstashSpecVolumeClaimTemplatesSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecOutput() LogstashSpecVolumeClaimTemplatesSpecOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecOutput).ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecArgs, LogstashSpecVolumeClaimTemplatesSpecPtr and LogstashSpecVolumeClaimTemplatesSpecPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecPtrType LogstashSpecVolumeClaimTemplatesSpecArgs

func LogstashSpecVolumeClaimTemplatesSpecPtr(v *LogstashSpecVolumeClaimTemplatesSpecArgs) LogstashSpecVolumeClaimTemplatesSpecPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecPtrType) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecPtrType) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecOutput() LogstashSpecVolumeClaimTemplatesSpecOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpec {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecPtrOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) DataSource() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSource {
		return v.DataSource
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) DataSourceRef() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		return v.DataSourceRef
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) Resources() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecResources {
		return v.Resources
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) Selector() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecSelector {
		return v.Selector
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.StorageClassName }).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.VolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.VolumeMode }).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) LogstashSpecVolumeClaimTemplatesSpec {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpec
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) DataSource() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSource {
		if v == nil {
			return nil
		}
		return v.DataSource
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) DataSourceRef() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		if v == nil {
			return nil
		}
		return v.DataSourceRef
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) Resources() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecResources {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) Selector() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.StorageClassName
	}).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeMode
	}).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSource struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs and LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecDataSourceInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput).ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs, LogstashSpecVolumeClaimTemplatesSpecDataSourcePtr and LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs

func LogstashSpecVolumeClaimTemplatesSpecDataSourcePtr(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecDataSource) *LogstashSpecVolumeClaimTemplatesSpecDataSource {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSource) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSource) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) LogstashSpecVolumeClaimTemplatesSpecDataSource {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecDataSource
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs and LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput).ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs, LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtr and LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrType LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs

func LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtr(v *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRef struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace *string `pulumi:"namespace"`
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs and LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput).ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs, LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtr and LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs

func LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtr(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecDataSourceRef
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace *string `pulumi:"namespace"`
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs and LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput).ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs, LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtr and LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrType LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs

func LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtr(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecPatch struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   []string                                                `pulumi:"accessModes"`
	DataSource    *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch    `pulumi:"dataSource"`
	DataSourceRef *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch `pulumi:"dataSourceRef"`
	Resources     *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch     `pulumi:"resources"`
	Selector      *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName *string `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName *string `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName *string `pulumi:"volumeName"`
}

// LogstashSpecVolumeClaimTemplatesSpecPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecPatchArgs and LogstashSpecVolumeClaimTemplatesSpecPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecPatchOutput() LogstashSpecVolumeClaimTemplatesSpecPatchOutput
	ToLogstashSpecVolumeClaimTemplatesSpecPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchOutput
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecPatchArgs struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   pulumi.StringArrayInput                                        `pulumi:"accessModes"`
	DataSource    LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrInput    `pulumi:"dataSource"`
	DataSourceRef LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput `pulumi:"dataSourceRef"`
	Resources     LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrInput     `pulumi:"resources"`
	Selector      LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrInput      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName pulumi.StringPtrInput `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName pulumi.StringPtrInput `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode pulumi.StringPtrInput `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
}

func (LogstashSpecVolumeClaimTemplatesSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecPatchOutput() LogstashSpecVolumeClaimTemplatesSpecPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecPatchOutput).ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecPatchArgs, LogstashSpecVolumeClaimTemplatesSpecPatchPtr and LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecPatchPtrType LogstashSpecVolumeClaimTemplatesSpecPatchArgs

func LogstashSpecVolumeClaimTemplatesSpecPatchPtr(v *LogstashSpecVolumeClaimTemplatesSpecPatchArgs) LogstashSpecVolumeClaimTemplatesSpecPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecPatchOutput() LogstashSpecVolumeClaimTemplatesSpecPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) DataSource() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch {
		return v.DataSource
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) DataSourceRef() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch {
		return v.DataSourceRef
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) Resources() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch {
		return v.Resources
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) Selector() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch {
		return v.Selector
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *string { return v.StorageClassName }).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *string { return v.VolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *string { return v.VolumeMode }).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o LogstashSpecVolumeClaimTemplatesSpecPatchOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecPatch) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) LogstashSpecVolumeClaimTemplatesSpecPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecPatchOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) DataSource() LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecDataSourcePatch {
		if v == nil {
			return nil
		}
		return v.DataSource
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) DataSourceRef() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatch {
		if v == nil {
			return nil
		}
		return v.DataSourceRef
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) Resources() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) Selector() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.StorageClassName
	}).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.VolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.VolumeMode
	}).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResources struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits map[string]interface{} `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests map[string]interface{} `pulumi:"requests"`
}

// LogstashSpecVolumeClaimTemplatesSpecResourcesInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecResourcesArgs and LogstashSpecVolumeClaimTemplatesSpecResourcesOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecResourcesInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecResourcesInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput
	ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesOutput
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesArgs struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits pulumi.MapInput `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests pulumi.MapInput `pulumi:"requests"`
}

func (LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput).ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecResourcesArgs, LogstashSpecVolumeClaimTemplatesSpecResourcesPtr and LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecResourcesPtrType LogstashSpecVolumeClaimTemplatesSpecResourcesArgs

func LogstashSpecVolumeClaimTemplatesSpecResourcesPtr(v *LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecResourcesPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecResourcesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecResourcesPtrType) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecResourcesPtrType) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecResources) *LogstashSpecVolumeClaimTemplatesSpecResources {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} { return v.Limits }).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} { return v.Requests }).(pulumi.MapOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResources) LogstashSpecVolumeClaimTemplatesSpecResources {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecResources
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.MapOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesPatch struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits map[string]interface{} `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests map[string]interface{} `pulumi:"requests"`
}

// LogstashSpecVolumeClaimTemplatesSpecResourcesPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs and LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecResourcesPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecResourcesPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput
	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits pulumi.MapInput `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests pulumi.MapInput `pulumi:"requests"`
}

func (LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput).ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs, LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtr and LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrType LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs

func LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtr(v *LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecResourcesPatch) *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} { return v.Limits }).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} { return v.Requests }).(pulumi.MapOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch) LogstashSpecVolumeClaimTemplatesSpecResourcesPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecResourcesPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.MapOutput)
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorArgs and LogstashSpecVolumeClaimTemplatesSpecSelectorOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecSelectorInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorOutput
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput).ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorArgs, LogstashSpecVolumeClaimTemplatesSpecSelectorPtr and LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecSelectorPtrType LogstashSpecVolumeClaimTemplatesSpecSelectorArgs

func LogstashSpecVolumeClaimTemplatesSpecSelectorPtr(v *LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecSelectorPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecSelectorPtrType) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecSelectorPtrType) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecSelector) *LogstashSpecVolumeClaimTemplatesSpecSelector {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) MatchExpressions() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelector) []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
		return v.MatchExpressions
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelector) LogstashSpecVolumeClaimTemplatesSpecSelector {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecSelector
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) MatchExpressions() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelector) []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs and LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput)
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray and LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray{ LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{...} }
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs and LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput)
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray and LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray{ LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs{...} }
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput)
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs and LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecSelectorPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput).ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs, LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtr and LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrType LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs

func LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtr(v *LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrType) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecSelectorPatch) *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) MatchExpressions() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorPatch) []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorPatch) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch) LogstashSpecVolumeClaimTemplatesSpecSelectorPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecSelectorPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput) MatchExpressions() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch) []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatus struct {
	// accessModes contains the actual access modes the volume backing the PVC has.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes []string `pulumi:"accessModes"`
	// allocatedResourceStatuses stores status of resource being resized for the given PVC.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// ClaimResourceStatus can be in any of following states:
	// 	- ControllerResizeInProgress:
	// 		State set when resize controller starts resizing the volume in control-plane.
	// 	- ControllerResizeFailed:
	// 		State set when resize has failed in resize controller with a terminal error.
	// 	- NodeResizePending:
	// 		State set when resize controller has finished resizing the volume but further resizing of
	// 		volume is needed on the node.
	// 	- NodeResizeInProgress:
	// 		State set when kubelet starts resizing the volume.
	// 	- NodeResizeFailed:
	// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
	// 		NodeResizeFailed.
	// For example: if expanding a PVC for more capacity - this field can be one of the following states:
	// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
	// When this field is not set, it means that no resize operation is in progress for the given PVC.
	//
	// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResourceStatuses map[string]string `pulumi:"allocatedResourceStatuses"`
	// allocatedResources tracks the resources allocated to a PVC including its capacity.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// Capacity reported here may be larger than the actual capacity when a volume expansion operation
	// is requested.
	// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
	// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
	// If a volume expansion capacity request is lowered, allocatedResources is only
	// lowered if there are no expansion operations in progress and if the actual volume capacity
	// is equal or lower than the requested capacity.
	//
	// A controller that receives PVC update with previously unknown resourceName
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResources map[string]interface{} `pulumi:"allocatedResources"`
	// capacity represents the actual resources of the underlying volume.
	Capacity map[string]interface{} `pulumi:"capacity"`
	// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
	// resized then the Condition will be set to 'Resizing'.
	Conditions []LogstashSpecVolumeClaimTemplatesStatusConditions `pulumi:"conditions"`
	// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
	// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	CurrentVolumeAttributesClassName *string                                                   `pulumi:"currentVolumeAttributesClassName"`
	ModifyVolumeStatus               *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus `pulumi:"modifyVolumeStatus"`
	// phase represents the current phase of PersistentVolumeClaim.
	Phase *string `pulumi:"phase"`
}

// LogstashSpecVolumeClaimTemplatesStatusInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusArgs and LogstashSpecVolumeClaimTemplatesStatusOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusOutput() LogstashSpecVolumeClaimTemplatesStatusOutput
	ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusOutput
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusArgs struct {
	// accessModes contains the actual access modes the volume backing the PVC has.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes pulumi.StringArrayInput `pulumi:"accessModes"`
	// allocatedResourceStatuses stores status of resource being resized for the given PVC.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// ClaimResourceStatus can be in any of following states:
	// 	- ControllerResizeInProgress:
	// 		State set when resize controller starts resizing the volume in control-plane.
	// 	- ControllerResizeFailed:
	// 		State set when resize has failed in resize controller with a terminal error.
	// 	- NodeResizePending:
	// 		State set when resize controller has finished resizing the volume but further resizing of
	// 		volume is needed on the node.
	// 	- NodeResizeInProgress:
	// 		State set when kubelet starts resizing the volume.
	// 	- NodeResizeFailed:
	// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
	// 		NodeResizeFailed.
	// For example: if expanding a PVC for more capacity - this field can be one of the following states:
	// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
	// When this field is not set, it means that no resize operation is in progress for the given PVC.
	//
	// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResourceStatuses pulumi.StringMapInput `pulumi:"allocatedResourceStatuses"`
	// allocatedResources tracks the resources allocated to a PVC including its capacity.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// Capacity reported here may be larger than the actual capacity when a volume expansion operation
	// is requested.
	// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
	// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
	// If a volume expansion capacity request is lowered, allocatedResources is only
	// lowered if there are no expansion operations in progress and if the actual volume capacity
	// is equal or lower than the requested capacity.
	//
	// A controller that receives PVC update with previously unknown resourceName
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResources pulumi.MapInput `pulumi:"allocatedResources"`
	// capacity represents the actual resources of the underlying volume.
	Capacity pulumi.MapInput `pulumi:"capacity"`
	// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
	// resized then the Condition will be set to 'Resizing'.
	Conditions LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput `pulumi:"conditions"`
	// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
	// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	CurrentVolumeAttributesClassName pulumi.StringPtrInput                                            `pulumi:"currentVolumeAttributesClassName"`
	ModifyVolumeStatus               LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput `pulumi:"modifyVolumeStatus"`
	// phase represents the current phase of PersistentVolumeClaim.
	Phase pulumi.StringPtrInput `pulumi:"phase"`
}

func (LogstashSpecVolumeClaimTemplatesStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusOutput() LogstashSpecVolumeClaimTemplatesStatusOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusOutput)
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusOutput).ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesStatusPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusArgs, LogstashSpecVolumeClaimTemplatesStatusPtr and LogstashSpecVolumeClaimTemplatesStatusPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesStatusArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesStatusPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput
	ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput
}

type logstashSpecVolumeClaimTemplatesStatusPtrType LogstashSpecVolumeClaimTemplatesStatusArgs

func LogstashSpecVolumeClaimTemplatesStatusPtr(v *LogstashSpecVolumeClaimTemplatesStatusArgs) LogstashSpecVolumeClaimTemplatesStatusPtrInput {
	return (*logstashSpecVolumeClaimTemplatesStatusPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusPtrOutput)
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusOutput() LogstashSpecVolumeClaimTemplatesStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesStatus) *LogstashSpecVolumeClaimTemplatesStatus {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesStatusPtrOutput)
}

// accessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) AllocatedResourceStatuses() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) map[string]string { return v.AllocatedResourceStatuses }).(pulumi.StringMapOutput)
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) AllocatedResources() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} { return v.AllocatedResources }).(pulumi.MapOutput)
}

// capacity represents the actual resources of the underlying volume.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) Capacity() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} { return v.Capacity }).(pulumi.MapOutput)
}

// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'Resizing'.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) Conditions() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) []LogstashSpecVolumeClaimTemplatesStatusConditions {
		return v.Conditions
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput)
}

// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) CurrentVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) *string { return v.CurrentVolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ModifyVolumeStatus() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		return v.ModifyVolumeStatus
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// phase represents the current phase of PersistentVolumeClaim.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesStatusOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) LogstashSpecVolumeClaimTemplatesStatus {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesStatus
		return ret
	}).(LogstashSpecVolumeClaimTemplatesStatusOutput)
}

// accessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) AllocatedResourceStatuses() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.AllocatedResourceStatuses
	}).(pulumi.StringMapOutput)
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) AllocatedResources() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.AllocatedResources
	}).(pulumi.MapOutput)
}

// capacity represents the actual resources of the underlying volume.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Capacity() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.MapOutput)
}

// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'Resizing'.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Conditions() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) []LogstashSpecVolumeClaimTemplatesStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput)
}

// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) CurrentVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) *string {
		if v == nil {
			return nil
		}
		return v.CurrentVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ModifyVolumeStatus() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		if v == nil {
			return nil
		}
		return v.ModifyVolumeStatus
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// phase represents the current phase of PersistentVolumeClaim.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditions struct {
	// lastProbeTime is the time we probed the condition.
	LastProbeTime *string `pulumi:"lastProbeTime"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is the human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "Resizing" that means the underlying
	// persistent volume is being resized.
	Reason *string `pulumi:"reason"`
	Status *string `pulumi:"status"`
	// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
	Type *string `pulumi:"type"`
}

// LogstashSpecVolumeClaimTemplatesStatusConditionsInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusConditionsArgs and LogstashSpecVolumeClaimTemplatesStatusConditionsOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusConditionsInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusConditionsArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusConditionsInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsOutput
	ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsArgs struct {
	// lastProbeTime is the time we probed the condition.
	LastProbeTime pulumi.StringPtrInput `pulumi:"lastProbeTime"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is the human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "Resizing" that means the underlying
	// persistent volume is being resized.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringPtrInput `pulumi:"status"`
	// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecVolumeClaimTemplatesStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArgs) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArgs) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusConditionsOutput)
}

// LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusConditionsArray and LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusConditionsArray{ LogstashSpecVolumeClaimTemplatesStatusConditionsArgs{...} }
type LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput
	ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput
}

type LogstashSpecVolumeClaimTemplatesStatusConditionsArray []LogstashSpecVolumeClaimTemplatesStatusConditionsInput

func (LogstashSpecVolumeClaimTemplatesStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArray) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArray) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput)
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return o
}

// lastProbeTime is the time we probed the condition.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) LastProbeTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.LastProbeTime }).(pulumi.StringPtrOutput)
}

// lastTransitionTime is the time the condition transitioned from one status to another.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is the human-readable message indicating details about last transition.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// reason is a unique, this should be a short, machine understandable string that gives the reason
// for condition's last transition. If it reports "Resizing" that means the underlying
// persistent volume is being resized.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesStatusConditions {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesStatusConditions)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsOutput)
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsPatch struct {
	// lastProbeTime is the time we probed the condition.
	LastProbeTime *string `pulumi:"lastProbeTime"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is the human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "Resizing" that means the underlying
	// persistent volume is being resized.
	Reason *string `pulumi:"reason"`
	Status *string `pulumi:"status"`
	// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
	Type *string `pulumi:"type"`
}

// LogstashSpecVolumeClaimTemplatesStatusConditionsPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs and LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusConditionsPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusConditionsPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput
	ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs struct {
	// lastProbeTime is the time we probed the condition.
	LastProbeTime pulumi.StringPtrInput `pulumi:"lastProbeTime"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is the human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "Resizing" that means the underlying
	// persistent volume is being resized.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringPtrInput `pulumi:"status"`
	// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput)
}

// LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray and LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray{ LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs{...} }
type LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput
	ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput
}

type LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray []LogstashSpecVolumeClaimTemplatesStatusConditionsPatchInput

func (LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesStatusConditionsPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput)
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput {
	return o
}

// lastProbeTime is the time we probed the condition.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) LastProbeTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditionsPatch) *string { return v.LastProbeTime }).(pulumi.StringPtrOutput)
}

// lastTransitionTime is the time the condition transitioned from one status to another.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is the human-readable message indicating details about last transition.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// reason is a unique, this should be a short, machine understandable string that gives the reason
// for condition's last transition. If it reports "Resizing" that means the underlying
// persistent volume is being resized.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesStatusConditionsPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesStatusConditionsPatch {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesStatusConditionsPatch)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus struct {
	// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
	//  - Pending
	//    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
	//    the specified VolumeAttributesClass not existing.
	//  - InProgress
	//    InProgress indicates that the volume is being modified.
	//  - Infeasible
	//      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
	//       resolve the error, a valid VolumeAttributesClass needs to be specified.
	//    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
	Status *string `pulumi:"status"`
	// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
	TargetVolumeAttributesClassName *string `pulumi:"targetVolumeAttributesClassName"`
}

// LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs and LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput
	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs struct {
	// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
	//  - Pending
	//    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
	//    the specified VolumeAttributesClass not existing.
	//  - InProgress
	//    InProgress indicates that the volume is being modified.
	//  - Infeasible
	//      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
	//       resolve the error, a valid VolumeAttributesClass needs to be specified.
	//    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
	TargetVolumeAttributesClassName pulumi.StringPtrInput `pulumi:"targetVolumeAttributesClassName"`
}

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput)
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput).ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs, LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtr and LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput
	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput
}

type logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs

func LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtr(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput {
	return (*logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
//   - Pending
//     Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
//     the specified VolumeAttributesClass not existing.
//   - InProgress
//     InProgress indicates that the volume is being modified.
//   - Infeasible
//     Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
//     resolve the error, a valid VolumeAttributesClass needs to be specified.
//     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) TargetVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string {
		return v.TargetVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus
		return ret
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput)
}

// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
//   - Pending
//     Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
//     the specified VolumeAttributesClass not existing.
//   - InProgress
//     InProgress indicates that the volume is being modified.
//   - Infeasible
//     Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
//     resolve the error, a valid VolumeAttributesClass needs to be specified.
//     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) TargetVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string {
		if v == nil {
			return nil
		}
		return v.TargetVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch struct {
	// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
	//  - Pending
	//    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
	//    the specified VolumeAttributesClass not existing.
	//  - InProgress
	//    InProgress indicates that the volume is being modified.
	//  - Infeasible
	//      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
	//       resolve the error, a valid VolumeAttributesClass needs to be specified.
	//    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
	Status *string `pulumi:"status"`
	// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
	TargetVolumeAttributesClassName *string `pulumi:"targetVolumeAttributesClassName"`
}

// LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs and LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput
	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs struct {
	// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
	//  - Pending
	//    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
	//    the specified VolumeAttributesClass not existing.
	//  - InProgress
	//    InProgress indicates that the volume is being modified.
	//  - Infeasible
	//      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
	//       resolve the error, a valid VolumeAttributesClass needs to be specified.
	//    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
	TargetVolumeAttributesClassName pulumi.StringPtrInput `pulumi:"targetVolumeAttributesClassName"`
}

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput).ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs, LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtr and LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrType LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs

func LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtr(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrType) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrType) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput)
}

// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
//   - Pending
//     Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
//     the specified VolumeAttributesClass not existing.
//   - InProgress
//     InProgress indicates that the volume is being modified.
//   - Infeasible
//     Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
//     resolve the error, a valid VolumeAttributesClass needs to be specified.
//     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput) TargetVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch) *string {
		return v.TargetVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput)
}

// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
//   - Pending
//     Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
//     the specified VolumeAttributesClass not existing.
//   - InProgress
//     InProgress indicates that the volume is being modified.
//   - Infeasible
//     Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
//     resolve the error, a valid VolumeAttributesClass needs to be specified.
//     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput) TargetVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.TargetVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusPatch struct {
	// accessModes contains the actual access modes the volume backing the PVC has.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes []string `pulumi:"accessModes"`
	// allocatedResourceStatuses stores status of resource being resized for the given PVC.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// ClaimResourceStatus can be in any of following states:
	// 	- ControllerResizeInProgress:
	// 		State set when resize controller starts resizing the volume in control-plane.
	// 	- ControllerResizeFailed:
	// 		State set when resize has failed in resize controller with a terminal error.
	// 	- NodeResizePending:
	// 		State set when resize controller has finished resizing the volume but further resizing of
	// 		volume is needed on the node.
	// 	- NodeResizeInProgress:
	// 		State set when kubelet starts resizing the volume.
	// 	- NodeResizeFailed:
	// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
	// 		NodeResizeFailed.
	// For example: if expanding a PVC for more capacity - this field can be one of the following states:
	// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
	// When this field is not set, it means that no resize operation is in progress for the given PVC.
	//
	// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResourceStatuses map[string]string `pulumi:"allocatedResourceStatuses"`
	// allocatedResources tracks the resources allocated to a PVC including its capacity.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// Capacity reported here may be larger than the actual capacity when a volume expansion operation
	// is requested.
	// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
	// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
	// If a volume expansion capacity request is lowered, allocatedResources is only
	// lowered if there are no expansion operations in progress and if the actual volume capacity
	// is equal or lower than the requested capacity.
	//
	// A controller that receives PVC update with previously unknown resourceName
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResources map[string]interface{} `pulumi:"allocatedResources"`
	// capacity represents the actual resources of the underlying volume.
	Capacity map[string]interface{} `pulumi:"capacity"`
	// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
	// resized then the Condition will be set to 'Resizing'.
	Conditions []LogstashSpecVolumeClaimTemplatesStatusConditionsPatch `pulumi:"conditions"`
	// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
	// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	CurrentVolumeAttributesClassName *string                                                        `pulumi:"currentVolumeAttributesClassName"`
	ModifyVolumeStatus               *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch `pulumi:"modifyVolumeStatus"`
	// phase represents the current phase of PersistentVolumeClaim.
	Phase *string `pulumi:"phase"`
}

// LogstashSpecVolumeClaimTemplatesStatusPatchInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusPatchArgs and LogstashSpecVolumeClaimTemplatesStatusPatchOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusPatchInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusPatchArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusPatchInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusPatchOutput() LogstashSpecVolumeClaimTemplatesStatusPatchOutput
	ToLogstashSpecVolumeClaimTemplatesStatusPatchOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchOutput
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusPatchArgs struct {
	// accessModes contains the actual access modes the volume backing the PVC has.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes pulumi.StringArrayInput `pulumi:"accessModes"`
	// allocatedResourceStatuses stores status of resource being resized for the given PVC.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// ClaimResourceStatus can be in any of following states:
	// 	- ControllerResizeInProgress:
	// 		State set when resize controller starts resizing the volume in control-plane.
	// 	- ControllerResizeFailed:
	// 		State set when resize has failed in resize controller with a terminal error.
	// 	- NodeResizePending:
	// 		State set when resize controller has finished resizing the volume but further resizing of
	// 		volume is needed on the node.
	// 	- NodeResizeInProgress:
	// 		State set when kubelet starts resizing the volume.
	// 	- NodeResizeFailed:
	// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
	// 		NodeResizeFailed.
	// For example: if expanding a PVC for more capacity - this field can be one of the following states:
	// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
	// When this field is not set, it means that no resize operation is in progress for the given PVC.
	//
	// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResourceStatuses pulumi.StringMapInput `pulumi:"allocatedResourceStatuses"`
	// allocatedResources tracks the resources allocated to a PVC including its capacity.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// Capacity reported here may be larger than the actual capacity when a volume expansion operation
	// is requested.
	// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
	// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
	// If a volume expansion capacity request is lowered, allocatedResources is only
	// lowered if there are no expansion operations in progress and if the actual volume capacity
	// is equal or lower than the requested capacity.
	//
	// A controller that receives PVC update with previously unknown resourceName
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResources pulumi.MapInput `pulumi:"allocatedResources"`
	// capacity represents the actual resources of the underlying volume.
	Capacity pulumi.MapInput `pulumi:"capacity"`
	// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
	// resized then the Condition will be set to 'Resizing'.
	Conditions LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayInput `pulumi:"conditions"`
	// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
	// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	CurrentVolumeAttributesClassName pulumi.StringPtrInput                                                 `pulumi:"currentVolumeAttributesClassName"`
	ModifyVolumeStatus               LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrInput `pulumi:"modifyVolumeStatus"`
	// phase represents the current phase of PersistentVolumeClaim.
	Phase pulumi.StringPtrInput `pulumi:"phase"`
}

func (LogstashSpecVolumeClaimTemplatesStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusPatch)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusPatchOutput() LogstashSpecVolumeClaimTemplatesStatusPatchOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPatchOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusPatchOutput)
}

func (i LogstashSpecVolumeClaimTemplatesStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusPatchArgs) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusPatchOutput).ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesStatusPatchPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusPatchArgs, LogstashSpecVolumeClaimTemplatesStatusPatchPtr and LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusPatchPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesStatusPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesStatusPatchPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput
	ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput
}

type logstashSpecVolumeClaimTemplatesStatusPatchPtrType LogstashSpecVolumeClaimTemplatesStatusPatchArgs

func LogstashSpecVolumeClaimTemplatesStatusPatchPtr(v *LogstashSpecVolumeClaimTemplatesStatusPatchArgs) LogstashSpecVolumeClaimTemplatesStatusPatchPtrInput {
	return (*logstashSpecVolumeClaimTemplatesStatusPatchPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusPatch)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesStatusPatchPtrType) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesStatusPatchPtrType) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput)
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusPatchOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusPatchOutput() LogstashSpecVolumeClaimTemplatesStatusPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusPatchOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesStatusPatch) *LogstashSpecVolumeClaimTemplatesStatusPatch {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput)
}

// accessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) AllocatedResourceStatuses() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) map[string]string {
		return v.AllocatedResourceStatuses
	}).(pulumi.StringMapOutput)
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) AllocatedResources() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) map[string]interface{} {
		return v.AllocatedResources
	}).(pulumi.MapOutput)
}

// capacity represents the actual resources of the underlying volume.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) Capacity() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) map[string]interface{} { return v.Capacity }).(pulumi.MapOutput)
}

// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'Resizing'.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) Conditions() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) []LogstashSpecVolumeClaimTemplatesStatusConditionsPatch {
		return v.Conditions
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput)
}

// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) CurrentVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) *string { return v.CurrentVolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) ModifyVolumeStatus() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch {
		return v.ModifyVolumeStatus
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput)
}

// phase represents the current phase of PersistentVolumeClaim.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusPatch) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusPatch)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusPatchPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesStatusPatchOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) LogstashSpecVolumeClaimTemplatesStatusPatch {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesStatusPatch
		return ret
	}).(LogstashSpecVolumeClaimTemplatesStatusPatchOutput)
}

// accessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) AllocatedResourceStatuses() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.AllocatedResourceStatuses
	}).(pulumi.StringMapOutput)
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) AllocatedResources() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.AllocatedResources
	}).(pulumi.MapOutput)
}

// capacity represents the actual resources of the underlying volume.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) Capacity() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.MapOutput)
}

// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'Resizing'.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) Conditions() LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) []LogstashSpecVolumeClaimTemplatesStatusConditionsPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput)
}

// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) CurrentVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.CurrentVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) ModifyVolumeStatus() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatch {
		if v == nil {
			return nil
		}
		return v.ModifyVolumeStatus
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput)
}

// phase represents the current phase of PersistentVolumeClaim.
func (o LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatus struct {
	AvailableNodes *int `pulumi:"availableNodes"`
	// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
	ElasticsearchAssociationsStatus map[string]string `pulumi:"elasticsearchAssociationsStatus"`
	ExpectedNodes                   *int              `pulumi:"expectedNodes"`
	Health                          *string           `pulumi:"health"`
	// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
	MonitoringAssociationStatus map[string]string `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration is the most recent generation observed for this Logstash instance.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Logstash
	// controller has not yet processed the changes contained in the Logstash specification.
	ObservedGeneration *int    `pulumi:"observedGeneration"`
	Selector           *string `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version *string `pulumi:"version"`
}

// LogstashStatusInput is an input type that accepts LogstashStatusArgs and LogstashStatusOutput values.
// You can construct a concrete instance of `LogstashStatusInput` via:
//
//	LogstashStatusArgs{...}
type LogstashStatusInput interface {
	pulumi.Input

	ToLogstashStatusOutput() LogstashStatusOutput
	ToLogstashStatusOutputWithContext(context.Context) LogstashStatusOutput
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusArgs struct {
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
	ElasticsearchAssociationsStatus pulumi.StringMapInput `pulumi:"elasticsearchAssociationsStatus"`
	ExpectedNodes                   pulumi.IntPtrInput    `pulumi:"expectedNodes"`
	Health                          pulumi.StringPtrInput `pulumi:"health"`
	// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
	MonitoringAssociationStatus pulumi.StringMapInput `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration is the most recent generation observed for this Logstash instance.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Logstash
	// controller has not yet processed the changes contained in the Logstash specification.
	ObservedGeneration pulumi.IntPtrInput    `pulumi:"observedGeneration"`
	Selector           pulumi.StringPtrInput `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (LogstashStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashStatus)(nil)).Elem()
}

func (i LogstashStatusArgs) ToLogstashStatusOutput() LogstashStatusOutput {
	return i.ToLogstashStatusOutputWithContext(context.Background())
}

func (i LogstashStatusArgs) ToLogstashStatusOutputWithContext(ctx context.Context) LogstashStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusOutput)
}

func (i LogstashStatusArgs) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return i.ToLogstashStatusPtrOutputWithContext(context.Background())
}

func (i LogstashStatusArgs) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusOutput).ToLogstashStatusPtrOutputWithContext(ctx)
}

// LogstashStatusPtrInput is an input type that accepts LogstashStatusArgs, LogstashStatusPtr and LogstashStatusPtrOutput values.
// You can construct a concrete instance of `LogstashStatusPtrInput` via:
//
//	        LogstashStatusArgs{...}
//
//	or:
//
//	        nil
type LogstashStatusPtrInput interface {
	pulumi.Input

	ToLogstashStatusPtrOutput() LogstashStatusPtrOutput
	ToLogstashStatusPtrOutputWithContext(context.Context) LogstashStatusPtrOutput
}

type logstashStatusPtrType LogstashStatusArgs

func LogstashStatusPtr(v *LogstashStatusArgs) LogstashStatusPtrInput {
	return (*logstashStatusPtrType)(v)
}

func (*logstashStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashStatus)(nil)).Elem()
}

func (i *logstashStatusPtrType) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return i.ToLogstashStatusPtrOutputWithContext(context.Background())
}

func (i *logstashStatusPtrType) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusPtrOutput)
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusOutput struct{ *pulumi.OutputState }

func (LogstashStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashStatus)(nil)).Elem()
}

func (o LogstashStatusOutput) ToLogstashStatusOutput() LogstashStatusOutput {
	return o
}

func (o LogstashStatusOutput) ToLogstashStatusOutputWithContext(ctx context.Context) LogstashStatusOutput {
	return o
}

func (o LogstashStatusOutput) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return o.ToLogstashStatusPtrOutputWithContext(context.Background())
}

func (o LogstashStatusOutput) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashStatus) *LogstashStatus {
		return &v
	}).(LogstashStatusPtrOutput)
}

func (o LogstashStatusOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
func (o LogstashStatusOutput) ElasticsearchAssociationsStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashStatus) map[string]string { return v.ElasticsearchAssociationsStatus }).(pulumi.StringMapOutput)
}

func (o LogstashStatusOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *int { return v.ExpectedNodes }).(pulumi.IntPtrOutput)
}

func (o LogstashStatusOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
func (o LogstashStatusOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashStatus) map[string]string { return v.MonitoringAssociationStatus }).(pulumi.StringMapOutput)
}

// ObservedGeneration is the most recent generation observed for this Logstash instance.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Logstash
// controller has not yet processed the changes contained in the Logstash specification.
func (o LogstashStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

func (o LogstashStatusOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *string { return v.Selector }).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o LogstashStatusOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type LogstashStatusPtrOutput struct{ *pulumi.OutputState }

func (LogstashStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashStatus)(nil)).Elem()
}

func (o LogstashStatusPtrOutput) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return o
}

func (o LogstashStatusPtrOutput) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return o
}

func (o LogstashStatusPtrOutput) Elem() LogstashStatusOutput {
	return o.ApplyT(func(v *LogstashStatus) LogstashStatus {
		if v != nil {
			return *v
		}
		var ret LogstashStatus
		return ret
	}).(LogstashStatusOutput)
}

func (o LogstashStatusPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
func (o LogstashStatusPtrOutput) ElasticsearchAssociationsStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.ElasticsearchAssociationsStatus
	}).(pulumi.StringMapOutput)
}

func (o LogstashStatusPtrOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *int {
		if v == nil {
			return nil
		}
		return v.ExpectedNodes
	}).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
func (o LogstashStatusPtrOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.MonitoringAssociationStatus
	}).(pulumi.StringMapOutput)
}

// ObservedGeneration is the most recent generation observed for this Logstash instance.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Logstash
// controller has not yet processed the changes contained in the Logstash specification.
func (o LogstashStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPtrOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o LogstashStatusPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusPatch struct {
	AvailableNodes *int `pulumi:"availableNodes"`
	// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
	ElasticsearchAssociationsStatus map[string]string `pulumi:"elasticsearchAssociationsStatus"`
	ExpectedNodes                   *int              `pulumi:"expectedNodes"`
	Health                          *string           `pulumi:"health"`
	// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
	MonitoringAssociationStatus map[string]string `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration is the most recent generation observed for this Logstash instance.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Logstash
	// controller has not yet processed the changes contained in the Logstash specification.
	ObservedGeneration *int    `pulumi:"observedGeneration"`
	Selector           *string `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version *string `pulumi:"version"`
}

// LogstashStatusPatchInput is an input type that accepts LogstashStatusPatchArgs and LogstashStatusPatchOutput values.
// You can construct a concrete instance of `LogstashStatusPatchInput` via:
//
//	LogstashStatusPatchArgs{...}
type LogstashStatusPatchInput interface {
	pulumi.Input

	ToLogstashStatusPatchOutput() LogstashStatusPatchOutput
	ToLogstashStatusPatchOutputWithContext(context.Context) LogstashStatusPatchOutput
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusPatchArgs struct {
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
	ElasticsearchAssociationsStatus pulumi.StringMapInput `pulumi:"elasticsearchAssociationsStatus"`
	ExpectedNodes                   pulumi.IntPtrInput    `pulumi:"expectedNodes"`
	Health                          pulumi.StringPtrInput `pulumi:"health"`
	// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
	MonitoringAssociationStatus pulumi.StringMapInput `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration is the most recent generation observed for this Logstash instance.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Logstash
	// controller has not yet processed the changes contained in the Logstash specification.
	ObservedGeneration pulumi.IntPtrInput    `pulumi:"observedGeneration"`
	Selector           pulumi.StringPtrInput `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (LogstashStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashStatusPatch)(nil)).Elem()
}

func (i LogstashStatusPatchArgs) ToLogstashStatusPatchOutput() LogstashStatusPatchOutput {
	return i.ToLogstashStatusPatchOutputWithContext(context.Background())
}

func (i LogstashStatusPatchArgs) ToLogstashStatusPatchOutputWithContext(ctx context.Context) LogstashStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusPatchOutput)
}

func (i LogstashStatusPatchArgs) ToLogstashStatusPatchPtrOutput() LogstashStatusPatchPtrOutput {
	return i.ToLogstashStatusPatchPtrOutputWithContext(context.Background())
}

func (i LogstashStatusPatchArgs) ToLogstashStatusPatchPtrOutputWithContext(ctx context.Context) LogstashStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusPatchOutput).ToLogstashStatusPatchPtrOutputWithContext(ctx)
}

// LogstashStatusPatchPtrInput is an input type that accepts LogstashStatusPatchArgs, LogstashStatusPatchPtr and LogstashStatusPatchPtrOutput values.
// You can construct a concrete instance of `LogstashStatusPatchPtrInput` via:
//
//	        LogstashStatusPatchArgs{...}
//
//	or:
//
//	        nil
type LogstashStatusPatchPtrInput interface {
	pulumi.Input

	ToLogstashStatusPatchPtrOutput() LogstashStatusPatchPtrOutput
	ToLogstashStatusPatchPtrOutputWithContext(context.Context) LogstashStatusPatchPtrOutput
}

type logstashStatusPatchPtrType LogstashStatusPatchArgs

func LogstashStatusPatchPtr(v *LogstashStatusPatchArgs) LogstashStatusPatchPtrInput {
	return (*logstashStatusPatchPtrType)(v)
}

func (*logstashStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashStatusPatch)(nil)).Elem()
}

func (i *logstashStatusPatchPtrType) ToLogstashStatusPatchPtrOutput() LogstashStatusPatchPtrOutput {
	return i.ToLogstashStatusPatchPtrOutputWithContext(context.Background())
}

func (i *logstashStatusPatchPtrType) ToLogstashStatusPatchPtrOutputWithContext(ctx context.Context) LogstashStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusPatchPtrOutput)
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusPatchOutput struct{ *pulumi.OutputState }

func (LogstashStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashStatusPatch)(nil)).Elem()
}

func (o LogstashStatusPatchOutput) ToLogstashStatusPatchOutput() LogstashStatusPatchOutput {
	return o
}

func (o LogstashStatusPatchOutput) ToLogstashStatusPatchOutputWithContext(ctx context.Context) LogstashStatusPatchOutput {
	return o
}

func (o LogstashStatusPatchOutput) ToLogstashStatusPatchPtrOutput() LogstashStatusPatchPtrOutput {
	return o.ToLogstashStatusPatchPtrOutputWithContext(context.Background())
}

func (o LogstashStatusPatchOutput) ToLogstashStatusPatchPtrOutputWithContext(ctx context.Context) LogstashStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashStatusPatch) *LogstashStatusPatch {
		return &v
	}).(LogstashStatusPatchPtrOutput)
}

func (o LogstashStatusPatchOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatusPatch) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
func (o LogstashStatusPatchOutput) ElasticsearchAssociationsStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashStatusPatch) map[string]string { return v.ElasticsearchAssociationsStatus }).(pulumi.StringMapOutput)
}

func (o LogstashStatusPatchOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatusPatch) *int { return v.ExpectedNodes }).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPatchOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatusPatch) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
func (o LogstashStatusPatchOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashStatusPatch) map[string]string { return v.MonitoringAssociationStatus }).(pulumi.StringMapOutput)
}

// ObservedGeneration is the most recent generation observed for this Logstash instance.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Logstash
// controller has not yet processed the changes contained in the Logstash specification.
func (o LogstashStatusPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatusPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPatchOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatusPatch) *string { return v.Selector }).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o LogstashStatusPatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatusPatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type LogstashStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (LogstashStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashStatusPatch)(nil)).Elem()
}

func (o LogstashStatusPatchPtrOutput) ToLogstashStatusPatchPtrOutput() LogstashStatusPatchPtrOutput {
	return o
}

func (o LogstashStatusPatchPtrOutput) ToLogstashStatusPatchPtrOutputWithContext(ctx context.Context) LogstashStatusPatchPtrOutput {
	return o
}

func (o LogstashStatusPatchPtrOutput) Elem() LogstashStatusPatchOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) LogstashStatusPatch {
		if v != nil {
			return *v
		}
		var ret LogstashStatusPatch
		return ret
	}).(LogstashStatusPatchOutput)
}

func (o LogstashStatusPatchPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
func (o LogstashStatusPatchPtrOutput) ElasticsearchAssociationsStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.ElasticsearchAssociationsStatus
	}).(pulumi.StringMapOutput)
}

func (o LogstashStatusPatchPtrOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.ExpectedNodes
	}).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPatchPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
func (o LogstashStatusPatchPtrOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MonitoringAssociationStatus
	}).(pulumi.StringMapOutput)
}

// ObservedGeneration is the most recent generation observed for this Logstash instance.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Logstash
// controller has not yet processed the changes contained in the Logstash specification.
func (o LogstashStatusPatchPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPatchPtrOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o LogstashStatusPatchPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashTypeInput)(nil)).Elem(), LogstashTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashTypeArrayInput)(nil)).Elem(), LogstashTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashListTypeInput)(nil)).Elem(), LogstashListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashPatchTypeInput)(nil)).Elem(), LogstashPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecInput)(nil)).Elem(), LogstashSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPtrInput)(nil)).Elem(), LogstashSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecConfigRefInput)(nil)).Elem(), LogstashSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecConfigRefPtrInput)(nil)).Elem(), LogstashSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecConfigRefPatchInput)(nil)).Elem(), LogstashSpecConfigRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecConfigRefPatchPtrInput)(nil)).Elem(), LogstashSpecConfigRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecElasticsearchRefsInput)(nil)).Elem(), LogstashSpecElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecElasticsearchRefsArrayInput)(nil)).Elem(), LogstashSpecElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecElasticsearchRefsPatchInput)(nil)).Elem(), LogstashSpecElasticsearchRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecElasticsearchRefsPatchArrayInput)(nil)).Elem(), LogstashSpecElasticsearchRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringInput)(nil)).Elem(), LogstashSpecMonitoringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringPtrInput)(nil)).Elem(), LogstashSpecMonitoringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsInput)(nil)).Elem(), LogstashSpecMonitoringLogsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsPtrInput)(nil)).Elem(), LogstashSpecMonitoringLogsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsInput)(nil)).Elem(), LogstashSpecMonitoringLogsElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsArrayInput)(nil)).Elem(), LogstashSpecMonitoringLogsElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsPatchInput)(nil)).Elem(), LogstashSpecMonitoringLogsElasticsearchRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayInput)(nil)).Elem(), LogstashSpecMonitoringLogsElasticsearchRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsPatchInput)(nil)).Elem(), LogstashSpecMonitoringLogsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsPatchPtrInput)(nil)).Elem(), LogstashSpecMonitoringLogsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsInput)(nil)).Elem(), LogstashSpecMonitoringMetricsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsPtrInput)(nil)).Elem(), LogstashSpecMonitoringMetricsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsInput)(nil)).Elem(), LogstashSpecMonitoringMetricsElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput)(nil)).Elem(), LogstashSpecMonitoringMetricsElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsPatchInput)(nil)).Elem(), LogstashSpecMonitoringMetricsElasticsearchRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayInput)(nil)).Elem(), LogstashSpecMonitoringMetricsElasticsearchRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsPatchInput)(nil)).Elem(), LogstashSpecMonitoringMetricsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsPatchPtrInput)(nil)).Elem(), LogstashSpecMonitoringMetricsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringPatchInput)(nil)).Elem(), LogstashSpecMonitoringPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringPatchPtrInput)(nil)).Elem(), LogstashSpecMonitoringPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPatchInput)(nil)).Elem(), LogstashSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPatchPtrInput)(nil)).Elem(), LogstashSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPipelinesRefInput)(nil)).Elem(), LogstashSpecPipelinesRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPipelinesRefPtrInput)(nil)).Elem(), LogstashSpecPipelinesRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPipelinesRefPatchInput)(nil)).Elem(), LogstashSpecPipelinesRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPipelinesRefPatchPtrInput)(nil)).Elem(), LogstashSpecPipelinesRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsInput)(nil)).Elem(), LogstashSpecSecureSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsArrayInput)(nil)).Elem(), LogstashSpecSecureSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsEntriesInput)(nil)).Elem(), LogstashSpecSecureSettingsEntriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsEntriesArrayInput)(nil)).Elem(), LogstashSpecSecureSettingsEntriesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsEntriesPatchInput)(nil)).Elem(), LogstashSpecSecureSettingsEntriesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsEntriesPatchArrayInput)(nil)).Elem(), LogstashSpecSecureSettingsEntriesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsPatchInput)(nil)).Elem(), LogstashSpecSecureSettingsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsPatchArrayInput)(nil)).Elem(), LogstashSpecSecureSettingsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesInput)(nil)).Elem(), LogstashSpecServicesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesArrayInput)(nil)).Elem(), LogstashSpecServicesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesPatchInput)(nil)).Elem(), LogstashSpecServicesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesPatchArrayInput)(nil)).Elem(), LogstashSpecServicesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceInput)(nil)).Elem(), LogstashSpecServicesServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServicePtrInput)(nil)).Elem(), LogstashSpecServicesServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceMetadataInput)(nil)).Elem(), LogstashSpecServicesServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceMetadataPtrInput)(nil)).Elem(), LogstashSpecServicesServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceMetadataPatchInput)(nil)).Elem(), LogstashSpecServicesServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceMetadataPatchPtrInput)(nil)).Elem(), LogstashSpecServicesServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServicePatchInput)(nil)).Elem(), LogstashSpecServicesServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServicePatchPtrInput)(nil)).Elem(), LogstashSpecServicesServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecInput)(nil)).Elem(), LogstashSpecServicesServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPatchInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPatchPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPortsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsArrayInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPortsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsPatchInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPortsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsPatchArrayInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPortsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigPatchInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsInput)(nil)).Elem(), LogstashSpecServicesTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsPtrInput)(nil)).Elem(), LogstashSpecServicesTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsCertificateInput)(nil)).Elem(), LogstashSpecServicesTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsCertificatePtrInput)(nil)).Elem(), LogstashSpecServicesTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsCertificatePatchInput)(nil)).Elem(), LogstashSpecServicesTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsCertificatePatchPtrInput)(nil)).Elem(), LogstashSpecServicesTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsPatchInput)(nil)).Elem(), LogstashSpecServicesTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsPatchPtrInput)(nil)).Elem(), LogstashSpecServicesTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificatePtrInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificatePatchInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificatePatchPtrInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyInput)(nil)).Elem(), LogstashSpecUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyPtrInput)(nil)).Elem(), LogstashSpecUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyPatchInput)(nil)).Elem(), LogstashSpecUpdateStrategyPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyPatchPtrInput)(nil)).Elem(), LogstashSpecUpdateStrategyPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdateInput)(nil)).Elem(), LogstashSpecUpdateStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdatePtrInput)(nil)).Elem(), LogstashSpecUpdateStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdatePatchInput)(nil)).Elem(), LogstashSpecUpdateStrategyRollingUpdatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdatePatchPtrInput)(nil)).Elem(), LogstashSpecUpdateStrategyRollingUpdatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesPatchArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecResourcesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusPatchInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusPatchPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashStatusInput)(nil)).Elem(), LogstashStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashStatusPtrInput)(nil)).Elem(), LogstashStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashStatusPatchInput)(nil)).Elem(), LogstashStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashStatusPatchPtrInput)(nil)).Elem(), LogstashStatusPatchArgs{})
	pulumi.RegisterOutputType(LogstashTypeOutput{})
	pulumi.RegisterOutputType(LogstashTypeArrayOutput{})
	pulumi.RegisterOutputType(LogstashListTypeOutput{})
	pulumi.RegisterOutputType(LogstashPatchTypeOutput{})
	pulumi.RegisterOutputType(LogstashSpecOutput{})
	pulumi.RegisterOutputType(LogstashSpecPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecConfigRefOutput{})
	pulumi.RegisterOutputType(LogstashSpecConfigRefPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecConfigRefPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecConfigRefPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(LogstashSpecElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecElasticsearchRefsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecElasticsearchRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsElasticsearchRefsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsElasticsearchRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsElasticsearchRefsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsElasticsearchRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecPipelinesRefOutput{})
	pulumi.RegisterOutputType(LogstashSpecPipelinesRefPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecPipelinesRefPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecPipelinesRefPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsEntriesOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsEntriesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsEntriesPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsEntriesPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServicePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceMetadataOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceMetadataPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceMetadataPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServicePatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServicePatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPortsOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPortsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPortsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPortsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIPPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsCertificateOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsCertificatePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsCertificatePatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificatePatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyRollingUpdateOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyRollingUpdatePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyRollingUpdatePatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyRollingUpdatePatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesMetadataOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesMetadataPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourcePatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecResourcesPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusConditionsOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusPatchOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(LogstashStatusOutput{})
	pulumi.RegisterOutputType(LogstashStatusPtrOutput{})
	pulumi.RegisterOutputType(LogstashStatusPatchOutput{})
	pulumi.RegisterOutputType(LogstashStatusPatchPtrOutput{})
}
