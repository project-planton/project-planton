// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
type ElasticMapsServerType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta       `pulumi:"metadata"`
	Spec     *ElasticMapsServerSpec   `pulumi:"spec"`
	Status   *ElasticMapsServerStatus `pulumi:"status"`
}

// ElasticMapsServerTypeInput is an input type that accepts ElasticMapsServerTypeArgs and ElasticMapsServerTypeOutput values.
// You can construct a concrete instance of `ElasticMapsServerTypeInput` via:
//
//	ElasticMapsServerTypeArgs{...}
type ElasticMapsServerTypeInput interface {
	pulumi.Input

	ToElasticMapsServerTypeOutput() ElasticMapsServerTypeOutput
	ToElasticMapsServerTypeOutputWithContext(context.Context) ElasticMapsServerTypeOutput
}

// ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
type ElasticMapsServerTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput       `pulumi:"metadata"`
	Spec     ElasticMapsServerSpecPtrInput   `pulumi:"spec"`
	Status   ElasticMapsServerStatusPtrInput `pulumi:"status"`
}

func (ElasticMapsServerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerType)(nil)).Elem()
}

func (i ElasticMapsServerTypeArgs) ToElasticMapsServerTypeOutput() ElasticMapsServerTypeOutput {
	return i.ToElasticMapsServerTypeOutputWithContext(context.Background())
}

func (i ElasticMapsServerTypeArgs) ToElasticMapsServerTypeOutputWithContext(ctx context.Context) ElasticMapsServerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerTypeOutput)
}

// ElasticMapsServerTypeArrayInput is an input type that accepts ElasticMapsServerTypeArray and ElasticMapsServerTypeArrayOutput values.
// You can construct a concrete instance of `ElasticMapsServerTypeArrayInput` via:
//
//	ElasticMapsServerTypeArray{ ElasticMapsServerTypeArgs{...} }
type ElasticMapsServerTypeArrayInput interface {
	pulumi.Input

	ToElasticMapsServerTypeArrayOutput() ElasticMapsServerTypeArrayOutput
	ToElasticMapsServerTypeArrayOutputWithContext(context.Context) ElasticMapsServerTypeArrayOutput
}

type ElasticMapsServerTypeArray []ElasticMapsServerTypeInput

func (ElasticMapsServerTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerType)(nil)).Elem()
}

func (i ElasticMapsServerTypeArray) ToElasticMapsServerTypeArrayOutput() ElasticMapsServerTypeArrayOutput {
	return i.ToElasticMapsServerTypeArrayOutputWithContext(context.Background())
}

func (i ElasticMapsServerTypeArray) ToElasticMapsServerTypeArrayOutputWithContext(ctx context.Context) ElasticMapsServerTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerTypeArrayOutput)
}

// ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
type ElasticMapsServerTypeOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerType)(nil)).Elem()
}

func (o ElasticMapsServerTypeOutput) ToElasticMapsServerTypeOutput() ElasticMapsServerTypeOutput {
	return o
}

func (o ElasticMapsServerTypeOutput) ToElasticMapsServerTypeOutputWithContext(ctx context.Context) ElasticMapsServerTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticMapsServerTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticMapsServerTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ElasticMapsServerTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o ElasticMapsServerTypeOutput) Spec() ElasticMapsServerSpecPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerType) *ElasticMapsServerSpec { return v.Spec }).(ElasticMapsServerSpecPtrOutput)
}

func (o ElasticMapsServerTypeOutput) Status() ElasticMapsServerStatusPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerType) *ElasticMapsServerStatus { return v.Status }).(ElasticMapsServerStatusPtrOutput)
}

type ElasticMapsServerTypeArrayOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerType)(nil)).Elem()
}

func (o ElasticMapsServerTypeArrayOutput) ToElasticMapsServerTypeArrayOutput() ElasticMapsServerTypeArrayOutput {
	return o
}

func (o ElasticMapsServerTypeArrayOutput) ToElasticMapsServerTypeArrayOutputWithContext(ctx context.Context) ElasticMapsServerTypeArrayOutput {
	return o
}

func (o ElasticMapsServerTypeArrayOutput) Index(i pulumi.IntInput) ElasticMapsServerTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticMapsServerType {
		return vs[0].([]ElasticMapsServerType)[vs[1].(int)]
	}).(ElasticMapsServerTypeOutput)
}

// ElasticMapsServerList is a list of ElasticMapsServer
type ElasticMapsServerListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of elasticmapsservers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []ElasticMapsServerType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ElasticMapsServerListTypeInput is an input type that accepts ElasticMapsServerListTypeArgs and ElasticMapsServerListTypeOutput values.
// You can construct a concrete instance of `ElasticMapsServerListTypeInput` via:
//
//	ElasticMapsServerListTypeArgs{...}
type ElasticMapsServerListTypeInput interface {
	pulumi.Input

	ToElasticMapsServerListTypeOutput() ElasticMapsServerListTypeOutput
	ToElasticMapsServerListTypeOutputWithContext(context.Context) ElasticMapsServerListTypeOutput
}

// ElasticMapsServerList is a list of ElasticMapsServer
type ElasticMapsServerListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of elasticmapsservers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items ElasticMapsServerTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ElasticMapsServerListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerListType)(nil)).Elem()
}

func (i ElasticMapsServerListTypeArgs) ToElasticMapsServerListTypeOutput() ElasticMapsServerListTypeOutput {
	return i.ToElasticMapsServerListTypeOutputWithContext(context.Background())
}

func (i ElasticMapsServerListTypeArgs) ToElasticMapsServerListTypeOutputWithContext(ctx context.Context) ElasticMapsServerListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerListTypeOutput)
}

// ElasticMapsServerList is a list of ElasticMapsServer
type ElasticMapsServerListTypeOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerListType)(nil)).Elem()
}

func (o ElasticMapsServerListTypeOutput) ToElasticMapsServerListTypeOutput() ElasticMapsServerListTypeOutput {
	return o
}

func (o ElasticMapsServerListTypeOutput) ToElasticMapsServerListTypeOutputWithContext(ctx context.Context) ElasticMapsServerListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticMapsServerListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of elasticmapsservers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o ElasticMapsServerListTypeOutput) Items() ElasticMapsServerTypeArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerListType) []ElasticMapsServerType { return v.Items }).(ElasticMapsServerTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticMapsServerListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticMapsServerListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
type ElasticMapsServerPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch       `pulumi:"metadata"`
	Spec     *ElasticMapsServerSpecPatch   `pulumi:"spec"`
	Status   *ElasticMapsServerStatusPatch `pulumi:"status"`
}

// ElasticMapsServerPatchTypeInput is an input type that accepts ElasticMapsServerPatchTypeArgs and ElasticMapsServerPatchTypeOutput values.
// You can construct a concrete instance of `ElasticMapsServerPatchTypeInput` via:
//
//	ElasticMapsServerPatchTypeArgs{...}
type ElasticMapsServerPatchTypeInput interface {
	pulumi.Input

	ToElasticMapsServerPatchTypeOutput() ElasticMapsServerPatchTypeOutput
	ToElasticMapsServerPatchTypeOutputWithContext(context.Context) ElasticMapsServerPatchTypeOutput
}

// ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
type ElasticMapsServerPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput       `pulumi:"metadata"`
	Spec     ElasticMapsServerSpecPatchPtrInput   `pulumi:"spec"`
	Status   ElasticMapsServerStatusPatchPtrInput `pulumi:"status"`
}

func (ElasticMapsServerPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerPatchType)(nil)).Elem()
}

func (i ElasticMapsServerPatchTypeArgs) ToElasticMapsServerPatchTypeOutput() ElasticMapsServerPatchTypeOutput {
	return i.ToElasticMapsServerPatchTypeOutputWithContext(context.Background())
}

func (i ElasticMapsServerPatchTypeArgs) ToElasticMapsServerPatchTypeOutputWithContext(ctx context.Context) ElasticMapsServerPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerPatchTypeOutput)
}

// ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
type ElasticMapsServerPatchTypeOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerPatchType)(nil)).Elem()
}

func (o ElasticMapsServerPatchTypeOutput) ToElasticMapsServerPatchTypeOutput() ElasticMapsServerPatchTypeOutput {
	return o
}

func (o ElasticMapsServerPatchTypeOutput) ToElasticMapsServerPatchTypeOutputWithContext(ctx context.Context) ElasticMapsServerPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticMapsServerPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticMapsServerPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ElasticMapsServerPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o ElasticMapsServerPatchTypeOutput) Spec() ElasticMapsServerSpecPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerPatchType) *ElasticMapsServerSpecPatch { return v.Spec }).(ElasticMapsServerSpecPatchPtrOutput)
}

func (o ElasticMapsServerPatchTypeOutput) Status() ElasticMapsServerStatusPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerPatchType) *ElasticMapsServerStatusPatch { return v.Status }).(ElasticMapsServerStatusPatchPtrOutput)
}

// MapsSpec holds the specification of an Elastic Maps Server instance.
type ElasticMapsServerSpec struct {
	// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
	Config    map[string]interface{}          `pulumi:"config"`
	ConfigRef *ElasticMapsServerSpecConfigRef `pulumi:"configRef"`
	// Count of Elastic Maps Server instances to deploy.
	Count            *int                                   `pulumi:"count"`
	ElasticsearchRef *ElasticMapsServerSpecElasticsearchRef `pulumi:"elasticsearchRef"`
	Http             *ElasticMapsServerSpecHttp             `pulumi:"http"`
	// Image is the Elastic Maps Server Docker image to deploy.
	Image *string `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Version of Elastic Maps Server.
	Version *string `pulumi:"version"`
}

// ElasticMapsServerSpecInput is an input type that accepts ElasticMapsServerSpecArgs and ElasticMapsServerSpecOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecInput` via:
//
//	ElasticMapsServerSpecArgs{...}
type ElasticMapsServerSpecInput interface {
	pulumi.Input

	ToElasticMapsServerSpecOutput() ElasticMapsServerSpecOutput
	ToElasticMapsServerSpecOutputWithContext(context.Context) ElasticMapsServerSpecOutput
}

// MapsSpec holds the specification of an Elastic Maps Server instance.
type ElasticMapsServerSpecArgs struct {
	// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
	Config    pulumi.MapInput                        `pulumi:"config"`
	ConfigRef ElasticMapsServerSpecConfigRefPtrInput `pulumi:"configRef"`
	// Count of Elastic Maps Server instances to deploy.
	Count            pulumi.IntPtrInput                            `pulumi:"count"`
	ElasticsearchRef ElasticMapsServerSpecElasticsearchRefPtrInput `pulumi:"elasticsearchRef"`
	Http             ElasticMapsServerSpecHttpPtrInput             `pulumi:"http"`
	// Image is the Elastic Maps Server Docker image to deploy.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Version of Elastic Maps Server.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ElasticMapsServerSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpec)(nil)).Elem()
}

func (i ElasticMapsServerSpecArgs) ToElasticMapsServerSpecOutput() ElasticMapsServerSpecOutput {
	return i.ToElasticMapsServerSpecOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecArgs) ToElasticMapsServerSpecOutputWithContext(ctx context.Context) ElasticMapsServerSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecOutput)
}

func (i ElasticMapsServerSpecArgs) ToElasticMapsServerSpecPtrOutput() ElasticMapsServerSpecPtrOutput {
	return i.ToElasticMapsServerSpecPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecArgs) ToElasticMapsServerSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecOutput).ToElasticMapsServerSpecPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecPtrInput is an input type that accepts ElasticMapsServerSpecArgs, ElasticMapsServerSpecPtr and ElasticMapsServerSpecPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecPtrInput` via:
//
//	        ElasticMapsServerSpecArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecPtrOutput() ElasticMapsServerSpecPtrOutput
	ToElasticMapsServerSpecPtrOutputWithContext(context.Context) ElasticMapsServerSpecPtrOutput
}

type elasticMapsServerSpecPtrType ElasticMapsServerSpecArgs

func ElasticMapsServerSpecPtr(v *ElasticMapsServerSpecArgs) ElasticMapsServerSpecPtrInput {
	return (*elasticMapsServerSpecPtrType)(v)
}

func (*elasticMapsServerSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpec)(nil)).Elem()
}

func (i *elasticMapsServerSpecPtrType) ToElasticMapsServerSpecPtrOutput() ElasticMapsServerSpecPtrOutput {
	return i.ToElasticMapsServerSpecPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecPtrType) ToElasticMapsServerSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecPtrOutput)
}

// MapsSpec holds the specification of an Elastic Maps Server instance.
type ElasticMapsServerSpecOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpec)(nil)).Elem()
}

func (o ElasticMapsServerSpecOutput) ToElasticMapsServerSpecOutput() ElasticMapsServerSpecOutput {
	return o
}

func (o ElasticMapsServerSpecOutput) ToElasticMapsServerSpecOutputWithContext(ctx context.Context) ElasticMapsServerSpecOutput {
	return o
}

func (o ElasticMapsServerSpecOutput) ToElasticMapsServerSpecPtrOutput() ElasticMapsServerSpecPtrOutput {
	return o.ToElasticMapsServerSpecPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecOutput) ToElasticMapsServerSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpec) *ElasticMapsServerSpec {
		return &v
	}).(ElasticMapsServerSpecPtrOutput)
}

// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
func (o ElasticMapsServerSpecOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

func (o ElasticMapsServerSpecOutput) ConfigRef() ElasticMapsServerSpecConfigRefPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *ElasticMapsServerSpecConfigRef { return v.ConfigRef }).(ElasticMapsServerSpecConfigRefPtrOutput)
}

// Count of Elastic Maps Server instances to deploy.
func (o ElasticMapsServerSpecOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *int { return v.Count }).(pulumi.IntPtrOutput)
}

func (o ElasticMapsServerSpecOutput) ElasticsearchRef() ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *ElasticMapsServerSpecElasticsearchRef { return v.ElasticsearchRef }).(ElasticMapsServerSpecElasticsearchRefPtrOutput)
}

func (o ElasticMapsServerSpecOutput) Http() ElasticMapsServerSpecHttpPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *ElasticMapsServerSpecHttp { return v.Http }).(ElasticMapsServerSpecHttpPtrOutput)
}

// Image is the Elastic Maps Server Docker image to deploy.
func (o ElasticMapsServerSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
func (o ElasticMapsServerSpecOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
func (o ElasticMapsServerSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o ElasticMapsServerSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Version of Elastic Maps Server.
func (o ElasticMapsServerSpecOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpec) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpec)(nil)).Elem()
}

func (o ElasticMapsServerSpecPtrOutput) ToElasticMapsServerSpecPtrOutput() ElasticMapsServerSpecPtrOutput {
	return o
}

func (o ElasticMapsServerSpecPtrOutput) ToElasticMapsServerSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPtrOutput {
	return o
}

func (o ElasticMapsServerSpecPtrOutput) Elem() ElasticMapsServerSpecOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) ElasticMapsServerSpec {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpec
		return ret
	}).(ElasticMapsServerSpecOutput)
}

// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
func (o ElasticMapsServerSpecPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

func (o ElasticMapsServerSpecPtrOutput) ConfigRef() ElasticMapsServerSpecConfigRefPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *ElasticMapsServerSpecConfigRef {
		if v == nil {
			return nil
		}
		return v.ConfigRef
	}).(ElasticMapsServerSpecConfigRefPtrOutput)
}

// Count of Elastic Maps Server instances to deploy.
func (o ElasticMapsServerSpecPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

func (o ElasticMapsServerSpecPtrOutput) ElasticsearchRef() ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *ElasticMapsServerSpecElasticsearchRef {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRef
	}).(ElasticMapsServerSpecElasticsearchRefPtrOutput)
}

func (o ElasticMapsServerSpecPtrOutput) Http() ElasticMapsServerSpecHttpPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *ElasticMapsServerSpecHttp {
		if v == nil {
			return nil
		}
		return v.Http
	}).(ElasticMapsServerSpecHttpPtrOutput)
}

// Image is the Elastic Maps Server Docker image to deploy.
func (o ElasticMapsServerSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
func (o ElasticMapsServerSpecPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
func (o ElasticMapsServerSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o ElasticMapsServerSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Version of Elastic Maps Server.
func (o ElasticMapsServerSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpec) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration.
// Configuration settings are merged and have precedence over settings specified in `config`.
type ElasticMapsServerSpecConfigRef struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticMapsServerSpecConfigRefInput is an input type that accepts ElasticMapsServerSpecConfigRefArgs and ElasticMapsServerSpecConfigRefOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecConfigRefInput` via:
//
//	ElasticMapsServerSpecConfigRefArgs{...}
type ElasticMapsServerSpecConfigRefInput interface {
	pulumi.Input

	ToElasticMapsServerSpecConfigRefOutput() ElasticMapsServerSpecConfigRefOutput
	ToElasticMapsServerSpecConfigRefOutputWithContext(context.Context) ElasticMapsServerSpecConfigRefOutput
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration.
// Configuration settings are merged and have precedence over settings specified in `config`.
type ElasticMapsServerSpecConfigRefArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticMapsServerSpecConfigRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecConfigRef)(nil)).Elem()
}

func (i ElasticMapsServerSpecConfigRefArgs) ToElasticMapsServerSpecConfigRefOutput() ElasticMapsServerSpecConfigRefOutput {
	return i.ToElasticMapsServerSpecConfigRefOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecConfigRefArgs) ToElasticMapsServerSpecConfigRefOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecConfigRefOutput)
}

func (i ElasticMapsServerSpecConfigRefArgs) ToElasticMapsServerSpecConfigRefPtrOutput() ElasticMapsServerSpecConfigRefPtrOutput {
	return i.ToElasticMapsServerSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecConfigRefArgs) ToElasticMapsServerSpecConfigRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecConfigRefOutput).ToElasticMapsServerSpecConfigRefPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecConfigRefPtrInput is an input type that accepts ElasticMapsServerSpecConfigRefArgs, ElasticMapsServerSpecConfigRefPtr and ElasticMapsServerSpecConfigRefPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecConfigRefPtrInput` via:
//
//	        ElasticMapsServerSpecConfigRefArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecConfigRefPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecConfigRefPtrOutput() ElasticMapsServerSpecConfigRefPtrOutput
	ToElasticMapsServerSpecConfigRefPtrOutputWithContext(context.Context) ElasticMapsServerSpecConfigRefPtrOutput
}

type elasticMapsServerSpecConfigRefPtrType ElasticMapsServerSpecConfigRefArgs

func ElasticMapsServerSpecConfigRefPtr(v *ElasticMapsServerSpecConfigRefArgs) ElasticMapsServerSpecConfigRefPtrInput {
	return (*elasticMapsServerSpecConfigRefPtrType)(v)
}

func (*elasticMapsServerSpecConfigRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecConfigRef)(nil)).Elem()
}

func (i *elasticMapsServerSpecConfigRefPtrType) ToElasticMapsServerSpecConfigRefPtrOutput() ElasticMapsServerSpecConfigRefPtrOutput {
	return i.ToElasticMapsServerSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecConfigRefPtrType) ToElasticMapsServerSpecConfigRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecConfigRefPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration.
// Configuration settings are merged and have precedence over settings specified in `config`.
type ElasticMapsServerSpecConfigRefOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecConfigRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecConfigRef)(nil)).Elem()
}

func (o ElasticMapsServerSpecConfigRefOutput) ToElasticMapsServerSpecConfigRefOutput() ElasticMapsServerSpecConfigRefOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefOutput) ToElasticMapsServerSpecConfigRefOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefOutput) ToElasticMapsServerSpecConfigRefPtrOutput() ElasticMapsServerSpecConfigRefPtrOutput {
	return o.ToElasticMapsServerSpecConfigRefPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecConfigRefOutput) ToElasticMapsServerSpecConfigRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecConfigRef) *ElasticMapsServerSpecConfigRef {
		return &v
	}).(ElasticMapsServerSpecConfigRefPtrOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecConfigRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecConfigRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecConfigRefPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecConfigRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecConfigRef)(nil)).Elem()
}

func (o ElasticMapsServerSpecConfigRefPtrOutput) ToElasticMapsServerSpecConfigRefPtrOutput() ElasticMapsServerSpecConfigRefPtrOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefPtrOutput) ToElasticMapsServerSpecConfigRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPtrOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefPtrOutput) Elem() ElasticMapsServerSpecConfigRefOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecConfigRef) ElasticMapsServerSpecConfigRef {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecConfigRef
		return ret
	}).(ElasticMapsServerSpecConfigRefOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecConfigRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecConfigRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration.
// Configuration settings are merged and have precedence over settings specified in `config`.
type ElasticMapsServerSpecConfigRefPatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticMapsServerSpecConfigRefPatchInput is an input type that accepts ElasticMapsServerSpecConfigRefPatchArgs and ElasticMapsServerSpecConfigRefPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecConfigRefPatchInput` via:
//
//	ElasticMapsServerSpecConfigRefPatchArgs{...}
type ElasticMapsServerSpecConfigRefPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecConfigRefPatchOutput() ElasticMapsServerSpecConfigRefPatchOutput
	ToElasticMapsServerSpecConfigRefPatchOutputWithContext(context.Context) ElasticMapsServerSpecConfigRefPatchOutput
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration.
// Configuration settings are merged and have precedence over settings specified in `config`.
type ElasticMapsServerSpecConfigRefPatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticMapsServerSpecConfigRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecConfigRefPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecConfigRefPatchArgs) ToElasticMapsServerSpecConfigRefPatchOutput() ElasticMapsServerSpecConfigRefPatchOutput {
	return i.ToElasticMapsServerSpecConfigRefPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecConfigRefPatchArgs) ToElasticMapsServerSpecConfigRefPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecConfigRefPatchOutput)
}

func (i ElasticMapsServerSpecConfigRefPatchArgs) ToElasticMapsServerSpecConfigRefPatchPtrOutput() ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return i.ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecConfigRefPatchArgs) ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecConfigRefPatchOutput).ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecConfigRefPatchPtrInput is an input type that accepts ElasticMapsServerSpecConfigRefPatchArgs, ElasticMapsServerSpecConfigRefPatchPtr and ElasticMapsServerSpecConfigRefPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecConfigRefPatchPtrInput` via:
//
//	        ElasticMapsServerSpecConfigRefPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecConfigRefPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecConfigRefPatchPtrOutput() ElasticMapsServerSpecConfigRefPatchPtrOutput
	ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecConfigRefPatchPtrOutput
}

type elasticMapsServerSpecConfigRefPatchPtrType ElasticMapsServerSpecConfigRefPatchArgs

func ElasticMapsServerSpecConfigRefPatchPtr(v *ElasticMapsServerSpecConfigRefPatchArgs) ElasticMapsServerSpecConfigRefPatchPtrInput {
	return (*elasticMapsServerSpecConfigRefPatchPtrType)(v)
}

func (*elasticMapsServerSpecConfigRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecConfigRefPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecConfigRefPatchPtrType) ToElasticMapsServerSpecConfigRefPatchPtrOutput() ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return i.ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecConfigRefPatchPtrType) ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecConfigRefPatchPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration.
// Configuration settings are merged and have precedence over settings specified in `config`.
type ElasticMapsServerSpecConfigRefPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecConfigRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecConfigRefPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecConfigRefPatchOutput) ToElasticMapsServerSpecConfigRefPatchOutput() ElasticMapsServerSpecConfigRefPatchOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefPatchOutput) ToElasticMapsServerSpecConfigRefPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPatchOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefPatchOutput) ToElasticMapsServerSpecConfigRefPatchPtrOutput() ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return o.ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecConfigRefPatchOutput) ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecConfigRefPatch) *ElasticMapsServerSpecConfigRefPatch {
		return &v
	}).(ElasticMapsServerSpecConfigRefPatchPtrOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecConfigRefPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecConfigRefPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecConfigRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecConfigRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecConfigRefPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecConfigRefPatchPtrOutput) ToElasticMapsServerSpecConfigRefPatchPtrOutput() ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefPatchPtrOutput) ToElasticMapsServerSpecConfigRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecConfigRefPatchPtrOutput) Elem() ElasticMapsServerSpecConfigRefPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecConfigRefPatch) ElasticMapsServerSpecConfigRefPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecConfigRefPatch
		return ret
	}).(ElasticMapsServerSpecConfigRefPatchOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecConfigRefPatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecConfigRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type ElasticMapsServerSpecElasticsearchRef struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// ElasticMapsServerSpecElasticsearchRefInput is an input type that accepts ElasticMapsServerSpecElasticsearchRefArgs and ElasticMapsServerSpecElasticsearchRefOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecElasticsearchRefInput` via:
//
//	ElasticMapsServerSpecElasticsearchRefArgs{...}
type ElasticMapsServerSpecElasticsearchRefInput interface {
	pulumi.Input

	ToElasticMapsServerSpecElasticsearchRefOutput() ElasticMapsServerSpecElasticsearchRefOutput
	ToElasticMapsServerSpecElasticsearchRefOutputWithContext(context.Context) ElasticMapsServerSpecElasticsearchRefOutput
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type ElasticMapsServerSpecElasticsearchRefArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (ElasticMapsServerSpecElasticsearchRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRef)(nil)).Elem()
}

func (i ElasticMapsServerSpecElasticsearchRefArgs) ToElasticMapsServerSpecElasticsearchRefOutput() ElasticMapsServerSpecElasticsearchRefOutput {
	return i.ToElasticMapsServerSpecElasticsearchRefOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecElasticsearchRefArgs) ToElasticMapsServerSpecElasticsearchRefOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecElasticsearchRefOutput)
}

func (i ElasticMapsServerSpecElasticsearchRefArgs) ToElasticMapsServerSpecElasticsearchRefPtrOutput() ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return i.ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecElasticsearchRefArgs) ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecElasticsearchRefOutput).ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecElasticsearchRefPtrInput is an input type that accepts ElasticMapsServerSpecElasticsearchRefArgs, ElasticMapsServerSpecElasticsearchRefPtr and ElasticMapsServerSpecElasticsearchRefPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecElasticsearchRefPtrInput` via:
//
//	        ElasticMapsServerSpecElasticsearchRefArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecElasticsearchRefPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecElasticsearchRefPtrOutput() ElasticMapsServerSpecElasticsearchRefPtrOutput
	ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(context.Context) ElasticMapsServerSpecElasticsearchRefPtrOutput
}

type elasticMapsServerSpecElasticsearchRefPtrType ElasticMapsServerSpecElasticsearchRefArgs

func ElasticMapsServerSpecElasticsearchRefPtr(v *ElasticMapsServerSpecElasticsearchRefArgs) ElasticMapsServerSpecElasticsearchRefPtrInput {
	return (*elasticMapsServerSpecElasticsearchRefPtrType)(v)
}

func (*elasticMapsServerSpecElasticsearchRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecElasticsearchRef)(nil)).Elem()
}

func (i *elasticMapsServerSpecElasticsearchRefPtrType) ToElasticMapsServerSpecElasticsearchRefPtrOutput() ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return i.ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecElasticsearchRefPtrType) ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecElasticsearchRefPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type ElasticMapsServerSpecElasticsearchRefOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecElasticsearchRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRef)(nil)).Elem()
}

func (o ElasticMapsServerSpecElasticsearchRefOutput) ToElasticMapsServerSpecElasticsearchRefOutput() ElasticMapsServerSpecElasticsearchRefOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefOutput) ToElasticMapsServerSpecElasticsearchRefOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefOutput) ToElasticMapsServerSpecElasticsearchRefPtrOutput() ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return o.ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecElasticsearchRefOutput) ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecElasticsearchRef) *ElasticMapsServerSpecElasticsearchRef {
		return &v
	}).(ElasticMapsServerSpecElasticsearchRefPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o ElasticMapsServerSpecElasticsearchRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o ElasticMapsServerSpecElasticsearchRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o ElasticMapsServerSpecElasticsearchRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o ElasticMapsServerSpecElasticsearchRefOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRef) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecElasticsearchRefPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecElasticsearchRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecElasticsearchRef)(nil)).Elem()
}

func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) ToElasticMapsServerSpecElasticsearchRefPtrOutput() ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) ToElasticMapsServerSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPtrOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) Elem() ElasticMapsServerSpecElasticsearchRefOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRef) ElasticMapsServerSpecElasticsearchRef {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecElasticsearchRef
		return ret
	}).(ElasticMapsServerSpecElasticsearchRefOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o ElasticMapsServerSpecElasticsearchRefPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type ElasticMapsServerSpecElasticsearchRefPatch struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// ElasticMapsServerSpecElasticsearchRefPatchInput is an input type that accepts ElasticMapsServerSpecElasticsearchRefPatchArgs and ElasticMapsServerSpecElasticsearchRefPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecElasticsearchRefPatchInput` via:
//
//	ElasticMapsServerSpecElasticsearchRefPatchArgs{...}
type ElasticMapsServerSpecElasticsearchRefPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecElasticsearchRefPatchOutput() ElasticMapsServerSpecElasticsearchRefPatchOutput
	ToElasticMapsServerSpecElasticsearchRefPatchOutputWithContext(context.Context) ElasticMapsServerSpecElasticsearchRefPatchOutput
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type ElasticMapsServerSpecElasticsearchRefPatchArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (ElasticMapsServerSpecElasticsearchRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRefPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecElasticsearchRefPatchArgs) ToElasticMapsServerSpecElasticsearchRefPatchOutput() ElasticMapsServerSpecElasticsearchRefPatchOutput {
	return i.ToElasticMapsServerSpecElasticsearchRefPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecElasticsearchRefPatchArgs) ToElasticMapsServerSpecElasticsearchRefPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecElasticsearchRefPatchOutput)
}

func (i ElasticMapsServerSpecElasticsearchRefPatchArgs) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutput() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return i.ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecElasticsearchRefPatchArgs) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecElasticsearchRefPatchOutput).ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecElasticsearchRefPatchPtrInput is an input type that accepts ElasticMapsServerSpecElasticsearchRefPatchArgs, ElasticMapsServerSpecElasticsearchRefPatchPtr and ElasticMapsServerSpecElasticsearchRefPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecElasticsearchRefPatchPtrInput` via:
//
//	        ElasticMapsServerSpecElasticsearchRefPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecElasticsearchRefPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecElasticsearchRefPatchPtrOutput() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput
	ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecElasticsearchRefPatchPtrOutput
}

type elasticMapsServerSpecElasticsearchRefPatchPtrType ElasticMapsServerSpecElasticsearchRefPatchArgs

func ElasticMapsServerSpecElasticsearchRefPatchPtr(v *ElasticMapsServerSpecElasticsearchRefPatchArgs) ElasticMapsServerSpecElasticsearchRefPatchPtrInput {
	return (*elasticMapsServerSpecElasticsearchRefPatchPtrType)(v)
}

func (*elasticMapsServerSpecElasticsearchRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecElasticsearchRefPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecElasticsearchRefPatchPtrType) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutput() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return i.ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecElasticsearchRefPatchPtrType) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecElasticsearchRefPatchPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type ElasticMapsServerSpecElasticsearchRefPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecElasticsearchRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRefPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) ToElasticMapsServerSpecElasticsearchRefPatchOutput() ElasticMapsServerSpecElasticsearchRefPatchOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) ToElasticMapsServerSpecElasticsearchRefPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPatchOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutput() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return o.ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecElasticsearchRefPatch) *ElasticMapsServerSpecElasticsearchRefPatch {
		return &v
	}).(ElasticMapsServerSpecElasticsearchRefPatchPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRefPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o ElasticMapsServerSpecElasticsearchRefPatchOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecElasticsearchRefPatch) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecElasticsearchRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecElasticsearchRefPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutput() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) ToElasticMapsServerSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) Elem() ElasticMapsServerSpecElasticsearchRefPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRefPatch) ElasticMapsServerSpecElasticsearchRefPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecElasticsearchRefPatch
		return ret
	}).(ElasticMapsServerSpecElasticsearchRefPatchOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o ElasticMapsServerSpecElasticsearchRefPatchPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecElasticsearchRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// HTTP holds the HTTP layer configuration for Elastic Maps Server.
type ElasticMapsServerSpecHttp struct {
	Service *ElasticMapsServerSpecHttpService `pulumi:"service"`
	Tls     *ElasticMapsServerSpecHttpTls     `pulumi:"tls"`
}

// ElasticMapsServerSpecHttpInput is an input type that accepts ElasticMapsServerSpecHttpArgs and ElasticMapsServerSpecHttpOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpInput` via:
//
//	ElasticMapsServerSpecHttpArgs{...}
type ElasticMapsServerSpecHttpInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpOutput() ElasticMapsServerSpecHttpOutput
	ToElasticMapsServerSpecHttpOutputWithContext(context.Context) ElasticMapsServerSpecHttpOutput
}

// HTTP holds the HTTP layer configuration for Elastic Maps Server.
type ElasticMapsServerSpecHttpArgs struct {
	Service ElasticMapsServerSpecHttpServicePtrInput `pulumi:"service"`
	Tls     ElasticMapsServerSpecHttpTlsPtrInput     `pulumi:"tls"`
}

func (ElasticMapsServerSpecHttpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttp)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpArgs) ToElasticMapsServerSpecHttpOutput() ElasticMapsServerSpecHttpOutput {
	return i.ToElasticMapsServerSpecHttpOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpArgs) ToElasticMapsServerSpecHttpOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpOutput)
}

func (i ElasticMapsServerSpecHttpArgs) ToElasticMapsServerSpecHttpPtrOutput() ElasticMapsServerSpecHttpPtrOutput {
	return i.ToElasticMapsServerSpecHttpPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpArgs) ToElasticMapsServerSpecHttpPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpOutput).ToElasticMapsServerSpecHttpPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpPtrInput is an input type that accepts ElasticMapsServerSpecHttpArgs, ElasticMapsServerSpecHttpPtr and ElasticMapsServerSpecHttpPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpPtrInput` via:
//
//	        ElasticMapsServerSpecHttpArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpPtrOutput() ElasticMapsServerSpecHttpPtrOutput
	ToElasticMapsServerSpecHttpPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpPtrOutput
}

type elasticMapsServerSpecHttpPtrType ElasticMapsServerSpecHttpArgs

func ElasticMapsServerSpecHttpPtr(v *ElasticMapsServerSpecHttpArgs) ElasticMapsServerSpecHttpPtrInput {
	return (*elasticMapsServerSpecHttpPtrType)(v)
}

func (*elasticMapsServerSpecHttpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttp)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpPtrType) ToElasticMapsServerSpecHttpPtrOutput() ElasticMapsServerSpecHttpPtrOutput {
	return i.ToElasticMapsServerSpecHttpPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpPtrType) ToElasticMapsServerSpecHttpPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpPtrOutput)
}

// HTTP holds the HTTP layer configuration for Elastic Maps Server.
type ElasticMapsServerSpecHttpOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttp)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpOutput) ToElasticMapsServerSpecHttpOutput() ElasticMapsServerSpecHttpOutput {
	return o
}

func (o ElasticMapsServerSpecHttpOutput) ToElasticMapsServerSpecHttpOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpOutput {
	return o
}

func (o ElasticMapsServerSpecHttpOutput) ToElasticMapsServerSpecHttpPtrOutput() ElasticMapsServerSpecHttpPtrOutput {
	return o.ToElasticMapsServerSpecHttpPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpOutput) ToElasticMapsServerSpecHttpPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttp) *ElasticMapsServerSpecHttp {
		return &v
	}).(ElasticMapsServerSpecHttpPtrOutput)
}

func (o ElasticMapsServerSpecHttpOutput) Service() ElasticMapsServerSpecHttpServicePtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttp) *ElasticMapsServerSpecHttpService { return v.Service }).(ElasticMapsServerSpecHttpServicePtrOutput)
}

func (o ElasticMapsServerSpecHttpOutput) Tls() ElasticMapsServerSpecHttpTlsPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttp) *ElasticMapsServerSpecHttpTls { return v.Tls }).(ElasticMapsServerSpecHttpTlsPtrOutput)
}

type ElasticMapsServerSpecHttpPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttp)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpPtrOutput) ToElasticMapsServerSpecHttpPtrOutput() ElasticMapsServerSpecHttpPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpPtrOutput) ToElasticMapsServerSpecHttpPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpPtrOutput) Elem() ElasticMapsServerSpecHttpOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttp) ElasticMapsServerSpecHttp {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttp
		return ret
	}).(ElasticMapsServerSpecHttpOutput)
}

func (o ElasticMapsServerSpecHttpPtrOutput) Service() ElasticMapsServerSpecHttpServicePtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttp) *ElasticMapsServerSpecHttpService {
		if v == nil {
			return nil
		}
		return v.Service
	}).(ElasticMapsServerSpecHttpServicePtrOutput)
}

func (o ElasticMapsServerSpecHttpPtrOutput) Tls() ElasticMapsServerSpecHttpTlsPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttp) *ElasticMapsServerSpecHttpTls {
		if v == nil {
			return nil
		}
		return v.Tls
	}).(ElasticMapsServerSpecHttpTlsPtrOutput)
}

// HTTP holds the HTTP layer configuration for Elastic Maps Server.
type ElasticMapsServerSpecHttpPatch struct {
	Service *ElasticMapsServerSpecHttpServicePatch `pulumi:"service"`
	Tls     *ElasticMapsServerSpecHttpTlsPatch     `pulumi:"tls"`
}

// ElasticMapsServerSpecHttpPatchInput is an input type that accepts ElasticMapsServerSpecHttpPatchArgs and ElasticMapsServerSpecHttpPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpPatchInput` via:
//
//	ElasticMapsServerSpecHttpPatchArgs{...}
type ElasticMapsServerSpecHttpPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpPatchOutput() ElasticMapsServerSpecHttpPatchOutput
	ToElasticMapsServerSpecHttpPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpPatchOutput
}

// HTTP holds the HTTP layer configuration for Elastic Maps Server.
type ElasticMapsServerSpecHttpPatchArgs struct {
	Service ElasticMapsServerSpecHttpServicePatchPtrInput `pulumi:"service"`
	Tls     ElasticMapsServerSpecHttpTlsPatchPtrInput     `pulumi:"tls"`
}

func (ElasticMapsServerSpecHttpPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpPatchArgs) ToElasticMapsServerSpecHttpPatchOutput() ElasticMapsServerSpecHttpPatchOutput {
	return i.ToElasticMapsServerSpecHttpPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpPatchArgs) ToElasticMapsServerSpecHttpPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpPatchOutput)
}

func (i ElasticMapsServerSpecHttpPatchArgs) ToElasticMapsServerSpecHttpPatchPtrOutput() ElasticMapsServerSpecHttpPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpPatchArgs) ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpPatchOutput).ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpPatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpPatchArgs, ElasticMapsServerSpecHttpPatchPtr and ElasticMapsServerSpecHttpPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpPatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpPatchPtrOutput() ElasticMapsServerSpecHttpPatchPtrOutput
	ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpPatchPtrOutput
}

type elasticMapsServerSpecHttpPatchPtrType ElasticMapsServerSpecHttpPatchArgs

func ElasticMapsServerSpecHttpPatchPtr(v *ElasticMapsServerSpecHttpPatchArgs) ElasticMapsServerSpecHttpPatchPtrInput {
	return (*elasticMapsServerSpecHttpPatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpPatchPtrType) ToElasticMapsServerSpecHttpPatchPtrOutput() ElasticMapsServerSpecHttpPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpPatchPtrType) ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpPatchPtrOutput)
}

// HTTP holds the HTTP layer configuration for Elastic Maps Server.
type ElasticMapsServerSpecHttpPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpPatchOutput) ToElasticMapsServerSpecHttpPatchOutput() ElasticMapsServerSpecHttpPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpPatchOutput) ToElasticMapsServerSpecHttpPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpPatchOutput) ToElasticMapsServerSpecHttpPatchPtrOutput() ElasticMapsServerSpecHttpPatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpPatchOutput) ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpPatch) *ElasticMapsServerSpecHttpPatch {
		return &v
	}).(ElasticMapsServerSpecHttpPatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpPatchOutput) Service() ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpPatch) *ElasticMapsServerSpecHttpServicePatch { return v.Service }).(ElasticMapsServerSpecHttpServicePatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpPatchOutput) Tls() ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpPatch) *ElasticMapsServerSpecHttpTlsPatch { return v.Tls }).(ElasticMapsServerSpecHttpTlsPatchPtrOutput)
}

type ElasticMapsServerSpecHttpPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpPatchPtrOutput) ToElasticMapsServerSpecHttpPatchPtrOutput() ElasticMapsServerSpecHttpPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpPatchPtrOutput) ToElasticMapsServerSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpPatchPtrOutput) Elem() ElasticMapsServerSpecHttpPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpPatch) ElasticMapsServerSpecHttpPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpPatch
		return ret
	}).(ElasticMapsServerSpecHttpPatchOutput)
}

func (o ElasticMapsServerSpecHttpPatchPtrOutput) Service() ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpPatch) *ElasticMapsServerSpecHttpServicePatch {
		if v == nil {
			return nil
		}
		return v.Service
	}).(ElasticMapsServerSpecHttpServicePatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpPatchPtrOutput) Tls() ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpPatch) *ElasticMapsServerSpecHttpTlsPatch {
		if v == nil {
			return nil
		}
		return v.Tls
	}).(ElasticMapsServerSpecHttpTlsPatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticMapsServerSpecHttpService struct {
	Metadata *ElasticMapsServerSpecHttpServiceMetadata `pulumi:"metadata"`
	Spec     *ElasticMapsServerSpecHttpServiceSpec     `pulumi:"spec"`
}

// ElasticMapsServerSpecHttpServiceInput is an input type that accepts ElasticMapsServerSpecHttpServiceArgs and ElasticMapsServerSpecHttpServiceOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceInput` via:
//
//	ElasticMapsServerSpecHttpServiceArgs{...}
type ElasticMapsServerSpecHttpServiceInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceOutput() ElasticMapsServerSpecHttpServiceOutput
	ToElasticMapsServerSpecHttpServiceOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceOutput
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticMapsServerSpecHttpServiceArgs struct {
	Metadata ElasticMapsServerSpecHttpServiceMetadataPtrInput `pulumi:"metadata"`
	Spec     ElasticMapsServerSpecHttpServiceSpecPtrInput     `pulumi:"spec"`
}

func (ElasticMapsServerSpecHttpServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpService)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceArgs) ToElasticMapsServerSpecHttpServiceOutput() ElasticMapsServerSpecHttpServiceOutput {
	return i.ToElasticMapsServerSpecHttpServiceOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceArgs) ToElasticMapsServerSpecHttpServiceOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceOutput)
}

func (i ElasticMapsServerSpecHttpServiceArgs) ToElasticMapsServerSpecHttpServicePtrOutput() ElasticMapsServerSpecHttpServicePtrOutput {
	return i.ToElasticMapsServerSpecHttpServicePtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceArgs) ToElasticMapsServerSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceOutput).ToElasticMapsServerSpecHttpServicePtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServicePtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceArgs, ElasticMapsServerSpecHttpServicePtr and ElasticMapsServerSpecHttpServicePtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServicePtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServicePtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServicePtrOutput() ElasticMapsServerSpecHttpServicePtrOutput
	ToElasticMapsServerSpecHttpServicePtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServicePtrOutput
}

type elasticMapsServerSpecHttpServicePtrType ElasticMapsServerSpecHttpServiceArgs

func ElasticMapsServerSpecHttpServicePtr(v *ElasticMapsServerSpecHttpServiceArgs) ElasticMapsServerSpecHttpServicePtrInput {
	return (*elasticMapsServerSpecHttpServicePtrType)(v)
}

func (*elasticMapsServerSpecHttpServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpService)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServicePtrType) ToElasticMapsServerSpecHttpServicePtrOutput() ElasticMapsServerSpecHttpServicePtrOutput {
	return i.ToElasticMapsServerSpecHttpServicePtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServicePtrType) ToElasticMapsServerSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServicePtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticMapsServerSpecHttpServiceOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpService)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceOutput) ToElasticMapsServerSpecHttpServiceOutput() ElasticMapsServerSpecHttpServiceOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceOutput) ToElasticMapsServerSpecHttpServiceOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceOutput) ToElasticMapsServerSpecHttpServicePtrOutput() ElasticMapsServerSpecHttpServicePtrOutput {
	return o.ToElasticMapsServerSpecHttpServicePtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceOutput) ToElasticMapsServerSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpService) *ElasticMapsServerSpecHttpService {
		return &v
	}).(ElasticMapsServerSpecHttpServicePtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceOutput) Metadata() ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpService) *ElasticMapsServerSpecHttpServiceMetadata { return v.Metadata }).(ElasticMapsServerSpecHttpServiceMetadataPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceOutput) Spec() ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpService) *ElasticMapsServerSpecHttpServiceSpec { return v.Spec }).(ElasticMapsServerSpecHttpServiceSpecPtrOutput)
}

type ElasticMapsServerSpecHttpServicePtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpService)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServicePtrOutput) ToElasticMapsServerSpecHttpServicePtrOutput() ElasticMapsServerSpecHttpServicePtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServicePtrOutput) ToElasticMapsServerSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServicePtrOutput) Elem() ElasticMapsServerSpecHttpServiceOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpService) ElasticMapsServerSpecHttpService {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpService
		return ret
	}).(ElasticMapsServerSpecHttpServiceOutput)
}

func (o ElasticMapsServerSpecHttpServicePtrOutput) Metadata() ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpService) *ElasticMapsServerSpecHttpServiceMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ElasticMapsServerSpecHttpServiceMetadataPtrOutput)
}

func (o ElasticMapsServerSpecHttpServicePtrOutput) Spec() ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpService) *ElasticMapsServerSpecHttpServiceSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ElasticMapsServerSpecHttpServiceSpecPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticMapsServerSpecHttpServiceMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticMapsServerSpecHttpServiceMetadataInput is an input type that accepts ElasticMapsServerSpecHttpServiceMetadataArgs and ElasticMapsServerSpecHttpServiceMetadataOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceMetadataInput` via:
//
//	ElasticMapsServerSpecHttpServiceMetadataArgs{...}
type ElasticMapsServerSpecHttpServiceMetadataInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceMetadataOutput() ElasticMapsServerSpecHttpServiceMetadataOutput
	ToElasticMapsServerSpecHttpServiceMetadataOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceMetadataOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticMapsServerSpecHttpServiceMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticMapsServerSpecHttpServiceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadata)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceMetadataArgs) ToElasticMapsServerSpecHttpServiceMetadataOutput() ElasticMapsServerSpecHttpServiceMetadataOutput {
	return i.ToElasticMapsServerSpecHttpServiceMetadataOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceMetadataArgs) ToElasticMapsServerSpecHttpServiceMetadataOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceMetadataOutput)
}

func (i ElasticMapsServerSpecHttpServiceMetadataArgs) ToElasticMapsServerSpecHttpServiceMetadataPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceMetadataArgs) ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceMetadataOutput).ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceMetadataPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceMetadataArgs, ElasticMapsServerSpecHttpServiceMetadataPtr and ElasticMapsServerSpecHttpServiceMetadataPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceMetadataPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceMetadataArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceMetadataPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceMetadataPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPtrOutput
	ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceMetadataPtrOutput
}

type elasticMapsServerSpecHttpServiceMetadataPtrType ElasticMapsServerSpecHttpServiceMetadataArgs

func ElasticMapsServerSpecHttpServiceMetadataPtr(v *ElasticMapsServerSpecHttpServiceMetadataArgs) ElasticMapsServerSpecHttpServiceMetadataPtrInput {
	return (*elasticMapsServerSpecHttpServiceMetadataPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceMetadata)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceMetadataPtrType) ToElasticMapsServerSpecHttpServiceMetadataPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceMetadataPtrType) ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceMetadataPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticMapsServerSpecHttpServiceMetadataOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadata)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) ToElasticMapsServerSpecHttpServiceMetadataOutput() ElasticMapsServerSpecHttpServiceMetadataOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) ToElasticMapsServerSpecHttpServiceMetadataOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) ToElasticMapsServerSpecHttpServiceMetadataPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceMetadata) *ElasticMapsServerSpecHttpServiceMetadata {
		return &v
	}).(ElasticMapsServerSpecHttpServiceMetadataPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpServiceMetadataPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceMetadata)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) ToElasticMapsServerSpecHttpServiceMetadataPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) ToElasticMapsServerSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) Elem() ElasticMapsServerSpecHttpServiceMetadataOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadata) ElasticMapsServerSpecHttpServiceMetadata {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceMetadata
		return ret
	}).(ElasticMapsServerSpecHttpServiceMetadataOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticMapsServerSpecHttpServiceMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticMapsServerSpecHttpServiceMetadataPatchInput is an input type that accepts ElasticMapsServerSpecHttpServiceMetadataPatchArgs and ElasticMapsServerSpecHttpServiceMetadataPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceMetadataPatchInput` via:
//
//	ElasticMapsServerSpecHttpServiceMetadataPatchArgs{...}
type ElasticMapsServerSpecHttpServiceMetadataPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceMetadataPatchOutput() ElasticMapsServerSpecHttpServiceMetadataPatchOutput
	ToElasticMapsServerSpecHttpServiceMetadataPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticMapsServerSpecHttpServiceMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticMapsServerSpecHttpServiceMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceMetadataPatchArgs) ToElasticMapsServerSpecHttpServiceMetadataPatchOutput() ElasticMapsServerSpecHttpServiceMetadataPatchOutput {
	return i.ToElasticMapsServerSpecHttpServiceMetadataPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceMetadataPatchArgs) ToElasticMapsServerSpecHttpServiceMetadataPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceMetadataPatchOutput)
}

func (i ElasticMapsServerSpecHttpServiceMetadataPatchArgs) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceMetadataPatchArgs) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceMetadataPatchOutput).ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceMetadataPatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceMetadataPatchArgs, ElasticMapsServerSpecHttpServiceMetadataPatchPtr and ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceMetadataPatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceMetadataPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput
	ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput
}

type elasticMapsServerSpecHttpServiceMetadataPatchPtrType ElasticMapsServerSpecHttpServiceMetadataPatchArgs

func ElasticMapsServerSpecHttpServiceMetadataPatchPtr(v *ElasticMapsServerSpecHttpServiceMetadataPatchArgs) ElasticMapsServerSpecHttpServiceMetadataPatchPtrInput {
	return (*elasticMapsServerSpecHttpServiceMetadataPatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceMetadataPatchPtrType) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceMetadataPatchPtrType) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticMapsServerSpecHttpServiceMetadataPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) ToElasticMapsServerSpecHttpServiceMetadataPatchOutput() ElasticMapsServerSpecHttpServiceMetadataPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) ToElasticMapsServerSpecHttpServiceMetadataPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceMetadataPatch) *ElasticMapsServerSpecHttpServiceMetadataPatch {
		return &v
	}).(ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadataPatch) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) ToElasticMapsServerSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) Elem() ElasticMapsServerSpecHttpServiceMetadataPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadataPatch) ElasticMapsServerSpecHttpServiceMetadataPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceMetadataPatch
		return ret
	}).(ElasticMapsServerSpecHttpServiceMetadataPatchOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticMapsServerSpecHttpServicePatch struct {
	Metadata *ElasticMapsServerSpecHttpServiceMetadataPatch `pulumi:"metadata"`
	Spec     *ElasticMapsServerSpecHttpServiceSpecPatch     `pulumi:"spec"`
}

// ElasticMapsServerSpecHttpServicePatchInput is an input type that accepts ElasticMapsServerSpecHttpServicePatchArgs and ElasticMapsServerSpecHttpServicePatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServicePatchInput` via:
//
//	ElasticMapsServerSpecHttpServicePatchArgs{...}
type ElasticMapsServerSpecHttpServicePatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServicePatchOutput() ElasticMapsServerSpecHttpServicePatchOutput
	ToElasticMapsServerSpecHttpServicePatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpServicePatchOutput
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticMapsServerSpecHttpServicePatchArgs struct {
	Metadata ElasticMapsServerSpecHttpServiceMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     ElasticMapsServerSpecHttpServiceSpecPatchPtrInput     `pulumi:"spec"`
}

func (ElasticMapsServerSpecHttpServicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServicePatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServicePatchArgs) ToElasticMapsServerSpecHttpServicePatchOutput() ElasticMapsServerSpecHttpServicePatchOutput {
	return i.ToElasticMapsServerSpecHttpServicePatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServicePatchArgs) ToElasticMapsServerSpecHttpServicePatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServicePatchOutput)
}

func (i ElasticMapsServerSpecHttpServicePatchArgs) ToElasticMapsServerSpecHttpServicePatchPtrOutput() ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServicePatchArgs) ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServicePatchOutput).ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServicePatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpServicePatchArgs, ElasticMapsServerSpecHttpServicePatchPtr and ElasticMapsServerSpecHttpServicePatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServicePatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServicePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServicePatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServicePatchPtrOutput() ElasticMapsServerSpecHttpServicePatchPtrOutput
	ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServicePatchPtrOutput
}

type elasticMapsServerSpecHttpServicePatchPtrType ElasticMapsServerSpecHttpServicePatchArgs

func ElasticMapsServerSpecHttpServicePatchPtr(v *ElasticMapsServerSpecHttpServicePatchArgs) ElasticMapsServerSpecHttpServicePatchPtrInput {
	return (*elasticMapsServerSpecHttpServicePatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpServicePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServicePatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServicePatchPtrType) ToElasticMapsServerSpecHttpServicePatchPtrOutput() ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServicePatchPtrType) ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServicePatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticMapsServerSpecHttpServicePatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServicePatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServicePatchOutput) ToElasticMapsServerSpecHttpServicePatchOutput() ElasticMapsServerSpecHttpServicePatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServicePatchOutput) ToElasticMapsServerSpecHttpServicePatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServicePatchOutput) ToElasticMapsServerSpecHttpServicePatchPtrOutput() ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServicePatchOutput) ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServicePatch) *ElasticMapsServerSpecHttpServicePatch {
		return &v
	}).(ElasticMapsServerSpecHttpServicePatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpServicePatchOutput) Metadata() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServicePatch) *ElasticMapsServerSpecHttpServiceMetadataPatch {
		return v.Metadata
	}).(ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpServicePatchOutput) Spec() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServicePatch) *ElasticMapsServerSpecHttpServiceSpecPatch {
		return v.Spec
	}).(ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput)
}

type ElasticMapsServerSpecHttpServicePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServicePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServicePatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServicePatchPtrOutput) ToElasticMapsServerSpecHttpServicePatchPtrOutput() ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServicePatchPtrOutput) ToElasticMapsServerSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServicePatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServicePatchPtrOutput) Elem() ElasticMapsServerSpecHttpServicePatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServicePatch) ElasticMapsServerSpecHttpServicePatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServicePatch
		return ret
	}).(ElasticMapsServerSpecHttpServicePatchOutput)
}

func (o ElasticMapsServerSpecHttpServicePatchPtrOutput) Metadata() ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServicePatch) *ElasticMapsServerSpecHttpServiceMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpServicePatchPtrOutput) Spec() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServicePatch) *ElasticMapsServerSpecHttpServiceSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type ElasticMapsServerSpecHttpServiceSpec struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []ElasticMapsServerSpecHttpServiceSpecPorts `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                                    `pulumi:"sessionAffinity"`
	SessionAffinityConfig *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// ElasticMapsServerSpecHttpServiceSpecInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecArgs and ElasticMapsServerSpecHttpServiceSpecOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecArgs{...}
type ElasticMapsServerSpecHttpServiceSpecInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecOutput() ElasticMapsServerSpecHttpServiceSpecOutput
	ToElasticMapsServerSpecHttpServiceSpecOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecOutput
}

// Spec is the specification of the service.
type ElasticMapsServerSpecHttpServiceSpecArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports ElasticMapsServerSpecHttpServiceSpecPortsArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                             `pulumi:"sessionAffinity"`
	SessionAffinityConfig ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ElasticMapsServerSpecHttpServiceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpec)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecArgs) ToElasticMapsServerSpecHttpServiceSpecOutput() ElasticMapsServerSpecHttpServiceSpecOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecArgs) ToElasticMapsServerSpecHttpServiceSpecOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecOutput)
}

func (i ElasticMapsServerSpecHttpServiceSpecArgs) ToElasticMapsServerSpecHttpServiceSpecPtrOutput() ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecArgs) ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecOutput).ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceSpecPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecArgs, ElasticMapsServerSpecHttpServiceSpecPtr and ElasticMapsServerSpecHttpServiceSpecPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceSpecArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceSpecPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPtrOutput() ElasticMapsServerSpecHttpServiceSpecPtrOutput
	ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPtrOutput
}

type elasticMapsServerSpecHttpServiceSpecPtrType ElasticMapsServerSpecHttpServiceSpecArgs

func ElasticMapsServerSpecHttpServiceSpecPtr(v *ElasticMapsServerSpecHttpServiceSpecArgs) ElasticMapsServerSpecHttpServiceSpecPtrInput {
	return (*elasticMapsServerSpecHttpServiceSpecPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpec)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceSpecPtrType) ToElasticMapsServerSpecHttpServiceSpecPtrOutput() ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceSpecPtrType) ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPtrOutput)
}

// Spec is the specification of the service.
type ElasticMapsServerSpecHttpServiceSpecOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpec)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecOutput) ToElasticMapsServerSpecHttpServiceSpecOutput() ElasticMapsServerSpecHttpServiceSpecOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecOutput) ToElasticMapsServerSpecHttpServiceSpecOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecOutput) ToElasticMapsServerSpecHttpServiceSpecPtrOutput() ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceSpecOutput) ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceSpec) *ElasticMapsServerSpecHttpServiceSpec {
		return &v
	}).(ElasticMapsServerSpecHttpServiceSpecPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticMapsServerSpecHttpServiceSpecOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticMapsServerSpecHttpServiceSpecOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticMapsServerSpecHttpServiceSpecOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecOutput) Ports() ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) []ElasticMapsServerSpecHttpServiceSpecPorts {
		return v.Ports
	}).(ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticMapsServerSpecHttpServiceSpecOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecOutput) SessionAffinityConfig() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig {
		return v.SessionAffinityConfig
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticMapsServerSpecHttpServiceSpecOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticMapsServerSpecHttpServiceSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpServiceSpecPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpec)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ToElasticMapsServerSpecHttpServiceSpecPtrOutput() ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ToElasticMapsServerSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) Elem() ElasticMapsServerSpecHttpServiceSpecOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) ElasticMapsServerSpecHttpServiceSpec {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceSpec
		return ret
	}).(ElasticMapsServerSpecHttpServiceSpecOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) Ports() ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) []ElasticMapsServerSpecHttpServiceSpecPorts {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) SessionAffinityConfig() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticMapsServerSpecHttpServiceSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Spec is the specification of the service.
type ElasticMapsServerSpecHttpServiceSpecPatch struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []ElasticMapsServerSpecHttpServiceSpecPortsPatch `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                                         `pulumi:"sessionAffinity"`
	SessionAffinityConfig *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// ElasticMapsServerSpecHttpServiceSpecPatchInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecPatchArgs and ElasticMapsServerSpecHttpServiceSpecPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPatchInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecPatchArgs{...}
type ElasticMapsServerSpecHttpServiceSpecPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPatchOutput() ElasticMapsServerSpecHttpServiceSpecPatchOutput
	ToElasticMapsServerSpecHttpServiceSpecPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPatchOutput
}

// Spec is the specification of the service.
type ElasticMapsServerSpecHttpServiceSpecPatchArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                                  `pulumi:"sessionAffinity"`
	SessionAffinityConfig ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ElasticMapsServerSpecHttpServiceSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecPatchArgs) ToElasticMapsServerSpecHttpServiceSpecPatchOutput() ElasticMapsServerSpecHttpServiceSpecPatchOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecPatchArgs) ToElasticMapsServerSpecHttpServiceSpecPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPatchOutput)
}

func (i ElasticMapsServerSpecHttpServiceSpecPatchArgs) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecPatchArgs) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPatchOutput).ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceSpecPatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecPatchArgs, ElasticMapsServerSpecHttpServiceSpecPatchPtr and ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceSpecPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput
	ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput
}

type elasticMapsServerSpecHttpServiceSpecPatchPtrType ElasticMapsServerSpecHttpServiceSpecPatchArgs

func ElasticMapsServerSpecHttpServiceSpecPatchPtr(v *ElasticMapsServerSpecHttpServiceSpecPatchArgs) ElasticMapsServerSpecHttpServiceSpecPatchPtrInput {
	return (*elasticMapsServerSpecHttpServiceSpecPatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceSpecPatchPtrType) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceSpecPatchPtrType) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type ElasticMapsServerSpecHttpServiceSpecPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ToElasticMapsServerSpecHttpServiceSpecPatchOutput() ElasticMapsServerSpecHttpServiceSpecPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ToElasticMapsServerSpecHttpServiceSpecPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceSpecPatch) *ElasticMapsServerSpecHttpServiceSpecPatch {
		return &v
	}).(ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) Ports() ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) []ElasticMapsServerSpecHttpServiceSpecPortsPatch {
		return v.Ports
	}).(ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) SessionAffinityConfig() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch {
		return v.SessionAffinityConfig
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticMapsServerSpecHttpServiceSpecPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ToElasticMapsServerSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) Elem() ElasticMapsServerSpecHttpServiceSpecPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) ElasticMapsServerSpecHttpServiceSpecPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceSpecPatch
		return ret
	}).(ElasticMapsServerSpecHttpServiceSpecPatchOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) Ports() ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) []ElasticMapsServerSpecHttpServiceSpecPortsPatch {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) SessionAffinityConfig() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ServicePort contains information on service's port.
type ElasticMapsServerSpecHttpServiceSpecPorts struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// ElasticMapsServerSpecHttpServiceSpecPortsInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecPortsArgs and ElasticMapsServerSpecHttpServiceSpecPortsOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPortsInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecPortsArgs{...}
type ElasticMapsServerSpecHttpServiceSpecPortsInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPortsOutput() ElasticMapsServerSpecHttpServiceSpecPortsOutput
	ToElasticMapsServerSpecHttpServiceSpecPortsOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPortsOutput
}

// ServicePort contains information on service's port.
type ElasticMapsServerSpecHttpServiceSpecPortsArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (ElasticMapsServerSpecHttpServiceSpecPortsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsArgs) ToElasticMapsServerSpecHttpServiceSpecPortsOutput() ElasticMapsServerSpecHttpServiceSpecPortsOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPortsOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsArgs) ToElasticMapsServerSpecHttpServiceSpecPortsOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPortsOutput)
}

// ElasticMapsServerSpecHttpServiceSpecPortsArrayInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecPortsArray and ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPortsArrayInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecPortsArray{ ElasticMapsServerSpecHttpServiceSpecPortsArgs{...} }
type ElasticMapsServerSpecHttpServiceSpecPortsArrayInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutput() ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput
	ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput
}

type ElasticMapsServerSpecHttpServiceSpecPortsArray []ElasticMapsServerSpecHttpServiceSpecPortsInput

func (ElasticMapsServerSpecHttpServiceSpecPortsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsArray) ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutput() ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsArray) ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput)
}

// ServicePort contains information on service's port.
type ElasticMapsServerSpecHttpServiceSpecPortsOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPortsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) ToElasticMapsServerSpecHttpServiceSpecPortsOutput() ElasticMapsServerSpecHttpServiceSpecPortsOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) ToElasticMapsServerSpecHttpServiceSpecPortsOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPorts) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPorts) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPorts) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPorts) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPorts) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o ElasticMapsServerSpecHttpServiceSpecPortsOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPorts) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput) ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutput() ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput) ToElasticMapsServerSpecHttpServiceSpecPortsArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput) Index(i pulumi.IntInput) ElasticMapsServerSpecHttpServiceSpecPortsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticMapsServerSpecHttpServiceSpecPorts {
		return vs[0].([]ElasticMapsServerSpecHttpServiceSpecPorts)[vs[1].(int)]
	}).(ElasticMapsServerSpecHttpServiceSpecPortsOutput)
}

// ServicePort contains information on service's port.
type ElasticMapsServerSpecHttpServiceSpecPortsPatch struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// ElasticMapsServerSpecHttpServiceSpecPortsPatchInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs and ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPortsPatchInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs{...}
type ElasticMapsServerSpecHttpServiceSpecPortsPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutput() ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput
	ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput
}

// ServicePort contains information on service's port.
type ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs) ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutput() ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs) ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput)
}

// ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecPortsPatchArray and ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecPortsPatchArray{ ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs{...} }
type ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput() ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput
	ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput
}

type ElasticMapsServerSpecHttpServiceSpecPortsPatchArray []ElasticMapsServerSpecHttpServiceSpecPortsPatchInput

func (ElasticMapsServerSpecHttpServiceSpecPortsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsPatchArray) ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput() ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecPortsPatchArray) ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput)
}

// ServicePort contains information on service's port.
type ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutput() ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) ToElasticMapsServerSpecHttpServiceSpecPortsPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPortsPatch) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPortsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPortsPatch) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPortsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPortsPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecPortsPatch) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput) ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput() ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput) ToElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput) Index(i pulumi.IntInput) ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticMapsServerSpecHttpServiceSpecPortsPatch {
		return vs[0].([]ElasticMapsServerSpecHttpServiceSpecPortsPatch)[vs[1].(int)]
	}).(ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig struct {
	ClientIP *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP `pulumi:"clientIP"`
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs{...}
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs struct {
	ClientIP ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput `pulumi:"clientIP"`
}

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput)
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput).ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs, ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtr and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput
}

type elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrType ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs

func ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtr(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrInput {
	return (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig {
		return &v
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput) ClientIP() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP {
		return v.ClientIP
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput) Elem() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig
		return ret
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ClientIP() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfig) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{...}
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput)
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput).ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs, ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtr and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput
}

type elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs

func ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtr(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput {
	return (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP {
		return &v
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP) *int {
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) Elem() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP
		return ret
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIP) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput).ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs, ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtr and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
}

type elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs

func ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtr(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput {
	return (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		return &v
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *int {
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) Elem() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch
		return ret
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch struct {
	ClientIP *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch `pulumi:"clientIP"`
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchInput` via:
//
//	ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs{...}
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs struct {
	ClientIP ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput `pulumi:"clientIP"`
}

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput)
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput).ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs, ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtr and ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput
	ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput
}

type elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrType ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs

func ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtr(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput {
	return (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch {
		return &v
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ClientIP() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		return v.ClientIP
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

type ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ToElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) Elem() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch) ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch
		return ret
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput)
}

func (o ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ClientIP() ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatch) *ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticMapsServerSpecHttpTls struct {
	Certificate           *ElasticMapsServerSpecHttpTlsCertificate           `pulumi:"certificate"`
	SelfSignedCertificate *ElasticMapsServerSpecHttpTlsSelfSignedCertificate `pulumi:"selfSignedCertificate"`
}

// ElasticMapsServerSpecHttpTlsInput is an input type that accepts ElasticMapsServerSpecHttpTlsArgs and ElasticMapsServerSpecHttpTlsOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsInput` via:
//
//	ElasticMapsServerSpecHttpTlsArgs{...}
type ElasticMapsServerSpecHttpTlsInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsOutput() ElasticMapsServerSpecHttpTlsOutput
	ToElasticMapsServerSpecHttpTlsOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsOutput
}

// TLS defines options for configuring TLS for HTTP.
type ElasticMapsServerSpecHttpTlsArgs struct {
	Certificate           ElasticMapsServerSpecHttpTlsCertificatePtrInput           `pulumi:"certificate"`
	SelfSignedCertificate ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrInput `pulumi:"selfSignedCertificate"`
}

func (ElasticMapsServerSpecHttpTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTls)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsArgs) ToElasticMapsServerSpecHttpTlsOutput() ElasticMapsServerSpecHttpTlsOutput {
	return i.ToElasticMapsServerSpecHttpTlsOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsArgs) ToElasticMapsServerSpecHttpTlsOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsOutput)
}

func (i ElasticMapsServerSpecHttpTlsArgs) ToElasticMapsServerSpecHttpTlsPtrOutput() ElasticMapsServerSpecHttpTlsPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsArgs) ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsOutput).ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpTlsPtrInput is an input type that accepts ElasticMapsServerSpecHttpTlsArgs, ElasticMapsServerSpecHttpTlsPtr and ElasticMapsServerSpecHttpTlsPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsPtrInput` via:
//
//	        ElasticMapsServerSpecHttpTlsArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpTlsPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsPtrOutput() ElasticMapsServerSpecHttpTlsPtrOutput
	ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsPtrOutput
}

type elasticMapsServerSpecHttpTlsPtrType ElasticMapsServerSpecHttpTlsArgs

func ElasticMapsServerSpecHttpTlsPtr(v *ElasticMapsServerSpecHttpTlsArgs) ElasticMapsServerSpecHttpTlsPtrInput {
	return (*elasticMapsServerSpecHttpTlsPtrType)(v)
}

func (*elasticMapsServerSpecHttpTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTls)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpTlsPtrType) ToElasticMapsServerSpecHttpTlsPtrOutput() ElasticMapsServerSpecHttpTlsPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpTlsPtrType) ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticMapsServerSpecHttpTlsOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTls)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsOutput) ToElasticMapsServerSpecHttpTlsOutput() ElasticMapsServerSpecHttpTlsOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsOutput) ToElasticMapsServerSpecHttpTlsOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsOutput) ToElasticMapsServerSpecHttpTlsPtrOutput() ElasticMapsServerSpecHttpTlsPtrOutput {
	return o.ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpTlsOutput) ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpTls) *ElasticMapsServerSpecHttpTls {
		return &v
	}).(ElasticMapsServerSpecHttpTlsPtrOutput)
}

func (o ElasticMapsServerSpecHttpTlsOutput) Certificate() ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTls) *ElasticMapsServerSpecHttpTlsCertificate { return v.Certificate }).(ElasticMapsServerSpecHttpTlsCertificatePtrOutput)
}

func (o ElasticMapsServerSpecHttpTlsOutput) SelfSignedCertificate() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTls) *ElasticMapsServerSpecHttpTlsSelfSignedCertificate {
		return v.SelfSignedCertificate
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput)
}

type ElasticMapsServerSpecHttpTlsPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTls)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsPtrOutput) ToElasticMapsServerSpecHttpTlsPtrOutput() ElasticMapsServerSpecHttpTlsPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsPtrOutput) ToElasticMapsServerSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsPtrOutput) Elem() ElasticMapsServerSpecHttpTlsOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTls) ElasticMapsServerSpecHttpTls {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpTls
		return ret
	}).(ElasticMapsServerSpecHttpTlsOutput)
}

func (o ElasticMapsServerSpecHttpTlsPtrOutput) Certificate() ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTls) *ElasticMapsServerSpecHttpTlsCertificate {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(ElasticMapsServerSpecHttpTlsCertificatePtrOutput)
}

func (o ElasticMapsServerSpecHttpTlsPtrOutput) SelfSignedCertificate() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTls) *ElasticMapsServerSpecHttpTlsSelfSignedCertificate {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticMapsServerSpecHttpTlsCertificate struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticMapsServerSpecHttpTlsCertificateInput is an input type that accepts ElasticMapsServerSpecHttpTlsCertificateArgs and ElasticMapsServerSpecHttpTlsCertificateOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsCertificateInput` via:
//
//	ElasticMapsServerSpecHttpTlsCertificateArgs{...}
type ElasticMapsServerSpecHttpTlsCertificateInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsCertificateOutput() ElasticMapsServerSpecHttpTlsCertificateOutput
	ToElasticMapsServerSpecHttpTlsCertificateOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsCertificateOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticMapsServerSpecHttpTlsCertificateArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticMapsServerSpecHttpTlsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificate)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsCertificateArgs) ToElasticMapsServerSpecHttpTlsCertificateOutput() ElasticMapsServerSpecHttpTlsCertificateOutput {
	return i.ToElasticMapsServerSpecHttpTlsCertificateOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsCertificateArgs) ToElasticMapsServerSpecHttpTlsCertificateOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsCertificateOutput)
}

func (i ElasticMapsServerSpecHttpTlsCertificateArgs) ToElasticMapsServerSpecHttpTlsCertificatePtrOutput() ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsCertificateArgs) ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsCertificateOutput).ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpTlsCertificatePtrInput is an input type that accepts ElasticMapsServerSpecHttpTlsCertificateArgs, ElasticMapsServerSpecHttpTlsCertificatePtr and ElasticMapsServerSpecHttpTlsCertificatePtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsCertificatePtrInput` via:
//
//	        ElasticMapsServerSpecHttpTlsCertificateArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpTlsCertificatePtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsCertificatePtrOutput() ElasticMapsServerSpecHttpTlsCertificatePtrOutput
	ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsCertificatePtrOutput
}

type elasticMapsServerSpecHttpTlsCertificatePtrType ElasticMapsServerSpecHttpTlsCertificateArgs

func ElasticMapsServerSpecHttpTlsCertificatePtr(v *ElasticMapsServerSpecHttpTlsCertificateArgs) ElasticMapsServerSpecHttpTlsCertificatePtrInput {
	return (*elasticMapsServerSpecHttpTlsCertificatePtrType)(v)
}

func (*elasticMapsServerSpecHttpTlsCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsCertificate)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpTlsCertificatePtrType) ToElasticMapsServerSpecHttpTlsCertificatePtrOutput() ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpTlsCertificatePtrType) ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticMapsServerSpecHttpTlsCertificateOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificate)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsCertificateOutput) ToElasticMapsServerSpecHttpTlsCertificateOutput() ElasticMapsServerSpecHttpTlsCertificateOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificateOutput) ToElasticMapsServerSpecHttpTlsCertificateOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificateOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificateOutput) ToElasticMapsServerSpecHttpTlsCertificatePtrOutput() ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return o.ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpTlsCertificateOutput) ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpTlsCertificate) *ElasticMapsServerSpecHttpTlsCertificate {
		return &v
	}).(ElasticMapsServerSpecHttpTlsCertificatePtrOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecHttpTlsCertificateOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsCertificate) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpTlsCertificatePtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsCertificate)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsCertificatePtrOutput) ToElasticMapsServerSpecHttpTlsCertificatePtrOutput() ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificatePtrOutput) ToElasticMapsServerSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificatePtrOutput) Elem() ElasticMapsServerSpecHttpTlsCertificateOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsCertificate) ElasticMapsServerSpecHttpTlsCertificate {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpTlsCertificate
		return ret
	}).(ElasticMapsServerSpecHttpTlsCertificateOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecHttpTlsCertificatePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsCertificate) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticMapsServerSpecHttpTlsCertificatePatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticMapsServerSpecHttpTlsCertificatePatchInput is an input type that accepts ElasticMapsServerSpecHttpTlsCertificatePatchArgs and ElasticMapsServerSpecHttpTlsCertificatePatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsCertificatePatchInput` via:
//
//	ElasticMapsServerSpecHttpTlsCertificatePatchArgs{...}
type ElasticMapsServerSpecHttpTlsCertificatePatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsCertificatePatchOutput() ElasticMapsServerSpecHttpTlsCertificatePatchOutput
	ToElasticMapsServerSpecHttpTlsCertificatePatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticMapsServerSpecHttpTlsCertificatePatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticMapsServerSpecHttpTlsCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsCertificatePatchOutput() ElasticMapsServerSpecHttpTlsCertificatePatchOutput {
	return i.ToElasticMapsServerSpecHttpTlsCertificatePatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsCertificatePatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsCertificatePatchOutput)
}

func (i ElasticMapsServerSpecHttpTlsCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsCertificatePatchOutput).ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpTlsCertificatePatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpTlsCertificatePatchArgs, ElasticMapsServerSpecHttpTlsCertificatePatchPtr and ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsCertificatePatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpTlsCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpTlsCertificatePatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput
	ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput
}

type elasticMapsServerSpecHttpTlsCertificatePatchPtrType ElasticMapsServerSpecHttpTlsCertificatePatchArgs

func ElasticMapsServerSpecHttpTlsCertificatePatchPtr(v *ElasticMapsServerSpecHttpTlsCertificatePatchArgs) ElasticMapsServerSpecHttpTlsCertificatePatchPtrInput {
	return (*elasticMapsServerSpecHttpTlsCertificatePatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpTlsCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpTlsCertificatePatchPtrType) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpTlsCertificatePatchPtrType) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticMapsServerSpecHttpTlsCertificatePatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsCertificatePatchOutput() ElasticMapsServerSpecHttpTlsCertificatePatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsCertificatePatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpTlsCertificatePatch) *ElasticMapsServerSpecHttpTlsCertificatePatch {
		return &v
	}).(ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecHttpTlsCertificatePatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsCertificatePatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput) ToElasticMapsServerSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput) Elem() ElasticMapsServerSpecHttpTlsCertificatePatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsCertificatePatch) ElasticMapsServerSpecHttpTlsCertificatePatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpTlsCertificatePatch
		return ret
	}).(ElasticMapsServerSpecHttpTlsCertificatePatchOutput)
}

// SecretName is the name of the secret.
func (o ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsCertificatePatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticMapsServerSpecHttpTlsPatch struct {
	Certificate           *ElasticMapsServerSpecHttpTlsCertificatePatch           `pulumi:"certificate"`
	SelfSignedCertificate *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch `pulumi:"selfSignedCertificate"`
}

// ElasticMapsServerSpecHttpTlsPatchInput is an input type that accepts ElasticMapsServerSpecHttpTlsPatchArgs and ElasticMapsServerSpecHttpTlsPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsPatchInput` via:
//
//	ElasticMapsServerSpecHttpTlsPatchArgs{...}
type ElasticMapsServerSpecHttpTlsPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsPatchOutput() ElasticMapsServerSpecHttpTlsPatchOutput
	ToElasticMapsServerSpecHttpTlsPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsPatchOutput
}

// TLS defines options for configuring TLS for HTTP.
type ElasticMapsServerSpecHttpTlsPatchArgs struct {
	Certificate           ElasticMapsServerSpecHttpTlsCertificatePatchPtrInput           `pulumi:"certificate"`
	SelfSignedCertificate ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrInput `pulumi:"selfSignedCertificate"`
}

func (ElasticMapsServerSpecHttpTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsPatchArgs) ToElasticMapsServerSpecHttpTlsPatchOutput() ElasticMapsServerSpecHttpTlsPatchOutput {
	return i.ToElasticMapsServerSpecHttpTlsPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsPatchArgs) ToElasticMapsServerSpecHttpTlsPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsPatchOutput)
}

func (i ElasticMapsServerSpecHttpTlsPatchArgs) ToElasticMapsServerSpecHttpTlsPatchPtrOutput() ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsPatchArgs) ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsPatchOutput).ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpTlsPatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpTlsPatchArgs, ElasticMapsServerSpecHttpTlsPatchPtr and ElasticMapsServerSpecHttpTlsPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsPatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpTlsPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpTlsPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsPatchPtrOutput() ElasticMapsServerSpecHttpTlsPatchPtrOutput
	ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsPatchPtrOutput
}

type elasticMapsServerSpecHttpTlsPatchPtrType ElasticMapsServerSpecHttpTlsPatchArgs

func ElasticMapsServerSpecHttpTlsPatchPtr(v *ElasticMapsServerSpecHttpTlsPatchArgs) ElasticMapsServerSpecHttpTlsPatchPtrInput {
	return (*elasticMapsServerSpecHttpTlsPatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpTlsPatchPtrType) ToElasticMapsServerSpecHttpTlsPatchPtrOutput() ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpTlsPatchPtrType) ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticMapsServerSpecHttpTlsPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsPatchOutput) ToElasticMapsServerSpecHttpTlsPatchOutput() ElasticMapsServerSpecHttpTlsPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsPatchOutput) ToElasticMapsServerSpecHttpTlsPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsPatchOutput) ToElasticMapsServerSpecHttpTlsPatchPtrOutput() ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpTlsPatchOutput) ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpTlsPatch) *ElasticMapsServerSpecHttpTlsPatch {
		return &v
	}).(ElasticMapsServerSpecHttpTlsPatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpTlsPatchOutput) Certificate() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsPatch) *ElasticMapsServerSpecHttpTlsCertificatePatch {
		return v.Certificate
	}).(ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpTlsPatchOutput) SelfSignedCertificate() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsPatch) *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch {
		return v.SelfSignedCertificate
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

type ElasticMapsServerSpecHttpTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsPatchPtrOutput) ToElasticMapsServerSpecHttpTlsPatchPtrOutput() ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsPatchPtrOutput) ToElasticMapsServerSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsPatchPtrOutput) Elem() ElasticMapsServerSpecHttpTlsPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsPatch) ElasticMapsServerSpecHttpTlsPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpTlsPatch
		return ret
	}).(ElasticMapsServerSpecHttpTlsPatchOutput)
}

func (o ElasticMapsServerSpecHttpTlsPatchPtrOutput) Certificate() ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsPatch) *ElasticMapsServerSpecHttpTlsCertificatePatch {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput)
}

func (o ElasticMapsServerSpecHttpTlsPatchPtrOutput) SelfSignedCertificate() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsPatch) *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificate struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames `pulumi:"subjectAltNames"`
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificateInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs and ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificateInput` via:
//
//	ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs{...}
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput `pulumi:"subjectAltNames"`
}

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput)
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput).ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs, ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtr and ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrInput` via:
//
//	        ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput
}

type elasticMapsServerSpecHttpTlsSelfSignedCertificatePtrType ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs

func ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtr(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrInput {
	return (*elasticMapsServerSpecHttpTlsSelfSignedCertificatePtrType)(v)
}

func (*elasticMapsServerSpecHttpTlsSelfSignedCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpTlsSelfSignedCertificatePtrType) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpTlsSelfSignedCertificatePtrType) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpTlsSelfSignedCertificate) *ElasticMapsServerSpecHttpTlsSelfSignedCertificate {
		return &v
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificate) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput) SubjectAltNames() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificate) []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		return v.SubjectAltNames
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput) Elem() ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificate) ElasticMapsServerSpecHttpTlsSelfSignedCertificate {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpTlsSelfSignedCertificate
		return ret
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificate) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput) SubjectAltNames() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificate) []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch `pulumi:"subjectAltNames"`
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs and ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchInput` via:
//
//	ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs{...}
type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput `pulumi:"subjectAltNames"`
}

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput)
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput).ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs, ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtr and ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrInput` via:
//
//	        ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput
}

type elasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrType ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs

func ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtr(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrInput {
	return (*elasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrType)(v)
}

func (*elasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrType) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrType) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch) *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch {
		return &v
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput) SubjectAltNames() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch) []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		return v.SubjectAltNames
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

type ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput) Elem() ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch) ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch
		return ret
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput) SubjectAltNames() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatch) []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs and ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput` via:
//
//	ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{...}
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray and ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput` via:
//
//	ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray{ ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{...} }
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput
}

type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) Index(i pulumi.IntInput) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		return vs[0].([]ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNames)[vs[1].(int)]
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs and ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput` via:
//
//	ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...}
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput is an input type that accepts ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray and ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput` via:
//
//	ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray{ ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...} }
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput interface {
	pulumi.Input

	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
	ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
}

type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray []ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return i.ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) Index(i pulumi.IntInput) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		return vs[0].([]ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)[vs[1].(int)]
	}).(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// MapsSpec holds the specification of an Elastic Maps Server instance.
type ElasticMapsServerSpecPatch struct {
	// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
	Config    map[string]interface{}               `pulumi:"config"`
	ConfigRef *ElasticMapsServerSpecConfigRefPatch `pulumi:"configRef"`
	// Count of Elastic Maps Server instances to deploy.
	Count            *int                                        `pulumi:"count"`
	ElasticsearchRef *ElasticMapsServerSpecElasticsearchRefPatch `pulumi:"elasticsearchRef"`
	Http             *ElasticMapsServerSpecHttpPatch             `pulumi:"http"`
	// Image is the Elastic Maps Server Docker image to deploy.
	Image *string `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Version of Elastic Maps Server.
	Version *string `pulumi:"version"`
}

// ElasticMapsServerSpecPatchInput is an input type that accepts ElasticMapsServerSpecPatchArgs and ElasticMapsServerSpecPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecPatchInput` via:
//
//	ElasticMapsServerSpecPatchArgs{...}
type ElasticMapsServerSpecPatchInput interface {
	pulumi.Input

	ToElasticMapsServerSpecPatchOutput() ElasticMapsServerSpecPatchOutput
	ToElasticMapsServerSpecPatchOutputWithContext(context.Context) ElasticMapsServerSpecPatchOutput
}

// MapsSpec holds the specification of an Elastic Maps Server instance.
type ElasticMapsServerSpecPatchArgs struct {
	// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
	Config    pulumi.MapInput                             `pulumi:"config"`
	ConfigRef ElasticMapsServerSpecConfigRefPatchPtrInput `pulumi:"configRef"`
	// Count of Elastic Maps Server instances to deploy.
	Count            pulumi.IntPtrInput                                 `pulumi:"count"`
	ElasticsearchRef ElasticMapsServerSpecElasticsearchRefPatchPtrInput `pulumi:"elasticsearchRef"`
	Http             ElasticMapsServerSpecHttpPatchPtrInput             `pulumi:"http"`
	// Image is the Elastic Maps Server Docker image to deploy.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Version of Elastic Maps Server.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ElasticMapsServerSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecPatch)(nil)).Elem()
}

func (i ElasticMapsServerSpecPatchArgs) ToElasticMapsServerSpecPatchOutput() ElasticMapsServerSpecPatchOutput {
	return i.ToElasticMapsServerSpecPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecPatchArgs) ToElasticMapsServerSpecPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecPatchOutput)
}

func (i ElasticMapsServerSpecPatchArgs) ToElasticMapsServerSpecPatchPtrOutput() ElasticMapsServerSpecPatchPtrOutput {
	return i.ToElasticMapsServerSpecPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerSpecPatchArgs) ToElasticMapsServerSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecPatchOutput).ToElasticMapsServerSpecPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerSpecPatchPtrInput is an input type that accepts ElasticMapsServerSpecPatchArgs, ElasticMapsServerSpecPatchPtr and ElasticMapsServerSpecPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerSpecPatchPtrInput` via:
//
//	        ElasticMapsServerSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerSpecPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerSpecPatchPtrOutput() ElasticMapsServerSpecPatchPtrOutput
	ToElasticMapsServerSpecPatchPtrOutputWithContext(context.Context) ElasticMapsServerSpecPatchPtrOutput
}

type elasticMapsServerSpecPatchPtrType ElasticMapsServerSpecPatchArgs

func ElasticMapsServerSpecPatchPtr(v *ElasticMapsServerSpecPatchArgs) ElasticMapsServerSpecPatchPtrInput {
	return (*elasticMapsServerSpecPatchPtrType)(v)
}

func (*elasticMapsServerSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecPatch)(nil)).Elem()
}

func (i *elasticMapsServerSpecPatchPtrType) ToElasticMapsServerSpecPatchPtrOutput() ElasticMapsServerSpecPatchPtrOutput {
	return i.ToElasticMapsServerSpecPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerSpecPatchPtrType) ToElasticMapsServerSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerSpecPatchPtrOutput)
}

// MapsSpec holds the specification of an Elastic Maps Server instance.
type ElasticMapsServerSpecPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerSpecPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecPatchOutput) ToElasticMapsServerSpecPatchOutput() ElasticMapsServerSpecPatchOutput {
	return o
}

func (o ElasticMapsServerSpecPatchOutput) ToElasticMapsServerSpecPatchOutputWithContext(ctx context.Context) ElasticMapsServerSpecPatchOutput {
	return o
}

func (o ElasticMapsServerSpecPatchOutput) ToElasticMapsServerSpecPatchPtrOutput() ElasticMapsServerSpecPatchPtrOutput {
	return o.ToElasticMapsServerSpecPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerSpecPatchOutput) ToElasticMapsServerSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerSpecPatch) *ElasticMapsServerSpecPatch {
		return &v
	}).(ElasticMapsServerSpecPatchPtrOutput)
}

// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
func (o ElasticMapsServerSpecPatchOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

func (o ElasticMapsServerSpecPatchOutput) ConfigRef() ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *ElasticMapsServerSpecConfigRefPatch { return v.ConfigRef }).(ElasticMapsServerSpecConfigRefPatchPtrOutput)
}

// Count of Elastic Maps Server instances to deploy.
func (o ElasticMapsServerSpecPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

func (o ElasticMapsServerSpecPatchOutput) ElasticsearchRef() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *ElasticMapsServerSpecElasticsearchRefPatch {
		return v.ElasticsearchRef
	}).(ElasticMapsServerSpecElasticsearchRefPatchPtrOutput)
}

func (o ElasticMapsServerSpecPatchOutput) Http() ElasticMapsServerSpecHttpPatchPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *ElasticMapsServerSpecHttpPatch { return v.Http }).(ElasticMapsServerSpecHttpPatchPtrOutput)
}

// Image is the Elastic Maps Server Docker image to deploy.
func (o ElasticMapsServerSpecPatchOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
func (o ElasticMapsServerSpecPatchOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
func (o ElasticMapsServerSpecPatchOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o ElasticMapsServerSpecPatchOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Version of Elastic Maps Server.
func (o ElasticMapsServerSpecPatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerSpecPatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerSpecPatch)(nil)).Elem()
}

func (o ElasticMapsServerSpecPatchPtrOutput) ToElasticMapsServerSpecPatchPtrOutput() ElasticMapsServerSpecPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecPatchPtrOutput) ToElasticMapsServerSpecPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerSpecPatchPtrOutput {
	return o
}

func (o ElasticMapsServerSpecPatchPtrOutput) Elem() ElasticMapsServerSpecPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) ElasticMapsServerSpecPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerSpecPatch
		return ret
	}).(ElasticMapsServerSpecPatchOutput)
}

// Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration
func (o ElasticMapsServerSpecPatchPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

func (o ElasticMapsServerSpecPatchPtrOutput) ConfigRef() ElasticMapsServerSpecConfigRefPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *ElasticMapsServerSpecConfigRefPatch {
		if v == nil {
			return nil
		}
		return v.ConfigRef
	}).(ElasticMapsServerSpecConfigRefPatchPtrOutput)
}

// Count of Elastic Maps Server instances to deploy.
func (o ElasticMapsServerSpecPatchPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

func (o ElasticMapsServerSpecPatchPtrOutput) ElasticsearchRef() ElasticMapsServerSpecElasticsearchRefPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *ElasticMapsServerSpecElasticsearchRefPatch {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRef
	}).(ElasticMapsServerSpecElasticsearchRefPatchPtrOutput)
}

func (o ElasticMapsServerSpecPatchPtrOutput) Http() ElasticMapsServerSpecHttpPatchPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *ElasticMapsServerSpecHttpPatch {
		if v == nil {
			return nil
		}
		return v.Http
	}).(ElasticMapsServerSpecHttpPatchPtrOutput)
}

// Image is the Elastic Maps Server Docker image to deploy.
func (o ElasticMapsServerSpecPatchPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
func (o ElasticMapsServerSpecPatchPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying Deployment.
func (o ElasticMapsServerSpecPatchPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o ElasticMapsServerSpecPatchPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Version of Elastic Maps Server.
func (o ElasticMapsServerSpecPatchPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// MapsStatus defines the observed state of Elastic Maps Server
type ElasticMapsServerStatus struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus *string `pulumi:"associationStatus"`
	// AvailableNodes is the number of available replicas in the deployment.
	AvailableNodes *int `pulumi:"availableNodes"`
	// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
	Count *int `pulumi:"count"`
	// Health of the deployment.
	Health *string `pulumi:"health"`
	// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Elastic
	// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// Selector is the label selector used to find all pods.
	Selector *string `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version *string `pulumi:"version"`
}

// ElasticMapsServerStatusInput is an input type that accepts ElasticMapsServerStatusArgs and ElasticMapsServerStatusOutput values.
// You can construct a concrete instance of `ElasticMapsServerStatusInput` via:
//
//	ElasticMapsServerStatusArgs{...}
type ElasticMapsServerStatusInput interface {
	pulumi.Input

	ToElasticMapsServerStatusOutput() ElasticMapsServerStatusOutput
	ToElasticMapsServerStatusOutputWithContext(context.Context) ElasticMapsServerStatusOutput
}

// MapsStatus defines the observed state of Elastic Maps Server
type ElasticMapsServerStatusArgs struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus pulumi.StringPtrInput `pulumi:"associationStatus"`
	// AvailableNodes is the number of available replicas in the deployment.
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// Health of the deployment.
	Health pulumi.StringPtrInput `pulumi:"health"`
	// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Elastic
	// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// Selector is the label selector used to find all pods.
	Selector pulumi.StringPtrInput `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ElasticMapsServerStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerStatus)(nil)).Elem()
}

func (i ElasticMapsServerStatusArgs) ToElasticMapsServerStatusOutput() ElasticMapsServerStatusOutput {
	return i.ToElasticMapsServerStatusOutputWithContext(context.Background())
}

func (i ElasticMapsServerStatusArgs) ToElasticMapsServerStatusOutputWithContext(ctx context.Context) ElasticMapsServerStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerStatusOutput)
}

func (i ElasticMapsServerStatusArgs) ToElasticMapsServerStatusPtrOutput() ElasticMapsServerStatusPtrOutput {
	return i.ToElasticMapsServerStatusPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerStatusArgs) ToElasticMapsServerStatusPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerStatusOutput).ToElasticMapsServerStatusPtrOutputWithContext(ctx)
}

// ElasticMapsServerStatusPtrInput is an input type that accepts ElasticMapsServerStatusArgs, ElasticMapsServerStatusPtr and ElasticMapsServerStatusPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerStatusPtrInput` via:
//
//	        ElasticMapsServerStatusArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerStatusPtrInput interface {
	pulumi.Input

	ToElasticMapsServerStatusPtrOutput() ElasticMapsServerStatusPtrOutput
	ToElasticMapsServerStatusPtrOutputWithContext(context.Context) ElasticMapsServerStatusPtrOutput
}

type elasticMapsServerStatusPtrType ElasticMapsServerStatusArgs

func ElasticMapsServerStatusPtr(v *ElasticMapsServerStatusArgs) ElasticMapsServerStatusPtrInput {
	return (*elasticMapsServerStatusPtrType)(v)
}

func (*elasticMapsServerStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerStatus)(nil)).Elem()
}

func (i *elasticMapsServerStatusPtrType) ToElasticMapsServerStatusPtrOutput() ElasticMapsServerStatusPtrOutput {
	return i.ToElasticMapsServerStatusPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerStatusPtrType) ToElasticMapsServerStatusPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerStatusPtrOutput)
}

// MapsStatus defines the observed state of Elastic Maps Server
type ElasticMapsServerStatusOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerStatus)(nil)).Elem()
}

func (o ElasticMapsServerStatusOutput) ToElasticMapsServerStatusOutput() ElasticMapsServerStatusOutput {
	return o
}

func (o ElasticMapsServerStatusOutput) ToElasticMapsServerStatusOutputWithContext(ctx context.Context) ElasticMapsServerStatusOutput {
	return o
}

func (o ElasticMapsServerStatusOutput) ToElasticMapsServerStatusPtrOutput() ElasticMapsServerStatusPtrOutput {
	return o.ToElasticMapsServerStatusPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerStatusOutput) ToElasticMapsServerStatusPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerStatus) *ElasticMapsServerStatus {
		return &v
	}).(ElasticMapsServerStatusPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o ElasticMapsServerStatusOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *string { return v.AssociationStatus }).(pulumi.StringPtrOutput)
}

// AvailableNodes is the number of available replicas in the deployment.
func (o ElasticMapsServerStatusOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
func (o ElasticMapsServerStatusOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// Health of the deployment.
func (o ElasticMapsServerStatusOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Elastic
// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
func (o ElasticMapsServerStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// Selector is the label selector used to find all pods.
func (o ElasticMapsServerStatusOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *string { return v.Selector }).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o ElasticMapsServerStatusOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatus) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerStatusPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerStatus)(nil)).Elem()
}

func (o ElasticMapsServerStatusPtrOutput) ToElasticMapsServerStatusPtrOutput() ElasticMapsServerStatusPtrOutput {
	return o
}

func (o ElasticMapsServerStatusPtrOutput) ToElasticMapsServerStatusPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPtrOutput {
	return o
}

func (o ElasticMapsServerStatusPtrOutput) Elem() ElasticMapsServerStatusOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) ElasticMapsServerStatus {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerStatus
		return ret
	}).(ElasticMapsServerStatusOutput)
}

// AssociationStatus is the status of an association resource.
func (o ElasticMapsServerStatusPtrOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *string {
		if v == nil {
			return nil
		}
		return v.AssociationStatus
	}).(pulumi.StringPtrOutput)
}

// AvailableNodes is the number of available replicas in the deployment.
func (o ElasticMapsServerStatusPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
func (o ElasticMapsServerStatusPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// Health of the deployment.
func (o ElasticMapsServerStatusPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Elastic
// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
func (o ElasticMapsServerStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// Selector is the label selector used to find all pods.
func (o ElasticMapsServerStatusPtrOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o ElasticMapsServerStatusPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatus) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// MapsStatus defines the observed state of Elastic Maps Server
type ElasticMapsServerStatusPatch struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus *string `pulumi:"associationStatus"`
	// AvailableNodes is the number of available replicas in the deployment.
	AvailableNodes *int `pulumi:"availableNodes"`
	// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
	Count *int `pulumi:"count"`
	// Health of the deployment.
	Health *string `pulumi:"health"`
	// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Elastic
	// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// Selector is the label selector used to find all pods.
	Selector *string `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version *string `pulumi:"version"`
}

// ElasticMapsServerStatusPatchInput is an input type that accepts ElasticMapsServerStatusPatchArgs and ElasticMapsServerStatusPatchOutput values.
// You can construct a concrete instance of `ElasticMapsServerStatusPatchInput` via:
//
//	ElasticMapsServerStatusPatchArgs{...}
type ElasticMapsServerStatusPatchInput interface {
	pulumi.Input

	ToElasticMapsServerStatusPatchOutput() ElasticMapsServerStatusPatchOutput
	ToElasticMapsServerStatusPatchOutputWithContext(context.Context) ElasticMapsServerStatusPatchOutput
}

// MapsStatus defines the observed state of Elastic Maps Server
type ElasticMapsServerStatusPatchArgs struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus pulumi.StringPtrInput `pulumi:"associationStatus"`
	// AvailableNodes is the number of available replicas in the deployment.
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// Health of the deployment.
	Health pulumi.StringPtrInput `pulumi:"health"`
	// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Elastic
	// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// Selector is the label selector used to find all pods.
	Selector pulumi.StringPtrInput `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ElasticMapsServerStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerStatusPatch)(nil)).Elem()
}

func (i ElasticMapsServerStatusPatchArgs) ToElasticMapsServerStatusPatchOutput() ElasticMapsServerStatusPatchOutput {
	return i.ToElasticMapsServerStatusPatchOutputWithContext(context.Background())
}

func (i ElasticMapsServerStatusPatchArgs) ToElasticMapsServerStatusPatchOutputWithContext(ctx context.Context) ElasticMapsServerStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerStatusPatchOutput)
}

func (i ElasticMapsServerStatusPatchArgs) ToElasticMapsServerStatusPatchPtrOutput() ElasticMapsServerStatusPatchPtrOutput {
	return i.ToElasticMapsServerStatusPatchPtrOutputWithContext(context.Background())
}

func (i ElasticMapsServerStatusPatchArgs) ToElasticMapsServerStatusPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerStatusPatchOutput).ToElasticMapsServerStatusPatchPtrOutputWithContext(ctx)
}

// ElasticMapsServerStatusPatchPtrInput is an input type that accepts ElasticMapsServerStatusPatchArgs, ElasticMapsServerStatusPatchPtr and ElasticMapsServerStatusPatchPtrOutput values.
// You can construct a concrete instance of `ElasticMapsServerStatusPatchPtrInput` via:
//
//	        ElasticMapsServerStatusPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticMapsServerStatusPatchPtrInput interface {
	pulumi.Input

	ToElasticMapsServerStatusPatchPtrOutput() ElasticMapsServerStatusPatchPtrOutput
	ToElasticMapsServerStatusPatchPtrOutputWithContext(context.Context) ElasticMapsServerStatusPatchPtrOutput
}

type elasticMapsServerStatusPatchPtrType ElasticMapsServerStatusPatchArgs

func ElasticMapsServerStatusPatchPtr(v *ElasticMapsServerStatusPatchArgs) ElasticMapsServerStatusPatchPtrInput {
	return (*elasticMapsServerStatusPatchPtrType)(v)
}

func (*elasticMapsServerStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerStatusPatch)(nil)).Elem()
}

func (i *elasticMapsServerStatusPatchPtrType) ToElasticMapsServerStatusPatchPtrOutput() ElasticMapsServerStatusPatchPtrOutput {
	return i.ToElasticMapsServerStatusPatchPtrOutputWithContext(context.Background())
}

func (i *elasticMapsServerStatusPatchPtrType) ToElasticMapsServerStatusPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticMapsServerStatusPatchPtrOutput)
}

// MapsStatus defines the observed state of Elastic Maps Server
type ElasticMapsServerStatusPatchOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticMapsServerStatusPatch)(nil)).Elem()
}

func (o ElasticMapsServerStatusPatchOutput) ToElasticMapsServerStatusPatchOutput() ElasticMapsServerStatusPatchOutput {
	return o
}

func (o ElasticMapsServerStatusPatchOutput) ToElasticMapsServerStatusPatchOutputWithContext(ctx context.Context) ElasticMapsServerStatusPatchOutput {
	return o
}

func (o ElasticMapsServerStatusPatchOutput) ToElasticMapsServerStatusPatchPtrOutput() ElasticMapsServerStatusPatchPtrOutput {
	return o.ToElasticMapsServerStatusPatchPtrOutputWithContext(context.Background())
}

func (o ElasticMapsServerStatusPatchOutput) ToElasticMapsServerStatusPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticMapsServerStatusPatch) *ElasticMapsServerStatusPatch {
		return &v
	}).(ElasticMapsServerStatusPatchPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o ElasticMapsServerStatusPatchOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *string { return v.AssociationStatus }).(pulumi.StringPtrOutput)
}

// AvailableNodes is the number of available replicas in the deployment.
func (o ElasticMapsServerStatusPatchOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
func (o ElasticMapsServerStatusPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// Health of the deployment.
func (o ElasticMapsServerStatusPatchOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Elastic
// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
func (o ElasticMapsServerStatusPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// Selector is the label selector used to find all pods.
func (o ElasticMapsServerStatusPatchOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *string { return v.Selector }).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o ElasticMapsServerStatusPatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticMapsServerStatusPatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ElasticMapsServerStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticMapsServerStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticMapsServerStatusPatch)(nil)).Elem()
}

func (o ElasticMapsServerStatusPatchPtrOutput) ToElasticMapsServerStatusPatchPtrOutput() ElasticMapsServerStatusPatchPtrOutput {
	return o
}

func (o ElasticMapsServerStatusPatchPtrOutput) ToElasticMapsServerStatusPatchPtrOutputWithContext(ctx context.Context) ElasticMapsServerStatusPatchPtrOutput {
	return o
}

func (o ElasticMapsServerStatusPatchPtrOutput) Elem() ElasticMapsServerStatusPatchOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) ElasticMapsServerStatusPatch {
		if v != nil {
			return *v
		}
		var ret ElasticMapsServerStatusPatch
		return ret
	}).(ElasticMapsServerStatusPatchOutput)
}

// AssociationStatus is the status of an association resource.
func (o ElasticMapsServerStatusPatchPtrOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.AssociationStatus
	}).(pulumi.StringPtrOutput)
}

// AvailableNodes is the number of available replicas in the deployment.
func (o ElasticMapsServerStatusPatchPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
func (o ElasticMapsServerStatusPatchPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// Health of the deployment.
func (o ElasticMapsServerStatusPatchPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the most recent generation observed for this Elastic Maps Server.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Elastic
// Maps controller has not yet processed the changes contained in the Elastic Maps specification.
func (o ElasticMapsServerStatusPatchPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// Selector is the label selector used to find all pods.
func (o ElasticMapsServerStatusPatchPtrOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o ElasticMapsServerStatusPatchPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticMapsServerStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerTypeInput)(nil)).Elem(), ElasticMapsServerTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerTypeArrayInput)(nil)).Elem(), ElasticMapsServerTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerListTypeInput)(nil)).Elem(), ElasticMapsServerListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerPatchTypeInput)(nil)).Elem(), ElasticMapsServerPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecInput)(nil)).Elem(), ElasticMapsServerSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecPtrInput)(nil)).Elem(), ElasticMapsServerSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecConfigRefInput)(nil)).Elem(), ElasticMapsServerSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecConfigRefPtrInput)(nil)).Elem(), ElasticMapsServerSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecConfigRefPatchInput)(nil)).Elem(), ElasticMapsServerSpecConfigRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecConfigRefPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecConfigRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRefInput)(nil)).Elem(), ElasticMapsServerSpecElasticsearchRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRefPtrInput)(nil)).Elem(), ElasticMapsServerSpecElasticsearchRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRefPatchInput)(nil)).Elem(), ElasticMapsServerSpecElasticsearchRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecElasticsearchRefPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecElasticsearchRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpInput)(nil)).Elem(), ElasticMapsServerSpecHttpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServicePtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadataInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadataPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadataPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceMetadataPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServicePatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServicePatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPortsInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecPortsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPortsArrayInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecPortsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPortsPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecPortsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecPortsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificateInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificatePtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificatePatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsCertificatePatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput)(nil)).Elem(), ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecPatchInput)(nil)).Elem(), ElasticMapsServerSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerSpecPatchPtrInput)(nil)).Elem(), ElasticMapsServerSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerStatusInput)(nil)).Elem(), ElasticMapsServerStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerStatusPtrInput)(nil)).Elem(), ElasticMapsServerStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerStatusPatchInput)(nil)).Elem(), ElasticMapsServerStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticMapsServerStatusPatchPtrInput)(nil)).Elem(), ElasticMapsServerStatusPatchArgs{})
	pulumi.RegisterOutputType(ElasticMapsServerTypeOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerTypeArrayOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerListTypeOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerPatchTypeOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecConfigRefOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecConfigRefPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecConfigRefPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecConfigRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecElasticsearchRefOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecElasticsearchRefPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecElasticsearchRefPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecElasticsearchRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServicePtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceMetadataOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceMetadataPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceMetadataPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServicePatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServicePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPortsOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPortsArrayOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPortsPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecPortsPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsCertificateOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsCertificatePtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsCertificatePatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificateOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerStatusOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerStatusPtrOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerStatusPatchOutput{})
	pulumi.RegisterOutputType(ElasticMapsServerStatusPatchPtrOutput{})
}
