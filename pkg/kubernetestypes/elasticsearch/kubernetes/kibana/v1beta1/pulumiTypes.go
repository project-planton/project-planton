// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Kibana represents a Kibana resource in a Kubernetes cluster.
type KibanaType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *KibanaSpec        `pulumi:"spec"`
	Status   *KibanaStatus      `pulumi:"status"`
}

// KibanaTypeInput is an input type that accepts KibanaTypeArgs and KibanaTypeOutput values.
// You can construct a concrete instance of `KibanaTypeInput` via:
//
//	KibanaTypeArgs{...}
type KibanaTypeInput interface {
	pulumi.Input

	ToKibanaTypeOutput() KibanaTypeOutput
	ToKibanaTypeOutputWithContext(context.Context) KibanaTypeOutput
}

// Kibana represents a Kibana resource in a Kubernetes cluster.
type KibanaTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     KibanaSpecPtrInput        `pulumi:"spec"`
	Status   KibanaStatusPtrInput      `pulumi:"status"`
}

func (KibanaTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaType)(nil)).Elem()
}

func (i KibanaTypeArgs) ToKibanaTypeOutput() KibanaTypeOutput {
	return i.ToKibanaTypeOutputWithContext(context.Background())
}

func (i KibanaTypeArgs) ToKibanaTypeOutputWithContext(ctx context.Context) KibanaTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaTypeOutput)
}

// KibanaTypeArrayInput is an input type that accepts KibanaTypeArray and KibanaTypeArrayOutput values.
// You can construct a concrete instance of `KibanaTypeArrayInput` via:
//
//	KibanaTypeArray{ KibanaTypeArgs{...} }
type KibanaTypeArrayInput interface {
	pulumi.Input

	ToKibanaTypeArrayOutput() KibanaTypeArrayOutput
	ToKibanaTypeArrayOutputWithContext(context.Context) KibanaTypeArrayOutput
}

type KibanaTypeArray []KibanaTypeInput

func (KibanaTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaType)(nil)).Elem()
}

func (i KibanaTypeArray) ToKibanaTypeArrayOutput() KibanaTypeArrayOutput {
	return i.ToKibanaTypeArrayOutputWithContext(context.Background())
}

func (i KibanaTypeArray) ToKibanaTypeArrayOutputWithContext(ctx context.Context) KibanaTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaTypeArrayOutput)
}

// Kibana represents a Kibana resource in a Kubernetes cluster.
type KibanaTypeOutput struct{ *pulumi.OutputState }

func (KibanaTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaType)(nil)).Elem()
}

func (o KibanaTypeOutput) ToKibanaTypeOutput() KibanaTypeOutput {
	return o
}

func (o KibanaTypeOutput) ToKibanaTypeOutputWithContext(ctx context.Context) KibanaTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o KibanaTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o KibanaTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o KibanaTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v KibanaType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o KibanaTypeOutput) Spec() KibanaSpecPtrOutput {
	return o.ApplyT(func(v KibanaType) *KibanaSpec { return v.Spec }).(KibanaSpecPtrOutput)
}

func (o KibanaTypeOutput) Status() KibanaStatusPtrOutput {
	return o.ApplyT(func(v KibanaType) *KibanaStatus { return v.Status }).(KibanaStatusPtrOutput)
}

type KibanaTypeArrayOutput struct{ *pulumi.OutputState }

func (KibanaTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaType)(nil)).Elem()
}

func (o KibanaTypeArrayOutput) ToKibanaTypeArrayOutput() KibanaTypeArrayOutput {
	return o
}

func (o KibanaTypeArrayOutput) ToKibanaTypeArrayOutputWithContext(ctx context.Context) KibanaTypeArrayOutput {
	return o
}

func (o KibanaTypeArrayOutput) Index(i pulumi.IntInput) KibanaTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaType {
		return vs[0].([]KibanaType)[vs[1].(int)]
	}).(KibanaTypeOutput)
}

// KibanaList is a list of Kibana
type KibanaListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of kibanas. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []KibanaType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// KibanaListTypeInput is an input type that accepts KibanaListTypeArgs and KibanaListTypeOutput values.
// You can construct a concrete instance of `KibanaListTypeInput` via:
//
//	KibanaListTypeArgs{...}
type KibanaListTypeInput interface {
	pulumi.Input

	ToKibanaListTypeOutput() KibanaListTypeOutput
	ToKibanaListTypeOutputWithContext(context.Context) KibanaListTypeOutput
}

// KibanaList is a list of Kibana
type KibanaListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of kibanas. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items KibanaTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (KibanaListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaListType)(nil)).Elem()
}

func (i KibanaListTypeArgs) ToKibanaListTypeOutput() KibanaListTypeOutput {
	return i.ToKibanaListTypeOutputWithContext(context.Background())
}

func (i KibanaListTypeArgs) ToKibanaListTypeOutputWithContext(ctx context.Context) KibanaListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaListTypeOutput)
}

// KibanaList is a list of Kibana
type KibanaListTypeOutput struct{ *pulumi.OutputState }

func (KibanaListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaListType)(nil)).Elem()
}

func (o KibanaListTypeOutput) ToKibanaListTypeOutput() KibanaListTypeOutput {
	return o
}

func (o KibanaListTypeOutput) ToKibanaListTypeOutputWithContext(ctx context.Context) KibanaListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o KibanaListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of kibanas. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o KibanaListTypeOutput) Items() KibanaTypeArrayOutput {
	return o.ApplyT(func(v KibanaListType) []KibanaType { return v.Items }).(KibanaTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o KibanaListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o KibanaListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v KibanaListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Kibana represents a Kibana resource in a Kubernetes cluster.
type KibanaPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *KibanaSpecPatch        `pulumi:"spec"`
	Status   *KibanaStatusPatch      `pulumi:"status"`
}

// KibanaPatchTypeInput is an input type that accepts KibanaPatchTypeArgs and KibanaPatchTypeOutput values.
// You can construct a concrete instance of `KibanaPatchTypeInput` via:
//
//	KibanaPatchTypeArgs{...}
type KibanaPatchTypeInput interface {
	pulumi.Input

	ToKibanaPatchTypeOutput() KibanaPatchTypeOutput
	ToKibanaPatchTypeOutputWithContext(context.Context) KibanaPatchTypeOutput
}

// Kibana represents a Kibana resource in a Kubernetes cluster.
type KibanaPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     KibanaSpecPatchPtrInput        `pulumi:"spec"`
	Status   KibanaStatusPatchPtrInput      `pulumi:"status"`
}

func (KibanaPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaPatchType)(nil)).Elem()
}

func (i KibanaPatchTypeArgs) ToKibanaPatchTypeOutput() KibanaPatchTypeOutput {
	return i.ToKibanaPatchTypeOutputWithContext(context.Background())
}

func (i KibanaPatchTypeArgs) ToKibanaPatchTypeOutputWithContext(ctx context.Context) KibanaPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaPatchTypeOutput)
}

// Kibana represents a Kibana resource in a Kubernetes cluster.
type KibanaPatchTypeOutput struct{ *pulumi.OutputState }

func (KibanaPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaPatchType)(nil)).Elem()
}

func (o KibanaPatchTypeOutput) ToKibanaPatchTypeOutput() KibanaPatchTypeOutput {
	return o
}

func (o KibanaPatchTypeOutput) ToKibanaPatchTypeOutputWithContext(ctx context.Context) KibanaPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o KibanaPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o KibanaPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o KibanaPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v KibanaPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o KibanaPatchTypeOutput) Spec() KibanaSpecPatchPtrOutput {
	return o.ApplyT(func(v KibanaPatchType) *KibanaSpecPatch { return v.Spec }).(KibanaSpecPatchPtrOutput)
}

func (o KibanaPatchTypeOutput) Status() KibanaStatusPatchPtrOutput {
	return o.ApplyT(func(v KibanaPatchType) *KibanaStatusPatch { return v.Status }).(KibanaStatusPatchPtrOutput)
}

// KibanaSpec holds the specification of a Kibana instance.
type KibanaSpec struct {
	// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
	Config map[string]interface{} `pulumi:"config"`
	// Count of Kibana instances to deploy.
	Count            *int                        `pulumi:"count"`
	ElasticsearchRef *KibanaSpecElasticsearchRef `pulumi:"elasticsearchRef"`
	Http             *KibanaSpecHttp             `pulumi:"http"`
	// Image is the Kibana Docker image to deploy.
	Image *string `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
	SecureSettings []KibanaSpecSecureSettings `pulumi:"secureSettings"`
	// Version of Kibana.
	Version *string `pulumi:"version"`
}

// KibanaSpecInput is an input type that accepts KibanaSpecArgs and KibanaSpecOutput values.
// You can construct a concrete instance of `KibanaSpecInput` via:
//
//	KibanaSpecArgs{...}
type KibanaSpecInput interface {
	pulumi.Input

	ToKibanaSpecOutput() KibanaSpecOutput
	ToKibanaSpecOutputWithContext(context.Context) KibanaSpecOutput
}

// KibanaSpec holds the specification of a Kibana instance.
type KibanaSpecArgs struct {
	// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
	Config pulumi.MapInput `pulumi:"config"`
	// Count of Kibana instances to deploy.
	Count            pulumi.IntPtrInput                 `pulumi:"count"`
	ElasticsearchRef KibanaSpecElasticsearchRefPtrInput `pulumi:"elasticsearchRef"`
	Http             KibanaSpecHttpPtrInput             `pulumi:"http"`
	// Image is the Kibana Docker image to deploy.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
	SecureSettings KibanaSpecSecureSettingsArrayInput `pulumi:"secureSettings"`
	// Version of Kibana.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (KibanaSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpec)(nil)).Elem()
}

func (i KibanaSpecArgs) ToKibanaSpecOutput() KibanaSpecOutput {
	return i.ToKibanaSpecOutputWithContext(context.Background())
}

func (i KibanaSpecArgs) ToKibanaSpecOutputWithContext(ctx context.Context) KibanaSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecOutput)
}

func (i KibanaSpecArgs) ToKibanaSpecPtrOutput() KibanaSpecPtrOutput {
	return i.ToKibanaSpecPtrOutputWithContext(context.Background())
}

func (i KibanaSpecArgs) ToKibanaSpecPtrOutputWithContext(ctx context.Context) KibanaSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecOutput).ToKibanaSpecPtrOutputWithContext(ctx)
}

// KibanaSpecPtrInput is an input type that accepts KibanaSpecArgs, KibanaSpecPtr and KibanaSpecPtrOutput values.
// You can construct a concrete instance of `KibanaSpecPtrInput` via:
//
//	        KibanaSpecArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecPtrInput interface {
	pulumi.Input

	ToKibanaSpecPtrOutput() KibanaSpecPtrOutput
	ToKibanaSpecPtrOutputWithContext(context.Context) KibanaSpecPtrOutput
}

type kibanaSpecPtrType KibanaSpecArgs

func KibanaSpecPtr(v *KibanaSpecArgs) KibanaSpecPtrInput {
	return (*kibanaSpecPtrType)(v)
}

func (*kibanaSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpec)(nil)).Elem()
}

func (i *kibanaSpecPtrType) ToKibanaSpecPtrOutput() KibanaSpecPtrOutput {
	return i.ToKibanaSpecPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecPtrType) ToKibanaSpecPtrOutputWithContext(ctx context.Context) KibanaSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecPtrOutput)
}

// KibanaSpec holds the specification of a Kibana instance.
type KibanaSpecOutput struct{ *pulumi.OutputState }

func (KibanaSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpec)(nil)).Elem()
}

func (o KibanaSpecOutput) ToKibanaSpecOutput() KibanaSpecOutput {
	return o
}

func (o KibanaSpecOutput) ToKibanaSpecOutputWithContext(ctx context.Context) KibanaSpecOutput {
	return o
}

func (o KibanaSpecOutput) ToKibanaSpecPtrOutput() KibanaSpecPtrOutput {
	return o.ToKibanaSpecPtrOutputWithContext(context.Background())
}

func (o KibanaSpecOutput) ToKibanaSpecPtrOutputWithContext(ctx context.Context) KibanaSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpec) *KibanaSpec {
		return &v
	}).(KibanaSpecPtrOutput)
}

// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
func (o KibanaSpecOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v KibanaSpec) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// Count of Kibana instances to deploy.
func (o KibanaSpecOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpec) *int { return v.Count }).(pulumi.IntPtrOutput)
}

func (o KibanaSpecOutput) ElasticsearchRef() KibanaSpecElasticsearchRefPtrOutput {
	return o.ApplyT(func(v KibanaSpec) *KibanaSpecElasticsearchRef { return v.ElasticsearchRef }).(KibanaSpecElasticsearchRefPtrOutput)
}

func (o KibanaSpecOutput) Http() KibanaSpecHttpPtrOutput {
	return o.ApplyT(func(v KibanaSpec) *KibanaSpecHttp { return v.Http }).(KibanaSpecHttpPtrOutput)
}

// Image is the Kibana Docker image to deploy.
func (o KibanaSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
func (o KibanaSpecOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v KibanaSpec) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
func (o KibanaSpecOutput) SecureSettings() KibanaSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v KibanaSpec) []KibanaSpecSecureSettings { return v.SecureSettings }).(KibanaSpecSecureSettingsArrayOutput)
}

// Version of Kibana.
func (o KibanaSpecOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpec) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type KibanaSpecPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpec)(nil)).Elem()
}

func (o KibanaSpecPtrOutput) ToKibanaSpecPtrOutput() KibanaSpecPtrOutput {
	return o
}

func (o KibanaSpecPtrOutput) ToKibanaSpecPtrOutputWithContext(ctx context.Context) KibanaSpecPtrOutput {
	return o
}

func (o KibanaSpecPtrOutput) Elem() KibanaSpecOutput {
	return o.ApplyT(func(v *KibanaSpec) KibanaSpec {
		if v != nil {
			return *v
		}
		var ret KibanaSpec
		return ret
	}).(KibanaSpecOutput)
}

// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
func (o KibanaSpecPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *KibanaSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// Count of Kibana instances to deploy.
func (o KibanaSpecPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaSpec) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

func (o KibanaSpecPtrOutput) ElasticsearchRef() KibanaSpecElasticsearchRefPtrOutput {
	return o.ApplyT(func(v *KibanaSpec) *KibanaSpecElasticsearchRef {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRef
	}).(KibanaSpecElasticsearchRefPtrOutput)
}

func (o KibanaSpecPtrOutput) Http() KibanaSpecHttpPtrOutput {
	return o.ApplyT(func(v *KibanaSpec) *KibanaSpecHttp {
		if v == nil {
			return nil
		}
		return v.Http
	}).(KibanaSpecHttpPtrOutput)
}

// Image is the Kibana Docker image to deploy.
func (o KibanaSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
func (o KibanaSpecPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *KibanaSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
func (o KibanaSpecPtrOutput) SecureSettings() KibanaSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v *KibanaSpec) []KibanaSpecSecureSettings {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(KibanaSpecSecureSettingsArrayOutput)
}

// Version of Kibana.
func (o KibanaSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpec) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type KibanaSpecElasticsearchRef struct {
	// Name of the Kubernetes object.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
}

// KibanaSpecElasticsearchRefInput is an input type that accepts KibanaSpecElasticsearchRefArgs and KibanaSpecElasticsearchRefOutput values.
// You can construct a concrete instance of `KibanaSpecElasticsearchRefInput` via:
//
//	KibanaSpecElasticsearchRefArgs{...}
type KibanaSpecElasticsearchRefInput interface {
	pulumi.Input

	ToKibanaSpecElasticsearchRefOutput() KibanaSpecElasticsearchRefOutput
	ToKibanaSpecElasticsearchRefOutputWithContext(context.Context) KibanaSpecElasticsearchRefOutput
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type KibanaSpecElasticsearchRefArgs struct {
	// Name of the Kubernetes object.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (KibanaSpecElasticsearchRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecElasticsearchRef)(nil)).Elem()
}

func (i KibanaSpecElasticsearchRefArgs) ToKibanaSpecElasticsearchRefOutput() KibanaSpecElasticsearchRefOutput {
	return i.ToKibanaSpecElasticsearchRefOutputWithContext(context.Background())
}

func (i KibanaSpecElasticsearchRefArgs) ToKibanaSpecElasticsearchRefOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecElasticsearchRefOutput)
}

func (i KibanaSpecElasticsearchRefArgs) ToKibanaSpecElasticsearchRefPtrOutput() KibanaSpecElasticsearchRefPtrOutput {
	return i.ToKibanaSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (i KibanaSpecElasticsearchRefArgs) ToKibanaSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecElasticsearchRefOutput).ToKibanaSpecElasticsearchRefPtrOutputWithContext(ctx)
}

// KibanaSpecElasticsearchRefPtrInput is an input type that accepts KibanaSpecElasticsearchRefArgs, KibanaSpecElasticsearchRefPtr and KibanaSpecElasticsearchRefPtrOutput values.
// You can construct a concrete instance of `KibanaSpecElasticsearchRefPtrInput` via:
//
//	        KibanaSpecElasticsearchRefArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecElasticsearchRefPtrInput interface {
	pulumi.Input

	ToKibanaSpecElasticsearchRefPtrOutput() KibanaSpecElasticsearchRefPtrOutput
	ToKibanaSpecElasticsearchRefPtrOutputWithContext(context.Context) KibanaSpecElasticsearchRefPtrOutput
}

type kibanaSpecElasticsearchRefPtrType KibanaSpecElasticsearchRefArgs

func KibanaSpecElasticsearchRefPtr(v *KibanaSpecElasticsearchRefArgs) KibanaSpecElasticsearchRefPtrInput {
	return (*kibanaSpecElasticsearchRefPtrType)(v)
}

func (*kibanaSpecElasticsearchRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecElasticsearchRef)(nil)).Elem()
}

func (i *kibanaSpecElasticsearchRefPtrType) ToKibanaSpecElasticsearchRefPtrOutput() KibanaSpecElasticsearchRefPtrOutput {
	return i.ToKibanaSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecElasticsearchRefPtrType) ToKibanaSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecElasticsearchRefPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type KibanaSpecElasticsearchRefOutput struct{ *pulumi.OutputState }

func (KibanaSpecElasticsearchRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecElasticsearchRef)(nil)).Elem()
}

func (o KibanaSpecElasticsearchRefOutput) ToKibanaSpecElasticsearchRefOutput() KibanaSpecElasticsearchRefOutput {
	return o
}

func (o KibanaSpecElasticsearchRefOutput) ToKibanaSpecElasticsearchRefOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefOutput {
	return o
}

func (o KibanaSpecElasticsearchRefOutput) ToKibanaSpecElasticsearchRefPtrOutput() KibanaSpecElasticsearchRefPtrOutput {
	return o.ToKibanaSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (o KibanaSpecElasticsearchRefOutput) ToKibanaSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecElasticsearchRef) *KibanaSpecElasticsearchRef {
		return &v
	}).(KibanaSpecElasticsearchRefPtrOutput)
}

// Name of the Kubernetes object.
func (o KibanaSpecElasticsearchRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecElasticsearchRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o KibanaSpecElasticsearchRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecElasticsearchRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type KibanaSpecElasticsearchRefPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecElasticsearchRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecElasticsearchRef)(nil)).Elem()
}

func (o KibanaSpecElasticsearchRefPtrOutput) ToKibanaSpecElasticsearchRefPtrOutput() KibanaSpecElasticsearchRefPtrOutput {
	return o
}

func (o KibanaSpecElasticsearchRefPtrOutput) ToKibanaSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPtrOutput {
	return o
}

func (o KibanaSpecElasticsearchRefPtrOutput) Elem() KibanaSpecElasticsearchRefOutput {
	return o.ApplyT(func(v *KibanaSpecElasticsearchRef) KibanaSpecElasticsearchRef {
		if v != nil {
			return *v
		}
		var ret KibanaSpecElasticsearchRef
		return ret
	}).(KibanaSpecElasticsearchRefOutput)
}

// Name of the Kubernetes object.
func (o KibanaSpecElasticsearchRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o KibanaSpecElasticsearchRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type KibanaSpecElasticsearchRefPatch struct {
	// Name of the Kubernetes object.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
}

// KibanaSpecElasticsearchRefPatchInput is an input type that accepts KibanaSpecElasticsearchRefPatchArgs and KibanaSpecElasticsearchRefPatchOutput values.
// You can construct a concrete instance of `KibanaSpecElasticsearchRefPatchInput` via:
//
//	KibanaSpecElasticsearchRefPatchArgs{...}
type KibanaSpecElasticsearchRefPatchInput interface {
	pulumi.Input

	ToKibanaSpecElasticsearchRefPatchOutput() KibanaSpecElasticsearchRefPatchOutput
	ToKibanaSpecElasticsearchRefPatchOutputWithContext(context.Context) KibanaSpecElasticsearchRefPatchOutput
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type KibanaSpecElasticsearchRefPatchArgs struct {
	// Name of the Kubernetes object.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (KibanaSpecElasticsearchRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecElasticsearchRefPatch)(nil)).Elem()
}

func (i KibanaSpecElasticsearchRefPatchArgs) ToKibanaSpecElasticsearchRefPatchOutput() KibanaSpecElasticsearchRefPatchOutput {
	return i.ToKibanaSpecElasticsearchRefPatchOutputWithContext(context.Background())
}

func (i KibanaSpecElasticsearchRefPatchArgs) ToKibanaSpecElasticsearchRefPatchOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecElasticsearchRefPatchOutput)
}

func (i KibanaSpecElasticsearchRefPatchArgs) ToKibanaSpecElasticsearchRefPatchPtrOutput() KibanaSpecElasticsearchRefPatchPtrOutput {
	return i.ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecElasticsearchRefPatchArgs) ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecElasticsearchRefPatchOutput).ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(ctx)
}

// KibanaSpecElasticsearchRefPatchPtrInput is an input type that accepts KibanaSpecElasticsearchRefPatchArgs, KibanaSpecElasticsearchRefPatchPtr and KibanaSpecElasticsearchRefPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecElasticsearchRefPatchPtrInput` via:
//
//	        KibanaSpecElasticsearchRefPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecElasticsearchRefPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecElasticsearchRefPatchPtrOutput() KibanaSpecElasticsearchRefPatchPtrOutput
	ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(context.Context) KibanaSpecElasticsearchRefPatchPtrOutput
}

type kibanaSpecElasticsearchRefPatchPtrType KibanaSpecElasticsearchRefPatchArgs

func KibanaSpecElasticsearchRefPatchPtr(v *KibanaSpecElasticsearchRefPatchArgs) KibanaSpecElasticsearchRefPatchPtrInput {
	return (*kibanaSpecElasticsearchRefPatchPtrType)(v)
}

func (*kibanaSpecElasticsearchRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecElasticsearchRefPatch)(nil)).Elem()
}

func (i *kibanaSpecElasticsearchRefPatchPtrType) ToKibanaSpecElasticsearchRefPatchPtrOutput() KibanaSpecElasticsearchRefPatchPtrOutput {
	return i.ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecElasticsearchRefPatchPtrType) ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecElasticsearchRefPatchPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type KibanaSpecElasticsearchRefPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecElasticsearchRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecElasticsearchRefPatch)(nil)).Elem()
}

func (o KibanaSpecElasticsearchRefPatchOutput) ToKibanaSpecElasticsearchRefPatchOutput() KibanaSpecElasticsearchRefPatchOutput {
	return o
}

func (o KibanaSpecElasticsearchRefPatchOutput) ToKibanaSpecElasticsearchRefPatchOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPatchOutput {
	return o
}

func (o KibanaSpecElasticsearchRefPatchOutput) ToKibanaSpecElasticsearchRefPatchPtrOutput() KibanaSpecElasticsearchRefPatchPtrOutput {
	return o.ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecElasticsearchRefPatchOutput) ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecElasticsearchRefPatch) *KibanaSpecElasticsearchRefPatch {
		return &v
	}).(KibanaSpecElasticsearchRefPatchPtrOutput)
}

// Name of the Kubernetes object.
func (o KibanaSpecElasticsearchRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecElasticsearchRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o KibanaSpecElasticsearchRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecElasticsearchRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type KibanaSpecElasticsearchRefPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecElasticsearchRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecElasticsearchRefPatch)(nil)).Elem()
}

func (o KibanaSpecElasticsearchRefPatchPtrOutput) ToKibanaSpecElasticsearchRefPatchPtrOutput() KibanaSpecElasticsearchRefPatchPtrOutput {
	return o
}

func (o KibanaSpecElasticsearchRefPatchPtrOutput) ToKibanaSpecElasticsearchRefPatchPtrOutputWithContext(ctx context.Context) KibanaSpecElasticsearchRefPatchPtrOutput {
	return o
}

func (o KibanaSpecElasticsearchRefPatchPtrOutput) Elem() KibanaSpecElasticsearchRefPatchOutput {
	return o.ApplyT(func(v *KibanaSpecElasticsearchRefPatch) KibanaSpecElasticsearchRefPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecElasticsearchRefPatch
		return ret
	}).(KibanaSpecElasticsearchRefPatchOutput)
}

// Name of the Kubernetes object.
func (o KibanaSpecElasticsearchRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecElasticsearchRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o KibanaSpecElasticsearchRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecElasticsearchRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// HTTP holds the HTTP layer configuration for Kibana.
type KibanaSpecHttp struct {
	Service *KibanaSpecHttpService `pulumi:"service"`
	Tls     *KibanaSpecHttpTls     `pulumi:"tls"`
}

// KibanaSpecHttpInput is an input type that accepts KibanaSpecHttpArgs and KibanaSpecHttpOutput values.
// You can construct a concrete instance of `KibanaSpecHttpInput` via:
//
//	KibanaSpecHttpArgs{...}
type KibanaSpecHttpInput interface {
	pulumi.Input

	ToKibanaSpecHttpOutput() KibanaSpecHttpOutput
	ToKibanaSpecHttpOutputWithContext(context.Context) KibanaSpecHttpOutput
}

// HTTP holds the HTTP layer configuration for Kibana.
type KibanaSpecHttpArgs struct {
	Service KibanaSpecHttpServicePtrInput `pulumi:"service"`
	Tls     KibanaSpecHttpTlsPtrInput     `pulumi:"tls"`
}

func (KibanaSpecHttpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttp)(nil)).Elem()
}

func (i KibanaSpecHttpArgs) ToKibanaSpecHttpOutput() KibanaSpecHttpOutput {
	return i.ToKibanaSpecHttpOutputWithContext(context.Background())
}

func (i KibanaSpecHttpArgs) ToKibanaSpecHttpOutputWithContext(ctx context.Context) KibanaSpecHttpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpOutput)
}

func (i KibanaSpecHttpArgs) ToKibanaSpecHttpPtrOutput() KibanaSpecHttpPtrOutput {
	return i.ToKibanaSpecHttpPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpArgs) ToKibanaSpecHttpPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpOutput).ToKibanaSpecHttpPtrOutputWithContext(ctx)
}

// KibanaSpecHttpPtrInput is an input type that accepts KibanaSpecHttpArgs, KibanaSpecHttpPtr and KibanaSpecHttpPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpPtrInput` via:
//
//	        KibanaSpecHttpArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpPtrOutput() KibanaSpecHttpPtrOutput
	ToKibanaSpecHttpPtrOutputWithContext(context.Context) KibanaSpecHttpPtrOutput
}

type kibanaSpecHttpPtrType KibanaSpecHttpArgs

func KibanaSpecHttpPtr(v *KibanaSpecHttpArgs) KibanaSpecHttpPtrInput {
	return (*kibanaSpecHttpPtrType)(v)
}

func (*kibanaSpecHttpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttp)(nil)).Elem()
}

func (i *kibanaSpecHttpPtrType) ToKibanaSpecHttpPtrOutput() KibanaSpecHttpPtrOutput {
	return i.ToKibanaSpecHttpPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpPtrType) ToKibanaSpecHttpPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpPtrOutput)
}

// HTTP holds the HTTP layer configuration for Kibana.
type KibanaSpecHttpOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttp)(nil)).Elem()
}

func (o KibanaSpecHttpOutput) ToKibanaSpecHttpOutput() KibanaSpecHttpOutput {
	return o
}

func (o KibanaSpecHttpOutput) ToKibanaSpecHttpOutputWithContext(ctx context.Context) KibanaSpecHttpOutput {
	return o
}

func (o KibanaSpecHttpOutput) ToKibanaSpecHttpPtrOutput() KibanaSpecHttpPtrOutput {
	return o.ToKibanaSpecHttpPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpOutput) ToKibanaSpecHttpPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttp) *KibanaSpecHttp {
		return &v
	}).(KibanaSpecHttpPtrOutput)
}

func (o KibanaSpecHttpOutput) Service() KibanaSpecHttpServicePtrOutput {
	return o.ApplyT(func(v KibanaSpecHttp) *KibanaSpecHttpService { return v.Service }).(KibanaSpecHttpServicePtrOutput)
}

func (o KibanaSpecHttpOutput) Tls() KibanaSpecHttpTlsPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttp) *KibanaSpecHttpTls { return v.Tls }).(KibanaSpecHttpTlsPtrOutput)
}

type KibanaSpecHttpPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttp)(nil)).Elem()
}

func (o KibanaSpecHttpPtrOutput) ToKibanaSpecHttpPtrOutput() KibanaSpecHttpPtrOutput {
	return o
}

func (o KibanaSpecHttpPtrOutput) ToKibanaSpecHttpPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPtrOutput {
	return o
}

func (o KibanaSpecHttpPtrOutput) Elem() KibanaSpecHttpOutput {
	return o.ApplyT(func(v *KibanaSpecHttp) KibanaSpecHttp {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttp
		return ret
	}).(KibanaSpecHttpOutput)
}

func (o KibanaSpecHttpPtrOutput) Service() KibanaSpecHttpServicePtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttp) *KibanaSpecHttpService {
		if v == nil {
			return nil
		}
		return v.Service
	}).(KibanaSpecHttpServicePtrOutput)
}

func (o KibanaSpecHttpPtrOutput) Tls() KibanaSpecHttpTlsPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttp) *KibanaSpecHttpTls {
		if v == nil {
			return nil
		}
		return v.Tls
	}).(KibanaSpecHttpTlsPtrOutput)
}

// HTTP holds the HTTP layer configuration for Kibana.
type KibanaSpecHttpPatch struct {
	Service *KibanaSpecHttpServicePatch `pulumi:"service"`
	Tls     *KibanaSpecHttpTlsPatch     `pulumi:"tls"`
}

// KibanaSpecHttpPatchInput is an input type that accepts KibanaSpecHttpPatchArgs and KibanaSpecHttpPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpPatchInput` via:
//
//	KibanaSpecHttpPatchArgs{...}
type KibanaSpecHttpPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpPatchOutput() KibanaSpecHttpPatchOutput
	ToKibanaSpecHttpPatchOutputWithContext(context.Context) KibanaSpecHttpPatchOutput
}

// HTTP holds the HTTP layer configuration for Kibana.
type KibanaSpecHttpPatchArgs struct {
	Service KibanaSpecHttpServicePatchPtrInput `pulumi:"service"`
	Tls     KibanaSpecHttpTlsPatchPtrInput     `pulumi:"tls"`
}

func (KibanaSpecHttpPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpPatch)(nil)).Elem()
}

func (i KibanaSpecHttpPatchArgs) ToKibanaSpecHttpPatchOutput() KibanaSpecHttpPatchOutput {
	return i.ToKibanaSpecHttpPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpPatchArgs) ToKibanaSpecHttpPatchOutputWithContext(ctx context.Context) KibanaSpecHttpPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpPatchOutput)
}

func (i KibanaSpecHttpPatchArgs) ToKibanaSpecHttpPatchPtrOutput() KibanaSpecHttpPatchPtrOutput {
	return i.ToKibanaSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpPatchArgs) ToKibanaSpecHttpPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpPatchOutput).ToKibanaSpecHttpPatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpPatchPtrInput is an input type that accepts KibanaSpecHttpPatchArgs, KibanaSpecHttpPatchPtr and KibanaSpecHttpPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpPatchPtrInput` via:
//
//	        KibanaSpecHttpPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpPatchPtrOutput() KibanaSpecHttpPatchPtrOutput
	ToKibanaSpecHttpPatchPtrOutputWithContext(context.Context) KibanaSpecHttpPatchPtrOutput
}

type kibanaSpecHttpPatchPtrType KibanaSpecHttpPatchArgs

func KibanaSpecHttpPatchPtr(v *KibanaSpecHttpPatchArgs) KibanaSpecHttpPatchPtrInput {
	return (*kibanaSpecHttpPatchPtrType)(v)
}

func (*kibanaSpecHttpPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpPatch)(nil)).Elem()
}

func (i *kibanaSpecHttpPatchPtrType) ToKibanaSpecHttpPatchPtrOutput() KibanaSpecHttpPatchPtrOutput {
	return i.ToKibanaSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpPatchPtrType) ToKibanaSpecHttpPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpPatchPtrOutput)
}

// HTTP holds the HTTP layer configuration for Kibana.
type KibanaSpecHttpPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpPatch)(nil)).Elem()
}

func (o KibanaSpecHttpPatchOutput) ToKibanaSpecHttpPatchOutput() KibanaSpecHttpPatchOutput {
	return o
}

func (o KibanaSpecHttpPatchOutput) ToKibanaSpecHttpPatchOutputWithContext(ctx context.Context) KibanaSpecHttpPatchOutput {
	return o
}

func (o KibanaSpecHttpPatchOutput) ToKibanaSpecHttpPatchPtrOutput() KibanaSpecHttpPatchPtrOutput {
	return o.ToKibanaSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpPatchOutput) ToKibanaSpecHttpPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpPatch) *KibanaSpecHttpPatch {
		return &v
	}).(KibanaSpecHttpPatchPtrOutput)
}

func (o KibanaSpecHttpPatchOutput) Service() KibanaSpecHttpServicePatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpPatch) *KibanaSpecHttpServicePatch { return v.Service }).(KibanaSpecHttpServicePatchPtrOutput)
}

func (o KibanaSpecHttpPatchOutput) Tls() KibanaSpecHttpTlsPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpPatch) *KibanaSpecHttpTlsPatch { return v.Tls }).(KibanaSpecHttpTlsPatchPtrOutput)
}

type KibanaSpecHttpPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpPatch)(nil)).Elem()
}

func (o KibanaSpecHttpPatchPtrOutput) ToKibanaSpecHttpPatchPtrOutput() KibanaSpecHttpPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpPatchPtrOutput) ToKibanaSpecHttpPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpPatchPtrOutput) Elem() KibanaSpecHttpPatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpPatch) KibanaSpecHttpPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpPatch
		return ret
	}).(KibanaSpecHttpPatchOutput)
}

func (o KibanaSpecHttpPatchPtrOutput) Service() KibanaSpecHttpServicePatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpPatch) *KibanaSpecHttpServicePatch {
		if v == nil {
			return nil
		}
		return v.Service
	}).(KibanaSpecHttpServicePatchPtrOutput)
}

func (o KibanaSpecHttpPatchPtrOutput) Tls() KibanaSpecHttpTlsPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpPatch) *KibanaSpecHttpTlsPatch {
		if v == nil {
			return nil
		}
		return v.Tls
	}).(KibanaSpecHttpTlsPatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type KibanaSpecHttpService struct {
	Metadata *KibanaSpecHttpServiceMetadata `pulumi:"metadata"`
	Spec     *KibanaSpecHttpServiceSpec     `pulumi:"spec"`
}

// KibanaSpecHttpServiceInput is an input type that accepts KibanaSpecHttpServiceArgs and KibanaSpecHttpServiceOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceInput` via:
//
//	KibanaSpecHttpServiceArgs{...}
type KibanaSpecHttpServiceInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceOutput() KibanaSpecHttpServiceOutput
	ToKibanaSpecHttpServiceOutputWithContext(context.Context) KibanaSpecHttpServiceOutput
}

// Service defines the template for the associated Kubernetes Service object.
type KibanaSpecHttpServiceArgs struct {
	Metadata KibanaSpecHttpServiceMetadataPtrInput `pulumi:"metadata"`
	Spec     KibanaSpecHttpServiceSpecPtrInput     `pulumi:"spec"`
}

func (KibanaSpecHttpServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpService)(nil)).Elem()
}

func (i KibanaSpecHttpServiceArgs) ToKibanaSpecHttpServiceOutput() KibanaSpecHttpServiceOutput {
	return i.ToKibanaSpecHttpServiceOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceArgs) ToKibanaSpecHttpServiceOutputWithContext(ctx context.Context) KibanaSpecHttpServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceOutput)
}

func (i KibanaSpecHttpServiceArgs) ToKibanaSpecHttpServicePtrOutput() KibanaSpecHttpServicePtrOutput {
	return i.ToKibanaSpecHttpServicePtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceArgs) ToKibanaSpecHttpServicePtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceOutput).ToKibanaSpecHttpServicePtrOutputWithContext(ctx)
}

// KibanaSpecHttpServicePtrInput is an input type that accepts KibanaSpecHttpServiceArgs, KibanaSpecHttpServicePtr and KibanaSpecHttpServicePtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServicePtrInput` via:
//
//	        KibanaSpecHttpServiceArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServicePtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServicePtrOutput() KibanaSpecHttpServicePtrOutput
	ToKibanaSpecHttpServicePtrOutputWithContext(context.Context) KibanaSpecHttpServicePtrOutput
}

type kibanaSpecHttpServicePtrType KibanaSpecHttpServiceArgs

func KibanaSpecHttpServicePtr(v *KibanaSpecHttpServiceArgs) KibanaSpecHttpServicePtrInput {
	return (*kibanaSpecHttpServicePtrType)(v)
}

func (*kibanaSpecHttpServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpService)(nil)).Elem()
}

func (i *kibanaSpecHttpServicePtrType) ToKibanaSpecHttpServicePtrOutput() KibanaSpecHttpServicePtrOutput {
	return i.ToKibanaSpecHttpServicePtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServicePtrType) ToKibanaSpecHttpServicePtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServicePtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type KibanaSpecHttpServiceOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpService)(nil)).Elem()
}

func (o KibanaSpecHttpServiceOutput) ToKibanaSpecHttpServiceOutput() KibanaSpecHttpServiceOutput {
	return o
}

func (o KibanaSpecHttpServiceOutput) ToKibanaSpecHttpServiceOutputWithContext(ctx context.Context) KibanaSpecHttpServiceOutput {
	return o
}

func (o KibanaSpecHttpServiceOutput) ToKibanaSpecHttpServicePtrOutput() KibanaSpecHttpServicePtrOutput {
	return o.ToKibanaSpecHttpServicePtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceOutput) ToKibanaSpecHttpServicePtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpService) *KibanaSpecHttpService {
		return &v
	}).(KibanaSpecHttpServicePtrOutput)
}

func (o KibanaSpecHttpServiceOutput) Metadata() KibanaSpecHttpServiceMetadataPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpService) *KibanaSpecHttpServiceMetadata { return v.Metadata }).(KibanaSpecHttpServiceMetadataPtrOutput)
}

func (o KibanaSpecHttpServiceOutput) Spec() KibanaSpecHttpServiceSpecPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpService) *KibanaSpecHttpServiceSpec { return v.Spec }).(KibanaSpecHttpServiceSpecPtrOutput)
}

type KibanaSpecHttpServicePtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpService)(nil)).Elem()
}

func (o KibanaSpecHttpServicePtrOutput) ToKibanaSpecHttpServicePtrOutput() KibanaSpecHttpServicePtrOutput {
	return o
}

func (o KibanaSpecHttpServicePtrOutput) ToKibanaSpecHttpServicePtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePtrOutput {
	return o
}

func (o KibanaSpecHttpServicePtrOutput) Elem() KibanaSpecHttpServiceOutput {
	return o.ApplyT(func(v *KibanaSpecHttpService) KibanaSpecHttpService {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpService
		return ret
	}).(KibanaSpecHttpServiceOutput)
}

func (o KibanaSpecHttpServicePtrOutput) Metadata() KibanaSpecHttpServiceMetadataPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpService) *KibanaSpecHttpServiceMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(KibanaSpecHttpServiceMetadataPtrOutput)
}

func (o KibanaSpecHttpServicePtrOutput) Spec() KibanaSpecHttpServiceSpecPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpService) *KibanaSpecHttpServiceSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(KibanaSpecHttpServiceSpecPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type KibanaSpecHttpServiceMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// KibanaSpecHttpServiceMetadataInput is an input type that accepts KibanaSpecHttpServiceMetadataArgs and KibanaSpecHttpServiceMetadataOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceMetadataInput` via:
//
//	KibanaSpecHttpServiceMetadataArgs{...}
type KibanaSpecHttpServiceMetadataInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceMetadataOutput() KibanaSpecHttpServiceMetadataOutput
	ToKibanaSpecHttpServiceMetadataOutputWithContext(context.Context) KibanaSpecHttpServiceMetadataOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type KibanaSpecHttpServiceMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (KibanaSpecHttpServiceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceMetadata)(nil)).Elem()
}

func (i KibanaSpecHttpServiceMetadataArgs) ToKibanaSpecHttpServiceMetadataOutput() KibanaSpecHttpServiceMetadataOutput {
	return i.ToKibanaSpecHttpServiceMetadataOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceMetadataArgs) ToKibanaSpecHttpServiceMetadataOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceMetadataOutput)
}

func (i KibanaSpecHttpServiceMetadataArgs) ToKibanaSpecHttpServiceMetadataPtrOutput() KibanaSpecHttpServiceMetadataPtrOutput {
	return i.ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceMetadataArgs) ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceMetadataOutput).ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceMetadataPtrInput is an input type that accepts KibanaSpecHttpServiceMetadataArgs, KibanaSpecHttpServiceMetadataPtr and KibanaSpecHttpServiceMetadataPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceMetadataPtrInput` via:
//
//	        KibanaSpecHttpServiceMetadataArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceMetadataPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceMetadataPtrOutput() KibanaSpecHttpServiceMetadataPtrOutput
	ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(context.Context) KibanaSpecHttpServiceMetadataPtrOutput
}

type kibanaSpecHttpServiceMetadataPtrType KibanaSpecHttpServiceMetadataArgs

func KibanaSpecHttpServiceMetadataPtr(v *KibanaSpecHttpServiceMetadataArgs) KibanaSpecHttpServiceMetadataPtrInput {
	return (*kibanaSpecHttpServiceMetadataPtrType)(v)
}

func (*kibanaSpecHttpServiceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceMetadata)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceMetadataPtrType) ToKibanaSpecHttpServiceMetadataPtrOutput() KibanaSpecHttpServiceMetadataPtrOutput {
	return i.ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceMetadataPtrType) ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceMetadataPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type KibanaSpecHttpServiceMetadataOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceMetadata)(nil)).Elem()
}

func (o KibanaSpecHttpServiceMetadataOutput) ToKibanaSpecHttpServiceMetadataOutput() KibanaSpecHttpServiceMetadataOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataOutput) ToKibanaSpecHttpServiceMetadataOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataOutput) ToKibanaSpecHttpServiceMetadataPtrOutput() KibanaSpecHttpServiceMetadataPtrOutput {
	return o.ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceMetadataOutput) ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceMetadata) *KibanaSpecHttpServiceMetadata {
		return &v
	}).(KibanaSpecHttpServiceMetadataPtrOutput)
}

func (o KibanaSpecHttpServiceMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o KibanaSpecHttpServiceMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpServiceMetadataPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceMetadata)(nil)).Elem()
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) ToKibanaSpecHttpServiceMetadataPtrOutput() KibanaSpecHttpServiceMetadataPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) ToKibanaSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) Elem() KibanaSpecHttpServiceMetadataOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadata) KibanaSpecHttpServiceMetadata {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceMetadata
		return ret
	}).(KibanaSpecHttpServiceMetadataOutput)
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type KibanaSpecHttpServiceMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// KibanaSpecHttpServiceMetadataPatchInput is an input type that accepts KibanaSpecHttpServiceMetadataPatchArgs and KibanaSpecHttpServiceMetadataPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceMetadataPatchInput` via:
//
//	KibanaSpecHttpServiceMetadataPatchArgs{...}
type KibanaSpecHttpServiceMetadataPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceMetadataPatchOutput() KibanaSpecHttpServiceMetadataPatchOutput
	ToKibanaSpecHttpServiceMetadataPatchOutputWithContext(context.Context) KibanaSpecHttpServiceMetadataPatchOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type KibanaSpecHttpServiceMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (KibanaSpecHttpServiceMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (i KibanaSpecHttpServiceMetadataPatchArgs) ToKibanaSpecHttpServiceMetadataPatchOutput() KibanaSpecHttpServiceMetadataPatchOutput {
	return i.ToKibanaSpecHttpServiceMetadataPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceMetadataPatchArgs) ToKibanaSpecHttpServiceMetadataPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceMetadataPatchOutput)
}

func (i KibanaSpecHttpServiceMetadataPatchArgs) ToKibanaSpecHttpServiceMetadataPatchPtrOutput() KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceMetadataPatchArgs) ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceMetadataPatchOutput).ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceMetadataPatchPtrInput is an input type that accepts KibanaSpecHttpServiceMetadataPatchArgs, KibanaSpecHttpServiceMetadataPatchPtr and KibanaSpecHttpServiceMetadataPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceMetadataPatchPtrInput` via:
//
//	        KibanaSpecHttpServiceMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceMetadataPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceMetadataPatchPtrOutput() KibanaSpecHttpServiceMetadataPatchPtrOutput
	ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Context) KibanaSpecHttpServiceMetadataPatchPtrOutput
}

type kibanaSpecHttpServiceMetadataPatchPtrType KibanaSpecHttpServiceMetadataPatchArgs

func KibanaSpecHttpServiceMetadataPatchPtr(v *KibanaSpecHttpServiceMetadataPatchArgs) KibanaSpecHttpServiceMetadataPatchPtrInput {
	return (*kibanaSpecHttpServiceMetadataPatchPtrType)(v)
}

func (*kibanaSpecHttpServiceMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceMetadataPatchPtrType) ToKibanaSpecHttpServiceMetadataPatchPtrOutput() KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceMetadataPatchPtrType) ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceMetadataPatchPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type KibanaSpecHttpServiceMetadataPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) ToKibanaSpecHttpServiceMetadataPatchOutput() KibanaSpecHttpServiceMetadataPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) ToKibanaSpecHttpServiceMetadataPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) ToKibanaSpecHttpServiceMetadataPatchPtrOutput() KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return o.ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceMetadataPatch) *KibanaSpecHttpServiceMetadataPatch {
		return &v
	}).(KibanaSpecHttpServiceMetadataPatchPtrOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadataPatch) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpServiceMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) ToKibanaSpecHttpServiceMetadataPatchPtrOutput() KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) ToKibanaSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) Elem() KibanaSpecHttpServiceMetadataPatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadataPatch) KibanaSpecHttpServiceMetadataPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceMetadataPatch
		return ret
	}).(KibanaSpecHttpServiceMetadataPatchOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type KibanaSpecHttpServicePatch struct {
	Metadata *KibanaSpecHttpServiceMetadataPatch `pulumi:"metadata"`
	Spec     *KibanaSpecHttpServiceSpecPatch     `pulumi:"spec"`
}

// KibanaSpecHttpServicePatchInput is an input type that accepts KibanaSpecHttpServicePatchArgs and KibanaSpecHttpServicePatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServicePatchInput` via:
//
//	KibanaSpecHttpServicePatchArgs{...}
type KibanaSpecHttpServicePatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpServicePatchOutput() KibanaSpecHttpServicePatchOutput
	ToKibanaSpecHttpServicePatchOutputWithContext(context.Context) KibanaSpecHttpServicePatchOutput
}

// Service defines the template for the associated Kubernetes Service object.
type KibanaSpecHttpServicePatchArgs struct {
	Metadata KibanaSpecHttpServiceMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     KibanaSpecHttpServiceSpecPatchPtrInput     `pulumi:"spec"`
}

func (KibanaSpecHttpServicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServicePatch)(nil)).Elem()
}

func (i KibanaSpecHttpServicePatchArgs) ToKibanaSpecHttpServicePatchOutput() KibanaSpecHttpServicePatchOutput {
	return i.ToKibanaSpecHttpServicePatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServicePatchArgs) ToKibanaSpecHttpServicePatchOutputWithContext(ctx context.Context) KibanaSpecHttpServicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServicePatchOutput)
}

func (i KibanaSpecHttpServicePatchArgs) ToKibanaSpecHttpServicePatchPtrOutput() KibanaSpecHttpServicePatchPtrOutput {
	return i.ToKibanaSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServicePatchArgs) ToKibanaSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServicePatchOutput).ToKibanaSpecHttpServicePatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServicePatchPtrInput is an input type that accepts KibanaSpecHttpServicePatchArgs, KibanaSpecHttpServicePatchPtr and KibanaSpecHttpServicePatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServicePatchPtrInput` via:
//
//	        KibanaSpecHttpServicePatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServicePatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServicePatchPtrOutput() KibanaSpecHttpServicePatchPtrOutput
	ToKibanaSpecHttpServicePatchPtrOutputWithContext(context.Context) KibanaSpecHttpServicePatchPtrOutput
}

type kibanaSpecHttpServicePatchPtrType KibanaSpecHttpServicePatchArgs

func KibanaSpecHttpServicePatchPtr(v *KibanaSpecHttpServicePatchArgs) KibanaSpecHttpServicePatchPtrInput {
	return (*kibanaSpecHttpServicePatchPtrType)(v)
}

func (*kibanaSpecHttpServicePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServicePatch)(nil)).Elem()
}

func (i *kibanaSpecHttpServicePatchPtrType) ToKibanaSpecHttpServicePatchPtrOutput() KibanaSpecHttpServicePatchPtrOutput {
	return i.ToKibanaSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServicePatchPtrType) ToKibanaSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServicePatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type KibanaSpecHttpServicePatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServicePatch)(nil)).Elem()
}

func (o KibanaSpecHttpServicePatchOutput) ToKibanaSpecHttpServicePatchOutput() KibanaSpecHttpServicePatchOutput {
	return o
}

func (o KibanaSpecHttpServicePatchOutput) ToKibanaSpecHttpServicePatchOutputWithContext(ctx context.Context) KibanaSpecHttpServicePatchOutput {
	return o
}

func (o KibanaSpecHttpServicePatchOutput) ToKibanaSpecHttpServicePatchPtrOutput() KibanaSpecHttpServicePatchPtrOutput {
	return o.ToKibanaSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServicePatchOutput) ToKibanaSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServicePatch) *KibanaSpecHttpServicePatch {
		return &v
	}).(KibanaSpecHttpServicePatchPtrOutput)
}

func (o KibanaSpecHttpServicePatchOutput) Metadata() KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServicePatch) *KibanaSpecHttpServiceMetadataPatch { return v.Metadata }).(KibanaSpecHttpServiceMetadataPatchPtrOutput)
}

func (o KibanaSpecHttpServicePatchOutput) Spec() KibanaSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServicePatch) *KibanaSpecHttpServiceSpecPatch { return v.Spec }).(KibanaSpecHttpServiceSpecPatchPtrOutput)
}

type KibanaSpecHttpServicePatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServicePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServicePatch)(nil)).Elem()
}

func (o KibanaSpecHttpServicePatchPtrOutput) ToKibanaSpecHttpServicePatchPtrOutput() KibanaSpecHttpServicePatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServicePatchPtrOutput) ToKibanaSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServicePatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServicePatchPtrOutput) Elem() KibanaSpecHttpServicePatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServicePatch) KibanaSpecHttpServicePatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServicePatch
		return ret
	}).(KibanaSpecHttpServicePatchOutput)
}

func (o KibanaSpecHttpServicePatchPtrOutput) Metadata() KibanaSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServicePatch) *KibanaSpecHttpServiceMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(KibanaSpecHttpServiceMetadataPatchPtrOutput)
}

func (o KibanaSpecHttpServicePatchPtrOutput) Spec() KibanaSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServicePatch) *KibanaSpecHttpServiceSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(KibanaSpecHttpServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type KibanaSpecHttpServiceSpec struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []KibanaSpecHttpServiceSpecPorts `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                         `pulumi:"sessionAffinity"`
	SessionAffinityConfig *KibanaSpecHttpServiceSpecSessionAffinityConfig `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// KibanaSpecHttpServiceSpecInput is an input type that accepts KibanaSpecHttpServiceSpecArgs and KibanaSpecHttpServiceSpecOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecInput` via:
//
//	KibanaSpecHttpServiceSpecArgs{...}
type KibanaSpecHttpServiceSpecInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecOutput() KibanaSpecHttpServiceSpecOutput
	ToKibanaSpecHttpServiceSpecOutputWithContext(context.Context) KibanaSpecHttpServiceSpecOutput
}

// Spec is the specification of the service.
type KibanaSpecHttpServiceSpecArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports KibanaSpecHttpServiceSpecPortsArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                  `pulumi:"sessionAffinity"`
	SessionAffinityConfig KibanaSpecHttpServiceSpecSessionAffinityConfigPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (KibanaSpecHttpServiceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpec)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecArgs) ToKibanaSpecHttpServiceSpecOutput() KibanaSpecHttpServiceSpecOutput {
	return i.ToKibanaSpecHttpServiceSpecOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecArgs) ToKibanaSpecHttpServiceSpecOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecOutput)
}

func (i KibanaSpecHttpServiceSpecArgs) ToKibanaSpecHttpServiceSpecPtrOutput() KibanaSpecHttpServiceSpecPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecArgs) ToKibanaSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecOutput).ToKibanaSpecHttpServiceSpecPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceSpecPtrInput is an input type that accepts KibanaSpecHttpServiceSpecArgs, KibanaSpecHttpServiceSpecPtr and KibanaSpecHttpServiceSpecPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPtrInput` via:
//
//	        KibanaSpecHttpServiceSpecArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceSpecPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPtrOutput() KibanaSpecHttpServiceSpecPtrOutput
	ToKibanaSpecHttpServiceSpecPtrOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPtrOutput
}

type kibanaSpecHttpServiceSpecPtrType KibanaSpecHttpServiceSpecArgs

func KibanaSpecHttpServiceSpecPtr(v *KibanaSpecHttpServiceSpecArgs) KibanaSpecHttpServiceSpecPtrInput {
	return (*kibanaSpecHttpServiceSpecPtrType)(v)
}

func (*kibanaSpecHttpServiceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpec)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceSpecPtrType) ToKibanaSpecHttpServiceSpecPtrOutput() KibanaSpecHttpServiceSpecPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceSpecPtrType) ToKibanaSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPtrOutput)
}

// Spec is the specification of the service.
type KibanaSpecHttpServiceSpecOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpec)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecOutput) ToKibanaSpecHttpServiceSpecOutput() KibanaSpecHttpServiceSpecOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecOutput) ToKibanaSpecHttpServiceSpecOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecOutput) ToKibanaSpecHttpServiceSpecPtrOutput() KibanaSpecHttpServiceSpecPtrOutput {
	return o.ToKibanaSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceSpecOutput) ToKibanaSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceSpec) *KibanaSpecHttpServiceSpec {
		return &v
	}).(KibanaSpecHttpServiceSpecPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o KibanaSpecHttpServiceSpecOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o KibanaSpecHttpServiceSpecOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o KibanaSpecHttpServiceSpecOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o KibanaSpecHttpServiceSpecOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o KibanaSpecHttpServiceSpecOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o KibanaSpecHttpServiceSpecOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o KibanaSpecHttpServiceSpecOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o KibanaSpecHttpServiceSpecOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o KibanaSpecHttpServiceSpecOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o KibanaSpecHttpServiceSpecOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o KibanaSpecHttpServiceSpecOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecOutput) Ports() KibanaSpecHttpServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) []KibanaSpecHttpServiceSpecPorts { return v.Ports }).(KibanaSpecHttpServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o KibanaSpecHttpServiceSpecOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o KibanaSpecHttpServiceSpecOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceSpecOutput) SessionAffinityConfig() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *KibanaSpecHttpServiceSpecSessionAffinityConfig {
		return v.SessionAffinityConfig
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o KibanaSpecHttpServiceSpecOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o KibanaSpecHttpServiceSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpServiceSpecPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpec)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPtrOutput) ToKibanaSpecHttpServiceSpecPtrOutput() KibanaSpecHttpServiceSpecPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPtrOutput) ToKibanaSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPtrOutput) Elem() KibanaSpecHttpServiceSpecOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) KibanaSpecHttpServiceSpec {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceSpec
		return ret
	}).(KibanaSpecHttpServiceSpecOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o KibanaSpecHttpServiceSpecPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o KibanaSpecHttpServiceSpecPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o KibanaSpecHttpServiceSpecPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o KibanaSpecHttpServiceSpecPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o KibanaSpecHttpServiceSpecPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o KibanaSpecHttpServiceSpecPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o KibanaSpecHttpServiceSpecPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o KibanaSpecHttpServiceSpecPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o KibanaSpecHttpServiceSpecPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o KibanaSpecHttpServiceSpecPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o KibanaSpecHttpServiceSpecPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPtrOutput) Ports() KibanaSpecHttpServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) []KibanaSpecHttpServiceSpecPorts {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(KibanaSpecHttpServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o KibanaSpecHttpServiceSpecPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o KibanaSpecHttpServiceSpecPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceSpecPtrOutput) SessionAffinityConfig() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *KibanaSpecHttpServiceSpecSessionAffinityConfig {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o KibanaSpecHttpServiceSpecPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o KibanaSpecHttpServiceSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Spec is the specification of the service.
type KibanaSpecHttpServiceSpecPatch struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []KibanaSpecHttpServiceSpecPortsPatch `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                              `pulumi:"sessionAffinity"`
	SessionAffinityConfig *KibanaSpecHttpServiceSpecSessionAffinityConfigPatch `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// KibanaSpecHttpServiceSpecPatchInput is an input type that accepts KibanaSpecHttpServiceSpecPatchArgs and KibanaSpecHttpServiceSpecPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPatchInput` via:
//
//	KibanaSpecHttpServiceSpecPatchArgs{...}
type KibanaSpecHttpServiceSpecPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPatchOutput() KibanaSpecHttpServiceSpecPatchOutput
	ToKibanaSpecHttpServiceSpecPatchOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPatchOutput
}

// Spec is the specification of the service.
type KibanaSpecHttpServiceSpecPatchArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports KibanaSpecHttpServiceSpecPortsPatchArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                       `pulumi:"sessionAffinity"`
	SessionAffinityConfig KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (KibanaSpecHttpServiceSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecPatchArgs) ToKibanaSpecHttpServiceSpecPatchOutput() KibanaSpecHttpServiceSpecPatchOutput {
	return i.ToKibanaSpecHttpServiceSpecPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecPatchArgs) ToKibanaSpecHttpServiceSpecPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPatchOutput)
}

func (i KibanaSpecHttpServiceSpecPatchArgs) ToKibanaSpecHttpServiceSpecPatchPtrOutput() KibanaSpecHttpServiceSpecPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecPatchArgs) ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPatchOutput).ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceSpecPatchPtrInput is an input type that accepts KibanaSpecHttpServiceSpecPatchArgs, KibanaSpecHttpServiceSpecPatchPtr and KibanaSpecHttpServiceSpecPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPatchPtrInput` via:
//
//	        KibanaSpecHttpServiceSpecPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceSpecPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPatchPtrOutput() KibanaSpecHttpServiceSpecPatchPtrOutput
	ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPatchPtrOutput
}

type kibanaSpecHttpServiceSpecPatchPtrType KibanaSpecHttpServiceSpecPatchArgs

func KibanaSpecHttpServiceSpecPatchPtr(v *KibanaSpecHttpServiceSpecPatchArgs) KibanaSpecHttpServiceSpecPatchPtrInput {
	return (*kibanaSpecHttpServiceSpecPatchPtrType)(v)
}

func (*kibanaSpecHttpServiceSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceSpecPatchPtrType) ToKibanaSpecHttpServiceSpecPatchPtrOutput() KibanaSpecHttpServiceSpecPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceSpecPatchPtrType) ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type KibanaSpecHttpServiceSpecPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPatchOutput) ToKibanaSpecHttpServiceSpecPatchOutput() KibanaSpecHttpServiceSpecPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPatchOutput) ToKibanaSpecHttpServiceSpecPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPatchOutput) ToKibanaSpecHttpServiceSpecPatchPtrOutput() KibanaSpecHttpServiceSpecPatchPtrOutput {
	return o.ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceSpecPatchOutput) ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceSpecPatch) *KibanaSpecHttpServiceSpecPatch {
		return &v
	}).(KibanaSpecHttpServiceSpecPatchPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o KibanaSpecHttpServiceSpecPatchOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o KibanaSpecHttpServiceSpecPatchOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o KibanaSpecHttpServiceSpecPatchOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o KibanaSpecHttpServiceSpecPatchOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o KibanaSpecHttpServiceSpecPatchOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o KibanaSpecHttpServiceSpecPatchOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o KibanaSpecHttpServiceSpecPatchOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o KibanaSpecHttpServiceSpecPatchOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o KibanaSpecHttpServiceSpecPatchOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o KibanaSpecHttpServiceSpecPatchOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o KibanaSpecHttpServiceSpecPatchOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchOutput) Ports() KibanaSpecHttpServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) []KibanaSpecHttpServiceSpecPortsPatch { return v.Ports }).(KibanaSpecHttpServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o KibanaSpecHttpServiceSpecPatchOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o KibanaSpecHttpServiceSpecPatchOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceSpecPatchOutput) SessionAffinityConfig() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *KibanaSpecHttpServiceSpecSessionAffinityConfigPatch {
		return v.SessionAffinityConfig
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o KibanaSpecHttpServiceSpecPatchOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o KibanaSpecHttpServiceSpecPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpServiceSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ToKibanaSpecHttpServiceSpecPatchPtrOutput() KibanaSpecHttpServiceSpecPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ToKibanaSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPatchPtrOutput) Elem() KibanaSpecHttpServiceSpecPatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) KibanaSpecHttpServiceSpecPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceSpecPatch
		return ret
	}).(KibanaSpecHttpServiceSpecPatchOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) Ports() KibanaSpecHttpServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) []KibanaSpecHttpServiceSpecPortsPatch {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(KibanaSpecHttpServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o KibanaSpecHttpServiceSpecPatchPtrOutput) SessionAffinityConfig() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *KibanaSpecHttpServiceSpecSessionAffinityConfigPatch {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o KibanaSpecHttpServiceSpecPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ServicePort contains information on service's port.
type KibanaSpecHttpServiceSpecPorts struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// KibanaSpecHttpServiceSpecPortsInput is an input type that accepts KibanaSpecHttpServiceSpecPortsArgs and KibanaSpecHttpServiceSpecPortsOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPortsInput` via:
//
//	KibanaSpecHttpServiceSpecPortsArgs{...}
type KibanaSpecHttpServiceSpecPortsInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPortsOutput() KibanaSpecHttpServiceSpecPortsOutput
	ToKibanaSpecHttpServiceSpecPortsOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPortsOutput
}

// ServicePort contains information on service's port.
type KibanaSpecHttpServiceSpecPortsArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (KibanaSpecHttpServiceSpecPortsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecPortsArgs) ToKibanaSpecHttpServiceSpecPortsOutput() KibanaSpecHttpServiceSpecPortsOutput {
	return i.ToKibanaSpecHttpServiceSpecPortsOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecPortsArgs) ToKibanaSpecHttpServiceSpecPortsOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPortsOutput)
}

// KibanaSpecHttpServiceSpecPortsArrayInput is an input type that accepts KibanaSpecHttpServiceSpecPortsArray and KibanaSpecHttpServiceSpecPortsArrayOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPortsArrayInput` via:
//
//	KibanaSpecHttpServiceSpecPortsArray{ KibanaSpecHttpServiceSpecPortsArgs{...} }
type KibanaSpecHttpServiceSpecPortsArrayInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPortsArrayOutput() KibanaSpecHttpServiceSpecPortsArrayOutput
	ToKibanaSpecHttpServiceSpecPortsArrayOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPortsArrayOutput
}

type KibanaSpecHttpServiceSpecPortsArray []KibanaSpecHttpServiceSpecPortsInput

func (KibanaSpecHttpServiceSpecPortsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecPortsArray) ToKibanaSpecHttpServiceSpecPortsArrayOutput() KibanaSpecHttpServiceSpecPortsArrayOutput {
	return i.ToKibanaSpecHttpServiceSpecPortsArrayOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecPortsArray) ToKibanaSpecHttpServiceSpecPortsArrayOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPortsArrayOutput)
}

// ServicePort contains information on service's port.
type KibanaSpecHttpServiceSpecPortsOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPortsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPortsOutput) ToKibanaSpecHttpServiceSpecPortsOutput() KibanaSpecHttpServiceSpecPortsOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPortsOutput) ToKibanaSpecHttpServiceSpecPortsOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o KibanaSpecHttpServiceSpecPortsOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPorts) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o KibanaSpecHttpServiceSpecPortsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPorts) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o KibanaSpecHttpServiceSpecPortsOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPorts) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o KibanaSpecHttpServiceSpecPortsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPorts) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o KibanaSpecHttpServiceSpecPortsOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPorts) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o KibanaSpecHttpServiceSpecPortsOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPorts) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type KibanaSpecHttpServiceSpecPortsArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPortsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPortsArrayOutput) ToKibanaSpecHttpServiceSpecPortsArrayOutput() KibanaSpecHttpServiceSpecPortsArrayOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPortsArrayOutput) ToKibanaSpecHttpServiceSpecPortsArrayOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsArrayOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPortsArrayOutput) Index(i pulumi.IntInput) KibanaSpecHttpServiceSpecPortsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecHttpServiceSpecPorts {
		return vs[0].([]KibanaSpecHttpServiceSpecPorts)[vs[1].(int)]
	}).(KibanaSpecHttpServiceSpecPortsOutput)
}

// ServicePort contains information on service's port.
type KibanaSpecHttpServiceSpecPortsPatch struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// KibanaSpecHttpServiceSpecPortsPatchInput is an input type that accepts KibanaSpecHttpServiceSpecPortsPatchArgs and KibanaSpecHttpServiceSpecPortsPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPortsPatchInput` via:
//
//	KibanaSpecHttpServiceSpecPortsPatchArgs{...}
type KibanaSpecHttpServiceSpecPortsPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPortsPatchOutput() KibanaSpecHttpServiceSpecPortsPatchOutput
	ToKibanaSpecHttpServiceSpecPortsPatchOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPortsPatchOutput
}

// ServicePort contains information on service's port.
type KibanaSpecHttpServiceSpecPortsPatchArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (KibanaSpecHttpServiceSpecPortsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecPortsPatchArgs) ToKibanaSpecHttpServiceSpecPortsPatchOutput() KibanaSpecHttpServiceSpecPortsPatchOutput {
	return i.ToKibanaSpecHttpServiceSpecPortsPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecPortsPatchArgs) ToKibanaSpecHttpServiceSpecPortsPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPortsPatchOutput)
}

// KibanaSpecHttpServiceSpecPortsPatchArrayInput is an input type that accepts KibanaSpecHttpServiceSpecPortsPatchArray and KibanaSpecHttpServiceSpecPortsPatchArrayOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecPortsPatchArrayInput` via:
//
//	KibanaSpecHttpServiceSpecPortsPatchArray{ KibanaSpecHttpServiceSpecPortsPatchArgs{...} }
type KibanaSpecHttpServiceSpecPortsPatchArrayInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecPortsPatchArrayOutput() KibanaSpecHttpServiceSpecPortsPatchArrayOutput
	ToKibanaSpecHttpServiceSpecPortsPatchArrayOutputWithContext(context.Context) KibanaSpecHttpServiceSpecPortsPatchArrayOutput
}

type KibanaSpecHttpServiceSpecPortsPatchArray []KibanaSpecHttpServiceSpecPortsPatchInput

func (KibanaSpecHttpServiceSpecPortsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecPortsPatchArray) ToKibanaSpecHttpServiceSpecPortsPatchArrayOutput() KibanaSpecHttpServiceSpecPortsPatchArrayOutput {
	return i.ToKibanaSpecHttpServiceSpecPortsPatchArrayOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecPortsPatchArray) ToKibanaSpecHttpServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecPortsPatchArrayOutput)
}

// ServicePort contains information on service's port.
type KibanaSpecHttpServiceSpecPortsPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPortsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPortsPatchOutput) ToKibanaSpecHttpServiceSpecPortsPatchOutput() KibanaSpecHttpServiceSpecPortsPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPortsPatchOutput) ToKibanaSpecHttpServiceSpecPortsPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsPatchOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o KibanaSpecHttpServiceSpecPortsPatchOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPortsPatch) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o KibanaSpecHttpServiceSpecPortsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPortsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o KibanaSpecHttpServiceSpecPortsPatchOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPortsPatch) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o KibanaSpecHttpServiceSpecPortsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPortsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o KibanaSpecHttpServiceSpecPortsPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPortsPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o KibanaSpecHttpServiceSpecPortsPatchOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecPortsPatch) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type KibanaSpecHttpServiceSpecPortsPatchArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecPortsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecPortsPatchArrayOutput) ToKibanaSpecHttpServiceSpecPortsPatchArrayOutput() KibanaSpecHttpServiceSpecPortsPatchArrayOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPortsPatchArrayOutput) ToKibanaSpecHttpServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecPortsPatchArrayOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecPortsPatchArrayOutput) Index(i pulumi.IntInput) KibanaSpecHttpServiceSpecPortsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecHttpServiceSpecPortsPatch {
		return vs[0].([]KibanaSpecHttpServiceSpecPortsPatch)[vs[1].(int)]
	}).(KibanaSpecHttpServiceSpecPortsPatchOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfig struct {
	ClientIP *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP `pulumi:"clientIP"`
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigArgs and KibanaSpecHttpServiceSpecSessionAffinityConfigOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigInput` via:
//
//	KibanaSpecHttpServiceSpecSessionAffinityConfigArgs{...}
type KibanaSpecHttpServiceSpecSessionAffinityConfigInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigArgs struct {
	ClientIP KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput `pulumi:"clientIP"`
}

func (KibanaSpecHttpServiceSpecSessionAffinityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigOutput)
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigOutput).ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigPtrInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigArgs, KibanaSpecHttpServiceSpecSessionAffinityConfigPtr and KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigPtrInput` via:
//
//	        KibanaSpecHttpServiceSpecSessionAffinityConfigArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceSpecSessionAffinityConfigPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput
}

type kibanaSpecHttpServiceSpecSessionAffinityConfigPtrType KibanaSpecHttpServiceSpecSessionAffinityConfigArgs

func KibanaSpecHttpServiceSpecSessionAffinityConfigPtr(v *KibanaSpecHttpServiceSpecSessionAffinityConfigArgs) KibanaSpecHttpServiceSpecSessionAffinityConfigPtrInput {
	return (*kibanaSpecHttpServiceSpecSessionAffinityConfigPtrType)(v)
}

func (*kibanaSpecHttpServiceSpecSessionAffinityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceSpecSessionAffinityConfig) *KibanaSpecHttpServiceSpecSessionAffinityConfig {
		return &v
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigOutput) ClientIP() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecSessionAffinityConfig) *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP {
		return v.ClientIP
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

type KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput) Elem() KibanaSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfig) KibanaSpecHttpServiceSpecSessionAffinityConfig {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceSpecSessionAffinityConfig
		return ret
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigOutput)
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ClientIP() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfig) *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs and KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPInput` via:
//
//	KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{...}
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput)
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput).ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs, KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtr and KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput` via:
//
//	        KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput
}

type kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs

func KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtr(v *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput {
	return (*kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType)(v)
}

func (*kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP) *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP {
		return &v
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) Elem() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP
		return ret
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIP) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs and KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput` via:
//
//	KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput).ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs, KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtr and KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput` via:
//
//	        KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
}

type kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs

func KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtr(v *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput {
	return (*kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType)(v)
}

func (*kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		return &v
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) Elem() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch
		return ret
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigPatch struct {
	ClientIP *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch `pulumi:"clientIP"`
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigPatchInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs and KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigPatchInput` via:
//
//	KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs{...}
type KibanaSpecHttpServiceSpecSessionAffinityConfigPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs struct {
	ClientIP KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput `pulumi:"clientIP"`
}

func (KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput)
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput).ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput is an input type that accepts KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs, KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtr and KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput` via:
//
//	        KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput
	ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput
}

type kibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrType KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs

func KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtr(v *KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput {
	return (*kibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrType)(v)
}

func (*kibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpServiceSpecSessionAffinityConfigPatch) *KibanaSpecHttpServiceSpecSessionAffinityConfigPatch {
		return &v
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ClientIP() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpServiceSpecSessionAffinityConfigPatch) *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		return v.ClientIP
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

type KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ToKibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) Elem() KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfigPatch) KibanaSpecHttpServiceSpecSessionAffinityConfigPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpServiceSpecSessionAffinityConfigPatch
		return ret
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput)
}

func (o KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ClientIP() KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpServiceSpecSessionAffinityConfigPatch) *KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type KibanaSpecHttpTls struct {
	Certificate           *KibanaSpecHttpTlsCertificate           `pulumi:"certificate"`
	SelfSignedCertificate *KibanaSpecHttpTlsSelfSignedCertificate `pulumi:"selfSignedCertificate"`
}

// KibanaSpecHttpTlsInput is an input type that accepts KibanaSpecHttpTlsArgs and KibanaSpecHttpTlsOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsInput` via:
//
//	KibanaSpecHttpTlsArgs{...}
type KibanaSpecHttpTlsInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsOutput() KibanaSpecHttpTlsOutput
	ToKibanaSpecHttpTlsOutputWithContext(context.Context) KibanaSpecHttpTlsOutput
}

// TLS defines options for configuring TLS for HTTP.
type KibanaSpecHttpTlsArgs struct {
	Certificate           KibanaSpecHttpTlsCertificatePtrInput           `pulumi:"certificate"`
	SelfSignedCertificate KibanaSpecHttpTlsSelfSignedCertificatePtrInput `pulumi:"selfSignedCertificate"`
}

func (KibanaSpecHttpTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTls)(nil)).Elem()
}

func (i KibanaSpecHttpTlsArgs) ToKibanaSpecHttpTlsOutput() KibanaSpecHttpTlsOutput {
	return i.ToKibanaSpecHttpTlsOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsArgs) ToKibanaSpecHttpTlsOutputWithContext(ctx context.Context) KibanaSpecHttpTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsOutput)
}

func (i KibanaSpecHttpTlsArgs) ToKibanaSpecHttpTlsPtrOutput() KibanaSpecHttpTlsPtrOutput {
	return i.ToKibanaSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsArgs) ToKibanaSpecHttpTlsPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsOutput).ToKibanaSpecHttpTlsPtrOutputWithContext(ctx)
}

// KibanaSpecHttpTlsPtrInput is an input type that accepts KibanaSpecHttpTlsArgs, KibanaSpecHttpTlsPtr and KibanaSpecHttpTlsPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsPtrInput` via:
//
//	        KibanaSpecHttpTlsArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpTlsPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsPtrOutput() KibanaSpecHttpTlsPtrOutput
	ToKibanaSpecHttpTlsPtrOutputWithContext(context.Context) KibanaSpecHttpTlsPtrOutput
}

type kibanaSpecHttpTlsPtrType KibanaSpecHttpTlsArgs

func KibanaSpecHttpTlsPtr(v *KibanaSpecHttpTlsArgs) KibanaSpecHttpTlsPtrInput {
	return (*kibanaSpecHttpTlsPtrType)(v)
}

func (*kibanaSpecHttpTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTls)(nil)).Elem()
}

func (i *kibanaSpecHttpTlsPtrType) ToKibanaSpecHttpTlsPtrOutput() KibanaSpecHttpTlsPtrOutput {
	return i.ToKibanaSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpTlsPtrType) ToKibanaSpecHttpTlsPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type KibanaSpecHttpTlsOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTls)(nil)).Elem()
}

func (o KibanaSpecHttpTlsOutput) ToKibanaSpecHttpTlsOutput() KibanaSpecHttpTlsOutput {
	return o
}

func (o KibanaSpecHttpTlsOutput) ToKibanaSpecHttpTlsOutputWithContext(ctx context.Context) KibanaSpecHttpTlsOutput {
	return o
}

func (o KibanaSpecHttpTlsOutput) ToKibanaSpecHttpTlsPtrOutput() KibanaSpecHttpTlsPtrOutput {
	return o.ToKibanaSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpTlsOutput) ToKibanaSpecHttpTlsPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpTls) *KibanaSpecHttpTls {
		return &v
	}).(KibanaSpecHttpTlsPtrOutput)
}

func (o KibanaSpecHttpTlsOutput) Certificate() KibanaSpecHttpTlsCertificatePtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTls) *KibanaSpecHttpTlsCertificate { return v.Certificate }).(KibanaSpecHttpTlsCertificatePtrOutput)
}

func (o KibanaSpecHttpTlsOutput) SelfSignedCertificate() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTls) *KibanaSpecHttpTlsSelfSignedCertificate { return v.SelfSignedCertificate }).(KibanaSpecHttpTlsSelfSignedCertificatePtrOutput)
}

type KibanaSpecHttpTlsPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTls)(nil)).Elem()
}

func (o KibanaSpecHttpTlsPtrOutput) ToKibanaSpecHttpTlsPtrOutput() KibanaSpecHttpTlsPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsPtrOutput) ToKibanaSpecHttpTlsPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsPtrOutput) Elem() KibanaSpecHttpTlsOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTls) KibanaSpecHttpTls {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpTls
		return ret
	}).(KibanaSpecHttpTlsOutput)
}

func (o KibanaSpecHttpTlsPtrOutput) Certificate() KibanaSpecHttpTlsCertificatePtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTls) *KibanaSpecHttpTlsCertificate {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(KibanaSpecHttpTlsCertificatePtrOutput)
}

func (o KibanaSpecHttpTlsPtrOutput) SelfSignedCertificate() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTls) *KibanaSpecHttpTlsSelfSignedCertificate {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(KibanaSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type KibanaSpecHttpTlsCertificate struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// KibanaSpecHttpTlsCertificateInput is an input type that accepts KibanaSpecHttpTlsCertificateArgs and KibanaSpecHttpTlsCertificateOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsCertificateInput` via:
//
//	KibanaSpecHttpTlsCertificateArgs{...}
type KibanaSpecHttpTlsCertificateInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsCertificateOutput() KibanaSpecHttpTlsCertificateOutput
	ToKibanaSpecHttpTlsCertificateOutputWithContext(context.Context) KibanaSpecHttpTlsCertificateOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type KibanaSpecHttpTlsCertificateArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (KibanaSpecHttpTlsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsCertificate)(nil)).Elem()
}

func (i KibanaSpecHttpTlsCertificateArgs) ToKibanaSpecHttpTlsCertificateOutput() KibanaSpecHttpTlsCertificateOutput {
	return i.ToKibanaSpecHttpTlsCertificateOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsCertificateArgs) ToKibanaSpecHttpTlsCertificateOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsCertificateOutput)
}

func (i KibanaSpecHttpTlsCertificateArgs) ToKibanaSpecHttpTlsCertificatePtrOutput() KibanaSpecHttpTlsCertificatePtrOutput {
	return i.ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsCertificateArgs) ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsCertificateOutput).ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(ctx)
}

// KibanaSpecHttpTlsCertificatePtrInput is an input type that accepts KibanaSpecHttpTlsCertificateArgs, KibanaSpecHttpTlsCertificatePtr and KibanaSpecHttpTlsCertificatePtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsCertificatePtrInput` via:
//
//	        KibanaSpecHttpTlsCertificateArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpTlsCertificatePtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsCertificatePtrOutput() KibanaSpecHttpTlsCertificatePtrOutput
	ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(context.Context) KibanaSpecHttpTlsCertificatePtrOutput
}

type kibanaSpecHttpTlsCertificatePtrType KibanaSpecHttpTlsCertificateArgs

func KibanaSpecHttpTlsCertificatePtr(v *KibanaSpecHttpTlsCertificateArgs) KibanaSpecHttpTlsCertificatePtrInput {
	return (*kibanaSpecHttpTlsCertificatePtrType)(v)
}

func (*kibanaSpecHttpTlsCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsCertificate)(nil)).Elem()
}

func (i *kibanaSpecHttpTlsCertificatePtrType) ToKibanaSpecHttpTlsCertificatePtrOutput() KibanaSpecHttpTlsCertificatePtrOutput {
	return i.ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpTlsCertificatePtrType) ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type KibanaSpecHttpTlsCertificateOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsCertificate)(nil)).Elem()
}

func (o KibanaSpecHttpTlsCertificateOutput) ToKibanaSpecHttpTlsCertificateOutput() KibanaSpecHttpTlsCertificateOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificateOutput) ToKibanaSpecHttpTlsCertificateOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificateOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificateOutput) ToKibanaSpecHttpTlsCertificatePtrOutput() KibanaSpecHttpTlsCertificatePtrOutput {
	return o.ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpTlsCertificateOutput) ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpTlsCertificate) *KibanaSpecHttpTlsCertificate {
		return &v
	}).(KibanaSpecHttpTlsCertificatePtrOutput)
}

// SecretName is the name of the secret.
func (o KibanaSpecHttpTlsCertificateOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsCertificate) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpTlsCertificatePtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsCertificate)(nil)).Elem()
}

func (o KibanaSpecHttpTlsCertificatePtrOutput) ToKibanaSpecHttpTlsCertificatePtrOutput() KibanaSpecHttpTlsCertificatePtrOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificatePtrOutput) ToKibanaSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePtrOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificatePtrOutput) Elem() KibanaSpecHttpTlsCertificateOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsCertificate) KibanaSpecHttpTlsCertificate {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpTlsCertificate
		return ret
	}).(KibanaSpecHttpTlsCertificateOutput)
}

// SecretName is the name of the secret.
func (o KibanaSpecHttpTlsCertificatePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsCertificate) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type KibanaSpecHttpTlsCertificatePatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// KibanaSpecHttpTlsCertificatePatchInput is an input type that accepts KibanaSpecHttpTlsCertificatePatchArgs and KibanaSpecHttpTlsCertificatePatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsCertificatePatchInput` via:
//
//	KibanaSpecHttpTlsCertificatePatchArgs{...}
type KibanaSpecHttpTlsCertificatePatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsCertificatePatchOutput() KibanaSpecHttpTlsCertificatePatchOutput
	ToKibanaSpecHttpTlsCertificatePatchOutputWithContext(context.Context) KibanaSpecHttpTlsCertificatePatchOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type KibanaSpecHttpTlsCertificatePatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (KibanaSpecHttpTlsCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (i KibanaSpecHttpTlsCertificatePatchArgs) ToKibanaSpecHttpTlsCertificatePatchOutput() KibanaSpecHttpTlsCertificatePatchOutput {
	return i.ToKibanaSpecHttpTlsCertificatePatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsCertificatePatchArgs) ToKibanaSpecHttpTlsCertificatePatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsCertificatePatchOutput)
}

func (i KibanaSpecHttpTlsCertificatePatchArgs) ToKibanaSpecHttpTlsCertificatePatchPtrOutput() KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return i.ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsCertificatePatchArgs) ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsCertificatePatchOutput).ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpTlsCertificatePatchPtrInput is an input type that accepts KibanaSpecHttpTlsCertificatePatchArgs, KibanaSpecHttpTlsCertificatePatchPtr and KibanaSpecHttpTlsCertificatePatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsCertificatePatchPtrInput` via:
//
//	        KibanaSpecHttpTlsCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpTlsCertificatePatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsCertificatePatchPtrOutput() KibanaSpecHttpTlsCertificatePatchPtrOutput
	ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Context) KibanaSpecHttpTlsCertificatePatchPtrOutput
}

type kibanaSpecHttpTlsCertificatePatchPtrType KibanaSpecHttpTlsCertificatePatchArgs

func KibanaSpecHttpTlsCertificatePatchPtr(v *KibanaSpecHttpTlsCertificatePatchArgs) KibanaSpecHttpTlsCertificatePatchPtrInput {
	return (*kibanaSpecHttpTlsCertificatePatchPtrType)(v)
}

func (*kibanaSpecHttpTlsCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (i *kibanaSpecHttpTlsCertificatePatchPtrType) ToKibanaSpecHttpTlsCertificatePatchPtrOutput() KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return i.ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpTlsCertificatePatchPtrType) ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsCertificatePatchPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type KibanaSpecHttpTlsCertificatePatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsCertificatePatchOutput) ToKibanaSpecHttpTlsCertificatePatchOutput() KibanaSpecHttpTlsCertificatePatchOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificatePatchOutput) ToKibanaSpecHttpTlsCertificatePatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePatchOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificatePatchOutput) ToKibanaSpecHttpTlsCertificatePatchPtrOutput() KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return o.ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpTlsCertificatePatchOutput) ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpTlsCertificatePatch) *KibanaSpecHttpTlsCertificatePatch {
		return &v
	}).(KibanaSpecHttpTlsCertificatePatchPtrOutput)
}

// SecretName is the name of the secret.
func (o KibanaSpecHttpTlsCertificatePatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsCertificatePatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpTlsCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsCertificatePatchPtrOutput) ToKibanaSpecHttpTlsCertificatePatchPtrOutput() KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificatePatchPtrOutput) ToKibanaSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsCertificatePatchPtrOutput) Elem() KibanaSpecHttpTlsCertificatePatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsCertificatePatch) KibanaSpecHttpTlsCertificatePatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpTlsCertificatePatch
		return ret
	}).(KibanaSpecHttpTlsCertificatePatchOutput)
}

// SecretName is the name of the secret.
func (o KibanaSpecHttpTlsCertificatePatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsCertificatePatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type KibanaSpecHttpTlsPatch struct {
	Certificate           *KibanaSpecHttpTlsCertificatePatch           `pulumi:"certificate"`
	SelfSignedCertificate *KibanaSpecHttpTlsSelfSignedCertificatePatch `pulumi:"selfSignedCertificate"`
}

// KibanaSpecHttpTlsPatchInput is an input type that accepts KibanaSpecHttpTlsPatchArgs and KibanaSpecHttpTlsPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsPatchInput` via:
//
//	KibanaSpecHttpTlsPatchArgs{...}
type KibanaSpecHttpTlsPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsPatchOutput() KibanaSpecHttpTlsPatchOutput
	ToKibanaSpecHttpTlsPatchOutputWithContext(context.Context) KibanaSpecHttpTlsPatchOutput
}

// TLS defines options for configuring TLS for HTTP.
type KibanaSpecHttpTlsPatchArgs struct {
	Certificate           KibanaSpecHttpTlsCertificatePatchPtrInput           `pulumi:"certificate"`
	SelfSignedCertificate KibanaSpecHttpTlsSelfSignedCertificatePatchPtrInput `pulumi:"selfSignedCertificate"`
}

func (KibanaSpecHttpTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsPatch)(nil)).Elem()
}

func (i KibanaSpecHttpTlsPatchArgs) ToKibanaSpecHttpTlsPatchOutput() KibanaSpecHttpTlsPatchOutput {
	return i.ToKibanaSpecHttpTlsPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsPatchArgs) ToKibanaSpecHttpTlsPatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsPatchOutput)
}

func (i KibanaSpecHttpTlsPatchArgs) ToKibanaSpecHttpTlsPatchPtrOutput() KibanaSpecHttpTlsPatchPtrOutput {
	return i.ToKibanaSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsPatchArgs) ToKibanaSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsPatchOutput).ToKibanaSpecHttpTlsPatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpTlsPatchPtrInput is an input type that accepts KibanaSpecHttpTlsPatchArgs, KibanaSpecHttpTlsPatchPtr and KibanaSpecHttpTlsPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsPatchPtrInput` via:
//
//	        KibanaSpecHttpTlsPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpTlsPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsPatchPtrOutput() KibanaSpecHttpTlsPatchPtrOutput
	ToKibanaSpecHttpTlsPatchPtrOutputWithContext(context.Context) KibanaSpecHttpTlsPatchPtrOutput
}

type kibanaSpecHttpTlsPatchPtrType KibanaSpecHttpTlsPatchArgs

func KibanaSpecHttpTlsPatchPtr(v *KibanaSpecHttpTlsPatchArgs) KibanaSpecHttpTlsPatchPtrInput {
	return (*kibanaSpecHttpTlsPatchPtrType)(v)
}

func (*kibanaSpecHttpTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsPatch)(nil)).Elem()
}

func (i *kibanaSpecHttpTlsPatchPtrType) ToKibanaSpecHttpTlsPatchPtrOutput() KibanaSpecHttpTlsPatchPtrOutput {
	return i.ToKibanaSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpTlsPatchPtrType) ToKibanaSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type KibanaSpecHttpTlsPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsPatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsPatchOutput) ToKibanaSpecHttpTlsPatchOutput() KibanaSpecHttpTlsPatchOutput {
	return o
}

func (o KibanaSpecHttpTlsPatchOutput) ToKibanaSpecHttpTlsPatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPatchOutput {
	return o
}

func (o KibanaSpecHttpTlsPatchOutput) ToKibanaSpecHttpTlsPatchPtrOutput() KibanaSpecHttpTlsPatchPtrOutput {
	return o.ToKibanaSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpTlsPatchOutput) ToKibanaSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpTlsPatch) *KibanaSpecHttpTlsPatch {
		return &v
	}).(KibanaSpecHttpTlsPatchPtrOutput)
}

func (o KibanaSpecHttpTlsPatchOutput) Certificate() KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsPatch) *KibanaSpecHttpTlsCertificatePatch { return v.Certificate }).(KibanaSpecHttpTlsCertificatePatchPtrOutput)
}

func (o KibanaSpecHttpTlsPatchOutput) SelfSignedCertificate() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsPatch) *KibanaSpecHttpTlsSelfSignedCertificatePatch {
		return v.SelfSignedCertificate
	}).(KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

type KibanaSpecHttpTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsPatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsPatchPtrOutput) ToKibanaSpecHttpTlsPatchPtrOutput() KibanaSpecHttpTlsPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsPatchPtrOutput) ToKibanaSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsPatchPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsPatchPtrOutput) Elem() KibanaSpecHttpTlsPatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsPatch) KibanaSpecHttpTlsPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpTlsPatch
		return ret
	}).(KibanaSpecHttpTlsPatchOutput)
}

func (o KibanaSpecHttpTlsPatchPtrOutput) Certificate() KibanaSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsPatch) *KibanaSpecHttpTlsCertificatePatch {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(KibanaSpecHttpTlsCertificatePatchPtrOutput)
}

func (o KibanaSpecHttpTlsPatchPtrOutput) SelfSignedCertificate() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsPatch) *KibanaSpecHttpTlsSelfSignedCertificatePatch {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type KibanaSpecHttpTlsSelfSignedCertificate struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames `pulumi:"subjectAltNames"`
}

// KibanaSpecHttpTlsSelfSignedCertificateInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificateArgs and KibanaSpecHttpTlsSelfSignedCertificateOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificateInput` via:
//
//	KibanaSpecHttpTlsSelfSignedCertificateArgs{...}
type KibanaSpecHttpTlsSelfSignedCertificateInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificateOutput() KibanaSpecHttpTlsSelfSignedCertificateOutput
	ToKibanaSpecHttpTlsSelfSignedCertificateOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificateOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type KibanaSpecHttpTlsSelfSignedCertificateArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput `pulumi:"subjectAltNames"`
}

func (KibanaSpecHttpTlsSelfSignedCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (i KibanaSpecHttpTlsSelfSignedCertificateArgs) ToKibanaSpecHttpTlsSelfSignedCertificateOutput() KibanaSpecHttpTlsSelfSignedCertificateOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificateOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificateArgs) ToKibanaSpecHttpTlsSelfSignedCertificateOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificateOutput)
}

func (i KibanaSpecHttpTlsSelfSignedCertificateArgs) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificateArgs) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificateOutput).ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx)
}

// KibanaSpecHttpTlsSelfSignedCertificatePtrInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificateArgs, KibanaSpecHttpTlsSelfSignedCertificatePtr and KibanaSpecHttpTlsSelfSignedCertificatePtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificatePtrInput` via:
//
//	        KibanaSpecHttpTlsSelfSignedCertificateArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpTlsSelfSignedCertificatePtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput
	ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificatePtrOutput
}

type kibanaSpecHttpTlsSelfSignedCertificatePtrType KibanaSpecHttpTlsSelfSignedCertificateArgs

func KibanaSpecHttpTlsSelfSignedCertificatePtr(v *KibanaSpecHttpTlsSelfSignedCertificateArgs) KibanaSpecHttpTlsSelfSignedCertificatePtrInput {
	return (*kibanaSpecHttpTlsSelfSignedCertificatePtrType)(v)
}

func (*kibanaSpecHttpTlsSelfSignedCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (i *kibanaSpecHttpTlsSelfSignedCertificatePtrType) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpTlsSelfSignedCertificatePtrType) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type KibanaSpecHttpTlsSelfSignedCertificateOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificateOutput) ToKibanaSpecHttpTlsSelfSignedCertificateOutput() KibanaSpecHttpTlsSelfSignedCertificateOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateOutput) ToKibanaSpecHttpTlsSelfSignedCertificateOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpTlsSelfSignedCertificateOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpTlsSelfSignedCertificate) *KibanaSpecHttpTlsSelfSignedCertificate {
		return &v
	}).(KibanaSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o KibanaSpecHttpTlsSelfSignedCertificateOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificate) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o KibanaSpecHttpTlsSelfSignedCertificateOutput) SubjectAltNames() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificate) []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		return v.SubjectAltNames
	}).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

type KibanaSpecHttpTlsSelfSignedCertificatePtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePtrOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePtrOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePtrOutput) Elem() KibanaSpecHttpTlsSelfSignedCertificateOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsSelfSignedCertificate) KibanaSpecHttpTlsSelfSignedCertificate {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpTlsSelfSignedCertificate
		return ret
	}).(KibanaSpecHttpTlsSelfSignedCertificateOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o KibanaSpecHttpTlsSelfSignedCertificatePtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsSelfSignedCertificate) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o KibanaSpecHttpTlsSelfSignedCertificatePtrOutput) SubjectAltNames() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsSelfSignedCertificate) []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type KibanaSpecHttpTlsSelfSignedCertificatePatch struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch `pulumi:"subjectAltNames"`
}

// KibanaSpecHttpTlsSelfSignedCertificatePatchInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificatePatchArgs and KibanaSpecHttpTlsSelfSignedCertificatePatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificatePatchInput` via:
//
//	KibanaSpecHttpTlsSelfSignedCertificatePatchArgs{...}
type KibanaSpecHttpTlsSelfSignedCertificatePatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchOutput
	ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type KibanaSpecHttpTlsSelfSignedCertificatePatchArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput `pulumi:"subjectAltNames"`
}

func (KibanaSpecHttpTlsSelfSignedCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i KibanaSpecHttpTlsSelfSignedCertificatePatchArgs) ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificatePatchArgs) ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificatePatchOutput)
}

func (i KibanaSpecHttpTlsSelfSignedCertificatePatchArgs) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificatePatchArgs) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificatePatchOutput).ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx)
}

// KibanaSpecHttpTlsSelfSignedCertificatePatchPtrInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificatePatchArgs, KibanaSpecHttpTlsSelfSignedCertificatePatchPtr and KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificatePatchPtrInput` via:
//
//	        KibanaSpecHttpTlsSelfSignedCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecHttpTlsSelfSignedCertificatePatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput
	ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput
}

type kibanaSpecHttpTlsSelfSignedCertificatePatchPtrType KibanaSpecHttpTlsSelfSignedCertificatePatchArgs

func KibanaSpecHttpTlsSelfSignedCertificatePatchPtr(v *KibanaSpecHttpTlsSelfSignedCertificatePatchArgs) KibanaSpecHttpTlsSelfSignedCertificatePatchPtrInput {
	return (*kibanaSpecHttpTlsSelfSignedCertificatePatchPtrType)(v)
}

func (*kibanaSpecHttpTlsSelfSignedCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i *kibanaSpecHttpTlsSelfSignedCertificatePatchPtrType) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecHttpTlsSelfSignedCertificatePatchPtrType) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type KibanaSpecHttpTlsSelfSignedCertificatePatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecHttpTlsSelfSignedCertificatePatch) *KibanaSpecHttpTlsSelfSignedCertificatePatch {
		return &v
	}).(KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificatePatch) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o KibanaSpecHttpTlsSelfSignedCertificatePatchOutput) SubjectAltNames() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificatePatch) []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		return v.SubjectAltNames
	}).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

type KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput() KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ToKibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput) Elem() KibanaSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsSelfSignedCertificatePatch) KibanaSpecHttpTlsSelfSignedCertificatePatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecHttpTlsSelfSignedCertificatePatch
		return ret
	}).(KibanaSpecHttpTlsSelfSignedCertificatePatchOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsSelfSignedCertificatePatch) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput) SubjectAltNames() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v *KibanaSpecHttpTlsSelfSignedCertificatePatch) []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs and KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput` via:
//
//	KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{...}
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput
	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray and KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput` via:
//
//	KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray{ KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{...} }
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput
	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput
}

type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) Index(i pulumi.IntInput) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		return vs[0].([]KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNames)[vs[1].(int)]
	}).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs and KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput` via:
//
//	KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...}
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput
	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput is an input type that accepts KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray and KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput values.
// You can construct a concrete instance of `KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput` via:
//
//	KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray{ KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...} }
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput interface {
	pulumi.Input

	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
	ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
}

type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray []KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return i.ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Background())
}

func (i KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToKibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) Index(i pulumi.IntInput) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		return vs[0].([]KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)[vs[1].(int)]
	}).(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// KibanaSpec holds the specification of a Kibana instance.
type KibanaSpecPatch struct {
	// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
	Config map[string]interface{} `pulumi:"config"`
	// Count of Kibana instances to deploy.
	Count            *int                             `pulumi:"count"`
	ElasticsearchRef *KibanaSpecElasticsearchRefPatch `pulumi:"elasticsearchRef"`
	Http             *KibanaSpecHttpPatch             `pulumi:"http"`
	// Image is the Kibana Docker image to deploy.
	Image *string `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
	SecureSettings []KibanaSpecSecureSettingsPatch `pulumi:"secureSettings"`
	// Version of Kibana.
	Version *string `pulumi:"version"`
}

// KibanaSpecPatchInput is an input type that accepts KibanaSpecPatchArgs and KibanaSpecPatchOutput values.
// You can construct a concrete instance of `KibanaSpecPatchInput` via:
//
//	KibanaSpecPatchArgs{...}
type KibanaSpecPatchInput interface {
	pulumi.Input

	ToKibanaSpecPatchOutput() KibanaSpecPatchOutput
	ToKibanaSpecPatchOutputWithContext(context.Context) KibanaSpecPatchOutput
}

// KibanaSpec holds the specification of a Kibana instance.
type KibanaSpecPatchArgs struct {
	// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
	Config pulumi.MapInput `pulumi:"config"`
	// Count of Kibana instances to deploy.
	Count            pulumi.IntPtrInput                      `pulumi:"count"`
	ElasticsearchRef KibanaSpecElasticsearchRefPatchPtrInput `pulumi:"elasticsearchRef"`
	Http             KibanaSpecHttpPatchPtrInput             `pulumi:"http"`
	// Image is the Kibana Docker image to deploy.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
	SecureSettings KibanaSpecSecureSettingsPatchArrayInput `pulumi:"secureSettings"`
	// Version of Kibana.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (KibanaSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecPatch)(nil)).Elem()
}

func (i KibanaSpecPatchArgs) ToKibanaSpecPatchOutput() KibanaSpecPatchOutput {
	return i.ToKibanaSpecPatchOutputWithContext(context.Background())
}

func (i KibanaSpecPatchArgs) ToKibanaSpecPatchOutputWithContext(ctx context.Context) KibanaSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecPatchOutput)
}

func (i KibanaSpecPatchArgs) ToKibanaSpecPatchPtrOutput() KibanaSpecPatchPtrOutput {
	return i.ToKibanaSpecPatchPtrOutputWithContext(context.Background())
}

func (i KibanaSpecPatchArgs) ToKibanaSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecPatchOutput).ToKibanaSpecPatchPtrOutputWithContext(ctx)
}

// KibanaSpecPatchPtrInput is an input type that accepts KibanaSpecPatchArgs, KibanaSpecPatchPtr and KibanaSpecPatchPtrOutput values.
// You can construct a concrete instance of `KibanaSpecPatchPtrInput` via:
//
//	        KibanaSpecPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaSpecPatchPtrInput interface {
	pulumi.Input

	ToKibanaSpecPatchPtrOutput() KibanaSpecPatchPtrOutput
	ToKibanaSpecPatchPtrOutputWithContext(context.Context) KibanaSpecPatchPtrOutput
}

type kibanaSpecPatchPtrType KibanaSpecPatchArgs

func KibanaSpecPatchPtr(v *KibanaSpecPatchArgs) KibanaSpecPatchPtrInput {
	return (*kibanaSpecPatchPtrType)(v)
}

func (*kibanaSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecPatch)(nil)).Elem()
}

func (i *kibanaSpecPatchPtrType) ToKibanaSpecPatchPtrOutput() KibanaSpecPatchPtrOutput {
	return i.ToKibanaSpecPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaSpecPatchPtrType) ToKibanaSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecPatchPtrOutput)
}

// KibanaSpec holds the specification of a Kibana instance.
type KibanaSpecPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecPatch)(nil)).Elem()
}

func (o KibanaSpecPatchOutput) ToKibanaSpecPatchOutput() KibanaSpecPatchOutput {
	return o
}

func (o KibanaSpecPatchOutput) ToKibanaSpecPatchOutputWithContext(ctx context.Context) KibanaSpecPatchOutput {
	return o
}

func (o KibanaSpecPatchOutput) ToKibanaSpecPatchPtrOutput() KibanaSpecPatchPtrOutput {
	return o.ToKibanaSpecPatchPtrOutputWithContext(context.Background())
}

func (o KibanaSpecPatchOutput) ToKibanaSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaSpecPatch) *KibanaSpecPatch {
		return &v
	}).(KibanaSpecPatchPtrOutput)
}

// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
func (o KibanaSpecPatchOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v KibanaSpecPatch) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// Count of Kibana instances to deploy.
func (o KibanaSpecPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaSpecPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

func (o KibanaSpecPatchOutput) ElasticsearchRef() KibanaSpecElasticsearchRefPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecPatch) *KibanaSpecElasticsearchRefPatch { return v.ElasticsearchRef }).(KibanaSpecElasticsearchRefPatchPtrOutput)
}

func (o KibanaSpecPatchOutput) Http() KibanaSpecHttpPatchPtrOutput {
	return o.ApplyT(func(v KibanaSpecPatch) *KibanaSpecHttpPatch { return v.Http }).(KibanaSpecHttpPatchPtrOutput)
}

// Image is the Kibana Docker image to deploy.
func (o KibanaSpecPatchOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecPatch) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
func (o KibanaSpecPatchOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v KibanaSpecPatch) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
func (o KibanaSpecPatchOutput) SecureSettings() KibanaSpecSecureSettingsPatchArrayOutput {
	return o.ApplyT(func(v KibanaSpecPatch) []KibanaSpecSecureSettingsPatch { return v.SecureSettings }).(KibanaSpecSecureSettingsPatchArrayOutput)
}

// Version of Kibana.
func (o KibanaSpecPatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecPatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type KibanaSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaSpecPatch)(nil)).Elem()
}

func (o KibanaSpecPatchPtrOutput) ToKibanaSpecPatchPtrOutput() KibanaSpecPatchPtrOutput {
	return o
}

func (o KibanaSpecPatchPtrOutput) ToKibanaSpecPatchPtrOutputWithContext(ctx context.Context) KibanaSpecPatchPtrOutput {
	return o
}

func (o KibanaSpecPatchPtrOutput) Elem() KibanaSpecPatchOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) KibanaSpecPatch {
		if v != nil {
			return *v
		}
		var ret KibanaSpecPatch
		return ret
	}).(KibanaSpecPatchOutput)
}

// Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html
func (o KibanaSpecPatchPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// Count of Kibana instances to deploy.
func (o KibanaSpecPatchPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

func (o KibanaSpecPatchPtrOutput) ElasticsearchRef() KibanaSpecElasticsearchRefPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) *KibanaSpecElasticsearchRefPatch {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRef
	}).(KibanaSpecElasticsearchRefPatchPtrOutput)
}

func (o KibanaSpecPatchPtrOutput) Http() KibanaSpecHttpPatchPtrOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) *KibanaSpecHttpPatch {
		if v == nil {
			return nil
		}
		return v.Http
	}).(KibanaSpecHttpPatchPtrOutput)
}

// Image is the Kibana Docker image to deploy.
func (o KibanaSpecPatchPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
func (o KibanaSpecPatchPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
func (o KibanaSpecPatchPtrOutput) SecureSettings() KibanaSpecSecureSettingsPatchArrayOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) []KibanaSpecSecureSettingsPatch {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(KibanaSpecSecureSettingsPatchArrayOutput)
}

// Version of Kibana.
func (o KibanaSpecPatchPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type KibanaSpecSecureSettings struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []KibanaSpecSecureSettingsEntries `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// KibanaSpecSecureSettingsInput is an input type that accepts KibanaSpecSecureSettingsArgs and KibanaSpecSecureSettingsOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsInput` via:
//
//	KibanaSpecSecureSettingsArgs{...}
type KibanaSpecSecureSettingsInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsOutput() KibanaSpecSecureSettingsOutput
	ToKibanaSpecSecureSettingsOutputWithContext(context.Context) KibanaSpecSecureSettingsOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type KibanaSpecSecureSettingsArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries KibanaSpecSecureSettingsEntriesArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (KibanaSpecSecureSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettings)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsArgs) ToKibanaSpecSecureSettingsOutput() KibanaSpecSecureSettingsOutput {
	return i.ToKibanaSpecSecureSettingsOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsArgs) ToKibanaSpecSecureSettingsOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsOutput)
}

// KibanaSpecSecureSettingsArrayInput is an input type that accepts KibanaSpecSecureSettingsArray and KibanaSpecSecureSettingsArrayOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsArrayInput` via:
//
//	KibanaSpecSecureSettingsArray{ KibanaSpecSecureSettingsArgs{...} }
type KibanaSpecSecureSettingsArrayInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsArrayOutput() KibanaSpecSecureSettingsArrayOutput
	ToKibanaSpecSecureSettingsArrayOutputWithContext(context.Context) KibanaSpecSecureSettingsArrayOutput
}

type KibanaSpecSecureSettingsArray []KibanaSpecSecureSettingsInput

func (KibanaSpecSecureSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettings)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsArray) ToKibanaSpecSecureSettingsArrayOutput() KibanaSpecSecureSettingsArrayOutput {
	return i.ToKibanaSpecSecureSettingsArrayOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsArray) ToKibanaSpecSecureSettingsArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type KibanaSpecSecureSettingsOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettings)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsOutput) ToKibanaSpecSecureSettingsOutput() KibanaSpecSecureSettingsOutput {
	return o
}

func (o KibanaSpecSecureSettingsOutput) ToKibanaSpecSecureSettingsOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o KibanaSpecSecureSettingsOutput) Entries() KibanaSpecSecureSettingsEntriesArrayOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettings) []KibanaSpecSecureSettingsEntries { return v.Entries }).(KibanaSpecSecureSettingsEntriesArrayOutput)
}

// SecretName is the name of the secret.
func (o KibanaSpecSecureSettingsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettings) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type KibanaSpecSecureSettingsArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettings)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsArrayOutput) ToKibanaSpecSecureSettingsArrayOutput() KibanaSpecSecureSettingsArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsArrayOutput) ToKibanaSpecSecureSettingsArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsArrayOutput) Index(i pulumi.IntInput) KibanaSpecSecureSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecSecureSettings {
		return vs[0].([]KibanaSpecSecureSettings)[vs[1].(int)]
	}).(KibanaSpecSecureSettingsOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type KibanaSpecSecureSettingsEntries struct {
	// Key is the key contained in the secret.
	Key *string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// KibanaSpecSecureSettingsEntriesInput is an input type that accepts KibanaSpecSecureSettingsEntriesArgs and KibanaSpecSecureSettingsEntriesOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsEntriesInput` via:
//
//	KibanaSpecSecureSettingsEntriesArgs{...}
type KibanaSpecSecureSettingsEntriesInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsEntriesOutput() KibanaSpecSecureSettingsEntriesOutput
	ToKibanaSpecSecureSettingsEntriesOutputWithContext(context.Context) KibanaSpecSecureSettingsEntriesOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type KibanaSpecSecureSettingsEntriesArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (KibanaSpecSecureSettingsEntriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettingsEntries)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsEntriesArgs) ToKibanaSpecSecureSettingsEntriesOutput() KibanaSpecSecureSettingsEntriesOutput {
	return i.ToKibanaSpecSecureSettingsEntriesOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsEntriesArgs) ToKibanaSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsEntriesOutput)
}

// KibanaSpecSecureSettingsEntriesArrayInput is an input type that accepts KibanaSpecSecureSettingsEntriesArray and KibanaSpecSecureSettingsEntriesArrayOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsEntriesArrayInput` via:
//
//	KibanaSpecSecureSettingsEntriesArray{ KibanaSpecSecureSettingsEntriesArgs{...} }
type KibanaSpecSecureSettingsEntriesArrayInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsEntriesArrayOutput() KibanaSpecSecureSettingsEntriesArrayOutput
	ToKibanaSpecSecureSettingsEntriesArrayOutputWithContext(context.Context) KibanaSpecSecureSettingsEntriesArrayOutput
}

type KibanaSpecSecureSettingsEntriesArray []KibanaSpecSecureSettingsEntriesInput

func (KibanaSpecSecureSettingsEntriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettingsEntries)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsEntriesArray) ToKibanaSpecSecureSettingsEntriesArrayOutput() KibanaSpecSecureSettingsEntriesArrayOutput {
	return i.ToKibanaSpecSecureSettingsEntriesArrayOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsEntriesArray) ToKibanaSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsEntriesArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type KibanaSpecSecureSettingsEntriesOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsEntriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettingsEntries)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsEntriesOutput) ToKibanaSpecSecureSettingsEntriesOutput() KibanaSpecSecureSettingsEntriesOutput {
	return o
}

func (o KibanaSpecSecureSettingsEntriesOutput) ToKibanaSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesOutput {
	return o
}

// Key is the key contained in the secret.
func (o KibanaSpecSecureSettingsEntriesOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettingsEntries) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o KibanaSpecSecureSettingsEntriesOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettingsEntries) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type KibanaSpecSecureSettingsEntriesArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsEntriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettingsEntries)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsEntriesArrayOutput) ToKibanaSpecSecureSettingsEntriesArrayOutput() KibanaSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsEntriesArrayOutput) ToKibanaSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsEntriesArrayOutput) Index(i pulumi.IntInput) KibanaSpecSecureSettingsEntriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecSecureSettingsEntries {
		return vs[0].([]KibanaSpecSecureSettingsEntries)[vs[1].(int)]
	}).(KibanaSpecSecureSettingsEntriesOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type KibanaSpecSecureSettingsEntriesPatch struct {
	// Key is the key contained in the secret.
	Key *string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// KibanaSpecSecureSettingsEntriesPatchInput is an input type that accepts KibanaSpecSecureSettingsEntriesPatchArgs and KibanaSpecSecureSettingsEntriesPatchOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsEntriesPatchInput` via:
//
//	KibanaSpecSecureSettingsEntriesPatchArgs{...}
type KibanaSpecSecureSettingsEntriesPatchInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsEntriesPatchOutput() KibanaSpecSecureSettingsEntriesPatchOutput
	ToKibanaSpecSecureSettingsEntriesPatchOutputWithContext(context.Context) KibanaSpecSecureSettingsEntriesPatchOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type KibanaSpecSecureSettingsEntriesPatchArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (KibanaSpecSecureSettingsEntriesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsEntriesPatchArgs) ToKibanaSpecSecureSettingsEntriesPatchOutput() KibanaSpecSecureSettingsEntriesPatchOutput {
	return i.ToKibanaSpecSecureSettingsEntriesPatchOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsEntriesPatchArgs) ToKibanaSpecSecureSettingsEntriesPatchOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsEntriesPatchOutput)
}

// KibanaSpecSecureSettingsEntriesPatchArrayInput is an input type that accepts KibanaSpecSecureSettingsEntriesPatchArray and KibanaSpecSecureSettingsEntriesPatchArrayOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsEntriesPatchArrayInput` via:
//
//	KibanaSpecSecureSettingsEntriesPatchArray{ KibanaSpecSecureSettingsEntriesPatchArgs{...} }
type KibanaSpecSecureSettingsEntriesPatchArrayInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsEntriesPatchArrayOutput() KibanaSpecSecureSettingsEntriesPatchArrayOutput
	ToKibanaSpecSecureSettingsEntriesPatchArrayOutputWithContext(context.Context) KibanaSpecSecureSettingsEntriesPatchArrayOutput
}

type KibanaSpecSecureSettingsEntriesPatchArray []KibanaSpecSecureSettingsEntriesPatchInput

func (KibanaSpecSecureSettingsEntriesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsEntriesPatchArray) ToKibanaSpecSecureSettingsEntriesPatchArrayOutput() KibanaSpecSecureSettingsEntriesPatchArrayOutput {
	return i.ToKibanaSpecSecureSettingsEntriesPatchArrayOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsEntriesPatchArray) ToKibanaSpecSecureSettingsEntriesPatchArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsEntriesPatchArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type KibanaSpecSecureSettingsEntriesPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsEntriesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsEntriesPatchOutput) ToKibanaSpecSecureSettingsEntriesPatchOutput() KibanaSpecSecureSettingsEntriesPatchOutput {
	return o
}

func (o KibanaSpecSecureSettingsEntriesPatchOutput) ToKibanaSpecSecureSettingsEntriesPatchOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesPatchOutput {
	return o
}

// Key is the key contained in the secret.
func (o KibanaSpecSecureSettingsEntriesPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettingsEntriesPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o KibanaSpecSecureSettingsEntriesPatchOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettingsEntriesPatch) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type KibanaSpecSecureSettingsEntriesPatchArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsEntriesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsEntriesPatchArrayOutput) ToKibanaSpecSecureSettingsEntriesPatchArrayOutput() KibanaSpecSecureSettingsEntriesPatchArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsEntriesPatchArrayOutput) ToKibanaSpecSecureSettingsEntriesPatchArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsEntriesPatchArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsEntriesPatchArrayOutput) Index(i pulumi.IntInput) KibanaSpecSecureSettingsEntriesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecSecureSettingsEntriesPatch {
		return vs[0].([]KibanaSpecSecureSettingsEntriesPatch)[vs[1].(int)]
	}).(KibanaSpecSecureSettingsEntriesPatchOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type KibanaSpecSecureSettingsPatch struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []KibanaSpecSecureSettingsEntriesPatch `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// KibanaSpecSecureSettingsPatchInput is an input type that accepts KibanaSpecSecureSettingsPatchArgs and KibanaSpecSecureSettingsPatchOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsPatchInput` via:
//
//	KibanaSpecSecureSettingsPatchArgs{...}
type KibanaSpecSecureSettingsPatchInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsPatchOutput() KibanaSpecSecureSettingsPatchOutput
	ToKibanaSpecSecureSettingsPatchOutputWithContext(context.Context) KibanaSpecSecureSettingsPatchOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type KibanaSpecSecureSettingsPatchArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries KibanaSpecSecureSettingsEntriesPatchArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (KibanaSpecSecureSettingsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettingsPatch)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsPatchArgs) ToKibanaSpecSecureSettingsPatchOutput() KibanaSpecSecureSettingsPatchOutput {
	return i.ToKibanaSpecSecureSettingsPatchOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsPatchArgs) ToKibanaSpecSecureSettingsPatchOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsPatchOutput)
}

// KibanaSpecSecureSettingsPatchArrayInput is an input type that accepts KibanaSpecSecureSettingsPatchArray and KibanaSpecSecureSettingsPatchArrayOutput values.
// You can construct a concrete instance of `KibanaSpecSecureSettingsPatchArrayInput` via:
//
//	KibanaSpecSecureSettingsPatchArray{ KibanaSpecSecureSettingsPatchArgs{...} }
type KibanaSpecSecureSettingsPatchArrayInput interface {
	pulumi.Input

	ToKibanaSpecSecureSettingsPatchArrayOutput() KibanaSpecSecureSettingsPatchArrayOutput
	ToKibanaSpecSecureSettingsPatchArrayOutputWithContext(context.Context) KibanaSpecSecureSettingsPatchArrayOutput
}

type KibanaSpecSecureSettingsPatchArray []KibanaSpecSecureSettingsPatchInput

func (KibanaSpecSecureSettingsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettingsPatch)(nil)).Elem()
}

func (i KibanaSpecSecureSettingsPatchArray) ToKibanaSpecSecureSettingsPatchArrayOutput() KibanaSpecSecureSettingsPatchArrayOutput {
	return i.ToKibanaSpecSecureSettingsPatchArrayOutputWithContext(context.Background())
}

func (i KibanaSpecSecureSettingsPatchArray) ToKibanaSpecSecureSettingsPatchArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaSpecSecureSettingsPatchArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type KibanaSpecSecureSettingsPatchOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaSpecSecureSettingsPatch)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsPatchOutput) ToKibanaSpecSecureSettingsPatchOutput() KibanaSpecSecureSettingsPatchOutput {
	return o
}

func (o KibanaSpecSecureSettingsPatchOutput) ToKibanaSpecSecureSettingsPatchOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsPatchOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o KibanaSpecSecureSettingsPatchOutput) Entries() KibanaSpecSecureSettingsEntriesPatchArrayOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettingsPatch) []KibanaSpecSecureSettingsEntriesPatch { return v.Entries }).(KibanaSpecSecureSettingsEntriesPatchArrayOutput)
}

// SecretName is the name of the secret.
func (o KibanaSpecSecureSettingsPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaSpecSecureSettingsPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type KibanaSpecSecureSettingsPatchArrayOutput struct{ *pulumi.OutputState }

func (KibanaSpecSecureSettingsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KibanaSpecSecureSettingsPatch)(nil)).Elem()
}

func (o KibanaSpecSecureSettingsPatchArrayOutput) ToKibanaSpecSecureSettingsPatchArrayOutput() KibanaSpecSecureSettingsPatchArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsPatchArrayOutput) ToKibanaSpecSecureSettingsPatchArrayOutputWithContext(ctx context.Context) KibanaSpecSecureSettingsPatchArrayOutput {
	return o
}

func (o KibanaSpecSecureSettingsPatchArrayOutput) Index(i pulumi.IntInput) KibanaSpecSecureSettingsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KibanaSpecSecureSettingsPatch {
		return vs[0].([]KibanaSpecSecureSettingsPatch)[vs[1].(int)]
	}).(KibanaSpecSecureSettingsPatchOutput)
}

// KibanaStatus defines the observed state of Kibana
type KibanaStatus struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus *string `pulumi:"associationStatus"`
	AvailableNodes    *int    `pulumi:"availableNodes"`
	// KibanaHealth expresses the status of the Kibana instances.
	Health *string `pulumi:"health"`
}

// KibanaStatusInput is an input type that accepts KibanaStatusArgs and KibanaStatusOutput values.
// You can construct a concrete instance of `KibanaStatusInput` via:
//
//	KibanaStatusArgs{...}
type KibanaStatusInput interface {
	pulumi.Input

	ToKibanaStatusOutput() KibanaStatusOutput
	ToKibanaStatusOutputWithContext(context.Context) KibanaStatusOutput
}

// KibanaStatus defines the observed state of Kibana
type KibanaStatusArgs struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus pulumi.StringPtrInput `pulumi:"associationStatus"`
	AvailableNodes    pulumi.IntPtrInput    `pulumi:"availableNodes"`
	// KibanaHealth expresses the status of the Kibana instances.
	Health pulumi.StringPtrInput `pulumi:"health"`
}

func (KibanaStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaStatus)(nil)).Elem()
}

func (i KibanaStatusArgs) ToKibanaStatusOutput() KibanaStatusOutput {
	return i.ToKibanaStatusOutputWithContext(context.Background())
}

func (i KibanaStatusArgs) ToKibanaStatusOutputWithContext(ctx context.Context) KibanaStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaStatusOutput)
}

func (i KibanaStatusArgs) ToKibanaStatusPtrOutput() KibanaStatusPtrOutput {
	return i.ToKibanaStatusPtrOutputWithContext(context.Background())
}

func (i KibanaStatusArgs) ToKibanaStatusPtrOutputWithContext(ctx context.Context) KibanaStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaStatusOutput).ToKibanaStatusPtrOutputWithContext(ctx)
}

// KibanaStatusPtrInput is an input type that accepts KibanaStatusArgs, KibanaStatusPtr and KibanaStatusPtrOutput values.
// You can construct a concrete instance of `KibanaStatusPtrInput` via:
//
//	        KibanaStatusArgs{...}
//
//	or:
//
//	        nil
type KibanaStatusPtrInput interface {
	pulumi.Input

	ToKibanaStatusPtrOutput() KibanaStatusPtrOutput
	ToKibanaStatusPtrOutputWithContext(context.Context) KibanaStatusPtrOutput
}

type kibanaStatusPtrType KibanaStatusArgs

func KibanaStatusPtr(v *KibanaStatusArgs) KibanaStatusPtrInput {
	return (*kibanaStatusPtrType)(v)
}

func (*kibanaStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaStatus)(nil)).Elem()
}

func (i *kibanaStatusPtrType) ToKibanaStatusPtrOutput() KibanaStatusPtrOutput {
	return i.ToKibanaStatusPtrOutputWithContext(context.Background())
}

func (i *kibanaStatusPtrType) ToKibanaStatusPtrOutputWithContext(ctx context.Context) KibanaStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaStatusPtrOutput)
}

// KibanaStatus defines the observed state of Kibana
type KibanaStatusOutput struct{ *pulumi.OutputState }

func (KibanaStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaStatus)(nil)).Elem()
}

func (o KibanaStatusOutput) ToKibanaStatusOutput() KibanaStatusOutput {
	return o
}

func (o KibanaStatusOutput) ToKibanaStatusOutputWithContext(ctx context.Context) KibanaStatusOutput {
	return o
}

func (o KibanaStatusOutput) ToKibanaStatusPtrOutput() KibanaStatusPtrOutput {
	return o.ToKibanaStatusPtrOutputWithContext(context.Background())
}

func (o KibanaStatusOutput) ToKibanaStatusPtrOutputWithContext(ctx context.Context) KibanaStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaStatus) *KibanaStatus {
		return &v
	}).(KibanaStatusPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o KibanaStatusOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaStatus) *string { return v.AssociationStatus }).(pulumi.StringPtrOutput)
}

func (o KibanaStatusOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaStatus) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// KibanaHealth expresses the status of the Kibana instances.
func (o KibanaStatusOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaStatus) *string { return v.Health }).(pulumi.StringPtrOutput)
}

type KibanaStatusPtrOutput struct{ *pulumi.OutputState }

func (KibanaStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaStatus)(nil)).Elem()
}

func (o KibanaStatusPtrOutput) ToKibanaStatusPtrOutput() KibanaStatusPtrOutput {
	return o
}

func (o KibanaStatusPtrOutput) ToKibanaStatusPtrOutputWithContext(ctx context.Context) KibanaStatusPtrOutput {
	return o
}

func (o KibanaStatusPtrOutput) Elem() KibanaStatusOutput {
	return o.ApplyT(func(v *KibanaStatus) KibanaStatus {
		if v != nil {
			return *v
		}
		var ret KibanaStatus
		return ret
	}).(KibanaStatusOutput)
}

// AssociationStatus is the status of an association resource.
func (o KibanaStatusPtrOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaStatus) *string {
		if v == nil {
			return nil
		}
		return v.AssociationStatus
	}).(pulumi.StringPtrOutput)
}

func (o KibanaStatusPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// KibanaHealth expresses the status of the Kibana instances.
func (o KibanaStatusPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaStatus) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// KibanaStatus defines the observed state of Kibana
type KibanaStatusPatch struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus *string `pulumi:"associationStatus"`
	AvailableNodes    *int    `pulumi:"availableNodes"`
	// KibanaHealth expresses the status of the Kibana instances.
	Health *string `pulumi:"health"`
}

// KibanaStatusPatchInput is an input type that accepts KibanaStatusPatchArgs and KibanaStatusPatchOutput values.
// You can construct a concrete instance of `KibanaStatusPatchInput` via:
//
//	KibanaStatusPatchArgs{...}
type KibanaStatusPatchInput interface {
	pulumi.Input

	ToKibanaStatusPatchOutput() KibanaStatusPatchOutput
	ToKibanaStatusPatchOutputWithContext(context.Context) KibanaStatusPatchOutput
}

// KibanaStatus defines the observed state of Kibana
type KibanaStatusPatchArgs struct {
	// AssociationStatus is the status of an association resource.
	AssociationStatus pulumi.StringPtrInput `pulumi:"associationStatus"`
	AvailableNodes    pulumi.IntPtrInput    `pulumi:"availableNodes"`
	// KibanaHealth expresses the status of the Kibana instances.
	Health pulumi.StringPtrInput `pulumi:"health"`
}

func (KibanaStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaStatusPatch)(nil)).Elem()
}

func (i KibanaStatusPatchArgs) ToKibanaStatusPatchOutput() KibanaStatusPatchOutput {
	return i.ToKibanaStatusPatchOutputWithContext(context.Background())
}

func (i KibanaStatusPatchArgs) ToKibanaStatusPatchOutputWithContext(ctx context.Context) KibanaStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaStatusPatchOutput)
}

func (i KibanaStatusPatchArgs) ToKibanaStatusPatchPtrOutput() KibanaStatusPatchPtrOutput {
	return i.ToKibanaStatusPatchPtrOutputWithContext(context.Background())
}

func (i KibanaStatusPatchArgs) ToKibanaStatusPatchPtrOutputWithContext(ctx context.Context) KibanaStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaStatusPatchOutput).ToKibanaStatusPatchPtrOutputWithContext(ctx)
}

// KibanaStatusPatchPtrInput is an input type that accepts KibanaStatusPatchArgs, KibanaStatusPatchPtr and KibanaStatusPatchPtrOutput values.
// You can construct a concrete instance of `KibanaStatusPatchPtrInput` via:
//
//	        KibanaStatusPatchArgs{...}
//
//	or:
//
//	        nil
type KibanaStatusPatchPtrInput interface {
	pulumi.Input

	ToKibanaStatusPatchPtrOutput() KibanaStatusPatchPtrOutput
	ToKibanaStatusPatchPtrOutputWithContext(context.Context) KibanaStatusPatchPtrOutput
}

type kibanaStatusPatchPtrType KibanaStatusPatchArgs

func KibanaStatusPatchPtr(v *KibanaStatusPatchArgs) KibanaStatusPatchPtrInput {
	return (*kibanaStatusPatchPtrType)(v)
}

func (*kibanaStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaStatusPatch)(nil)).Elem()
}

func (i *kibanaStatusPatchPtrType) ToKibanaStatusPatchPtrOutput() KibanaStatusPatchPtrOutput {
	return i.ToKibanaStatusPatchPtrOutputWithContext(context.Background())
}

func (i *kibanaStatusPatchPtrType) ToKibanaStatusPatchPtrOutputWithContext(ctx context.Context) KibanaStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KibanaStatusPatchPtrOutput)
}

// KibanaStatus defines the observed state of Kibana
type KibanaStatusPatchOutput struct{ *pulumi.OutputState }

func (KibanaStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KibanaStatusPatch)(nil)).Elem()
}

func (o KibanaStatusPatchOutput) ToKibanaStatusPatchOutput() KibanaStatusPatchOutput {
	return o
}

func (o KibanaStatusPatchOutput) ToKibanaStatusPatchOutputWithContext(ctx context.Context) KibanaStatusPatchOutput {
	return o
}

func (o KibanaStatusPatchOutput) ToKibanaStatusPatchPtrOutput() KibanaStatusPatchPtrOutput {
	return o.ToKibanaStatusPatchPtrOutputWithContext(context.Background())
}

func (o KibanaStatusPatchOutput) ToKibanaStatusPatchPtrOutputWithContext(ctx context.Context) KibanaStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KibanaStatusPatch) *KibanaStatusPatch {
		return &v
	}).(KibanaStatusPatchPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o KibanaStatusPatchOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaStatusPatch) *string { return v.AssociationStatus }).(pulumi.StringPtrOutput)
}

func (o KibanaStatusPatchOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KibanaStatusPatch) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// KibanaHealth expresses the status of the Kibana instances.
func (o KibanaStatusPatchOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KibanaStatusPatch) *string { return v.Health }).(pulumi.StringPtrOutput)
}

type KibanaStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (KibanaStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KibanaStatusPatch)(nil)).Elem()
}

func (o KibanaStatusPatchPtrOutput) ToKibanaStatusPatchPtrOutput() KibanaStatusPatchPtrOutput {
	return o
}

func (o KibanaStatusPatchPtrOutput) ToKibanaStatusPatchPtrOutputWithContext(ctx context.Context) KibanaStatusPatchPtrOutput {
	return o
}

func (o KibanaStatusPatchPtrOutput) Elem() KibanaStatusPatchOutput {
	return o.ApplyT(func(v *KibanaStatusPatch) KibanaStatusPatch {
		if v != nil {
			return *v
		}
		var ret KibanaStatusPatch
		return ret
	}).(KibanaStatusPatchOutput)
}

// AssociationStatus is the status of an association resource.
func (o KibanaStatusPatchPtrOutput) AssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.AssociationStatus
	}).(pulumi.StringPtrOutput)
}

func (o KibanaStatusPatchPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KibanaStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// KibanaHealth expresses the status of the Kibana instances.
func (o KibanaStatusPatchPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KibanaStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaTypeInput)(nil)).Elem(), KibanaTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaTypeArrayInput)(nil)).Elem(), KibanaTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaListTypeInput)(nil)).Elem(), KibanaListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaPatchTypeInput)(nil)).Elem(), KibanaPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecInput)(nil)).Elem(), KibanaSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecPtrInput)(nil)).Elem(), KibanaSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecElasticsearchRefInput)(nil)).Elem(), KibanaSpecElasticsearchRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecElasticsearchRefPtrInput)(nil)).Elem(), KibanaSpecElasticsearchRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecElasticsearchRefPatchInput)(nil)).Elem(), KibanaSpecElasticsearchRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecElasticsearchRefPatchPtrInput)(nil)).Elem(), KibanaSpecElasticsearchRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpInput)(nil)).Elem(), KibanaSpecHttpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpPtrInput)(nil)).Elem(), KibanaSpecHttpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpPatchInput)(nil)).Elem(), KibanaSpecHttpPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpPatchPtrInput)(nil)).Elem(), KibanaSpecHttpPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceInput)(nil)).Elem(), KibanaSpecHttpServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServicePtrInput)(nil)).Elem(), KibanaSpecHttpServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceMetadataInput)(nil)).Elem(), KibanaSpecHttpServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceMetadataPtrInput)(nil)).Elem(), KibanaSpecHttpServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceMetadataPatchInput)(nil)).Elem(), KibanaSpecHttpServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceMetadataPatchPtrInput)(nil)).Elem(), KibanaSpecHttpServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServicePatchInput)(nil)).Elem(), KibanaSpecHttpServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServicePatchPtrInput)(nil)).Elem(), KibanaSpecHttpServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecInput)(nil)).Elem(), KibanaSpecHttpServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPtrInput)(nil)).Elem(), KibanaSpecHttpServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPatchInput)(nil)).Elem(), KibanaSpecHttpServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPatchPtrInput)(nil)).Elem(), KibanaSpecHttpServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPortsInput)(nil)).Elem(), KibanaSpecHttpServiceSpecPortsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPortsArrayInput)(nil)).Elem(), KibanaSpecHttpServiceSpecPortsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPortsPatchInput)(nil)).Elem(), KibanaSpecHttpServiceSpecPortsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecPortsPatchArrayInput)(nil)).Elem(), KibanaSpecHttpServiceSpecPortsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigPtrInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigPatchInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput)(nil)).Elem(), KibanaSpecHttpServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsInput)(nil)).Elem(), KibanaSpecHttpTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsPtrInput)(nil)).Elem(), KibanaSpecHttpTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsCertificateInput)(nil)).Elem(), KibanaSpecHttpTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsCertificatePtrInput)(nil)).Elem(), KibanaSpecHttpTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsCertificatePatchInput)(nil)).Elem(), KibanaSpecHttpTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsCertificatePatchPtrInput)(nil)).Elem(), KibanaSpecHttpTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsPatchInput)(nil)).Elem(), KibanaSpecHttpTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsPatchPtrInput)(nil)).Elem(), KibanaSpecHttpTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificatePtrInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificatePatchInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificatePatchPtrInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput)(nil)).Elem(), KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecPatchInput)(nil)).Elem(), KibanaSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecPatchPtrInput)(nil)).Elem(), KibanaSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsInput)(nil)).Elem(), KibanaSpecSecureSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsArrayInput)(nil)).Elem(), KibanaSpecSecureSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsEntriesInput)(nil)).Elem(), KibanaSpecSecureSettingsEntriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsEntriesArrayInput)(nil)).Elem(), KibanaSpecSecureSettingsEntriesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsEntriesPatchInput)(nil)).Elem(), KibanaSpecSecureSettingsEntriesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsEntriesPatchArrayInput)(nil)).Elem(), KibanaSpecSecureSettingsEntriesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsPatchInput)(nil)).Elem(), KibanaSpecSecureSettingsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaSpecSecureSettingsPatchArrayInput)(nil)).Elem(), KibanaSpecSecureSettingsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaStatusInput)(nil)).Elem(), KibanaStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaStatusPtrInput)(nil)).Elem(), KibanaStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaStatusPatchInput)(nil)).Elem(), KibanaStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KibanaStatusPatchPtrInput)(nil)).Elem(), KibanaStatusPatchArgs{})
	pulumi.RegisterOutputType(KibanaTypeOutput{})
	pulumi.RegisterOutputType(KibanaTypeArrayOutput{})
	pulumi.RegisterOutputType(KibanaListTypeOutput{})
	pulumi.RegisterOutputType(KibanaPatchTypeOutput{})
	pulumi.RegisterOutputType(KibanaSpecOutput{})
	pulumi.RegisterOutputType(KibanaSpecPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecElasticsearchRefOutput{})
	pulumi.RegisterOutputType(KibanaSpecElasticsearchRefPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecElasticsearchRefPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecElasticsearchRefPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServicePtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceMetadataOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceMetadataPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceMetadataPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServicePatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServicePatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPortsOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPortsArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPortsPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecPortsPatchArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsCertificateOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsCertificatePtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsCertificatePatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificateOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificatePtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificatePatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsEntriesOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsEntriesArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsEntriesPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsEntriesPatchArrayOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsPatchOutput{})
	pulumi.RegisterOutputType(KibanaSpecSecureSettingsPatchArrayOutput{})
	pulumi.RegisterOutputType(KibanaStatusOutput{})
	pulumi.RegisterOutputType(KibanaStatusPtrOutput{})
	pulumi.RegisterOutputType(KibanaStatusPatchOutput{})
	pulumi.RegisterOutputType(KibanaStatusPatchPtrOutput{})
}
