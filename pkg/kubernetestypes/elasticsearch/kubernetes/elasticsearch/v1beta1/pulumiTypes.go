// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
type ElasticsearchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta   `pulumi:"metadata"`
	Spec     *ElasticsearchSpec   `pulumi:"spec"`
	Status   *ElasticsearchStatus `pulumi:"status"`
}

// ElasticsearchTypeInput is an input type that accepts ElasticsearchTypeArgs and ElasticsearchTypeOutput values.
// You can construct a concrete instance of `ElasticsearchTypeInput` via:
//
//	ElasticsearchTypeArgs{...}
type ElasticsearchTypeInput interface {
	pulumi.Input

	ToElasticsearchTypeOutput() ElasticsearchTypeOutput
	ToElasticsearchTypeOutputWithContext(context.Context) ElasticsearchTypeOutput
}

// Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
type ElasticsearchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput   `pulumi:"metadata"`
	Spec     ElasticsearchSpecPtrInput   `pulumi:"spec"`
	Status   ElasticsearchStatusPtrInput `pulumi:"status"`
}

func (ElasticsearchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchType)(nil)).Elem()
}

func (i ElasticsearchTypeArgs) ToElasticsearchTypeOutput() ElasticsearchTypeOutput {
	return i.ToElasticsearchTypeOutputWithContext(context.Background())
}

func (i ElasticsearchTypeArgs) ToElasticsearchTypeOutputWithContext(ctx context.Context) ElasticsearchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchTypeOutput)
}

// ElasticsearchTypeArrayInput is an input type that accepts ElasticsearchTypeArray and ElasticsearchTypeArrayOutput values.
// You can construct a concrete instance of `ElasticsearchTypeArrayInput` via:
//
//	ElasticsearchTypeArray{ ElasticsearchTypeArgs{...} }
type ElasticsearchTypeArrayInput interface {
	pulumi.Input

	ToElasticsearchTypeArrayOutput() ElasticsearchTypeArrayOutput
	ToElasticsearchTypeArrayOutputWithContext(context.Context) ElasticsearchTypeArrayOutput
}

type ElasticsearchTypeArray []ElasticsearchTypeInput

func (ElasticsearchTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchType)(nil)).Elem()
}

func (i ElasticsearchTypeArray) ToElasticsearchTypeArrayOutput() ElasticsearchTypeArrayOutput {
	return i.ToElasticsearchTypeArrayOutputWithContext(context.Background())
}

func (i ElasticsearchTypeArray) ToElasticsearchTypeArrayOutputWithContext(ctx context.Context) ElasticsearchTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchTypeArrayOutput)
}

// Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
type ElasticsearchTypeOutput struct{ *pulumi.OutputState }

func (ElasticsearchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchType)(nil)).Elem()
}

func (o ElasticsearchTypeOutput) ToElasticsearchTypeOutput() ElasticsearchTypeOutput {
	return o
}

func (o ElasticsearchTypeOutput) ToElasticsearchTypeOutputWithContext(ctx context.Context) ElasticsearchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticsearchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticsearchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ElasticsearchTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ElasticsearchType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o ElasticsearchTypeOutput) Spec() ElasticsearchSpecPtrOutput {
	return o.ApplyT(func(v ElasticsearchType) *ElasticsearchSpec { return v.Spec }).(ElasticsearchSpecPtrOutput)
}

func (o ElasticsearchTypeOutput) Status() ElasticsearchStatusPtrOutput {
	return o.ApplyT(func(v ElasticsearchType) *ElasticsearchStatus { return v.Status }).(ElasticsearchStatusPtrOutput)
}

type ElasticsearchTypeArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchType)(nil)).Elem()
}

func (o ElasticsearchTypeArrayOutput) ToElasticsearchTypeArrayOutput() ElasticsearchTypeArrayOutput {
	return o
}

func (o ElasticsearchTypeArrayOutput) ToElasticsearchTypeArrayOutputWithContext(ctx context.Context) ElasticsearchTypeArrayOutput {
	return o
}

func (o ElasticsearchTypeArrayOutput) Index(i pulumi.IntInput) ElasticsearchTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchType {
		return vs[0].([]ElasticsearchType)[vs[1].(int)]
	}).(ElasticsearchTypeOutput)
}

// ElasticsearchList is a list of Elasticsearch
type ElasticsearchListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of elasticsearches. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []ElasticsearchType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ElasticsearchListTypeInput is an input type that accepts ElasticsearchListTypeArgs and ElasticsearchListTypeOutput values.
// You can construct a concrete instance of `ElasticsearchListTypeInput` via:
//
//	ElasticsearchListTypeArgs{...}
type ElasticsearchListTypeInput interface {
	pulumi.Input

	ToElasticsearchListTypeOutput() ElasticsearchListTypeOutput
	ToElasticsearchListTypeOutputWithContext(context.Context) ElasticsearchListTypeOutput
}

// ElasticsearchList is a list of Elasticsearch
type ElasticsearchListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of elasticsearches. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items ElasticsearchTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ElasticsearchListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchListType)(nil)).Elem()
}

func (i ElasticsearchListTypeArgs) ToElasticsearchListTypeOutput() ElasticsearchListTypeOutput {
	return i.ToElasticsearchListTypeOutputWithContext(context.Background())
}

func (i ElasticsearchListTypeArgs) ToElasticsearchListTypeOutputWithContext(ctx context.Context) ElasticsearchListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchListTypeOutput)
}

// ElasticsearchList is a list of Elasticsearch
type ElasticsearchListTypeOutput struct{ *pulumi.OutputState }

func (ElasticsearchListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchListType)(nil)).Elem()
}

func (o ElasticsearchListTypeOutput) ToElasticsearchListTypeOutput() ElasticsearchListTypeOutput {
	return o
}

func (o ElasticsearchListTypeOutput) ToElasticsearchListTypeOutputWithContext(ctx context.Context) ElasticsearchListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticsearchListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of elasticsearches. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o ElasticsearchListTypeOutput) Items() ElasticsearchTypeArrayOutput {
	return o.ApplyT(func(v ElasticsearchListType) []ElasticsearchType { return v.Items }).(ElasticsearchTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticsearchListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticsearchListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ElasticsearchListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
type ElasticsearchPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch   `pulumi:"metadata"`
	Spec     *ElasticsearchSpecPatch   `pulumi:"spec"`
	Status   *ElasticsearchStatusPatch `pulumi:"status"`
}

// ElasticsearchPatchTypeInput is an input type that accepts ElasticsearchPatchTypeArgs and ElasticsearchPatchTypeOutput values.
// You can construct a concrete instance of `ElasticsearchPatchTypeInput` via:
//
//	ElasticsearchPatchTypeArgs{...}
type ElasticsearchPatchTypeInput interface {
	pulumi.Input

	ToElasticsearchPatchTypeOutput() ElasticsearchPatchTypeOutput
	ToElasticsearchPatchTypeOutputWithContext(context.Context) ElasticsearchPatchTypeOutput
}

// Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
type ElasticsearchPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput   `pulumi:"metadata"`
	Spec     ElasticsearchSpecPatchPtrInput   `pulumi:"spec"`
	Status   ElasticsearchStatusPatchPtrInput `pulumi:"status"`
}

func (ElasticsearchPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchPatchType)(nil)).Elem()
}

func (i ElasticsearchPatchTypeArgs) ToElasticsearchPatchTypeOutput() ElasticsearchPatchTypeOutput {
	return i.ToElasticsearchPatchTypeOutputWithContext(context.Background())
}

func (i ElasticsearchPatchTypeArgs) ToElasticsearchPatchTypeOutputWithContext(ctx context.Context) ElasticsearchPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchPatchTypeOutput)
}

// Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
type ElasticsearchPatchTypeOutput struct{ *pulumi.OutputState }

func (ElasticsearchPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchPatchType)(nil)).Elem()
}

func (o ElasticsearchPatchTypeOutput) ToElasticsearchPatchTypeOutput() ElasticsearchPatchTypeOutput {
	return o
}

func (o ElasticsearchPatchTypeOutput) ToElasticsearchPatchTypeOutputWithContext(ctx context.Context) ElasticsearchPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticsearchPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticsearchPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ElasticsearchPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o ElasticsearchPatchTypeOutput) Spec() ElasticsearchSpecPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchPatchType) *ElasticsearchSpecPatch { return v.Spec }).(ElasticsearchSpecPatchPtrOutput)
}

func (o ElasticsearchPatchTypeOutput) Status() ElasticsearchStatusPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchPatchType) *ElasticsearchStatusPatch { return v.Status }).(ElasticsearchStatusPatchPtrOutput)
}

// ElasticsearchSpec holds the specification of an Elasticsearch cluster.
type ElasticsearchSpec struct {
	Http *ElasticsearchSpecHttp `pulumi:"http"`
	// Image is the Elasticsearch Docker image to deploy.
	Image *string `pulumi:"image"`
	// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
	NodeSets            []ElasticsearchSpecNodeSets           `pulumi:"nodeSets"`
	PodDisruptionBudget *ElasticsearchSpecPodDisruptionBudget `pulumi:"podDisruptionBudget"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
	SecureSettings []ElasticsearchSpecSecureSettings `pulumi:"secureSettings"`
	UpdateStrategy *ElasticsearchSpecUpdateStrategy  `pulumi:"updateStrategy"`
	// Version of Elasticsearch.
	Version *string `pulumi:"version"`
}

// ElasticsearchSpecInput is an input type that accepts ElasticsearchSpecArgs and ElasticsearchSpecOutput values.
// You can construct a concrete instance of `ElasticsearchSpecInput` via:
//
//	ElasticsearchSpecArgs{...}
type ElasticsearchSpecInput interface {
	pulumi.Input

	ToElasticsearchSpecOutput() ElasticsearchSpecOutput
	ToElasticsearchSpecOutputWithContext(context.Context) ElasticsearchSpecOutput
}

// ElasticsearchSpec holds the specification of an Elasticsearch cluster.
type ElasticsearchSpecArgs struct {
	Http ElasticsearchSpecHttpPtrInput `pulumi:"http"`
	// Image is the Elasticsearch Docker image to deploy.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
	NodeSets            ElasticsearchSpecNodeSetsArrayInput          `pulumi:"nodeSets"`
	PodDisruptionBudget ElasticsearchSpecPodDisruptionBudgetPtrInput `pulumi:"podDisruptionBudget"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
	SecureSettings ElasticsearchSpecSecureSettingsArrayInput `pulumi:"secureSettings"`
	UpdateStrategy ElasticsearchSpecUpdateStrategyPtrInput   `pulumi:"updateStrategy"`
	// Version of Elasticsearch.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ElasticsearchSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpec)(nil)).Elem()
}

func (i ElasticsearchSpecArgs) ToElasticsearchSpecOutput() ElasticsearchSpecOutput {
	return i.ToElasticsearchSpecOutputWithContext(context.Background())
}

func (i ElasticsearchSpecArgs) ToElasticsearchSpecOutputWithContext(ctx context.Context) ElasticsearchSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecOutput)
}

func (i ElasticsearchSpecArgs) ToElasticsearchSpecPtrOutput() ElasticsearchSpecPtrOutput {
	return i.ToElasticsearchSpecPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecArgs) ToElasticsearchSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecOutput).ToElasticsearchSpecPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPtrInput is an input type that accepts ElasticsearchSpecArgs, ElasticsearchSpecPtr and ElasticsearchSpecPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPtrInput` via:
//
//	        ElasticsearchSpecArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPtrOutput() ElasticsearchSpecPtrOutput
	ToElasticsearchSpecPtrOutputWithContext(context.Context) ElasticsearchSpecPtrOutput
}

type elasticsearchSpecPtrType ElasticsearchSpecArgs

func ElasticsearchSpecPtr(v *ElasticsearchSpecArgs) ElasticsearchSpecPtrInput {
	return (*elasticsearchSpecPtrType)(v)
}

func (*elasticsearchSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpec)(nil)).Elem()
}

func (i *elasticsearchSpecPtrType) ToElasticsearchSpecPtrOutput() ElasticsearchSpecPtrOutput {
	return i.ToElasticsearchSpecPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPtrType) ToElasticsearchSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPtrOutput)
}

// ElasticsearchSpec holds the specification of an Elasticsearch cluster.
type ElasticsearchSpecOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpec)(nil)).Elem()
}

func (o ElasticsearchSpecOutput) ToElasticsearchSpecOutput() ElasticsearchSpecOutput {
	return o
}

func (o ElasticsearchSpecOutput) ToElasticsearchSpecOutputWithContext(ctx context.Context) ElasticsearchSpecOutput {
	return o
}

func (o ElasticsearchSpecOutput) ToElasticsearchSpecPtrOutput() ElasticsearchSpecPtrOutput {
	return o.ToElasticsearchSpecPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecOutput) ToElasticsearchSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpec) *ElasticsearchSpec {
		return &v
	}).(ElasticsearchSpecPtrOutput)
}

func (o ElasticsearchSpecOutput) Http() ElasticsearchSpecHttpPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpec) *ElasticsearchSpecHttp { return v.Http }).(ElasticsearchSpecHttpPtrOutput)
}

// Image is the Elasticsearch Docker image to deploy.
func (o ElasticsearchSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
func (o ElasticsearchSpecOutput) NodeSets() ElasticsearchSpecNodeSetsArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpec) []ElasticsearchSpecNodeSets { return v.NodeSets }).(ElasticsearchSpecNodeSetsArrayOutput)
}

func (o ElasticsearchSpecOutput) PodDisruptionBudget() ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpec) *ElasticsearchSpecPodDisruptionBudget { return v.PodDisruptionBudget }).(ElasticsearchSpecPodDisruptionBudgetPtrOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
func (o ElasticsearchSpecOutput) SecureSettings() ElasticsearchSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpec) []ElasticsearchSpecSecureSettings { return v.SecureSettings }).(ElasticsearchSpecSecureSettingsArrayOutput)
}

func (o ElasticsearchSpecOutput) UpdateStrategy() ElasticsearchSpecUpdateStrategyPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpec) *ElasticsearchSpecUpdateStrategy { return v.UpdateStrategy }).(ElasticsearchSpecUpdateStrategyPtrOutput)
}

// Version of Elasticsearch.
func (o ElasticsearchSpecOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpec) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpec)(nil)).Elem()
}

func (o ElasticsearchSpecPtrOutput) ToElasticsearchSpecPtrOutput() ElasticsearchSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecPtrOutput) ToElasticsearchSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecPtrOutput) Elem() ElasticsearchSpecOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) ElasticsearchSpec {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpec
		return ret
	}).(ElasticsearchSpecOutput)
}

func (o ElasticsearchSpecPtrOutput) Http() ElasticsearchSpecHttpPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) *ElasticsearchSpecHttp {
		if v == nil {
			return nil
		}
		return v.Http
	}).(ElasticsearchSpecHttpPtrOutput)
}

// Image is the Elasticsearch Docker image to deploy.
func (o ElasticsearchSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
func (o ElasticsearchSpecPtrOutput) NodeSets() ElasticsearchSpecNodeSetsArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) []ElasticsearchSpecNodeSets {
		if v == nil {
			return nil
		}
		return v.NodeSets
	}).(ElasticsearchSpecNodeSetsArrayOutput)
}

func (o ElasticsearchSpecPtrOutput) PodDisruptionBudget() ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) *ElasticsearchSpecPodDisruptionBudget {
		if v == nil {
			return nil
		}
		return v.PodDisruptionBudget
	}).(ElasticsearchSpecPodDisruptionBudgetPtrOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
func (o ElasticsearchSpecPtrOutput) SecureSettings() ElasticsearchSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) []ElasticsearchSpecSecureSettings {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(ElasticsearchSpecSecureSettingsArrayOutput)
}

func (o ElasticsearchSpecPtrOutput) UpdateStrategy() ElasticsearchSpecUpdateStrategyPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) *ElasticsearchSpecUpdateStrategy {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(ElasticsearchSpecUpdateStrategyPtrOutput)
}

// Version of Elasticsearch.
func (o ElasticsearchSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpec) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// HTTP holds HTTP layer settings for Elasticsearch.
type ElasticsearchSpecHttp struct {
	Service *ElasticsearchSpecHttpService `pulumi:"service"`
	Tls     *ElasticsearchSpecHttpTls     `pulumi:"tls"`
}

// ElasticsearchSpecHttpInput is an input type that accepts ElasticsearchSpecHttpArgs and ElasticsearchSpecHttpOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpInput` via:
//
//	ElasticsearchSpecHttpArgs{...}
type ElasticsearchSpecHttpInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpOutput() ElasticsearchSpecHttpOutput
	ToElasticsearchSpecHttpOutputWithContext(context.Context) ElasticsearchSpecHttpOutput
}

// HTTP holds HTTP layer settings for Elasticsearch.
type ElasticsearchSpecHttpArgs struct {
	Service ElasticsearchSpecHttpServicePtrInput `pulumi:"service"`
	Tls     ElasticsearchSpecHttpTlsPtrInput     `pulumi:"tls"`
}

func (ElasticsearchSpecHttpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttp)(nil)).Elem()
}

func (i ElasticsearchSpecHttpArgs) ToElasticsearchSpecHttpOutput() ElasticsearchSpecHttpOutput {
	return i.ToElasticsearchSpecHttpOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpArgs) ToElasticsearchSpecHttpOutputWithContext(ctx context.Context) ElasticsearchSpecHttpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpOutput)
}

func (i ElasticsearchSpecHttpArgs) ToElasticsearchSpecHttpPtrOutput() ElasticsearchSpecHttpPtrOutput {
	return i.ToElasticsearchSpecHttpPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpArgs) ToElasticsearchSpecHttpPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpOutput).ToElasticsearchSpecHttpPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpPtrInput is an input type that accepts ElasticsearchSpecHttpArgs, ElasticsearchSpecHttpPtr and ElasticsearchSpecHttpPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpPtrInput` via:
//
//	        ElasticsearchSpecHttpArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpPtrOutput() ElasticsearchSpecHttpPtrOutput
	ToElasticsearchSpecHttpPtrOutputWithContext(context.Context) ElasticsearchSpecHttpPtrOutput
}

type elasticsearchSpecHttpPtrType ElasticsearchSpecHttpArgs

func ElasticsearchSpecHttpPtr(v *ElasticsearchSpecHttpArgs) ElasticsearchSpecHttpPtrInput {
	return (*elasticsearchSpecHttpPtrType)(v)
}

func (*elasticsearchSpecHttpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttp)(nil)).Elem()
}

func (i *elasticsearchSpecHttpPtrType) ToElasticsearchSpecHttpPtrOutput() ElasticsearchSpecHttpPtrOutput {
	return i.ToElasticsearchSpecHttpPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpPtrType) ToElasticsearchSpecHttpPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpPtrOutput)
}

// HTTP holds HTTP layer settings for Elasticsearch.
type ElasticsearchSpecHttpOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttp)(nil)).Elem()
}

func (o ElasticsearchSpecHttpOutput) ToElasticsearchSpecHttpOutput() ElasticsearchSpecHttpOutput {
	return o
}

func (o ElasticsearchSpecHttpOutput) ToElasticsearchSpecHttpOutputWithContext(ctx context.Context) ElasticsearchSpecHttpOutput {
	return o
}

func (o ElasticsearchSpecHttpOutput) ToElasticsearchSpecHttpPtrOutput() ElasticsearchSpecHttpPtrOutput {
	return o.ToElasticsearchSpecHttpPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpOutput) ToElasticsearchSpecHttpPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttp) *ElasticsearchSpecHttp {
		return &v
	}).(ElasticsearchSpecHttpPtrOutput)
}

func (o ElasticsearchSpecHttpOutput) Service() ElasticsearchSpecHttpServicePtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttp) *ElasticsearchSpecHttpService { return v.Service }).(ElasticsearchSpecHttpServicePtrOutput)
}

func (o ElasticsearchSpecHttpOutput) Tls() ElasticsearchSpecHttpTlsPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttp) *ElasticsearchSpecHttpTls { return v.Tls }).(ElasticsearchSpecHttpTlsPtrOutput)
}

type ElasticsearchSpecHttpPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttp)(nil)).Elem()
}

func (o ElasticsearchSpecHttpPtrOutput) ToElasticsearchSpecHttpPtrOutput() ElasticsearchSpecHttpPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpPtrOutput) ToElasticsearchSpecHttpPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpPtrOutput) Elem() ElasticsearchSpecHttpOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttp) ElasticsearchSpecHttp {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttp
		return ret
	}).(ElasticsearchSpecHttpOutput)
}

func (o ElasticsearchSpecHttpPtrOutput) Service() ElasticsearchSpecHttpServicePtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttp) *ElasticsearchSpecHttpService {
		if v == nil {
			return nil
		}
		return v.Service
	}).(ElasticsearchSpecHttpServicePtrOutput)
}

func (o ElasticsearchSpecHttpPtrOutput) Tls() ElasticsearchSpecHttpTlsPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttp) *ElasticsearchSpecHttpTls {
		if v == nil {
			return nil
		}
		return v.Tls
	}).(ElasticsearchSpecHttpTlsPtrOutput)
}

// HTTP holds HTTP layer settings for Elasticsearch.
type ElasticsearchSpecHttpPatch struct {
	Service *ElasticsearchSpecHttpServicePatch `pulumi:"service"`
	Tls     *ElasticsearchSpecHttpTlsPatch     `pulumi:"tls"`
}

// ElasticsearchSpecHttpPatchInput is an input type that accepts ElasticsearchSpecHttpPatchArgs and ElasticsearchSpecHttpPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpPatchInput` via:
//
//	ElasticsearchSpecHttpPatchArgs{...}
type ElasticsearchSpecHttpPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpPatchOutput() ElasticsearchSpecHttpPatchOutput
	ToElasticsearchSpecHttpPatchOutputWithContext(context.Context) ElasticsearchSpecHttpPatchOutput
}

// HTTP holds HTTP layer settings for Elasticsearch.
type ElasticsearchSpecHttpPatchArgs struct {
	Service ElasticsearchSpecHttpServicePatchPtrInput `pulumi:"service"`
	Tls     ElasticsearchSpecHttpTlsPatchPtrInput     `pulumi:"tls"`
}

func (ElasticsearchSpecHttpPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpPatchArgs) ToElasticsearchSpecHttpPatchOutput() ElasticsearchSpecHttpPatchOutput {
	return i.ToElasticsearchSpecHttpPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpPatchArgs) ToElasticsearchSpecHttpPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpPatchOutput)
}

func (i ElasticsearchSpecHttpPatchArgs) ToElasticsearchSpecHttpPatchPtrOutput() ElasticsearchSpecHttpPatchPtrOutput {
	return i.ToElasticsearchSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpPatchArgs) ToElasticsearchSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpPatchOutput).ToElasticsearchSpecHttpPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpPatchPtrInput is an input type that accepts ElasticsearchSpecHttpPatchArgs, ElasticsearchSpecHttpPatchPtr and ElasticsearchSpecHttpPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpPatchPtrInput` via:
//
//	        ElasticsearchSpecHttpPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpPatchPtrOutput() ElasticsearchSpecHttpPatchPtrOutput
	ToElasticsearchSpecHttpPatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpPatchPtrOutput
}

type elasticsearchSpecHttpPatchPtrType ElasticsearchSpecHttpPatchArgs

func ElasticsearchSpecHttpPatchPtr(v *ElasticsearchSpecHttpPatchArgs) ElasticsearchSpecHttpPatchPtrInput {
	return (*elasticsearchSpecHttpPatchPtrType)(v)
}

func (*elasticsearchSpecHttpPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpPatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpPatchPtrType) ToElasticsearchSpecHttpPatchPtrOutput() ElasticsearchSpecHttpPatchPtrOutput {
	return i.ToElasticsearchSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpPatchPtrType) ToElasticsearchSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpPatchPtrOutput)
}

// HTTP holds HTTP layer settings for Elasticsearch.
type ElasticsearchSpecHttpPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpPatchOutput) ToElasticsearchSpecHttpPatchOutput() ElasticsearchSpecHttpPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpPatchOutput) ToElasticsearchSpecHttpPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpPatchOutput) ToElasticsearchSpecHttpPatchPtrOutput() ElasticsearchSpecHttpPatchPtrOutput {
	return o.ToElasticsearchSpecHttpPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpPatchOutput) ToElasticsearchSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpPatch) *ElasticsearchSpecHttpPatch {
		return &v
	}).(ElasticsearchSpecHttpPatchPtrOutput)
}

func (o ElasticsearchSpecHttpPatchOutput) Service() ElasticsearchSpecHttpServicePatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpPatch) *ElasticsearchSpecHttpServicePatch { return v.Service }).(ElasticsearchSpecHttpServicePatchPtrOutput)
}

func (o ElasticsearchSpecHttpPatchOutput) Tls() ElasticsearchSpecHttpTlsPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpPatch) *ElasticsearchSpecHttpTlsPatch { return v.Tls }).(ElasticsearchSpecHttpTlsPatchPtrOutput)
}

type ElasticsearchSpecHttpPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpPatchPtrOutput) ToElasticsearchSpecHttpPatchPtrOutput() ElasticsearchSpecHttpPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpPatchPtrOutput) ToElasticsearchSpecHttpPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpPatchPtrOutput) Elem() ElasticsearchSpecHttpPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpPatch) ElasticsearchSpecHttpPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpPatch
		return ret
	}).(ElasticsearchSpecHttpPatchOutput)
}

func (o ElasticsearchSpecHttpPatchPtrOutput) Service() ElasticsearchSpecHttpServicePatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpPatch) *ElasticsearchSpecHttpServicePatch {
		if v == nil {
			return nil
		}
		return v.Service
	}).(ElasticsearchSpecHttpServicePatchPtrOutput)
}

func (o ElasticsearchSpecHttpPatchPtrOutput) Tls() ElasticsearchSpecHttpTlsPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpPatch) *ElasticsearchSpecHttpTlsPatch {
		if v == nil {
			return nil
		}
		return v.Tls
	}).(ElasticsearchSpecHttpTlsPatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticsearchSpecHttpService struct {
	Metadata *ElasticsearchSpecHttpServiceMetadata `pulumi:"metadata"`
	Spec     *ElasticsearchSpecHttpServiceSpec     `pulumi:"spec"`
}

// ElasticsearchSpecHttpServiceInput is an input type that accepts ElasticsearchSpecHttpServiceArgs and ElasticsearchSpecHttpServiceOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceInput` via:
//
//	ElasticsearchSpecHttpServiceArgs{...}
type ElasticsearchSpecHttpServiceInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceOutput() ElasticsearchSpecHttpServiceOutput
	ToElasticsearchSpecHttpServiceOutputWithContext(context.Context) ElasticsearchSpecHttpServiceOutput
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticsearchSpecHttpServiceArgs struct {
	Metadata ElasticsearchSpecHttpServiceMetadataPtrInput `pulumi:"metadata"`
	Spec     ElasticsearchSpecHttpServiceSpecPtrInput     `pulumi:"spec"`
}

func (ElasticsearchSpecHttpServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpService)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceArgs) ToElasticsearchSpecHttpServiceOutput() ElasticsearchSpecHttpServiceOutput {
	return i.ToElasticsearchSpecHttpServiceOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceArgs) ToElasticsearchSpecHttpServiceOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceOutput)
}

func (i ElasticsearchSpecHttpServiceArgs) ToElasticsearchSpecHttpServicePtrOutput() ElasticsearchSpecHttpServicePtrOutput {
	return i.ToElasticsearchSpecHttpServicePtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceArgs) ToElasticsearchSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceOutput).ToElasticsearchSpecHttpServicePtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServicePtrInput is an input type that accepts ElasticsearchSpecHttpServiceArgs, ElasticsearchSpecHttpServicePtr and ElasticsearchSpecHttpServicePtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServicePtrInput` via:
//
//	        ElasticsearchSpecHttpServiceArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServicePtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServicePtrOutput() ElasticsearchSpecHttpServicePtrOutput
	ToElasticsearchSpecHttpServicePtrOutputWithContext(context.Context) ElasticsearchSpecHttpServicePtrOutput
}

type elasticsearchSpecHttpServicePtrType ElasticsearchSpecHttpServiceArgs

func ElasticsearchSpecHttpServicePtr(v *ElasticsearchSpecHttpServiceArgs) ElasticsearchSpecHttpServicePtrInput {
	return (*elasticsearchSpecHttpServicePtrType)(v)
}

func (*elasticsearchSpecHttpServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpService)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServicePtrType) ToElasticsearchSpecHttpServicePtrOutput() ElasticsearchSpecHttpServicePtrOutput {
	return i.ToElasticsearchSpecHttpServicePtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServicePtrType) ToElasticsearchSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServicePtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticsearchSpecHttpServiceOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpService)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceOutput) ToElasticsearchSpecHttpServiceOutput() ElasticsearchSpecHttpServiceOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceOutput) ToElasticsearchSpecHttpServiceOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceOutput) ToElasticsearchSpecHttpServicePtrOutput() ElasticsearchSpecHttpServicePtrOutput {
	return o.ToElasticsearchSpecHttpServicePtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceOutput) ToElasticsearchSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpService) *ElasticsearchSpecHttpService {
		return &v
	}).(ElasticsearchSpecHttpServicePtrOutput)
}

func (o ElasticsearchSpecHttpServiceOutput) Metadata() ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpService) *ElasticsearchSpecHttpServiceMetadata { return v.Metadata }).(ElasticsearchSpecHttpServiceMetadataPtrOutput)
}

func (o ElasticsearchSpecHttpServiceOutput) Spec() ElasticsearchSpecHttpServiceSpecPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpService) *ElasticsearchSpecHttpServiceSpec { return v.Spec }).(ElasticsearchSpecHttpServiceSpecPtrOutput)
}

type ElasticsearchSpecHttpServicePtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpService)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServicePtrOutput) ToElasticsearchSpecHttpServicePtrOutput() ElasticsearchSpecHttpServicePtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServicePtrOutput) ToElasticsearchSpecHttpServicePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServicePtrOutput) Elem() ElasticsearchSpecHttpServiceOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpService) ElasticsearchSpecHttpService {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpService
		return ret
	}).(ElasticsearchSpecHttpServiceOutput)
}

func (o ElasticsearchSpecHttpServicePtrOutput) Metadata() ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpService) *ElasticsearchSpecHttpServiceMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ElasticsearchSpecHttpServiceMetadataPtrOutput)
}

func (o ElasticsearchSpecHttpServicePtrOutput) Spec() ElasticsearchSpecHttpServiceSpecPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpService) *ElasticsearchSpecHttpServiceSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ElasticsearchSpecHttpServiceSpecPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecHttpServiceMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticsearchSpecHttpServiceMetadataInput is an input type that accepts ElasticsearchSpecHttpServiceMetadataArgs and ElasticsearchSpecHttpServiceMetadataOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceMetadataInput` via:
//
//	ElasticsearchSpecHttpServiceMetadataArgs{...}
type ElasticsearchSpecHttpServiceMetadataInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceMetadataOutput() ElasticsearchSpecHttpServiceMetadataOutput
	ToElasticsearchSpecHttpServiceMetadataOutputWithContext(context.Context) ElasticsearchSpecHttpServiceMetadataOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecHttpServiceMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticsearchSpecHttpServiceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadata)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceMetadataArgs) ToElasticsearchSpecHttpServiceMetadataOutput() ElasticsearchSpecHttpServiceMetadataOutput {
	return i.ToElasticsearchSpecHttpServiceMetadataOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceMetadataArgs) ToElasticsearchSpecHttpServiceMetadataOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceMetadataOutput)
}

func (i ElasticsearchSpecHttpServiceMetadataArgs) ToElasticsearchSpecHttpServiceMetadataPtrOutput() ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return i.ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceMetadataArgs) ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceMetadataOutput).ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceMetadataPtrInput is an input type that accepts ElasticsearchSpecHttpServiceMetadataArgs, ElasticsearchSpecHttpServiceMetadataPtr and ElasticsearchSpecHttpServiceMetadataPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceMetadataPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceMetadataArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceMetadataPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceMetadataPtrOutput() ElasticsearchSpecHttpServiceMetadataPtrOutput
	ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceMetadataPtrOutput
}

type elasticsearchSpecHttpServiceMetadataPtrType ElasticsearchSpecHttpServiceMetadataArgs

func ElasticsearchSpecHttpServiceMetadataPtr(v *ElasticsearchSpecHttpServiceMetadataArgs) ElasticsearchSpecHttpServiceMetadataPtrInput {
	return (*elasticsearchSpecHttpServiceMetadataPtrType)(v)
}

func (*elasticsearchSpecHttpServiceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceMetadata)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceMetadataPtrType) ToElasticsearchSpecHttpServiceMetadataPtrOutput() ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return i.ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceMetadataPtrType) ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceMetadataPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecHttpServiceMetadataOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadata)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) ToElasticsearchSpecHttpServiceMetadataOutput() ElasticsearchSpecHttpServiceMetadataOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) ToElasticsearchSpecHttpServiceMetadataOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) ToElasticsearchSpecHttpServiceMetadataPtrOutput() ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return o.ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceMetadata) *ElasticsearchSpecHttpServiceMetadata {
		return &v
	}).(ElasticsearchSpecHttpServiceMetadataPtrOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpServiceMetadataPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceMetadata)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) ToElasticsearchSpecHttpServiceMetadataPtrOutput() ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) ToElasticsearchSpecHttpServiceMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) Elem() ElasticsearchSpecHttpServiceMetadataOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadata) ElasticsearchSpecHttpServiceMetadata {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceMetadata
		return ret
	}).(ElasticsearchSpecHttpServiceMetadataOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecHttpServiceMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticsearchSpecHttpServiceMetadataPatchInput is an input type that accepts ElasticsearchSpecHttpServiceMetadataPatchArgs and ElasticsearchSpecHttpServiceMetadataPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceMetadataPatchInput` via:
//
//	ElasticsearchSpecHttpServiceMetadataPatchArgs{...}
type ElasticsearchSpecHttpServiceMetadataPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceMetadataPatchOutput() ElasticsearchSpecHttpServiceMetadataPatchOutput
	ToElasticsearchSpecHttpServiceMetadataPatchOutputWithContext(context.Context) ElasticsearchSpecHttpServiceMetadataPatchOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecHttpServiceMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticsearchSpecHttpServiceMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceMetadataPatchArgs) ToElasticsearchSpecHttpServiceMetadataPatchOutput() ElasticsearchSpecHttpServiceMetadataPatchOutput {
	return i.ToElasticsearchSpecHttpServiceMetadataPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceMetadataPatchArgs) ToElasticsearchSpecHttpServiceMetadataPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceMetadataPatchOutput)
}

func (i ElasticsearchSpecHttpServiceMetadataPatchArgs) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutput() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceMetadataPatchArgs) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceMetadataPatchOutput).ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceMetadataPatchPtrInput is an input type that accepts ElasticsearchSpecHttpServiceMetadataPatchArgs, ElasticsearchSpecHttpServiceMetadataPatchPtr and ElasticsearchSpecHttpServiceMetadataPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceMetadataPatchPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceMetadataPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceMetadataPatchPtrOutput() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput
	ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceMetadataPatchPtrOutput
}

type elasticsearchSpecHttpServiceMetadataPatchPtrType ElasticsearchSpecHttpServiceMetadataPatchArgs

func ElasticsearchSpecHttpServiceMetadataPatchPtr(v *ElasticsearchSpecHttpServiceMetadataPatchArgs) ElasticsearchSpecHttpServiceMetadataPatchPtrInput {
	return (*elasticsearchSpecHttpServiceMetadataPatchPtrType)(v)
}

func (*elasticsearchSpecHttpServiceMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceMetadataPatchPtrType) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutput() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceMetadataPatchPtrType) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceMetadataPatchPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecHttpServiceMetadataPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) ToElasticsearchSpecHttpServiceMetadataPatchOutput() ElasticsearchSpecHttpServiceMetadataPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) ToElasticsearchSpecHttpServiceMetadataPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutput() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return o.ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceMetadataPatch) *ElasticsearchSpecHttpServiceMetadataPatch {
		return &v
	}).(ElasticsearchSpecHttpServiceMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadataPatch) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpServiceMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceMetadataPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutput() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) ToElasticsearchSpecHttpServiceMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) Elem() ElasticsearchSpecHttpServiceMetadataPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadataPatch) ElasticsearchSpecHttpServiceMetadataPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceMetadataPatch
		return ret
	}).(ElasticsearchSpecHttpServiceMetadataPatchOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticsearchSpecHttpServicePatch struct {
	Metadata *ElasticsearchSpecHttpServiceMetadataPatch `pulumi:"metadata"`
	Spec     *ElasticsearchSpecHttpServiceSpecPatch     `pulumi:"spec"`
}

// ElasticsearchSpecHttpServicePatchInput is an input type that accepts ElasticsearchSpecHttpServicePatchArgs and ElasticsearchSpecHttpServicePatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServicePatchInput` via:
//
//	ElasticsearchSpecHttpServicePatchArgs{...}
type ElasticsearchSpecHttpServicePatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServicePatchOutput() ElasticsearchSpecHttpServicePatchOutput
	ToElasticsearchSpecHttpServicePatchOutputWithContext(context.Context) ElasticsearchSpecHttpServicePatchOutput
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticsearchSpecHttpServicePatchArgs struct {
	Metadata ElasticsearchSpecHttpServiceMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     ElasticsearchSpecHttpServiceSpecPatchPtrInput     `pulumi:"spec"`
}

func (ElasticsearchSpecHttpServicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServicePatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServicePatchArgs) ToElasticsearchSpecHttpServicePatchOutput() ElasticsearchSpecHttpServicePatchOutput {
	return i.ToElasticsearchSpecHttpServicePatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServicePatchArgs) ToElasticsearchSpecHttpServicePatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServicePatchOutput)
}

func (i ElasticsearchSpecHttpServicePatchArgs) ToElasticsearchSpecHttpServicePatchPtrOutput() ElasticsearchSpecHttpServicePatchPtrOutput {
	return i.ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServicePatchArgs) ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServicePatchOutput).ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServicePatchPtrInput is an input type that accepts ElasticsearchSpecHttpServicePatchArgs, ElasticsearchSpecHttpServicePatchPtr and ElasticsearchSpecHttpServicePatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServicePatchPtrInput` via:
//
//	        ElasticsearchSpecHttpServicePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServicePatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServicePatchPtrOutput() ElasticsearchSpecHttpServicePatchPtrOutput
	ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServicePatchPtrOutput
}

type elasticsearchSpecHttpServicePatchPtrType ElasticsearchSpecHttpServicePatchArgs

func ElasticsearchSpecHttpServicePatchPtr(v *ElasticsearchSpecHttpServicePatchArgs) ElasticsearchSpecHttpServicePatchPtrInput {
	return (*elasticsearchSpecHttpServicePatchPtrType)(v)
}

func (*elasticsearchSpecHttpServicePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServicePatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServicePatchPtrType) ToElasticsearchSpecHttpServicePatchPtrOutput() ElasticsearchSpecHttpServicePatchPtrOutput {
	return i.ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServicePatchPtrType) ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServicePatchPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type ElasticsearchSpecHttpServicePatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServicePatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServicePatchOutput) ToElasticsearchSpecHttpServicePatchOutput() ElasticsearchSpecHttpServicePatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServicePatchOutput) ToElasticsearchSpecHttpServicePatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServicePatchOutput) ToElasticsearchSpecHttpServicePatchPtrOutput() ElasticsearchSpecHttpServicePatchPtrOutput {
	return o.ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServicePatchOutput) ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServicePatch) *ElasticsearchSpecHttpServicePatch {
		return &v
	}).(ElasticsearchSpecHttpServicePatchPtrOutput)
}

func (o ElasticsearchSpecHttpServicePatchOutput) Metadata() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServicePatch) *ElasticsearchSpecHttpServiceMetadataPatch {
		return v.Metadata
	}).(ElasticsearchSpecHttpServiceMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecHttpServicePatchOutput) Spec() ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServicePatch) *ElasticsearchSpecHttpServiceSpecPatch { return v.Spec }).(ElasticsearchSpecHttpServiceSpecPatchPtrOutput)
}

type ElasticsearchSpecHttpServicePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServicePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServicePatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServicePatchPtrOutput) ToElasticsearchSpecHttpServicePatchPtrOutput() ElasticsearchSpecHttpServicePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServicePatchPtrOutput) ToElasticsearchSpecHttpServicePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServicePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServicePatchPtrOutput) Elem() ElasticsearchSpecHttpServicePatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServicePatch) ElasticsearchSpecHttpServicePatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServicePatch
		return ret
	}).(ElasticsearchSpecHttpServicePatchOutput)
}

func (o ElasticsearchSpecHttpServicePatchPtrOutput) Metadata() ElasticsearchSpecHttpServiceMetadataPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServicePatch) *ElasticsearchSpecHttpServiceMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ElasticsearchSpecHttpServiceMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecHttpServicePatchPtrOutput) Spec() ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServicePatch) *ElasticsearchSpecHttpServiceSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ElasticsearchSpecHttpServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type ElasticsearchSpecHttpServiceSpec struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []ElasticsearchSpecHttpServiceSpecPorts `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                                `pulumi:"sessionAffinity"`
	SessionAffinityConfig *ElasticsearchSpecHttpServiceSpecSessionAffinityConfig `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// ElasticsearchSpecHttpServiceSpecInput is an input type that accepts ElasticsearchSpecHttpServiceSpecArgs and ElasticsearchSpecHttpServiceSpecOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecInput` via:
//
//	ElasticsearchSpecHttpServiceSpecArgs{...}
type ElasticsearchSpecHttpServiceSpecInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecOutput() ElasticsearchSpecHttpServiceSpecOutput
	ToElasticsearchSpecHttpServiceSpecOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecOutput
}

// Spec is the specification of the service.
type ElasticsearchSpecHttpServiceSpecArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports ElasticsearchSpecHttpServiceSpecPortsArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                         `pulumi:"sessionAffinity"`
	SessionAffinityConfig ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ElasticsearchSpecHttpServiceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpec)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecArgs) ToElasticsearchSpecHttpServiceSpecOutput() ElasticsearchSpecHttpServiceSpecOutput {
	return i.ToElasticsearchSpecHttpServiceSpecOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecArgs) ToElasticsearchSpecHttpServiceSpecOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecOutput)
}

func (i ElasticsearchSpecHttpServiceSpecArgs) ToElasticsearchSpecHttpServiceSpecPtrOutput() ElasticsearchSpecHttpServiceSpecPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecArgs) ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecOutput).ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceSpecPtrInput is an input type that accepts ElasticsearchSpecHttpServiceSpecArgs, ElasticsearchSpecHttpServiceSpecPtr and ElasticsearchSpecHttpServiceSpecPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceSpecArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceSpecPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPtrOutput() ElasticsearchSpecHttpServiceSpecPtrOutput
	ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPtrOutput
}

type elasticsearchSpecHttpServiceSpecPtrType ElasticsearchSpecHttpServiceSpecArgs

func ElasticsearchSpecHttpServiceSpecPtr(v *ElasticsearchSpecHttpServiceSpecArgs) ElasticsearchSpecHttpServiceSpecPtrInput {
	return (*elasticsearchSpecHttpServiceSpecPtrType)(v)
}

func (*elasticsearchSpecHttpServiceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpec)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceSpecPtrType) ToElasticsearchSpecHttpServiceSpecPtrOutput() ElasticsearchSpecHttpServiceSpecPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceSpecPtrType) ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPtrOutput)
}

// Spec is the specification of the service.
type ElasticsearchSpecHttpServiceSpecOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpec)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecOutput) ToElasticsearchSpecHttpServiceSpecOutput() ElasticsearchSpecHttpServiceSpecOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecOutput) ToElasticsearchSpecHttpServiceSpecOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecOutput) ToElasticsearchSpecHttpServiceSpecPtrOutput() ElasticsearchSpecHttpServiceSpecPtrOutput {
	return o.ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceSpecOutput) ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceSpec) *ElasticsearchSpecHttpServiceSpec {
		return &v
	}).(ElasticsearchSpecHttpServiceSpecPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticsearchSpecHttpServiceSpecOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticsearchSpecHttpServiceSpecOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticsearchSpecHttpServiceSpecOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticsearchSpecHttpServiceSpecOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticsearchSpecHttpServiceSpecOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticsearchSpecHttpServiceSpecOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticsearchSpecHttpServiceSpecOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticsearchSpecHttpServiceSpecOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticsearchSpecHttpServiceSpecOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticsearchSpecHttpServiceSpecOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticsearchSpecHttpServiceSpecOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecOutput) Ports() ElasticsearchSpecHttpServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) []ElasticsearchSpecHttpServiceSpecPorts { return v.Ports }).(ElasticsearchSpecHttpServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticsearchSpecHttpServiceSpecOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticsearchSpecHttpServiceSpecOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceSpecOutput) SessionAffinityConfig() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfig {
		return v.SessionAffinityConfig
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticsearchSpecHttpServiceSpecOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticsearchSpecHttpServiceSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpServiceSpecPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpec)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ToElasticsearchSpecHttpServiceSpecPtrOutput() ElasticsearchSpecHttpServiceSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ToElasticsearchSpecHttpServiceSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPtrOutput) Elem() ElasticsearchSpecHttpServiceSpecOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) ElasticsearchSpecHttpServiceSpec {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceSpec
		return ret
	}).(ElasticsearchSpecHttpServiceSpecOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) Ports() ElasticsearchSpecHttpServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) []ElasticsearchSpecHttpServiceSpecPorts {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(ElasticsearchSpecHttpServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceSpecPtrOutput) SessionAffinityConfig() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfig {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticsearchSpecHttpServiceSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Spec is the specification of the service.
type ElasticsearchSpecHttpServiceSpecPatch struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []ElasticsearchSpecHttpServiceSpecPortsPatch `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       *string                                                     `pulumi:"sessionAffinity"`
	SessionAffinityConfig *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// ElasticsearchSpecHttpServiceSpecPatchInput is an input type that accepts ElasticsearchSpecHttpServiceSpecPatchArgs and ElasticsearchSpecHttpServiceSpecPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPatchInput` via:
//
//	ElasticsearchSpecHttpServiceSpecPatchArgs{...}
type ElasticsearchSpecHttpServiceSpecPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPatchOutput() ElasticsearchSpecHttpServiceSpecPatchOutput
	ToElasticsearchSpecHttpServiceSpecPatchOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPatchOutput
}

// Spec is the specification of the service.
type ElasticsearchSpecHttpServiceSpecPatchArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports ElasticsearchSpecHttpServiceSpecPortsPatchArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity       pulumi.StringPtrInput                                              `pulumi:"sessionAffinity"`
	SessionAffinityConfig ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ElasticsearchSpecHttpServiceSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecPatchArgs) ToElasticsearchSpecHttpServiceSpecPatchOutput() ElasticsearchSpecHttpServiceSpecPatchOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecPatchArgs) ToElasticsearchSpecHttpServiceSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPatchOutput)
}

func (i ElasticsearchSpecHttpServiceSpecPatchArgs) ToElasticsearchSpecHttpServiceSpecPatchPtrOutput() ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecPatchArgs) ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPatchOutput).ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceSpecPatchPtrInput is an input type that accepts ElasticsearchSpecHttpServiceSpecPatchArgs, ElasticsearchSpecHttpServiceSpecPatchPtr and ElasticsearchSpecHttpServiceSpecPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPatchPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceSpecPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPatchPtrOutput() ElasticsearchSpecHttpServiceSpecPatchPtrOutput
	ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPatchPtrOutput
}

type elasticsearchSpecHttpServiceSpecPatchPtrType ElasticsearchSpecHttpServiceSpecPatchArgs

func ElasticsearchSpecHttpServiceSpecPatchPtr(v *ElasticsearchSpecHttpServiceSpecPatchArgs) ElasticsearchSpecHttpServiceSpecPatchPtrInput {
	return (*elasticsearchSpecHttpServiceSpecPatchPtrType)(v)
}

func (*elasticsearchSpecHttpServiceSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceSpecPatchPtrType) ToElasticsearchSpecHttpServiceSpecPatchPtrOutput() ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceSpecPatchPtrType) ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPatchPtrOutput)
}

// Spec is the specification of the service.
type ElasticsearchSpecHttpServiceSpecPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ToElasticsearchSpecHttpServiceSpecPatchOutput() ElasticsearchSpecHttpServiceSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ToElasticsearchSpecHttpServiceSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ToElasticsearchSpecHttpServiceSpecPatchPtrOutput() ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return o.ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceSpecPatch) *ElasticsearchSpecHttpServiceSpecPatch {
		return &v
	}).(ElasticsearchSpecHttpServiceSpecPatchPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) Ports() ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) []ElasticsearchSpecHttpServiceSpecPortsPatch {
		return v.Ports
	}).(ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceSpecPatchOutput) SessionAffinityConfig() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch {
		return v.SessionAffinityConfig
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticsearchSpecHttpServiceSpecPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpServiceSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ToElasticsearchSpecHttpServiceSpecPatchPtrOutput() ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ToElasticsearchSpecHttpServiceSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) Elem() ElasticsearchSpecHttpServiceSpecPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) ElasticsearchSpecHttpServiceSpecPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceSpecPatch
		return ret
	}).(ElasticsearchSpecHttpServiceSpecPatchOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) Ports() ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) []ElasticsearchSpecHttpServiceSpecPortsPatch {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) SessionAffinityConfig() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o ElasticsearchSpecHttpServiceSpecPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ServicePort contains information on service's port.
type ElasticsearchSpecHttpServiceSpecPorts struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// ElasticsearchSpecHttpServiceSpecPortsInput is an input type that accepts ElasticsearchSpecHttpServiceSpecPortsArgs and ElasticsearchSpecHttpServiceSpecPortsOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPortsInput` via:
//
//	ElasticsearchSpecHttpServiceSpecPortsArgs{...}
type ElasticsearchSpecHttpServiceSpecPortsInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPortsOutput() ElasticsearchSpecHttpServiceSpecPortsOutput
	ToElasticsearchSpecHttpServiceSpecPortsOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPortsOutput
}

// ServicePort contains information on service's port.
type ElasticsearchSpecHttpServiceSpecPortsArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (ElasticsearchSpecHttpServiceSpecPortsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecPortsArgs) ToElasticsearchSpecHttpServiceSpecPortsOutput() ElasticsearchSpecHttpServiceSpecPortsOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPortsOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecPortsArgs) ToElasticsearchSpecHttpServiceSpecPortsOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPortsOutput)
}

// ElasticsearchSpecHttpServiceSpecPortsArrayInput is an input type that accepts ElasticsearchSpecHttpServiceSpecPortsArray and ElasticsearchSpecHttpServiceSpecPortsArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPortsArrayInput` via:
//
//	ElasticsearchSpecHttpServiceSpecPortsArray{ ElasticsearchSpecHttpServiceSpecPortsArgs{...} }
type ElasticsearchSpecHttpServiceSpecPortsArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPortsArrayOutput() ElasticsearchSpecHttpServiceSpecPortsArrayOutput
	ToElasticsearchSpecHttpServiceSpecPortsArrayOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPortsArrayOutput
}

type ElasticsearchSpecHttpServiceSpecPortsArray []ElasticsearchSpecHttpServiceSpecPortsInput

func (ElasticsearchSpecHttpServiceSpecPortsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecPortsArray) ToElasticsearchSpecHttpServiceSpecPortsArrayOutput() ElasticsearchSpecHttpServiceSpecPortsArrayOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPortsArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecPortsArray) ToElasticsearchSpecHttpServiceSpecPortsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPortsArrayOutput)
}

// ServicePort contains information on service's port.
type ElasticsearchSpecHttpServiceSpecPortsOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPortsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPortsOutput) ToElasticsearchSpecHttpServiceSpecPortsOutput() ElasticsearchSpecHttpServiceSpecPortsOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPortsOutput) ToElasticsearchSpecHttpServiceSpecPortsOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o ElasticsearchSpecHttpServiceSpecPortsOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPorts) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o ElasticsearchSpecHttpServiceSpecPortsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPorts) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o ElasticsearchSpecHttpServiceSpecPortsOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPorts) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o ElasticsearchSpecHttpServiceSpecPortsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPorts) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o ElasticsearchSpecHttpServiceSpecPortsOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPorts) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o ElasticsearchSpecHttpServiceSpecPortsOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPorts) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type ElasticsearchSpecHttpServiceSpecPortsArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPortsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpServiceSpecPorts)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPortsArrayOutput) ToElasticsearchSpecHttpServiceSpecPortsArrayOutput() ElasticsearchSpecHttpServiceSpecPortsArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPortsArrayOutput) ToElasticsearchSpecHttpServiceSpecPortsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPortsArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecHttpServiceSpecPortsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecHttpServiceSpecPorts {
		return vs[0].([]ElasticsearchSpecHttpServiceSpecPorts)[vs[1].(int)]
	}).(ElasticsearchSpecHttpServiceSpecPortsOutput)
}

// ServicePort contains information on service's port.
type ElasticsearchSpecHttpServiceSpecPortsPatch struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port *int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// ElasticsearchSpecHttpServiceSpecPortsPatchInput is an input type that accepts ElasticsearchSpecHttpServiceSpecPortsPatchArgs and ElasticsearchSpecHttpServiceSpecPortsPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPortsPatchInput` via:
//
//	ElasticsearchSpecHttpServiceSpecPortsPatchArgs{...}
type ElasticsearchSpecHttpServiceSpecPortsPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPortsPatchOutput() ElasticsearchSpecHttpServiceSpecPortsPatchOutput
	ToElasticsearchSpecHttpServiceSpecPortsPatchOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPortsPatchOutput
}

// ServicePort contains information on service's port.
type ElasticsearchSpecHttpServiceSpecPortsPatchArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

func (ElasticsearchSpecHttpServiceSpecPortsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecPortsPatchArgs) ToElasticsearchSpecHttpServiceSpecPortsPatchOutput() ElasticsearchSpecHttpServiceSpecPortsPatchOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPortsPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecPortsPatchArgs) ToElasticsearchSpecHttpServiceSpecPortsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPortsPatchOutput)
}

// ElasticsearchSpecHttpServiceSpecPortsPatchArrayInput is an input type that accepts ElasticsearchSpecHttpServiceSpecPortsPatchArray and ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecPortsPatchArrayInput` via:
//
//	ElasticsearchSpecHttpServiceSpecPortsPatchArray{ ElasticsearchSpecHttpServiceSpecPortsPatchArgs{...} }
type ElasticsearchSpecHttpServiceSpecPortsPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput() ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput
	ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput
}

type ElasticsearchSpecHttpServiceSpecPortsPatchArray []ElasticsearchSpecHttpServiceSpecPortsPatchInput

func (ElasticsearchSpecHttpServiceSpecPortsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecPortsPatchArray) ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput() ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput {
	return i.ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecPortsPatchArray) ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput)
}

// ServicePort contains information on service's port.
type ElasticsearchSpecHttpServiceSpecPortsPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPortsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) ToElasticsearchSpecHttpServiceSpecPortsPatchOutput() ElasticsearchSpecHttpServiceSpecPortsPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) ToElasticsearchSpecHttpServiceSpecPortsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsPatchOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPortsPatch) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPortsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPortsPatch) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPortsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPortsPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o ElasticsearchSpecHttpServiceSpecPortsPatchOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecPortsPatch) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpServiceSpecPortsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput) ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput() ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput) ToElasticsearchSpecHttpServiceSpecPortsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecHttpServiceSpecPortsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecHttpServiceSpecPortsPatch {
		return vs[0].([]ElasticsearchSpecHttpServiceSpecPortsPatch)[vs[1].(int)]
	}).(ElasticsearchSpecHttpServiceSpecPortsPatchOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfig struct {
	ClientIP *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP `pulumi:"clientIP"`
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigInput` via:
//
//	ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs{...}
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs struct {
	ClientIP ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput `pulumi:"clientIP"`
}

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput)
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput).ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs, ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtr and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput
}

type elasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrType ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs

func ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtr(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrInput {
	return (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrType)(v)
}

func (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceSpecSessionAffinityConfig) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfig {
		return &v
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput)
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput) ClientIP() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecSessionAffinityConfig) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP {
		return v.ClientIP
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput) Elem() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfig) ElasticsearchSpecHttpServiceSpecSessionAffinityConfig {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceSpecSessionAffinityConfig
		return ret
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput)
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput) ClientIP() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfig) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPInput` via:
//
//	ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{...}
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput)
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput).ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs, ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtr and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput
}

type elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs

func ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtr(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput {
	return (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType)(v)
}

func (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP {
		return &v
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) Elem() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP
		return ret
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIP) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput` via:
//
//	ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput).ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs, ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtr and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput
}

type elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs

func ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtr(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput {
	return (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType)(v)
}

func (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		return &v
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *int {
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) Elem() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch
		return ret
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch struct {
	ClientIP *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch `pulumi:"clientIP"`
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchInput` via:
//
//	ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs{...}
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs struct {
	ClientIP ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput `pulumi:"clientIP"`
}

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput)
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput).ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput is an input type that accepts ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs, ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtr and ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput` via:
//
//	        ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput
	ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput
}

type elasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrType ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs

func ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtr(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput {
	return (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrType)(v)
}

func (*elasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return i.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrType) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch {
		return &v
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput)
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput) ClientIP() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		return v.ClientIP
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

type ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ToElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) Elem() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch) ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch
		return ret
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput)
}

func (o ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput) ClientIP() ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatch) *ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatch {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticsearchSpecHttpTls struct {
	Certificate           *ElasticsearchSpecHttpTlsCertificate           `pulumi:"certificate"`
	SelfSignedCertificate *ElasticsearchSpecHttpTlsSelfSignedCertificate `pulumi:"selfSignedCertificate"`
}

// ElasticsearchSpecHttpTlsInput is an input type that accepts ElasticsearchSpecHttpTlsArgs and ElasticsearchSpecHttpTlsOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsInput` via:
//
//	ElasticsearchSpecHttpTlsArgs{...}
type ElasticsearchSpecHttpTlsInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsOutput() ElasticsearchSpecHttpTlsOutput
	ToElasticsearchSpecHttpTlsOutputWithContext(context.Context) ElasticsearchSpecHttpTlsOutput
}

// TLS defines options for configuring TLS for HTTP.
type ElasticsearchSpecHttpTlsArgs struct {
	Certificate           ElasticsearchSpecHttpTlsCertificatePtrInput           `pulumi:"certificate"`
	SelfSignedCertificate ElasticsearchSpecHttpTlsSelfSignedCertificatePtrInput `pulumi:"selfSignedCertificate"`
}

func (ElasticsearchSpecHttpTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTls)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsArgs) ToElasticsearchSpecHttpTlsOutput() ElasticsearchSpecHttpTlsOutput {
	return i.ToElasticsearchSpecHttpTlsOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsArgs) ToElasticsearchSpecHttpTlsOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsOutput)
}

func (i ElasticsearchSpecHttpTlsArgs) ToElasticsearchSpecHttpTlsPtrOutput() ElasticsearchSpecHttpTlsPtrOutput {
	return i.ToElasticsearchSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsArgs) ToElasticsearchSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsOutput).ToElasticsearchSpecHttpTlsPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpTlsPtrInput is an input type that accepts ElasticsearchSpecHttpTlsArgs, ElasticsearchSpecHttpTlsPtr and ElasticsearchSpecHttpTlsPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsPtrInput` via:
//
//	        ElasticsearchSpecHttpTlsArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpTlsPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsPtrOutput() ElasticsearchSpecHttpTlsPtrOutput
	ToElasticsearchSpecHttpTlsPtrOutputWithContext(context.Context) ElasticsearchSpecHttpTlsPtrOutput
}

type elasticsearchSpecHttpTlsPtrType ElasticsearchSpecHttpTlsArgs

func ElasticsearchSpecHttpTlsPtr(v *ElasticsearchSpecHttpTlsArgs) ElasticsearchSpecHttpTlsPtrInput {
	return (*elasticsearchSpecHttpTlsPtrType)(v)
}

func (*elasticsearchSpecHttpTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTls)(nil)).Elem()
}

func (i *elasticsearchSpecHttpTlsPtrType) ToElasticsearchSpecHttpTlsPtrOutput() ElasticsearchSpecHttpTlsPtrOutput {
	return i.ToElasticsearchSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpTlsPtrType) ToElasticsearchSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticsearchSpecHttpTlsOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTls)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsOutput) ToElasticsearchSpecHttpTlsOutput() ElasticsearchSpecHttpTlsOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsOutput) ToElasticsearchSpecHttpTlsOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsOutput) ToElasticsearchSpecHttpTlsPtrOutput() ElasticsearchSpecHttpTlsPtrOutput {
	return o.ToElasticsearchSpecHttpTlsPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpTlsOutput) ToElasticsearchSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpTls) *ElasticsearchSpecHttpTls {
		return &v
	}).(ElasticsearchSpecHttpTlsPtrOutput)
}

func (o ElasticsearchSpecHttpTlsOutput) Certificate() ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTls) *ElasticsearchSpecHttpTlsCertificate { return v.Certificate }).(ElasticsearchSpecHttpTlsCertificatePtrOutput)
}

func (o ElasticsearchSpecHttpTlsOutput) SelfSignedCertificate() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTls) *ElasticsearchSpecHttpTlsSelfSignedCertificate {
		return v.SelfSignedCertificate
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput)
}

type ElasticsearchSpecHttpTlsPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTls)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsPtrOutput) ToElasticsearchSpecHttpTlsPtrOutput() ElasticsearchSpecHttpTlsPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsPtrOutput) ToElasticsearchSpecHttpTlsPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsPtrOutput) Elem() ElasticsearchSpecHttpTlsOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTls) ElasticsearchSpecHttpTls {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpTls
		return ret
	}).(ElasticsearchSpecHttpTlsOutput)
}

func (o ElasticsearchSpecHttpTlsPtrOutput) Certificate() ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTls) *ElasticsearchSpecHttpTlsCertificate {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(ElasticsearchSpecHttpTlsCertificatePtrOutput)
}

func (o ElasticsearchSpecHttpTlsPtrOutput) SelfSignedCertificate() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTls) *ElasticsearchSpecHttpTlsSelfSignedCertificate {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticsearchSpecHttpTlsCertificate struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticsearchSpecHttpTlsCertificateInput is an input type that accepts ElasticsearchSpecHttpTlsCertificateArgs and ElasticsearchSpecHttpTlsCertificateOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsCertificateInput` via:
//
//	ElasticsearchSpecHttpTlsCertificateArgs{...}
type ElasticsearchSpecHttpTlsCertificateInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsCertificateOutput() ElasticsearchSpecHttpTlsCertificateOutput
	ToElasticsearchSpecHttpTlsCertificateOutputWithContext(context.Context) ElasticsearchSpecHttpTlsCertificateOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticsearchSpecHttpTlsCertificateArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticsearchSpecHttpTlsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificate)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsCertificateArgs) ToElasticsearchSpecHttpTlsCertificateOutput() ElasticsearchSpecHttpTlsCertificateOutput {
	return i.ToElasticsearchSpecHttpTlsCertificateOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsCertificateArgs) ToElasticsearchSpecHttpTlsCertificateOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsCertificateOutput)
}

func (i ElasticsearchSpecHttpTlsCertificateArgs) ToElasticsearchSpecHttpTlsCertificatePtrOutput() ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return i.ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsCertificateArgs) ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsCertificateOutput).ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpTlsCertificatePtrInput is an input type that accepts ElasticsearchSpecHttpTlsCertificateArgs, ElasticsearchSpecHttpTlsCertificatePtr and ElasticsearchSpecHttpTlsCertificatePtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsCertificatePtrInput` via:
//
//	        ElasticsearchSpecHttpTlsCertificateArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpTlsCertificatePtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsCertificatePtrOutput() ElasticsearchSpecHttpTlsCertificatePtrOutput
	ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(context.Context) ElasticsearchSpecHttpTlsCertificatePtrOutput
}

type elasticsearchSpecHttpTlsCertificatePtrType ElasticsearchSpecHttpTlsCertificateArgs

func ElasticsearchSpecHttpTlsCertificatePtr(v *ElasticsearchSpecHttpTlsCertificateArgs) ElasticsearchSpecHttpTlsCertificatePtrInput {
	return (*elasticsearchSpecHttpTlsCertificatePtrType)(v)
}

func (*elasticsearchSpecHttpTlsCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsCertificate)(nil)).Elem()
}

func (i *elasticsearchSpecHttpTlsCertificatePtrType) ToElasticsearchSpecHttpTlsCertificatePtrOutput() ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return i.ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpTlsCertificatePtrType) ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticsearchSpecHttpTlsCertificateOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificate)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsCertificateOutput) ToElasticsearchSpecHttpTlsCertificateOutput() ElasticsearchSpecHttpTlsCertificateOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificateOutput) ToElasticsearchSpecHttpTlsCertificateOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificateOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificateOutput) ToElasticsearchSpecHttpTlsCertificatePtrOutput() ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return o.ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpTlsCertificateOutput) ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpTlsCertificate) *ElasticsearchSpecHttpTlsCertificate {
		return &v
	}).(ElasticsearchSpecHttpTlsCertificatePtrOutput)
}

// SecretName is the name of the secret.
func (o ElasticsearchSpecHttpTlsCertificateOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsCertificate) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpTlsCertificatePtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsCertificate)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsCertificatePtrOutput) ToElasticsearchSpecHttpTlsCertificatePtrOutput() ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificatePtrOutput) ToElasticsearchSpecHttpTlsCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificatePtrOutput) Elem() ElasticsearchSpecHttpTlsCertificateOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsCertificate) ElasticsearchSpecHttpTlsCertificate {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpTlsCertificate
		return ret
	}).(ElasticsearchSpecHttpTlsCertificateOutput)
}

// SecretName is the name of the secret.
func (o ElasticsearchSpecHttpTlsCertificatePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsCertificate) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticsearchSpecHttpTlsCertificatePatch struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticsearchSpecHttpTlsCertificatePatchInput is an input type that accepts ElasticsearchSpecHttpTlsCertificatePatchArgs and ElasticsearchSpecHttpTlsCertificatePatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsCertificatePatchInput` via:
//
//	ElasticsearchSpecHttpTlsCertificatePatchArgs{...}
type ElasticsearchSpecHttpTlsCertificatePatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsCertificatePatchOutput() ElasticsearchSpecHttpTlsCertificatePatchOutput
	ToElasticsearchSpecHttpTlsCertificatePatchOutputWithContext(context.Context) ElasticsearchSpecHttpTlsCertificatePatchOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticsearchSpecHttpTlsCertificatePatchArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticsearchSpecHttpTlsCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsCertificatePatchArgs) ToElasticsearchSpecHttpTlsCertificatePatchOutput() ElasticsearchSpecHttpTlsCertificatePatchOutput {
	return i.ToElasticsearchSpecHttpTlsCertificatePatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsCertificatePatchArgs) ToElasticsearchSpecHttpTlsCertificatePatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsCertificatePatchOutput)
}

func (i ElasticsearchSpecHttpTlsCertificatePatchArgs) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return i.ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsCertificatePatchArgs) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsCertificatePatchOutput).ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpTlsCertificatePatchPtrInput is an input type that accepts ElasticsearchSpecHttpTlsCertificatePatchArgs, ElasticsearchSpecHttpTlsCertificatePatchPtr and ElasticsearchSpecHttpTlsCertificatePatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsCertificatePatchPtrInput` via:
//
//	        ElasticsearchSpecHttpTlsCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpTlsCertificatePatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput
	ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpTlsCertificatePatchPtrOutput
}

type elasticsearchSpecHttpTlsCertificatePatchPtrType ElasticsearchSpecHttpTlsCertificatePatchArgs

func ElasticsearchSpecHttpTlsCertificatePatchPtr(v *ElasticsearchSpecHttpTlsCertificatePatchArgs) ElasticsearchSpecHttpTlsCertificatePatchPtrInput {
	return (*elasticsearchSpecHttpTlsCertificatePatchPtrType)(v)
}

func (*elasticsearchSpecHttpTlsCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpTlsCertificatePatchPtrType) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return i.ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpTlsCertificatePatchPtrType) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsCertificatePatchPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type ElasticsearchSpecHttpTlsCertificatePatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsCertificatePatchOutput) ToElasticsearchSpecHttpTlsCertificatePatchOutput() ElasticsearchSpecHttpTlsCertificatePatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificatePatchOutput) ToElasticsearchSpecHttpTlsCertificatePatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificatePatchOutput) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return o.ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpTlsCertificatePatchOutput) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpTlsCertificatePatch) *ElasticsearchSpecHttpTlsCertificatePatch {
		return &v
	}).(ElasticsearchSpecHttpTlsCertificatePatchPtrOutput)
}

// SecretName is the name of the secret.
func (o ElasticsearchSpecHttpTlsCertificatePatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsCertificatePatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpTlsCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsCertificatePatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsCertificatePatchPtrOutput) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificatePatchPtrOutput) ToElasticsearchSpecHttpTlsCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsCertificatePatchPtrOutput) Elem() ElasticsearchSpecHttpTlsCertificatePatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsCertificatePatch) ElasticsearchSpecHttpTlsCertificatePatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpTlsCertificatePatch
		return ret
	}).(ElasticsearchSpecHttpTlsCertificatePatchOutput)
}

// SecretName is the name of the secret.
func (o ElasticsearchSpecHttpTlsCertificatePatchPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsCertificatePatch) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticsearchSpecHttpTlsPatch struct {
	Certificate           *ElasticsearchSpecHttpTlsCertificatePatch           `pulumi:"certificate"`
	SelfSignedCertificate *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch `pulumi:"selfSignedCertificate"`
}

// ElasticsearchSpecHttpTlsPatchInput is an input type that accepts ElasticsearchSpecHttpTlsPatchArgs and ElasticsearchSpecHttpTlsPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsPatchInput` via:
//
//	ElasticsearchSpecHttpTlsPatchArgs{...}
type ElasticsearchSpecHttpTlsPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsPatchOutput() ElasticsearchSpecHttpTlsPatchOutput
	ToElasticsearchSpecHttpTlsPatchOutputWithContext(context.Context) ElasticsearchSpecHttpTlsPatchOutput
}

// TLS defines options for configuring TLS for HTTP.
type ElasticsearchSpecHttpTlsPatchArgs struct {
	Certificate           ElasticsearchSpecHttpTlsCertificatePatchPtrInput           `pulumi:"certificate"`
	SelfSignedCertificate ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrInput `pulumi:"selfSignedCertificate"`
}

func (ElasticsearchSpecHttpTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsPatchArgs) ToElasticsearchSpecHttpTlsPatchOutput() ElasticsearchSpecHttpTlsPatchOutput {
	return i.ToElasticsearchSpecHttpTlsPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsPatchArgs) ToElasticsearchSpecHttpTlsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsPatchOutput)
}

func (i ElasticsearchSpecHttpTlsPatchArgs) ToElasticsearchSpecHttpTlsPatchPtrOutput() ElasticsearchSpecHttpTlsPatchPtrOutput {
	return i.ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsPatchArgs) ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsPatchOutput).ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpTlsPatchPtrInput is an input type that accepts ElasticsearchSpecHttpTlsPatchArgs, ElasticsearchSpecHttpTlsPatchPtr and ElasticsearchSpecHttpTlsPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsPatchPtrInput` via:
//
//	        ElasticsearchSpecHttpTlsPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpTlsPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsPatchPtrOutput() ElasticsearchSpecHttpTlsPatchPtrOutput
	ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpTlsPatchPtrOutput
}

type elasticsearchSpecHttpTlsPatchPtrType ElasticsearchSpecHttpTlsPatchArgs

func ElasticsearchSpecHttpTlsPatchPtr(v *ElasticsearchSpecHttpTlsPatchArgs) ElasticsearchSpecHttpTlsPatchPtrInput {
	return (*elasticsearchSpecHttpTlsPatchPtrType)(v)
}

func (*elasticsearchSpecHttpTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsPatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpTlsPatchPtrType) ToElasticsearchSpecHttpTlsPatchPtrOutput() ElasticsearchSpecHttpTlsPatchPtrOutput {
	return i.ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpTlsPatchPtrType) ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsPatchPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type ElasticsearchSpecHttpTlsPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsPatchOutput) ToElasticsearchSpecHttpTlsPatchOutput() ElasticsearchSpecHttpTlsPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsPatchOutput) ToElasticsearchSpecHttpTlsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsPatchOutput) ToElasticsearchSpecHttpTlsPatchPtrOutput() ElasticsearchSpecHttpTlsPatchPtrOutput {
	return o.ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpTlsPatchOutput) ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpTlsPatch) *ElasticsearchSpecHttpTlsPatch {
		return &v
	}).(ElasticsearchSpecHttpTlsPatchPtrOutput)
}

func (o ElasticsearchSpecHttpTlsPatchOutput) Certificate() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsPatch) *ElasticsearchSpecHttpTlsCertificatePatch { return v.Certificate }).(ElasticsearchSpecHttpTlsCertificatePatchPtrOutput)
}

func (o ElasticsearchSpecHttpTlsPatchOutput) SelfSignedCertificate() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsPatch) *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch {
		return v.SelfSignedCertificate
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

type ElasticsearchSpecHttpTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsPatchPtrOutput) ToElasticsearchSpecHttpTlsPatchPtrOutput() ElasticsearchSpecHttpTlsPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsPatchPtrOutput) ToElasticsearchSpecHttpTlsPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsPatchPtrOutput) Elem() ElasticsearchSpecHttpTlsPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsPatch) ElasticsearchSpecHttpTlsPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpTlsPatch
		return ret
	}).(ElasticsearchSpecHttpTlsPatchOutput)
}

func (o ElasticsearchSpecHttpTlsPatchPtrOutput) Certificate() ElasticsearchSpecHttpTlsCertificatePatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsPatch) *ElasticsearchSpecHttpTlsCertificatePatch {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(ElasticsearchSpecHttpTlsCertificatePatchPtrOutput)
}

func (o ElasticsearchSpecHttpTlsPatchPtrOutput) SelfSignedCertificate() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsPatch) *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticsearchSpecHttpTlsSelfSignedCertificate struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames `pulumi:"subjectAltNames"`
}

// ElasticsearchSpecHttpTlsSelfSignedCertificateInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificateArgs and ElasticsearchSpecHttpTlsSelfSignedCertificateOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificateInput` via:
//
//	ElasticsearchSpecHttpTlsSelfSignedCertificateArgs{...}
type ElasticsearchSpecHttpTlsSelfSignedCertificateInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificateOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificateOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticsearchSpecHttpTlsSelfSignedCertificateArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput `pulumi:"subjectAltNames"`
}

func (ElasticsearchSpecHttpTlsSelfSignedCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificateOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificateOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificateOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificateOutput)
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificateOutput).ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpTlsSelfSignedCertificatePtrInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificateArgs, ElasticsearchSpecHttpTlsSelfSignedCertificatePtr and ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificatePtrInput` via:
//
//	        ElasticsearchSpecHttpTlsSelfSignedCertificateArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpTlsSelfSignedCertificatePtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput
}

type elasticsearchSpecHttpTlsSelfSignedCertificatePtrType ElasticsearchSpecHttpTlsSelfSignedCertificateArgs

func ElasticsearchSpecHttpTlsSelfSignedCertificatePtr(v *ElasticsearchSpecHttpTlsSelfSignedCertificateArgs) ElasticsearchSpecHttpTlsSelfSignedCertificatePtrInput {
	return (*elasticsearchSpecHttpTlsSelfSignedCertificatePtrType)(v)
}

func (*elasticsearchSpecHttpTlsSelfSignedCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (i *elasticsearchSpecHttpTlsSelfSignedCertificatePtrType) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpTlsSelfSignedCertificatePtrType) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticsearchSpecHttpTlsSelfSignedCertificateOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpTlsSelfSignedCertificate) *ElasticsearchSpecHttpTlsSelfSignedCertificate {
		return &v
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificate) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificateOutput) SubjectAltNames() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificate) []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		return v.SubjectAltNames
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

type ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsSelfSignedCertificate)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput) Elem() ElasticsearchSpecHttpTlsSelfSignedCertificateOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsSelfSignedCertificate) ElasticsearchSpecHttpTlsSelfSignedCertificate {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpTlsSelfSignedCertificate
		return ret
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsSelfSignedCertificate) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput) SubjectAltNames() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsSelfSignedCertificate) []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticsearchSpecHttpTlsSelfSignedCertificatePatch struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch `pulumi:"subjectAltNames"`
}

// ElasticsearchSpecHttpTlsSelfSignedCertificatePatchInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs and ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificatePatchInput` via:
//
//	ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs{...}
type ElasticsearchSpecHttpTlsSelfSignedCertificatePatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput `pulumi:"subjectAltNames"`
}

func (ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput)
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput).ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs, ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtr and ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrInput` via:
//
//	        ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput
}

type elasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrType ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs

func ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtr(v *ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrInput {
	return (*elasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrType)(v)
}

func (*elasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (i *elasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrType) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrType) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecHttpTlsSelfSignedCertificatePatch) *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch {
		return &v
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificatePatch) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput) SubjectAltNames() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificatePatch) []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		return v.SubjectAltNames
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

type ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecHttpTlsSelfSignedCertificatePatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput) Elem() ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch) ElasticsearchSpecHttpTlsSelfSignedCertificatePatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecHttpTlsSelfSignedCertificatePatch
		return ret
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput) SubjectAltNames() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecHttpTlsSelfSignedCertificatePatch) []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs and ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput` via:
//
//	ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{...}
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray and ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput` via:
//
//	ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray{ ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{...} }
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput
}

type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames {
		return vs[0].([]ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNames)[vs[1].(int)]
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs and ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput` via:
//
//	ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...}
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput is an input type that accepts ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray and ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput` via:
//
//	ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray{ ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{...} }
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
	ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput
}

type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray []ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return i.ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput() ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) ToElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch {
		return vs[0].([]ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatch)[vs[1].(int)]
	}).(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput)
}

// NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
type ElasticsearchSpecNodeSets struct {
	// Config holds the Elasticsearch configuration.
	Config map[string]string `pulumi:"config"`
	// Count of Elasticsearch nodes to deploy.
	Count *int `pulumi:"count"`
	// Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
	Name *string `pulumi:"name"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
	PodTemplate map[string]string `pulumi:"podTemplate"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates []ElasticsearchSpecNodeSetsVolumeClaimTemplates `pulumi:"volumeClaimTemplates"`
}

// ElasticsearchSpecNodeSetsInput is an input type that accepts ElasticsearchSpecNodeSetsArgs and ElasticsearchSpecNodeSetsOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsInput` via:
//
//	ElasticsearchSpecNodeSetsArgs{...}
type ElasticsearchSpecNodeSetsInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsOutput() ElasticsearchSpecNodeSetsOutput
	ToElasticsearchSpecNodeSetsOutputWithContext(context.Context) ElasticsearchSpecNodeSetsOutput
}

// NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
type ElasticsearchSpecNodeSetsArgs struct {
	// Config holds the Elasticsearch configuration.
	Config pulumi.StringMapInput `pulumi:"config"`
	// Count of Elasticsearch nodes to deploy.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
	PodTemplate pulumi.StringMapInput `pulumi:"podTemplate"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayInput `pulumi:"volumeClaimTemplates"`
}

func (ElasticsearchSpecNodeSetsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSets)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsArgs) ToElasticsearchSpecNodeSetsOutput() ElasticsearchSpecNodeSetsOutput {
	return i.ToElasticsearchSpecNodeSetsOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsArgs) ToElasticsearchSpecNodeSetsOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsOutput)
}

// ElasticsearchSpecNodeSetsArrayInput is an input type that accepts ElasticsearchSpecNodeSetsArray and ElasticsearchSpecNodeSetsArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsArrayInput` via:
//
//	ElasticsearchSpecNodeSetsArray{ ElasticsearchSpecNodeSetsArgs{...} }
type ElasticsearchSpecNodeSetsArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsArrayOutput() ElasticsearchSpecNodeSetsArrayOutput
	ToElasticsearchSpecNodeSetsArrayOutputWithContext(context.Context) ElasticsearchSpecNodeSetsArrayOutput
}

type ElasticsearchSpecNodeSetsArray []ElasticsearchSpecNodeSetsInput

func (ElasticsearchSpecNodeSetsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSets)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsArray) ToElasticsearchSpecNodeSetsArrayOutput() ElasticsearchSpecNodeSetsArrayOutput {
	return i.ToElasticsearchSpecNodeSetsArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsArray) ToElasticsearchSpecNodeSetsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsArrayOutput)
}

// NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
type ElasticsearchSpecNodeSetsOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSets)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsOutput) ToElasticsearchSpecNodeSetsOutput() ElasticsearchSpecNodeSetsOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsOutput) ToElasticsearchSpecNodeSetsOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsOutput {
	return o
}

// Config holds the Elasticsearch configuration.
func (o ElasticsearchSpecNodeSetsOutput) Config() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSets) map[string]string { return v.Config }).(pulumi.StringMapOutput)
}

// Count of Elasticsearch nodes to deploy.
func (o ElasticsearchSpecNodeSetsOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSets) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
func (o ElasticsearchSpecNodeSetsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSets) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
func (o ElasticsearchSpecNodeSetsOutput) PodTemplate() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSets) map[string]string { return v.PodTemplate }).(pulumi.StringMapOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o ElasticsearchSpecNodeSetsOutput) VolumeClaimTemplates() ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSets) []ElasticsearchSpecNodeSetsVolumeClaimTemplates {
		return v.VolumeClaimTemplates
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput)
}

type ElasticsearchSpecNodeSetsArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSets)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsArrayOutput) ToElasticsearchSpecNodeSetsArrayOutput() ElasticsearchSpecNodeSetsArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsArrayOutput) ToElasticsearchSpecNodeSetsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecNodeSetsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecNodeSets {
		return vs[0].([]ElasticsearchSpecNodeSets)[vs[1].(int)]
	}).(ElasticsearchSpecNodeSetsOutput)
}

// NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
type ElasticsearchSpecNodeSetsPatch struct {
	// Config holds the Elasticsearch configuration.
	Config map[string]string `pulumi:"config"`
	// Count of Elasticsearch nodes to deploy.
	Count *int `pulumi:"count"`
	// Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
	Name *string `pulumi:"name"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
	PodTemplate map[string]string `pulumi:"podTemplate"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates []ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch `pulumi:"volumeClaimTemplates"`
}

// ElasticsearchSpecNodeSetsPatchInput is an input type that accepts ElasticsearchSpecNodeSetsPatchArgs and ElasticsearchSpecNodeSetsPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsPatchInput` via:
//
//	ElasticsearchSpecNodeSetsPatchArgs{...}
type ElasticsearchSpecNodeSetsPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsPatchOutput() ElasticsearchSpecNodeSetsPatchOutput
	ToElasticsearchSpecNodeSetsPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsPatchOutput
}

// NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
type ElasticsearchSpecNodeSetsPatchArgs struct {
	// Config holds the Elasticsearch configuration.
	Config pulumi.StringMapInput `pulumi:"config"`
	// Count of Elasticsearch nodes to deploy.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
	PodTemplate pulumi.StringMapInput `pulumi:"podTemplate"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayInput `pulumi:"volumeClaimTemplates"`
}

func (ElasticsearchSpecNodeSetsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsPatchArgs) ToElasticsearchSpecNodeSetsPatchOutput() ElasticsearchSpecNodeSetsPatchOutput {
	return i.ToElasticsearchSpecNodeSetsPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsPatchArgs) ToElasticsearchSpecNodeSetsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsPatchOutput)
}

// ElasticsearchSpecNodeSetsPatchArrayInput is an input type that accepts ElasticsearchSpecNodeSetsPatchArray and ElasticsearchSpecNodeSetsPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsPatchArrayInput` via:
//
//	ElasticsearchSpecNodeSetsPatchArray{ ElasticsearchSpecNodeSetsPatchArgs{...} }
type ElasticsearchSpecNodeSetsPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsPatchArrayOutput() ElasticsearchSpecNodeSetsPatchArrayOutput
	ToElasticsearchSpecNodeSetsPatchArrayOutputWithContext(context.Context) ElasticsearchSpecNodeSetsPatchArrayOutput
}

type ElasticsearchSpecNodeSetsPatchArray []ElasticsearchSpecNodeSetsPatchInput

func (ElasticsearchSpecNodeSetsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsPatchArray) ToElasticsearchSpecNodeSetsPatchArrayOutput() ElasticsearchSpecNodeSetsPatchArrayOutput {
	return i.ToElasticsearchSpecNodeSetsPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsPatchArray) ToElasticsearchSpecNodeSetsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsPatchArrayOutput)
}

// NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
type ElasticsearchSpecNodeSetsPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsPatchOutput) ToElasticsearchSpecNodeSetsPatchOutput() ElasticsearchSpecNodeSetsPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsPatchOutput) ToElasticsearchSpecNodeSetsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsPatchOutput {
	return o
}

// Config holds the Elasticsearch configuration.
func (o ElasticsearchSpecNodeSetsPatchOutput) Config() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsPatch) map[string]string { return v.Config }).(pulumi.StringMapOutput)
}

// Count of Elasticsearch nodes to deploy.
func (o ElasticsearchSpecNodeSetsPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
func (o ElasticsearchSpecNodeSetsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
func (o ElasticsearchSpecNodeSetsPatchOutput) PodTemplate() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsPatch) map[string]string { return v.PodTemplate }).(pulumi.StringMapOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o ElasticsearchSpecNodeSetsPatchOutput) VolumeClaimTemplates() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsPatch) []ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch {
		return v.VolumeClaimTemplates
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput)
}

type ElasticsearchSpecNodeSetsPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsPatchArrayOutput) ToElasticsearchSpecNodeSetsPatchArrayOutput() ElasticsearchSpecNodeSetsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsPatchArrayOutput) ToElasticsearchSpecNodeSetsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecNodeSetsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecNodeSetsPatch {
		return vs[0].([]ElasticsearchSpecNodeSetsPatch)[vs[1].(int)]
	}).(ElasticsearchSpecNodeSetsPatchOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type ElasticsearchSpecNodeSetsVolumeClaimTemplates struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string                                                `pulumi:"kind"`
	Metadata *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata `pulumi:"metadata"`
	Spec     *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec     `pulumi:"spec"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput                                         `pulumi:"kind"`
	Metadata ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrInput `pulumi:"metadata"`
	Spec     ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrInput     `pulumi:"spec"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplates)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray and ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray{ ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs{...} }
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray []ElasticsearchSpecNodeSetsVolumeClaimTemplatesInput

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplates)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplates)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object.
// Servers should convert recognized schemas to the latest internal value, and
// may reject unrecognized values.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplates) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents.
// Servers may infer this from the endpoint the client submits requests to.
// Cannot be updated.
// In CamelCase.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplates) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) Metadata() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplates) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata {
		return v.Metadata
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput) Spec() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplates) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec {
		return v.Spec
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplates)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecNodeSetsVolumeClaimTemplates {
		return vs[0].([]ElasticsearchSpecNodeSetsVolumeClaimTemplates)[vs[1].(int)]
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string                                                     `pulumi:"kind"`
	Metadata *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch `pulumi:"metadata"`
	Spec     *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch     `pulumi:"spec"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput                                              `pulumi:"kind"`
	Metadata ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrInput     `pulumi:"spec"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray and ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray{ ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs{...} }
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray []ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchInput

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object.
// Servers should convert recognized schemas to the latest internal value, and
// may reject unrecognized values.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents.
// Servers may infer this from the endpoint the client submits requests to.
// Cannot be updated.
// In CamelCase.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) Metadata() ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatch {
		return v.Metadata
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput) Spec() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch {
		return v.Spec
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch {
		return vs[0].([]ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatch)[vs[1].(int)]
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   []string                                                        `pulumi:"accessModes"`
	DataSource    *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource    `pulumi:"dataSource"`
	DataSourceRef *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef `pulumi:"dataSourceRef"`
	Resources     *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources     `pulumi:"resources"`
	Selector      *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName *string `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName *string `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName *string `pulumi:"volumeName"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   pulumi.StringArrayInput                                                `pulumi:"accessModes"`
	DataSource    ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrInput    `pulumi:"dataSource"`
	DataSourceRef ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrInput `pulumi:"dataSourceRef"`
	Resources     ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrInput     `pulumi:"resources"`
	Selector      ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrInput      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName pulumi.StringPtrInput `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName pulumi.StringPtrInput `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode pulumi.StringPtrInput `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) DataSource() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource {
		return v.DataSource
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) DataSourceRef() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef {
		return v.DataSourceRef
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) Resources() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources {
		return v.Resources
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) Selector() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector {
		return v.Selector
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string { return v.StorageClassName }).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string { return v.VolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string { return v.VolumeMode }).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) DataSource() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource {
		if v == nil {
			return nil
		}
		return v.DataSource
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) DataSourceRef() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef {
		if v == nil {
			return nil
		}
		return v.DataSourceRef
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) Resources() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) Selector() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.StorageClassName
	}).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeMode
	}).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace *string `pulumi:"namespace"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind *string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name *string `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace *string `pulumi:"namespace"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   []string                                                             `pulumi:"accessModes"`
	DataSource    *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch    `pulumi:"dataSource"`
	DataSourceRef *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch `pulumi:"dataSourceRef"`
	Resources     *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch     `pulumi:"resources"`
	Selector      *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName *string `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName *string `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName *string `pulumi:"volumeName"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes   pulumi.StringArrayInput                                                     `pulumi:"accessModes"`
	DataSource    ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrInput    `pulumi:"dataSource"`
	DataSourceRef ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput `pulumi:"dataSourceRef"`
	Resources     ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrInput     `pulumi:"resources"`
	Selector      ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrInput      `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName pulumi.StringPtrInput `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName pulumi.StringPtrInput `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode pulumi.StringPtrInput `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) DataSource() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch {
		return v.DataSource
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) DataSourceRef() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch {
		return v.DataSourceRef
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) Resources() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch {
		return v.Resources
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) Selector() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch {
		return v.Selector
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string { return v.StorageClassName }).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string {
		return v.VolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string { return v.VolumeMode }).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) DataSource() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatch {
		if v == nil {
			return nil
		}
		return v.DataSource
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) DataSourceRef() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatch {
		if v == nil {
			return nil
		}
		return v.DataSourceRef
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) Resources() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) Selector() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.StorageClassName
	}).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.VolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.VolumeMode
	}).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits map[string]interface{} `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests map[string]interface{} `pulumi:"requests"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits pulumi.MapInput `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests pulumi.MapInput `pulumi:"requests"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources) map[string]interface{} {
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources) map[string]interface{} {
		return v.Requests
	}).(pulumi.MapOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResources) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.MapOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits map[string]interface{} `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests map[string]interface{} `pulumi:"requests"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits pulumi.MapInput `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests pulumi.MapInput `pulumi:"requests"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} {
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} {
		return v.Requests
	}).(pulumi.MapOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.MapOutput)
}

// selector is a label query over volumes to consider for binding.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput
}

// selector is a label query over volumes to consider for binding.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// selector is a label query over volumes to consider for binding.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) MatchExpressions() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector) []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput) MatchExpressions() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector) []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray{ ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{...} }
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsInput

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions {
		return vs[0].([]ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressions)[vs[1].(int)]
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray{ ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs{...} }
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch {
		return vs[0].([]ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput)
}

// selector is a label query over volumes to consider for binding.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchInput` via:
//
//	ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs{...}
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput
}

// selector is a label query over volumes to consider for binding.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput)
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput).ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrInput is an input type that accepts ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs, ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtr and ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrInput` via:
//
//	        ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput
	ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput
}

type elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrType ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs

func ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtr(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrInput {
	return (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrType)(v)
}

func (*elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return i.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrType) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// selector is a label query over volumes to consider for binding.
type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch) *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch {
		return &v
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) MatchExpressions() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch) []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch)(nil)).Elem()
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput) ToElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput) Elem() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch) ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch
		return ret
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput) MatchExpressions() ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch) []ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// ElasticsearchSpec holds the specification of an Elasticsearch cluster.
type ElasticsearchSpecPatch struct {
	Http *ElasticsearchSpecHttpPatch `pulumi:"http"`
	// Image is the Elasticsearch Docker image to deploy.
	Image *string `pulumi:"image"`
	// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
	NodeSets            []ElasticsearchSpecNodeSetsPatch           `pulumi:"nodeSets"`
	PodDisruptionBudget *ElasticsearchSpecPodDisruptionBudgetPatch `pulumi:"podDisruptionBudget"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
	SecureSettings []ElasticsearchSpecSecureSettingsPatch `pulumi:"secureSettings"`
	UpdateStrategy *ElasticsearchSpecUpdateStrategyPatch  `pulumi:"updateStrategy"`
	// Version of Elasticsearch.
	Version *string `pulumi:"version"`
}

// ElasticsearchSpecPatchInput is an input type that accepts ElasticsearchSpecPatchArgs and ElasticsearchSpecPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPatchInput` via:
//
//	ElasticsearchSpecPatchArgs{...}
type ElasticsearchSpecPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecPatchOutput() ElasticsearchSpecPatchOutput
	ToElasticsearchSpecPatchOutputWithContext(context.Context) ElasticsearchSpecPatchOutput
}

// ElasticsearchSpec holds the specification of an Elasticsearch cluster.
type ElasticsearchSpecPatchArgs struct {
	Http ElasticsearchSpecHttpPatchPtrInput `pulumi:"http"`
	// Image is the Elasticsearch Docker image to deploy.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
	NodeSets            ElasticsearchSpecNodeSetsPatchArrayInput          `pulumi:"nodeSets"`
	PodDisruptionBudget ElasticsearchSpecPodDisruptionBudgetPatchPtrInput `pulumi:"podDisruptionBudget"`
	// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
	SecureSettings ElasticsearchSpecSecureSettingsPatchArrayInput `pulumi:"secureSettings"`
	UpdateStrategy ElasticsearchSpecUpdateStrategyPatchPtrInput   `pulumi:"updateStrategy"`
	// Version of Elasticsearch.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ElasticsearchSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPatchArgs) ToElasticsearchSpecPatchOutput() ElasticsearchSpecPatchOutput {
	return i.ToElasticsearchSpecPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPatchArgs) ToElasticsearchSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPatchOutput)
}

func (i ElasticsearchSpecPatchArgs) ToElasticsearchSpecPatchPtrOutput() ElasticsearchSpecPatchPtrOutput {
	return i.ToElasticsearchSpecPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPatchArgs) ToElasticsearchSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPatchOutput).ToElasticsearchSpecPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPatchPtrInput is an input type that accepts ElasticsearchSpecPatchArgs, ElasticsearchSpecPatchPtr and ElasticsearchSpecPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPatchPtrInput` via:
//
//	        ElasticsearchSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPatchPtrOutput() ElasticsearchSpecPatchPtrOutput
	ToElasticsearchSpecPatchPtrOutputWithContext(context.Context) ElasticsearchSpecPatchPtrOutput
}

type elasticsearchSpecPatchPtrType ElasticsearchSpecPatchArgs

func ElasticsearchSpecPatchPtr(v *ElasticsearchSpecPatchArgs) ElasticsearchSpecPatchPtrInput {
	return (*elasticsearchSpecPatchPtrType)(v)
}

func (*elasticsearchSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPatch)(nil)).Elem()
}

func (i *elasticsearchSpecPatchPtrType) ToElasticsearchSpecPatchPtrOutput() ElasticsearchSpecPatchPtrOutput {
	return i.ToElasticsearchSpecPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPatchPtrType) ToElasticsearchSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPatchPtrOutput)
}

// ElasticsearchSpec holds the specification of an Elasticsearch cluster.
type ElasticsearchSpecPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPatchOutput) ToElasticsearchSpecPatchOutput() ElasticsearchSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecPatchOutput) ToElasticsearchSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecPatchOutput) ToElasticsearchSpecPatchPtrOutput() ElasticsearchSpecPatchPtrOutput {
	return o.ToElasticsearchSpecPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPatchOutput) ToElasticsearchSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPatch) *ElasticsearchSpecPatch {
		return &v
	}).(ElasticsearchSpecPatchPtrOutput)
}

func (o ElasticsearchSpecPatchOutput) Http() ElasticsearchSpecHttpPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) *ElasticsearchSpecHttpPatch { return v.Http }).(ElasticsearchSpecHttpPatchPtrOutput)
}

// Image is the Elasticsearch Docker image to deploy.
func (o ElasticsearchSpecPatchOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
func (o ElasticsearchSpecPatchOutput) NodeSets() ElasticsearchSpecNodeSetsPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) []ElasticsearchSpecNodeSetsPatch { return v.NodeSets }).(ElasticsearchSpecNodeSetsPatchArrayOutput)
}

func (o ElasticsearchSpecPatchOutput) PodDisruptionBudget() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) *ElasticsearchSpecPodDisruptionBudgetPatch {
		return v.PodDisruptionBudget
	}).(ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
func (o ElasticsearchSpecPatchOutput) SecureSettings() ElasticsearchSpecSecureSettingsPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) []ElasticsearchSpecSecureSettingsPatch { return v.SecureSettings }).(ElasticsearchSpecSecureSettingsPatchArrayOutput)
}

func (o ElasticsearchSpecPatchOutput) UpdateStrategy() ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) *ElasticsearchSpecUpdateStrategyPatch { return v.UpdateStrategy }).(ElasticsearchSpecUpdateStrategyPatchPtrOutput)
}

// Version of Elasticsearch.
func (o ElasticsearchSpecPatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPatchPtrOutput) ToElasticsearchSpecPatchPtrOutput() ElasticsearchSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPatchPtrOutput) ToElasticsearchSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPatchPtrOutput) Elem() ElasticsearchSpecPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) ElasticsearchSpecPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPatch
		return ret
	}).(ElasticsearchSpecPatchOutput)
}

func (o ElasticsearchSpecPatchPtrOutput) Http() ElasticsearchSpecHttpPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) *ElasticsearchSpecHttpPatch {
		if v == nil {
			return nil
		}
		return v.Http
	}).(ElasticsearchSpecHttpPatchPtrOutput)
}

// Image is the Elasticsearch Docker image to deploy.
func (o ElasticsearchSpecPatchPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
func (o ElasticsearchSpecPatchPtrOutput) NodeSets() ElasticsearchSpecNodeSetsPatchArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) []ElasticsearchSpecNodeSetsPatch {
		if v == nil {
			return nil
		}
		return v.NodeSets
	}).(ElasticsearchSpecNodeSetsPatchArrayOutput)
}

func (o ElasticsearchSpecPatchPtrOutput) PodDisruptionBudget() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) *ElasticsearchSpecPodDisruptionBudgetPatch {
		if v == nil {
			return nil
		}
		return v.PodDisruptionBudget
	}).(ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput)
}

// SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
func (o ElasticsearchSpecPatchPtrOutput) SecureSettings() ElasticsearchSpecSecureSettingsPatchArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) []ElasticsearchSpecSecureSettingsPatch {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(ElasticsearchSpecSecureSettingsPatchArrayOutput)
}

func (o ElasticsearchSpecPatchPtrOutput) UpdateStrategy() ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) *ElasticsearchSpecUpdateStrategyPatch {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(ElasticsearchSpecUpdateStrategyPatchPtrOutput)
}

// Version of Elasticsearch.
func (o ElasticsearchSpecPatchPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster.
// The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget`
// to the empty value (`{}` in YAML).
type ElasticsearchSpecPodDisruptionBudget struct {
	Metadata *ElasticsearchSpecPodDisruptionBudgetMetadata `pulumi:"metadata"`
	Spec     *ElasticsearchSpecPodDisruptionBudgetSpec     `pulumi:"spec"`
}

// ElasticsearchSpecPodDisruptionBudgetInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetArgs and ElasticsearchSpecPodDisruptionBudgetOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetArgs{...}
type ElasticsearchSpecPodDisruptionBudgetInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetOutput() ElasticsearchSpecPodDisruptionBudgetOutput
	ToElasticsearchSpecPodDisruptionBudgetOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetOutput
}

// PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster.
// The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget`
// to the empty value (`{}` in YAML).
type ElasticsearchSpecPodDisruptionBudgetArgs struct {
	Metadata ElasticsearchSpecPodDisruptionBudgetMetadataPtrInput `pulumi:"metadata"`
	Spec     ElasticsearchSpecPodDisruptionBudgetSpecPtrInput     `pulumi:"spec"`
}

func (ElasticsearchSpecPodDisruptionBudgetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudget)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetArgs) ToElasticsearchSpecPodDisruptionBudgetOutput() ElasticsearchSpecPodDisruptionBudgetOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetArgs) ToElasticsearchSpecPodDisruptionBudgetOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetArgs) ToElasticsearchSpecPodDisruptionBudgetPtrOutput() ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetArgs) ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetOutput).ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetArgs, ElasticsearchSpecPodDisruptionBudgetPtr and ElasticsearchSpecPodDisruptionBudgetPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetPtrOutput() ElasticsearchSpecPodDisruptionBudgetPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetPtrType ElasticsearchSpecPodDisruptionBudgetArgs

func ElasticsearchSpecPodDisruptionBudgetPtr(v *ElasticsearchSpecPodDisruptionBudgetArgs) ElasticsearchSpecPodDisruptionBudgetPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudget)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetPtrType) ToElasticsearchSpecPodDisruptionBudgetPtrOutput() ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetPtrType) ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetPtrOutput)
}

// PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster.
// The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget`
// to the empty value (`{}` in YAML).
type ElasticsearchSpecPodDisruptionBudgetOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudget)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetOutput) ToElasticsearchSpecPodDisruptionBudgetOutput() ElasticsearchSpecPodDisruptionBudgetOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetOutput) ToElasticsearchSpecPodDisruptionBudgetOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetOutput) ToElasticsearchSpecPodDisruptionBudgetPtrOutput() ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetOutput) ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudget) *ElasticsearchSpecPodDisruptionBudget {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetOutput) Metadata() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudget) *ElasticsearchSpecPodDisruptionBudgetMetadata {
		return v.Metadata
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetOutput) Spec() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudget) *ElasticsearchSpecPodDisruptionBudgetSpec { return v.Spec }).(ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput)
}

type ElasticsearchSpecPodDisruptionBudgetPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudget)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetPtrOutput) ToElasticsearchSpecPodDisruptionBudgetPtrOutput() ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetPtrOutput) ToElasticsearchSpecPodDisruptionBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudget) ElasticsearchSpecPodDisruptionBudget {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudget
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetPtrOutput) Metadata() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudget) *ElasticsearchSpecPodDisruptionBudgetMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetPtrOutput) Spec() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudget) *ElasticsearchSpecPodDisruptionBudgetSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput)
}

// ObjectMeta is the metadata of the PDB.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecPodDisruptionBudgetMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticsearchSpecPodDisruptionBudgetMetadataInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetMetadataArgs and ElasticsearchSpecPodDisruptionBudgetMetadataOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetMetadataInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetMetadataArgs{...}
type ElasticsearchSpecPodDisruptionBudgetMetadataInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetMetadataOutput() ElasticsearchSpecPodDisruptionBudgetMetadataOutput
	ToElasticsearchSpecPodDisruptionBudgetMetadataOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataOutput
}

// ObjectMeta is the metadata of the PDB.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecPodDisruptionBudgetMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticsearchSpecPodDisruptionBudgetMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadata)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataOutput() ElasticsearchSpecPodDisruptionBudgetMetadataOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetMetadataOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetMetadataOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetMetadataOutput).ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetMetadataPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetMetadataArgs, ElasticsearchSpecPodDisruptionBudgetMetadataPtr and ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetMetadataPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetMetadataArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetMetadataPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetMetadataPtrType ElasticsearchSpecPodDisruptionBudgetMetadataArgs

func ElasticsearchSpecPodDisruptionBudgetMetadataPtr(v *ElasticsearchSpecPodDisruptionBudgetMetadataArgs) ElasticsearchSpecPodDisruptionBudgetMetadataPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetMetadataPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetMetadata)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetMetadataPtrType) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetMetadataPtrType) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput)
}

// ObjectMeta is the metadata of the PDB.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecPodDisruptionBudgetMetadataOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadata)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataOutput() ElasticsearchSpecPodDisruptionBudgetMetadataOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetMetadata) *ElasticsearchSpecPodDisruptionBudgetMetadata {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetMetadata)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetMetadataOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadata) ElasticsearchSpecPodDisruptionBudgetMetadata {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetMetadata
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ObjectMeta is the metadata of the PDB.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecPodDisruptionBudgetMetadataPatch struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// ElasticsearchSpecPodDisruptionBudgetMetadataPatchInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs and ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetMetadataPatchInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs{...}
type ElasticsearchSpecPodDisruptionBudgetMetadataPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput
	ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput
}

// ObjectMeta is the metadata of the PDB.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadataPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput).ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs, ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtr and ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetMetadataPatchPtrType ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs

func ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtr(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs) ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetMetadataPatchPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetMetadataPatch)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetMetadataPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetMetadataPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput)
}

// ObjectMeta is the metadata of the PDB.
// The name and namespace provided here are managed by ECK and will be ignored.
type ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadataPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetMetadataPatch) *ElasticsearchSpecPodDisruptionBudgetMetadataPatch {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadataPatch) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadataPatch) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadataPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetMetadataPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetMetadataPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatch) ElasticsearchSpecPodDisruptionBudgetMetadataPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetMetadataPatch
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetMetadataPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster.
// The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget`
// to the empty value (`{}` in YAML).
type ElasticsearchSpecPodDisruptionBudgetPatch struct {
	Metadata *ElasticsearchSpecPodDisruptionBudgetMetadataPatch `pulumi:"metadata"`
	Spec     *ElasticsearchSpecPodDisruptionBudgetSpecPatch     `pulumi:"spec"`
}

// ElasticsearchSpecPodDisruptionBudgetPatchInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetPatchArgs and ElasticsearchSpecPodDisruptionBudgetPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetPatchInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetPatchArgs{...}
type ElasticsearchSpecPodDisruptionBudgetPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetPatchOutput() ElasticsearchSpecPodDisruptionBudgetPatchOutput
	ToElasticsearchSpecPodDisruptionBudgetPatchOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetPatchOutput
}

// PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster.
// The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget`
// to the empty value (`{}` in YAML).
type ElasticsearchSpecPodDisruptionBudgetPatchArgs struct {
	Metadata ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrInput     `pulumi:"spec"`
}

func (ElasticsearchSpecPodDisruptionBudgetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetPatchArgs) ToElasticsearchSpecPodDisruptionBudgetPatchOutput() ElasticsearchSpecPodDisruptionBudgetPatchOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetPatchArgs) ToElasticsearchSpecPodDisruptionBudgetPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetPatchOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetPatchArgs) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetPatchArgs) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetPatchOutput).ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetPatchPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetPatchArgs, ElasticsearchSpecPodDisruptionBudgetPatchPtr and ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetPatchPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetPatchPtrType ElasticsearchSpecPodDisruptionBudgetPatchArgs

func ElasticsearchSpecPodDisruptionBudgetPatchPtr(v *ElasticsearchSpecPodDisruptionBudgetPatchArgs) ElasticsearchSpecPodDisruptionBudgetPatchPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetPatchPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetPatch)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput)
}

// PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster.
// The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget`
// to the empty value (`{}` in YAML).
type ElasticsearchSpecPodDisruptionBudgetPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchOutput) ToElasticsearchSpecPodDisruptionBudgetPatchOutput() ElasticsearchSpecPodDisruptionBudgetPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchOutput) ToElasticsearchSpecPodDisruptionBudgetPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchOutput) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchOutput) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetPatch) *ElasticsearchSpecPodDisruptionBudgetPatch {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchOutput) Metadata() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetPatch) *ElasticsearchSpecPodDisruptionBudgetMetadataPatch {
		return v.Metadata
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchOutput) Spec() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetPatch) *ElasticsearchSpecPodDisruptionBudgetSpecPatch {
		return v.Spec
	}).(ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput)
}

type ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetPatch) ElasticsearchSpecPodDisruptionBudgetPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetPatch
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetPatchOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput) Metadata() ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetPatch) *ElasticsearchSpecPodDisruptionBudgetMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput) Spec() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetPatch) *ElasticsearchSpecPodDisruptionBudgetSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput)
}

// Spec is the specification of the PDB.
type ElasticsearchSpecPodDisruptionBudgetSpec struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by
	// "selector" are unavailable after the eviction, i.e. even in absence of
	// the evicted pod. For example, one can prevent all voluntary evictions
	// by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by
	// "selector" will still be available after the eviction, i.e. even in the
	// absence of the evicted pod.  So for example you can prevent all voluntary
	// evictions by specifying "100%".
	MinAvailable interface{}                                       `pulumi:"minAvailable"`
	Selector     *ElasticsearchSpecPodDisruptionBudgetSpecSelector `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
	// should be considered for eviction. Current implementation considers healthy pods,
	// as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow.
	// If no policy is specified, the default behavior will be used,
	// which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"),
	// but not yet healthy can be evicted only if the guarded application is not
	// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
	// Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"),
	// but not yet healthy are considered disrupted and can be evicted regardless
	// of whether the criteria in a PDB is met. This means perspective running
	// pods of a disrupted application might not get a chance to become healthy.
	// Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future.
	// Clients making eviction decisions should disallow eviction of unhealthy pods
	// if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when
	// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy *string `pulumi:"unhealthyPodEvictionPolicy"`
}

// ElasticsearchSpecPodDisruptionBudgetSpecInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecArgs and ElasticsearchSpecPodDisruptionBudgetSpecOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecArgs{...}
type ElasticsearchSpecPodDisruptionBudgetSpecInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecOutput() ElasticsearchSpecPodDisruptionBudgetSpecOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecOutput
}

// Spec is the specification of the PDB.
type ElasticsearchSpecPodDisruptionBudgetSpecArgs struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by
	// "selector" are unavailable after the eviction, i.e. even in absence of
	// the evicted pod. For example, one can prevent all voluntary evictions
	// by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by
	// "selector" will still be available after the eviction, i.e. even in the
	// absence of the evicted pod.  So for example you can prevent all voluntary
	// evictions by specifying "100%".
	MinAvailable pulumi.Input                                             `pulumi:"minAvailable"`
	Selector     ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrInput `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
	// should be considered for eviction. Current implementation considers healthy pods,
	// as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow.
	// If no policy is specified, the default behavior will be used,
	// which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"),
	// but not yet healthy can be evicted only if the guarded application is not
	// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
	// Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"),
	// but not yet healthy are considered disrupted and can be evicted regardless
	// of whether the criteria in a PDB is met. This means perspective running
	// pods of a disrupted application might not get a chance to become healthy.
	// Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future.
	// Clients making eviction decisions should disallow eviction of unhealthy pods
	// if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when
	// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy pulumi.StringPtrInput `pulumi:"unhealthyPodEvictionPolicy"`
}

func (ElasticsearchSpecPodDisruptionBudgetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpec)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecArgs) ToElasticsearchSpecPodDisruptionBudgetSpecOutput() ElasticsearchSpecPodDisruptionBudgetSpecOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecArgs) ToElasticsearchSpecPodDisruptionBudgetSpecOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecArgs) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecArgs) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecOutput).ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetSpecPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecArgs, ElasticsearchSpecPodDisruptionBudgetSpecPtr and ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetSpecArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetSpecPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetSpecPtrType ElasticsearchSpecPodDisruptionBudgetSpecArgs

func ElasticsearchSpecPodDisruptionBudgetSpecPtr(v *ElasticsearchSpecPodDisruptionBudgetSpecArgs) ElasticsearchSpecPodDisruptionBudgetSpecPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetSpecPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpec)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput)
}

// Spec is the specification of the PDB.
type ElasticsearchSpecPodDisruptionBudgetSpecOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpec)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) ToElasticsearchSpecPodDisruptionBudgetSpecOutput() ElasticsearchSpecPodDisruptionBudgetSpecOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) ToElasticsearchSpecPodDisruptionBudgetSpecOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetSpec) *ElasticsearchSpecPodDisruptionBudgetSpec {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by
// "selector" are unavailable after the eviction, i.e. even in absence of
// the evicted pod. For example, one can prevent all voluntary evictions
// by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpec) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by
// "selector" will still be available after the eviction, i.e. even in the
// absence of the evicted pod.  So for example you can prevent all voluntary
// evictions by specifying "100%".
func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpec) interface{} { return v.MinAvailable }).(pulumi.AnyOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) Selector() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpec) *ElasticsearchSpecPodDisruptionBudgetSpecSelector {
		return v.Selector
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
// should be considered for eviction. Current implementation considers healthy pods,
// as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow.
// If no policy is specified, the default behavior will be used,
// which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"),
// but not yet healthy can be evicted only if the guarded application is not
// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
// Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"),
// but not yet healthy are considered disrupted and can be evicted regardless
// of whether the criteria in a PDB is met. This means perspective running
// pods of a disrupted application might not get a chance to become healthy.
// Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future.
// Clients making eviction decisions should disallow eviction of unhealthy pods
// if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when
// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o ElasticsearchSpecPodDisruptionBudgetSpecOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpec) *string { return v.UnhealthyPodEvictionPolicy }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpec)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetSpecOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpec) ElasticsearchSpecPodDisruptionBudgetSpec {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetSpec
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetSpecOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by
// "selector" are unavailable after the eviction, i.e. even in absence of
// the evicted pod. For example, one can prevent all voluntary evictions
// by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpec) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by
// "selector" will still be available after the eviction, i.e. even in the
// absence of the evicted pod.  So for example you can prevent all voluntary
// evictions by specifying "100%".
func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpec) interface{} {
		if v == nil {
			return nil
		}
		return v.MinAvailable
	}).(pulumi.AnyOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) Selector() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpec) *ElasticsearchSpecPodDisruptionBudgetSpecSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
// should be considered for eviction. Current implementation considers healthy pods,
// as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow.
// If no policy is specified, the default behavior will be used,
// which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"),
// but not yet healthy can be evicted only if the guarded application is not
// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
// Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"),
// but not yet healthy are considered disrupted and can be evicted regardless
// of whether the criteria in a PDB is met. This means perspective running
// pods of a disrupted application might not get a chance to become healthy.
// Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future.
// Clients making eviction decisions should disallow eviction of unhealthy pods
// if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when
// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpec) *string {
		if v == nil {
			return nil
		}
		return v.UnhealthyPodEvictionPolicy
	}).(pulumi.StringPtrOutput)
}

// Spec is the specification of the PDB.
type ElasticsearchSpecPodDisruptionBudgetSpecPatch struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by
	// "selector" are unavailable after the eviction, i.e. even in absence of
	// the evicted pod. For example, one can prevent all voluntary evictions
	// by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by
	// "selector" will still be available after the eviction, i.e. even in the
	// absence of the evicted pod.  So for example you can prevent all voluntary
	// evictions by specifying "100%".
	MinAvailable interface{}                                            `pulumi:"minAvailable"`
	Selector     *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
	// should be considered for eviction. Current implementation considers healthy pods,
	// as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow.
	// If no policy is specified, the default behavior will be used,
	// which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"),
	// but not yet healthy can be evicted only if the guarded application is not
	// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
	// Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"),
	// but not yet healthy are considered disrupted and can be evicted regardless
	// of whether the criteria in a PDB is met. This means perspective running
	// pods of a disrupted application might not get a chance to become healthy.
	// Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future.
	// Clients making eviction decisions should disallow eviction of unhealthy pods
	// if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when
	// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy *string `pulumi:"unhealthyPodEvictionPolicy"`
}

// ElasticsearchSpecPodDisruptionBudgetSpecPatchInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs and ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecPatchInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs{...}
type ElasticsearchSpecPodDisruptionBudgetSpecPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput
}

// Spec is the specification of the PDB.
type ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by
	// "selector" are unavailable after the eviction, i.e. even in absence of
	// the evicted pod. For example, one can prevent all voluntary evictions
	// by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by
	// "selector" will still be available after the eviction, i.e. even in the
	// absence of the evicted pod.  So for example you can prevent all voluntary
	// evictions by specifying "100%".
	MinAvailable pulumi.Input                                                  `pulumi:"minAvailable"`
	Selector     ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrInput `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
	// should be considered for eviction. Current implementation considers healthy pods,
	// as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow.
	// If no policy is specified, the default behavior will be used,
	// which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"),
	// but not yet healthy can be evicted only if the guarded application is not
	// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
	// Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"),
	// but not yet healthy are considered disrupted and can be evicted regardless
	// of whether the criteria in a PDB is met. This means perspective running
	// pods of a disrupted application might not get a chance to become healthy.
	// Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future.
	// Clients making eviction decisions should disallow eviction of unhealthy pods
	// if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when
	// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy pulumi.StringPtrInput `pulumi:"unhealthyPodEvictionPolicy"`
}

func (ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput).ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs, ElasticsearchSpecPodDisruptionBudgetSpecPatchPtr and ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetSpecPatchPtrType ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs

func ElasticsearchSpecPodDisruptionBudgetSpecPatchPtr(v *ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs) ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetSpecPatchPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput)
}

// Spec is the specification of the PDB.
type ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetSpecPatch) *ElasticsearchSpecPodDisruptionBudgetSpecPatch {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by
// "selector" are unavailable after the eviction, i.e. even in absence of
// the evicted pod. For example, one can prevent all voluntary evictions
// by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecPatch) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by
// "selector" will still be available after the eviction, i.e. even in the
// absence of the evicted pod.  So for example you can prevent all voluntary
// evictions by specifying "100%".
func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecPatch) interface{} { return v.MinAvailable }).(pulumi.AnyOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) Selector() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecPatch) *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch {
		return v.Selector
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
// should be considered for eviction. Current implementation considers healthy pods,
// as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow.
// If no policy is specified, the default behavior will be used,
// which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"),
// but not yet healthy can be evicted only if the guarded application is not
// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
// Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"),
// but not yet healthy are considered disrupted and can be evicted regardless
// of whether the criteria in a PDB is met. This means perspective running
// pods of a disrupted application might not get a chance to become healthy.
// Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future.
// Clients making eviction decisions should disallow eviction of unhealthy pods
// if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when
// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecPatch) *string { return v.UnhealthyPodEvictionPolicy }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecPatch) ElasticsearchSpecPodDisruptionBudgetSpecPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetSpecPatch
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by
// "selector" are unavailable after the eviction, i.e. even in absence of
// the evicted pod. For example, one can prevent all voluntary evictions
// by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecPatch) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by
// "selector" will still be available after the eviction, i.e. even in the
// absence of the evicted pod.  So for example you can prevent all voluntary
// evictions by specifying "100%".
func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecPatch) interface{} {
		if v == nil {
			return nil
		}
		return v.MinAvailable
	}).(pulumi.AnyOutput)
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) Selector() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecPatch) *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods
// should be considered for eviction. Current implementation considers healthy pods,
// as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow.
// If no policy is specified, the default behavior will be used,
// which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"),
// but not yet healthy can be evicted only if the guarded application is not
// disrupted (status.currentHealthy is at least equal to status.desiredHealthy).
// Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"),
// but not yet healthy are considered disrupted and can be evicted regardless
// of whether the criteria in a PDB is met. This means perspective running
// pods of a disrupted application might not get a chance to become healthy.
// Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future.
// Clients making eviction decisions should disallow eviction of unhealthy pods
// if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when
// the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.UnhealthyPodEvictionPolicy
	}).(pulumi.StringPtrOutput)
}

// Label query over pods whose evictions are managed by the disruption
// budget.
// A null selector selects no pods.
// An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods.
// In policy/v1, an empty selector will select all pods in the namespace.
type ElasticsearchSpecPodDisruptionBudgetSpecSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs and ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs{...}
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput
}

// Label query over pods whose evictions are managed by the disruption
// budget.
// A null selector selects no pods.
// An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods.
// In policy/v1, an empty selector will select all pods in the namespace.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelector)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput).ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs, ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtr and ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetSpecSelectorPtrType ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs

func ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtr(v *ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetSpecSelectorPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetSpecSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpecSelector)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecSelectorPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecSelectorPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput)
}

// Label query over pods whose evictions are managed by the disruption
// budget.
// A null selector selects no pods.
// An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods.
// In policy/v1, an empty selector will select all pods in the namespace.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelector)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetSpecSelector) *ElasticsearchSpecPodDisruptionBudgetSpecSelector {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) MatchExpressions() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelector) []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpecSelector)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecSelector) ElasticsearchSpecPodDisruptionBudgetSpecSelector {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetSpecSelector
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput) MatchExpressions() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecSelector) []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs and ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs{...}
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput)
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray and ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray{ ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs{...} }
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput
}

type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsInput

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions {
		return vs[0].([]ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressions)[vs[1].(int)]
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs and ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs{...}
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput)
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray and ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray{ ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs{...} }
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput
}

type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchInput

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch {
		return vs[0].([]ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput)
}

// Label query over pods whose evictions are managed by the disruption
// budget.
// A null selector selects no pods.
// An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods.
// In policy/v1, an empty selector will select all pods in the namespace.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs and ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchInput` via:
//
//	ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs{...}
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput
}

// Label query over pods whose evictions are managed by the disruption
// budget.
// A null selector selects no pods.
// An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods.
// In policy/v1, an empty selector will select all pods in the namespace.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch)(nil)).Elem()
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput)
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput).ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrInput is an input type that accepts ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs, ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtr and ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrInput` via:
//
//	        ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput
	ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput
}

type elasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrType ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs

func ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtr(v *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrInput {
	return (*elasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrType)(v)
}

func (*elasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch)(nil)).Elem()
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return i.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrType) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput)
}

// Label query over pods whose evictions are managed by the disruption
// budget.
// A null selector selects no pods.
// An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods.
// In policy/v1, an empty selector will select all pods in the namespace.
type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return o.ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch) *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch {
		return &v
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) MatchExpressions() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch) []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch)(nil)).Elem()
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput) ToElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput) Elem() ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch) ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch
		return ret
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput) MatchExpressions() ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch) []ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type ElasticsearchSpecSecureSettings struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []ElasticsearchSpecSecureSettingsEntries `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticsearchSpecSecureSettingsInput is an input type that accepts ElasticsearchSpecSecureSettingsArgs and ElasticsearchSpecSecureSettingsOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsInput` via:
//
//	ElasticsearchSpecSecureSettingsArgs{...}
type ElasticsearchSpecSecureSettingsInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsOutput() ElasticsearchSpecSecureSettingsOutput
	ToElasticsearchSpecSecureSettingsOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type ElasticsearchSpecSecureSettingsArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries ElasticsearchSpecSecureSettingsEntriesArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticsearchSpecSecureSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettings)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsArgs) ToElasticsearchSpecSecureSettingsOutput() ElasticsearchSpecSecureSettingsOutput {
	return i.ToElasticsearchSpecSecureSettingsOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsArgs) ToElasticsearchSpecSecureSettingsOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsOutput)
}

// ElasticsearchSpecSecureSettingsArrayInput is an input type that accepts ElasticsearchSpecSecureSettingsArray and ElasticsearchSpecSecureSettingsArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsArrayInput` via:
//
//	ElasticsearchSpecSecureSettingsArray{ ElasticsearchSpecSecureSettingsArgs{...} }
type ElasticsearchSpecSecureSettingsArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsArrayOutput() ElasticsearchSpecSecureSettingsArrayOutput
	ToElasticsearchSpecSecureSettingsArrayOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsArrayOutput
}

type ElasticsearchSpecSecureSettingsArray []ElasticsearchSpecSecureSettingsInput

func (ElasticsearchSpecSecureSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettings)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsArray) ToElasticsearchSpecSecureSettingsArrayOutput() ElasticsearchSpecSecureSettingsArrayOutput {
	return i.ToElasticsearchSpecSecureSettingsArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsArray) ToElasticsearchSpecSecureSettingsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type ElasticsearchSpecSecureSettingsOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettings)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsOutput) ToElasticsearchSpecSecureSettingsOutput() ElasticsearchSpecSecureSettingsOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsOutput) ToElasticsearchSpecSecureSettingsOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o ElasticsearchSpecSecureSettingsOutput) Entries() ElasticsearchSpecSecureSettingsEntriesArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettings) []ElasticsearchSpecSecureSettingsEntries { return v.Entries }).(ElasticsearchSpecSecureSettingsEntriesArrayOutput)
}

// SecretName is the name of the secret.
func (o ElasticsearchSpecSecureSettingsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettings) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecSecureSettingsArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettings)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsArrayOutput) ToElasticsearchSpecSecureSettingsArrayOutput() ElasticsearchSpecSecureSettingsArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsArrayOutput) ToElasticsearchSpecSecureSettingsArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecSecureSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecSecureSettings {
		return vs[0].([]ElasticsearchSpecSecureSettings)[vs[1].(int)]
	}).(ElasticsearchSpecSecureSettingsOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type ElasticsearchSpecSecureSettingsEntries struct {
	// Key is the key contained in the secret.
	Key *string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// ElasticsearchSpecSecureSettingsEntriesInput is an input type that accepts ElasticsearchSpecSecureSettingsEntriesArgs and ElasticsearchSpecSecureSettingsEntriesOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsEntriesInput` via:
//
//	ElasticsearchSpecSecureSettingsEntriesArgs{...}
type ElasticsearchSpecSecureSettingsEntriesInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsEntriesOutput() ElasticsearchSpecSecureSettingsEntriesOutput
	ToElasticsearchSpecSecureSettingsEntriesOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsEntriesOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type ElasticsearchSpecSecureSettingsEntriesArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (ElasticsearchSpecSecureSettingsEntriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntries)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsEntriesArgs) ToElasticsearchSpecSecureSettingsEntriesOutput() ElasticsearchSpecSecureSettingsEntriesOutput {
	return i.ToElasticsearchSpecSecureSettingsEntriesOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsEntriesArgs) ToElasticsearchSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsEntriesOutput)
}

// ElasticsearchSpecSecureSettingsEntriesArrayInput is an input type that accepts ElasticsearchSpecSecureSettingsEntriesArray and ElasticsearchSpecSecureSettingsEntriesArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsEntriesArrayInput` via:
//
//	ElasticsearchSpecSecureSettingsEntriesArray{ ElasticsearchSpecSecureSettingsEntriesArgs{...} }
type ElasticsearchSpecSecureSettingsEntriesArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsEntriesArrayOutput() ElasticsearchSpecSecureSettingsEntriesArrayOutput
	ToElasticsearchSpecSecureSettingsEntriesArrayOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsEntriesArrayOutput
}

type ElasticsearchSpecSecureSettingsEntriesArray []ElasticsearchSpecSecureSettingsEntriesInput

func (ElasticsearchSpecSecureSettingsEntriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettingsEntries)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsEntriesArray) ToElasticsearchSpecSecureSettingsEntriesArrayOutput() ElasticsearchSpecSecureSettingsEntriesArrayOutput {
	return i.ToElasticsearchSpecSecureSettingsEntriesArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsEntriesArray) ToElasticsearchSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsEntriesArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type ElasticsearchSpecSecureSettingsEntriesOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsEntriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntries)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsEntriesOutput) ToElasticsearchSpecSecureSettingsEntriesOutput() ElasticsearchSpecSecureSettingsEntriesOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsEntriesOutput) ToElasticsearchSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesOutput {
	return o
}

// Key is the key contained in the secret.
func (o ElasticsearchSpecSecureSettingsEntriesOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettingsEntries) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o ElasticsearchSpecSecureSettingsEntriesOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettingsEntries) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecSecureSettingsEntriesArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsEntriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettingsEntries)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsEntriesArrayOutput) ToElasticsearchSpecSecureSettingsEntriesArrayOutput() ElasticsearchSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsEntriesArrayOutput) ToElasticsearchSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsEntriesArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecSecureSettingsEntriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecSecureSettingsEntries {
		return vs[0].([]ElasticsearchSpecSecureSettingsEntries)[vs[1].(int)]
	}).(ElasticsearchSpecSecureSettingsEntriesOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type ElasticsearchSpecSecureSettingsEntriesPatch struct {
	// Key is the key contained in the secret.
	Key *string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// ElasticsearchSpecSecureSettingsEntriesPatchInput is an input type that accepts ElasticsearchSpecSecureSettingsEntriesPatchArgs and ElasticsearchSpecSecureSettingsEntriesPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsEntriesPatchInput` via:
//
//	ElasticsearchSpecSecureSettingsEntriesPatchArgs{...}
type ElasticsearchSpecSecureSettingsEntriesPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsEntriesPatchOutput() ElasticsearchSpecSecureSettingsEntriesPatchOutput
	ToElasticsearchSpecSecureSettingsEntriesPatchOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsEntriesPatchOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type ElasticsearchSpecSecureSettingsEntriesPatchArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (ElasticsearchSpecSecureSettingsEntriesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsEntriesPatchArgs) ToElasticsearchSpecSecureSettingsEntriesPatchOutput() ElasticsearchSpecSecureSettingsEntriesPatchOutput {
	return i.ToElasticsearchSpecSecureSettingsEntriesPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsEntriesPatchArgs) ToElasticsearchSpecSecureSettingsEntriesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsEntriesPatchOutput)
}

// ElasticsearchSpecSecureSettingsEntriesPatchArrayInput is an input type that accepts ElasticsearchSpecSecureSettingsEntriesPatchArray and ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsEntriesPatchArrayInput` via:
//
//	ElasticsearchSpecSecureSettingsEntriesPatchArray{ ElasticsearchSpecSecureSettingsEntriesPatchArgs{...} }
type ElasticsearchSpecSecureSettingsEntriesPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutput() ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput
	ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput
}

type ElasticsearchSpecSecureSettingsEntriesPatchArray []ElasticsearchSpecSecureSettingsEntriesPatchInput

func (ElasticsearchSpecSecureSettingsEntriesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsEntriesPatchArray) ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutput() ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput {
	return i.ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsEntriesPatchArray) ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type ElasticsearchSpecSecureSettingsEntriesPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsEntriesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsEntriesPatchOutput) ToElasticsearchSpecSecureSettingsEntriesPatchOutput() ElasticsearchSpecSecureSettingsEntriesPatchOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsEntriesPatchOutput) ToElasticsearchSpecSecureSettingsEntriesPatchOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesPatchOutput {
	return o
}

// Key is the key contained in the secret.
func (o ElasticsearchSpecSecureSettingsEntriesPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettingsEntriesPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o ElasticsearchSpecSecureSettingsEntriesPatchOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettingsEntriesPatch) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettingsEntriesPatch)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput) ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutput() ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput) ToElasticsearchSpecSecureSettingsEntriesPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecSecureSettingsEntriesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecSecureSettingsEntriesPatch {
		return vs[0].([]ElasticsearchSpecSecureSettingsEntriesPatch)[vs[1].(int)]
	}).(ElasticsearchSpecSecureSettingsEntriesPatchOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type ElasticsearchSpecSecureSettingsPatch struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []ElasticsearchSpecSecureSettingsEntriesPatch `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// ElasticsearchSpecSecureSettingsPatchInput is an input type that accepts ElasticsearchSpecSecureSettingsPatchArgs and ElasticsearchSpecSecureSettingsPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsPatchInput` via:
//
//	ElasticsearchSpecSecureSettingsPatchArgs{...}
type ElasticsearchSpecSecureSettingsPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsPatchOutput() ElasticsearchSpecSecureSettingsPatchOutput
	ToElasticsearchSpecSecureSettingsPatchOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsPatchOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type ElasticsearchSpecSecureSettingsPatchArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries ElasticsearchSpecSecureSettingsEntriesPatchArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (ElasticsearchSpecSecureSettingsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettingsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsPatchArgs) ToElasticsearchSpecSecureSettingsPatchOutput() ElasticsearchSpecSecureSettingsPatchOutput {
	return i.ToElasticsearchSpecSecureSettingsPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsPatchArgs) ToElasticsearchSpecSecureSettingsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsPatchOutput)
}

// ElasticsearchSpecSecureSettingsPatchArrayInput is an input type that accepts ElasticsearchSpecSecureSettingsPatchArray and ElasticsearchSpecSecureSettingsPatchArrayOutput values.
// You can construct a concrete instance of `ElasticsearchSpecSecureSettingsPatchArrayInput` via:
//
//	ElasticsearchSpecSecureSettingsPatchArray{ ElasticsearchSpecSecureSettingsPatchArgs{...} }
type ElasticsearchSpecSecureSettingsPatchArrayInput interface {
	pulumi.Input

	ToElasticsearchSpecSecureSettingsPatchArrayOutput() ElasticsearchSpecSecureSettingsPatchArrayOutput
	ToElasticsearchSpecSecureSettingsPatchArrayOutputWithContext(context.Context) ElasticsearchSpecSecureSettingsPatchArrayOutput
}

type ElasticsearchSpecSecureSettingsPatchArray []ElasticsearchSpecSecureSettingsPatchInput

func (ElasticsearchSpecSecureSettingsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettingsPatch)(nil)).Elem()
}

func (i ElasticsearchSpecSecureSettingsPatchArray) ToElasticsearchSpecSecureSettingsPatchArrayOutput() ElasticsearchSpecSecureSettingsPatchArrayOutput {
	return i.ToElasticsearchSpecSecureSettingsPatchArrayOutputWithContext(context.Background())
}

func (i ElasticsearchSpecSecureSettingsPatchArray) ToElasticsearchSpecSecureSettingsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecSecureSettingsPatchArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type ElasticsearchSpecSecureSettingsPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecSecureSettingsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsPatchOutput) ToElasticsearchSpecSecureSettingsPatchOutput() ElasticsearchSpecSecureSettingsPatchOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsPatchOutput) ToElasticsearchSpecSecureSettingsPatchOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsPatchOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o ElasticsearchSpecSecureSettingsPatchOutput) Entries() ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettingsPatch) []ElasticsearchSpecSecureSettingsEntriesPatch {
		return v.Entries
	}).(ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput)
}

// SecretName is the name of the secret.
func (o ElasticsearchSpecSecureSettingsPatchOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecSecureSettingsPatch) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type ElasticsearchSpecSecureSettingsPatchArrayOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecSecureSettingsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ElasticsearchSpecSecureSettingsPatch)(nil)).Elem()
}

func (o ElasticsearchSpecSecureSettingsPatchArrayOutput) ToElasticsearchSpecSecureSettingsPatchArrayOutput() ElasticsearchSpecSecureSettingsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsPatchArrayOutput) ToElasticsearchSpecSecureSettingsPatchArrayOutputWithContext(ctx context.Context) ElasticsearchSpecSecureSettingsPatchArrayOutput {
	return o
}

func (o ElasticsearchSpecSecureSettingsPatchArrayOutput) Index(i pulumi.IntInput) ElasticsearchSpecSecureSettingsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ElasticsearchSpecSecureSettingsPatch {
		return vs[0].([]ElasticsearchSpecSecureSettingsPatch)[vs[1].(int)]
	}).(ElasticsearchSpecSecureSettingsPatchOutput)
}

// UpdateStrategy specifies how updates to the cluster should be performed.
type ElasticsearchSpecUpdateStrategy struct {
	ChangeBudget *ElasticsearchSpecUpdateStrategyChangeBudget `pulumi:"changeBudget"`
}

// ElasticsearchSpecUpdateStrategyInput is an input type that accepts ElasticsearchSpecUpdateStrategyArgs and ElasticsearchSpecUpdateStrategyOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyInput` via:
//
//	ElasticsearchSpecUpdateStrategyArgs{...}
type ElasticsearchSpecUpdateStrategyInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyOutput() ElasticsearchSpecUpdateStrategyOutput
	ToElasticsearchSpecUpdateStrategyOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyOutput
}

// UpdateStrategy specifies how updates to the cluster should be performed.
type ElasticsearchSpecUpdateStrategyArgs struct {
	ChangeBudget ElasticsearchSpecUpdateStrategyChangeBudgetPtrInput `pulumi:"changeBudget"`
}

func (ElasticsearchSpecUpdateStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategy)(nil)).Elem()
}

func (i ElasticsearchSpecUpdateStrategyArgs) ToElasticsearchSpecUpdateStrategyOutput() ElasticsearchSpecUpdateStrategyOutput {
	return i.ToElasticsearchSpecUpdateStrategyOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyArgs) ToElasticsearchSpecUpdateStrategyOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyOutput)
}

func (i ElasticsearchSpecUpdateStrategyArgs) ToElasticsearchSpecUpdateStrategyPtrOutput() ElasticsearchSpecUpdateStrategyPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyArgs) ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyOutput).ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(ctx)
}

// ElasticsearchSpecUpdateStrategyPtrInput is an input type that accepts ElasticsearchSpecUpdateStrategyArgs, ElasticsearchSpecUpdateStrategyPtr and ElasticsearchSpecUpdateStrategyPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyPtrInput` via:
//
//	        ElasticsearchSpecUpdateStrategyArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecUpdateStrategyPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyPtrOutput() ElasticsearchSpecUpdateStrategyPtrOutput
	ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyPtrOutput
}

type elasticsearchSpecUpdateStrategyPtrType ElasticsearchSpecUpdateStrategyArgs

func ElasticsearchSpecUpdateStrategyPtr(v *ElasticsearchSpecUpdateStrategyArgs) ElasticsearchSpecUpdateStrategyPtrInput {
	return (*elasticsearchSpecUpdateStrategyPtrType)(v)
}

func (*elasticsearchSpecUpdateStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategy)(nil)).Elem()
}

func (i *elasticsearchSpecUpdateStrategyPtrType) ToElasticsearchSpecUpdateStrategyPtrOutput() ElasticsearchSpecUpdateStrategyPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecUpdateStrategyPtrType) ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyPtrOutput)
}

// UpdateStrategy specifies how updates to the cluster should be performed.
type ElasticsearchSpecUpdateStrategyOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategy)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyOutput) ToElasticsearchSpecUpdateStrategyOutput() ElasticsearchSpecUpdateStrategyOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyOutput) ToElasticsearchSpecUpdateStrategyOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyOutput) ToElasticsearchSpecUpdateStrategyPtrOutput() ElasticsearchSpecUpdateStrategyPtrOutput {
	return o.ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecUpdateStrategyOutput) ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecUpdateStrategy) *ElasticsearchSpecUpdateStrategy {
		return &v
	}).(ElasticsearchSpecUpdateStrategyPtrOutput)
}

func (o ElasticsearchSpecUpdateStrategyOutput) ChangeBudget() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecUpdateStrategy) *ElasticsearchSpecUpdateStrategyChangeBudget {
		return v.ChangeBudget
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput)
}

type ElasticsearchSpecUpdateStrategyPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategy)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyPtrOutput) ToElasticsearchSpecUpdateStrategyPtrOutput() ElasticsearchSpecUpdateStrategyPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyPtrOutput) ToElasticsearchSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyPtrOutput) Elem() ElasticsearchSpecUpdateStrategyOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategy) ElasticsearchSpecUpdateStrategy {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecUpdateStrategy
		return ret
	}).(ElasticsearchSpecUpdateStrategyOutput)
}

func (o ElasticsearchSpecUpdateStrategyPtrOutput) ChangeBudget() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategy) *ElasticsearchSpecUpdateStrategyChangeBudget {
		if v == nil {
			return nil
		}
		return v.ChangeBudget
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput)
}

// ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
type ElasticsearchSpecUpdateStrategyChangeBudget struct {
	// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
	// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
	// disable the restriction. Defaults to unbounded if not specified.
	MaxSurge *int `pulumi:"maxSurge"`
	// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
	// circumstances under the control of the operator. Setting a negative value will disable this restriction.
	// Defaults to 1 if not specified.
	MaxUnavailable *int `pulumi:"maxUnavailable"`
}

// ElasticsearchSpecUpdateStrategyChangeBudgetInput is an input type that accepts ElasticsearchSpecUpdateStrategyChangeBudgetArgs and ElasticsearchSpecUpdateStrategyChangeBudgetOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyChangeBudgetInput` via:
//
//	ElasticsearchSpecUpdateStrategyChangeBudgetArgs{...}
type ElasticsearchSpecUpdateStrategyChangeBudgetInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyChangeBudgetOutput() ElasticsearchSpecUpdateStrategyChangeBudgetOutput
	ToElasticsearchSpecUpdateStrategyChangeBudgetOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetOutput
}

// ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
type ElasticsearchSpecUpdateStrategyChangeBudgetArgs struct {
	// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
	// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
	// disable the restriction. Defaults to unbounded if not specified.
	MaxSurge pulumi.IntPtrInput `pulumi:"maxSurge"`
	// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
	// circumstances under the control of the operator. Setting a negative value will disable this restriction.
	// Defaults to 1 if not specified.
	MaxUnavailable pulumi.IntPtrInput `pulumi:"maxUnavailable"`
}

func (ElasticsearchSpecUpdateStrategyChangeBudgetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudget)(nil)).Elem()
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetOutput() ElasticsearchSpecUpdateStrategyChangeBudgetOutput {
	return i.ToElasticsearchSpecUpdateStrategyChangeBudgetOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyChangeBudgetOutput)
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyChangeBudgetOutput).ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(ctx)
}

// ElasticsearchSpecUpdateStrategyChangeBudgetPtrInput is an input type that accepts ElasticsearchSpecUpdateStrategyChangeBudgetArgs, ElasticsearchSpecUpdateStrategyChangeBudgetPtr and ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyChangeBudgetPtrInput` via:
//
//	        ElasticsearchSpecUpdateStrategyChangeBudgetArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecUpdateStrategyChangeBudgetPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput
	ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput
}

type elasticsearchSpecUpdateStrategyChangeBudgetPtrType ElasticsearchSpecUpdateStrategyChangeBudgetArgs

func ElasticsearchSpecUpdateStrategyChangeBudgetPtr(v *ElasticsearchSpecUpdateStrategyChangeBudgetArgs) ElasticsearchSpecUpdateStrategyChangeBudgetPtrInput {
	return (*elasticsearchSpecUpdateStrategyChangeBudgetPtrType)(v)
}

func (*elasticsearchSpecUpdateStrategyChangeBudgetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategyChangeBudget)(nil)).Elem()
}

func (i *elasticsearchSpecUpdateStrategyChangeBudgetPtrType) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecUpdateStrategyChangeBudgetPtrType) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput)
}

// ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
type ElasticsearchSpecUpdateStrategyChangeBudgetOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyChangeBudgetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudget)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetOutput() ElasticsearchSpecUpdateStrategyChangeBudgetOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return o.ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecUpdateStrategyChangeBudget) *ElasticsearchSpecUpdateStrategyChangeBudget {
		return &v
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput)
}

// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
// disable the restriction. Defaults to unbounded if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetOutput) MaxSurge() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecUpdateStrategyChangeBudget) *int { return v.MaxSurge }).(pulumi.IntPtrOutput)
}

// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
// circumstances under the control of the operator. Setting a negative value will disable this restriction.
// Defaults to 1 if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetOutput) MaxUnavailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecUpdateStrategyChangeBudget) *int { return v.MaxUnavailable }).(pulumi.IntPtrOutput)
}

type ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategyChangeBudget)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput) Elem() ElasticsearchSpecUpdateStrategyChangeBudgetOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyChangeBudget) ElasticsearchSpecUpdateStrategyChangeBudget {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecUpdateStrategyChangeBudget
		return ret
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetOutput)
}

// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
// disable the restriction. Defaults to unbounded if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput) MaxSurge() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyChangeBudget) *int {
		if v == nil {
			return nil
		}
		return v.MaxSurge
	}).(pulumi.IntPtrOutput)
}

// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
// circumstances under the control of the operator. Setting a negative value will disable this restriction.
// Defaults to 1 if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput) MaxUnavailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyChangeBudget) *int {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.IntPtrOutput)
}

// ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
type ElasticsearchSpecUpdateStrategyChangeBudgetPatch struct {
	// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
	// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
	// disable the restriction. Defaults to unbounded if not specified.
	MaxSurge *int `pulumi:"maxSurge"`
	// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
	// circumstances under the control of the operator. Setting a negative value will disable this restriction.
	// Defaults to 1 if not specified.
	MaxUnavailable *int `pulumi:"maxUnavailable"`
}

// ElasticsearchSpecUpdateStrategyChangeBudgetPatchInput is an input type that accepts ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs and ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyChangeBudgetPatchInput` via:
//
//	ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs{...}
type ElasticsearchSpecUpdateStrategyChangeBudgetPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput
	ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput
}

// ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
type ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs struct {
	// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
	// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
	// disable the restriction. Defaults to unbounded if not specified.
	MaxSurge pulumi.IntPtrInput `pulumi:"maxSurge"`
	// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
	// circumstances under the control of the operator. Setting a negative value will disable this restriction.
	// Defaults to 1 if not specified.
	MaxUnavailable pulumi.IntPtrInput `pulumi:"maxUnavailable"`
}

func (ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudgetPatch)(nil)).Elem()
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput {
	return i.ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput)
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput).ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrInput is an input type that accepts ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs, ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtr and ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrInput` via:
//
//	        ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput
	ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput
}

type elasticsearchSpecUpdateStrategyChangeBudgetPatchPtrType ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs

func ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtr(v *ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs) ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrInput {
	return (*elasticsearchSpecUpdateStrategyChangeBudgetPatchPtrType)(v)
}

func (*elasticsearchSpecUpdateStrategyChangeBudgetPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategyChangeBudgetPatch)(nil)).Elem()
}

func (i *elasticsearchSpecUpdateStrategyChangeBudgetPatchPtrType) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecUpdateStrategyChangeBudgetPatchPtrType) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput)
}

// ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
type ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudgetPatch)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return o.ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecUpdateStrategyChangeBudgetPatch) *ElasticsearchSpecUpdateStrategyChangeBudgetPatch {
		return &v
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput)
}

// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
// disable the restriction. Defaults to unbounded if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) MaxSurge() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecUpdateStrategyChangeBudgetPatch) *int { return v.MaxSurge }).(pulumi.IntPtrOutput)
}

// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
// circumstances under the control of the operator. Setting a negative value will disable this restriction.
// Defaults to 1 if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput) MaxUnavailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecUpdateStrategyChangeBudgetPatch) *int { return v.MaxUnavailable }).(pulumi.IntPtrOutput)
}

type ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategyChangeBudgetPatch)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput) ToElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput) Elem() ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyChangeBudgetPatch) ElasticsearchSpecUpdateStrategyChangeBudgetPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecUpdateStrategyChangeBudgetPatch
		return ret
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput)
}

// MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in
// the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will
// disable the restriction. Defaults to unbounded if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput) MaxSurge() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyChangeBudgetPatch) *int {
		if v == nil {
			return nil
		}
		return v.MaxSurge
	}).(pulumi.IntPtrOutput)
}

// MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to
// circumstances under the control of the operator. Setting a negative value will disable this restriction.
// Defaults to 1 if not specified.
func (o ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput) MaxUnavailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyChangeBudgetPatch) *int {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.IntPtrOutput)
}

// UpdateStrategy specifies how updates to the cluster should be performed.
type ElasticsearchSpecUpdateStrategyPatch struct {
	ChangeBudget *ElasticsearchSpecUpdateStrategyChangeBudgetPatch `pulumi:"changeBudget"`
}

// ElasticsearchSpecUpdateStrategyPatchInput is an input type that accepts ElasticsearchSpecUpdateStrategyPatchArgs and ElasticsearchSpecUpdateStrategyPatchOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyPatchInput` via:
//
//	ElasticsearchSpecUpdateStrategyPatchArgs{...}
type ElasticsearchSpecUpdateStrategyPatchInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyPatchOutput() ElasticsearchSpecUpdateStrategyPatchOutput
	ToElasticsearchSpecUpdateStrategyPatchOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyPatchOutput
}

// UpdateStrategy specifies how updates to the cluster should be performed.
type ElasticsearchSpecUpdateStrategyPatchArgs struct {
	ChangeBudget ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrInput `pulumi:"changeBudget"`
}

func (ElasticsearchSpecUpdateStrategyPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategyPatch)(nil)).Elem()
}

func (i ElasticsearchSpecUpdateStrategyPatchArgs) ToElasticsearchSpecUpdateStrategyPatchOutput() ElasticsearchSpecUpdateStrategyPatchOutput {
	return i.ToElasticsearchSpecUpdateStrategyPatchOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyPatchArgs) ToElasticsearchSpecUpdateStrategyPatchOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyPatchOutput)
}

func (i ElasticsearchSpecUpdateStrategyPatchArgs) ToElasticsearchSpecUpdateStrategyPatchPtrOutput() ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchSpecUpdateStrategyPatchArgs) ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyPatchOutput).ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(ctx)
}

// ElasticsearchSpecUpdateStrategyPatchPtrInput is an input type that accepts ElasticsearchSpecUpdateStrategyPatchArgs, ElasticsearchSpecUpdateStrategyPatchPtr and ElasticsearchSpecUpdateStrategyPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchSpecUpdateStrategyPatchPtrInput` via:
//
//	        ElasticsearchSpecUpdateStrategyPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchSpecUpdateStrategyPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchSpecUpdateStrategyPatchPtrOutput() ElasticsearchSpecUpdateStrategyPatchPtrOutput
	ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(context.Context) ElasticsearchSpecUpdateStrategyPatchPtrOutput
}

type elasticsearchSpecUpdateStrategyPatchPtrType ElasticsearchSpecUpdateStrategyPatchArgs

func ElasticsearchSpecUpdateStrategyPatchPtr(v *ElasticsearchSpecUpdateStrategyPatchArgs) ElasticsearchSpecUpdateStrategyPatchPtrInput {
	return (*elasticsearchSpecUpdateStrategyPatchPtrType)(v)
}

func (*elasticsearchSpecUpdateStrategyPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategyPatch)(nil)).Elem()
}

func (i *elasticsearchSpecUpdateStrategyPatchPtrType) ToElasticsearchSpecUpdateStrategyPatchPtrOutput() ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return i.ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchSpecUpdateStrategyPatchPtrType) ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchSpecUpdateStrategyPatchPtrOutput)
}

// UpdateStrategy specifies how updates to the cluster should be performed.
type ElasticsearchSpecUpdateStrategyPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchSpecUpdateStrategyPatch)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyPatchOutput) ToElasticsearchSpecUpdateStrategyPatchOutput() ElasticsearchSpecUpdateStrategyPatchOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyPatchOutput) ToElasticsearchSpecUpdateStrategyPatchOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPatchOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyPatchOutput) ToElasticsearchSpecUpdateStrategyPatchPtrOutput() ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return o.ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchSpecUpdateStrategyPatchOutput) ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchSpecUpdateStrategyPatch) *ElasticsearchSpecUpdateStrategyPatch {
		return &v
	}).(ElasticsearchSpecUpdateStrategyPatchPtrOutput)
}

func (o ElasticsearchSpecUpdateStrategyPatchOutput) ChangeBudget() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return o.ApplyT(func(v ElasticsearchSpecUpdateStrategyPatch) *ElasticsearchSpecUpdateStrategyChangeBudgetPatch {
		return v.ChangeBudget
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput)
}

type ElasticsearchSpecUpdateStrategyPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchSpecUpdateStrategyPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchSpecUpdateStrategyPatch)(nil)).Elem()
}

func (o ElasticsearchSpecUpdateStrategyPatchPtrOutput) ToElasticsearchSpecUpdateStrategyPatchPtrOutput() ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyPatchPtrOutput) ToElasticsearchSpecUpdateStrategyPatchPtrOutputWithContext(ctx context.Context) ElasticsearchSpecUpdateStrategyPatchPtrOutput {
	return o
}

func (o ElasticsearchSpecUpdateStrategyPatchPtrOutput) Elem() ElasticsearchSpecUpdateStrategyPatchOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyPatch) ElasticsearchSpecUpdateStrategyPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchSpecUpdateStrategyPatch
		return ret
	}).(ElasticsearchSpecUpdateStrategyPatchOutput)
}

func (o ElasticsearchSpecUpdateStrategyPatchPtrOutput) ChangeBudget() ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput {
	return o.ApplyT(func(v *ElasticsearchSpecUpdateStrategyPatch) *ElasticsearchSpecUpdateStrategyChangeBudgetPatch {
		if v == nil {
			return nil
		}
		return v.ChangeBudget
	}).(ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput)
}

// ElasticsearchStatus defines the observed state of Elasticsearch
type ElasticsearchStatus struct {
	AvailableNodes *int `pulumi:"availableNodes"`
	// ElasticsearchHealth is the health of the cluster as returned by the health API.
	Health *string `pulumi:"health"`
	// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
	Phase *string `pulumi:"phase"`
}

// ElasticsearchStatusInput is an input type that accepts ElasticsearchStatusArgs and ElasticsearchStatusOutput values.
// You can construct a concrete instance of `ElasticsearchStatusInput` via:
//
//	ElasticsearchStatusArgs{...}
type ElasticsearchStatusInput interface {
	pulumi.Input

	ToElasticsearchStatusOutput() ElasticsearchStatusOutput
	ToElasticsearchStatusOutputWithContext(context.Context) ElasticsearchStatusOutput
}

// ElasticsearchStatus defines the observed state of Elasticsearch
type ElasticsearchStatusArgs struct {
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// ElasticsearchHealth is the health of the cluster as returned by the health API.
	Health pulumi.StringPtrInput `pulumi:"health"`
	// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
	Phase pulumi.StringPtrInput `pulumi:"phase"`
}

func (ElasticsearchStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchStatus)(nil)).Elem()
}

func (i ElasticsearchStatusArgs) ToElasticsearchStatusOutput() ElasticsearchStatusOutput {
	return i.ToElasticsearchStatusOutputWithContext(context.Background())
}

func (i ElasticsearchStatusArgs) ToElasticsearchStatusOutputWithContext(ctx context.Context) ElasticsearchStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchStatusOutput)
}

func (i ElasticsearchStatusArgs) ToElasticsearchStatusPtrOutput() ElasticsearchStatusPtrOutput {
	return i.ToElasticsearchStatusPtrOutputWithContext(context.Background())
}

func (i ElasticsearchStatusArgs) ToElasticsearchStatusPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchStatusOutput).ToElasticsearchStatusPtrOutputWithContext(ctx)
}

// ElasticsearchStatusPtrInput is an input type that accepts ElasticsearchStatusArgs, ElasticsearchStatusPtr and ElasticsearchStatusPtrOutput values.
// You can construct a concrete instance of `ElasticsearchStatusPtrInput` via:
//
//	        ElasticsearchStatusArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchStatusPtrInput interface {
	pulumi.Input

	ToElasticsearchStatusPtrOutput() ElasticsearchStatusPtrOutput
	ToElasticsearchStatusPtrOutputWithContext(context.Context) ElasticsearchStatusPtrOutput
}

type elasticsearchStatusPtrType ElasticsearchStatusArgs

func ElasticsearchStatusPtr(v *ElasticsearchStatusArgs) ElasticsearchStatusPtrInput {
	return (*elasticsearchStatusPtrType)(v)
}

func (*elasticsearchStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchStatus)(nil)).Elem()
}

func (i *elasticsearchStatusPtrType) ToElasticsearchStatusPtrOutput() ElasticsearchStatusPtrOutput {
	return i.ToElasticsearchStatusPtrOutputWithContext(context.Background())
}

func (i *elasticsearchStatusPtrType) ToElasticsearchStatusPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchStatusPtrOutput)
}

// ElasticsearchStatus defines the observed state of Elasticsearch
type ElasticsearchStatusOutput struct{ *pulumi.OutputState }

func (ElasticsearchStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchStatus)(nil)).Elem()
}

func (o ElasticsearchStatusOutput) ToElasticsearchStatusOutput() ElasticsearchStatusOutput {
	return o
}

func (o ElasticsearchStatusOutput) ToElasticsearchStatusOutputWithContext(ctx context.Context) ElasticsearchStatusOutput {
	return o
}

func (o ElasticsearchStatusOutput) ToElasticsearchStatusPtrOutput() ElasticsearchStatusPtrOutput {
	return o.ToElasticsearchStatusPtrOutputWithContext(context.Background())
}

func (o ElasticsearchStatusOutput) ToElasticsearchStatusPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchStatus) *ElasticsearchStatus {
		return &v
	}).(ElasticsearchStatusPtrOutput)
}

func (o ElasticsearchStatusOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchStatus) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// ElasticsearchHealth is the health of the cluster as returned by the health API.
func (o ElasticsearchStatusOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchStatus) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
func (o ElasticsearchStatusOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchStatus) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

type ElasticsearchStatusPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchStatus)(nil)).Elem()
}

func (o ElasticsearchStatusPtrOutput) ToElasticsearchStatusPtrOutput() ElasticsearchStatusPtrOutput {
	return o
}

func (o ElasticsearchStatusPtrOutput) ToElasticsearchStatusPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPtrOutput {
	return o
}

func (o ElasticsearchStatusPtrOutput) Elem() ElasticsearchStatusOutput {
	return o.ApplyT(func(v *ElasticsearchStatus) ElasticsearchStatus {
		if v != nil {
			return *v
		}
		var ret ElasticsearchStatus
		return ret
	}).(ElasticsearchStatusOutput)
}

func (o ElasticsearchStatusPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchHealth is the health of the cluster as returned by the health API.
func (o ElasticsearchStatusPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchStatus) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
func (o ElasticsearchStatusPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchStatus) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchStatus defines the observed state of Elasticsearch
type ElasticsearchStatusPatch struct {
	AvailableNodes *int `pulumi:"availableNodes"`
	// ElasticsearchHealth is the health of the cluster as returned by the health API.
	Health *string `pulumi:"health"`
	// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
	Phase *string `pulumi:"phase"`
}

// ElasticsearchStatusPatchInput is an input type that accepts ElasticsearchStatusPatchArgs and ElasticsearchStatusPatchOutput values.
// You can construct a concrete instance of `ElasticsearchStatusPatchInput` via:
//
//	ElasticsearchStatusPatchArgs{...}
type ElasticsearchStatusPatchInput interface {
	pulumi.Input

	ToElasticsearchStatusPatchOutput() ElasticsearchStatusPatchOutput
	ToElasticsearchStatusPatchOutputWithContext(context.Context) ElasticsearchStatusPatchOutput
}

// ElasticsearchStatus defines the observed state of Elasticsearch
type ElasticsearchStatusPatchArgs struct {
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// ElasticsearchHealth is the health of the cluster as returned by the health API.
	Health pulumi.StringPtrInput `pulumi:"health"`
	// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
	Phase pulumi.StringPtrInput `pulumi:"phase"`
}

func (ElasticsearchStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchStatusPatch)(nil)).Elem()
}

func (i ElasticsearchStatusPatchArgs) ToElasticsearchStatusPatchOutput() ElasticsearchStatusPatchOutput {
	return i.ToElasticsearchStatusPatchOutputWithContext(context.Background())
}

func (i ElasticsearchStatusPatchArgs) ToElasticsearchStatusPatchOutputWithContext(ctx context.Context) ElasticsearchStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchStatusPatchOutput)
}

func (i ElasticsearchStatusPatchArgs) ToElasticsearchStatusPatchPtrOutput() ElasticsearchStatusPatchPtrOutput {
	return i.ToElasticsearchStatusPatchPtrOutputWithContext(context.Background())
}

func (i ElasticsearchStatusPatchArgs) ToElasticsearchStatusPatchPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchStatusPatchOutput).ToElasticsearchStatusPatchPtrOutputWithContext(ctx)
}

// ElasticsearchStatusPatchPtrInput is an input type that accepts ElasticsearchStatusPatchArgs, ElasticsearchStatusPatchPtr and ElasticsearchStatusPatchPtrOutput values.
// You can construct a concrete instance of `ElasticsearchStatusPatchPtrInput` via:
//
//	        ElasticsearchStatusPatchArgs{...}
//
//	or:
//
//	        nil
type ElasticsearchStatusPatchPtrInput interface {
	pulumi.Input

	ToElasticsearchStatusPatchPtrOutput() ElasticsearchStatusPatchPtrOutput
	ToElasticsearchStatusPatchPtrOutputWithContext(context.Context) ElasticsearchStatusPatchPtrOutput
}

type elasticsearchStatusPatchPtrType ElasticsearchStatusPatchArgs

func ElasticsearchStatusPatchPtr(v *ElasticsearchStatusPatchArgs) ElasticsearchStatusPatchPtrInput {
	return (*elasticsearchStatusPatchPtrType)(v)
}

func (*elasticsearchStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchStatusPatch)(nil)).Elem()
}

func (i *elasticsearchStatusPatchPtrType) ToElasticsearchStatusPatchPtrOutput() ElasticsearchStatusPatchPtrOutput {
	return i.ToElasticsearchStatusPatchPtrOutputWithContext(context.Background())
}

func (i *elasticsearchStatusPatchPtrType) ToElasticsearchStatusPatchPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ElasticsearchStatusPatchPtrOutput)
}

// ElasticsearchStatus defines the observed state of Elasticsearch
type ElasticsearchStatusPatchOutput struct{ *pulumi.OutputState }

func (ElasticsearchStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ElasticsearchStatusPatch)(nil)).Elem()
}

func (o ElasticsearchStatusPatchOutput) ToElasticsearchStatusPatchOutput() ElasticsearchStatusPatchOutput {
	return o
}

func (o ElasticsearchStatusPatchOutput) ToElasticsearchStatusPatchOutputWithContext(ctx context.Context) ElasticsearchStatusPatchOutput {
	return o
}

func (o ElasticsearchStatusPatchOutput) ToElasticsearchStatusPatchPtrOutput() ElasticsearchStatusPatchPtrOutput {
	return o.ToElasticsearchStatusPatchPtrOutputWithContext(context.Background())
}

func (o ElasticsearchStatusPatchOutput) ToElasticsearchStatusPatchPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ElasticsearchStatusPatch) *ElasticsearchStatusPatch {
		return &v
	}).(ElasticsearchStatusPatchPtrOutput)
}

func (o ElasticsearchStatusPatchOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ElasticsearchStatusPatch) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// ElasticsearchHealth is the health of the cluster as returned by the health API.
func (o ElasticsearchStatusPatchOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchStatusPatch) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
func (o ElasticsearchStatusPatchOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ElasticsearchStatusPatch) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

type ElasticsearchStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (ElasticsearchStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ElasticsearchStatusPatch)(nil)).Elem()
}

func (o ElasticsearchStatusPatchPtrOutput) ToElasticsearchStatusPatchPtrOutput() ElasticsearchStatusPatchPtrOutput {
	return o
}

func (o ElasticsearchStatusPatchPtrOutput) ToElasticsearchStatusPatchPtrOutputWithContext(ctx context.Context) ElasticsearchStatusPatchPtrOutput {
	return o
}

func (o ElasticsearchStatusPatchPtrOutput) Elem() ElasticsearchStatusPatchOutput {
	return o.ApplyT(func(v *ElasticsearchStatusPatch) ElasticsearchStatusPatch {
		if v != nil {
			return *v
		}
		var ret ElasticsearchStatusPatch
		return ret
	}).(ElasticsearchStatusPatchOutput)
}

func (o ElasticsearchStatusPatchPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ElasticsearchStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchHealth is the health of the cluster as returned by the health API.
func (o ElasticsearchStatusPatchPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
func (o ElasticsearchStatusPatchPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ElasticsearchStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchTypeInput)(nil)).Elem(), ElasticsearchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchTypeArrayInput)(nil)).Elem(), ElasticsearchTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchListTypeInput)(nil)).Elem(), ElasticsearchListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchPatchTypeInput)(nil)).Elem(), ElasticsearchPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecInput)(nil)).Elem(), ElasticsearchSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPtrInput)(nil)).Elem(), ElasticsearchSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpInput)(nil)).Elem(), ElasticsearchSpecHttpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpPtrInput)(nil)).Elem(), ElasticsearchSpecHttpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpPatchInput)(nil)).Elem(), ElasticsearchSpecHttpPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpPatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceInput)(nil)).Elem(), ElasticsearchSpecHttpServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServicePtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadataInput)(nil)).Elem(), ElasticsearchSpecHttpServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadataPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadataPatchInput)(nil)).Elem(), ElasticsearchSpecHttpServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceMetadataPatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServicePatchInput)(nil)).Elem(), ElasticsearchSpecHttpServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServicePatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPatchInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPortsInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecPortsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPortsArrayInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecPortsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPortsPatchInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecPortsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecPortsPatchArrayInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecPortsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsInput)(nil)).Elem(), ElasticsearchSpecHttpTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsPtrInput)(nil)).Elem(), ElasticsearchSpecHttpTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificateInput)(nil)).Elem(), ElasticsearchSpecHttpTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificatePtrInput)(nil)).Elem(), ElasticsearchSpecHttpTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificatePatchInput)(nil)).Elem(), ElasticsearchSpecHttpTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsCertificatePatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpTlsCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsPatchInput)(nil)).Elem(), ElasticsearchSpecHttpTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsPatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificatePtrInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificatePatchInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayInput)(nil)).Elem(), ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsInput)(nil)).Elem(), ElasticsearchSpecNodeSetsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsArrayInput)(nil)).Elem(), ElasticsearchSpecNodeSetsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsPatchArrayInput)(nil)).Elem(), ElasticsearchSpecNodeSetsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrInput)(nil)).Elem(), ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPatchInput)(nil)).Elem(), ElasticsearchSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPatchPtrInput)(nil)).Elem(), ElasticsearchSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadataInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadataPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadataPatchInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetPatchInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetPatchPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecPatchInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrInput)(nil)).Elem(), ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsArrayInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntriesInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsEntriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntriesArrayInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsEntriesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntriesPatchInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsEntriesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsEntriesPatchArrayInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsEntriesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsPatchInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecSecureSettingsPatchArrayInput)(nil)).Elem(), ElasticsearchSpecSecureSettingsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyPtrInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudgetInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyChangeBudgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudgetPtrInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyChangeBudgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudgetPatchInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyChangeBudgetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyPatchInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchSpecUpdateStrategyPatchPtrInput)(nil)).Elem(), ElasticsearchSpecUpdateStrategyPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchStatusInput)(nil)).Elem(), ElasticsearchStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchStatusPtrInput)(nil)).Elem(), ElasticsearchStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchStatusPatchInput)(nil)).Elem(), ElasticsearchStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ElasticsearchStatusPatchPtrInput)(nil)).Elem(), ElasticsearchStatusPatchArgs{})
	pulumi.RegisterOutputType(ElasticsearchTypeOutput{})
	pulumi.RegisterOutputType(ElasticsearchTypeArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchListTypeOutput{})
	pulumi.RegisterOutputType(ElasticsearchPatchTypeOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServicePtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceMetadataOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceMetadataPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceMetadataPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServicePatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServicePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPortsOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPortsArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPortsPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecPortsPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigClientIPPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpServiceSpecSessionAffinityConfigPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsCertificateOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsCertificatePtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsCertificatePatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificateOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificatePtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificatePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecHttpTlsSelfSignedCertificateSubjectAltNamesPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourcePatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecDataSourceRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecResourcesPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecNodeSetsVolumeClaimTemplatesSpecSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetMetadataOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetMetadataPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetMetadataPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecPodDisruptionBudgetSpecSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsEntriesOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsEntriesArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsEntriesPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsEntriesPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecSecureSettingsPatchArrayOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyChangeBudgetOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyChangeBudgetPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyChangeBudgetPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyChangeBudgetPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchSpecUpdateStrategyPatchPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchStatusOutput{})
	pulumi.RegisterOutputType(ElasticsearchStatusPtrOutput{})
	pulumi.RegisterOutputType(ElasticsearchStatusPatchOutput{})
	pulumi.RegisterOutputType(ElasticsearchStatusPatchPtrOutput{})
}
