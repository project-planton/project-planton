// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *ChallengeSpec     `pulumi:"spec"`
	Status   *ChallengeStatus   `pulumi:"status"`
}

// ChallengeTypeInput is an input type that accepts ChallengeTypeArgs and ChallengeTypeOutput values.
// You can construct a concrete instance of `ChallengeTypeInput` via:
//
//	ChallengeTypeArgs{...}
type ChallengeTypeInput interface {
	pulumi.Input

	ToChallengeTypeOutput() ChallengeTypeOutput
	ToChallengeTypeOutputWithContext(context.Context) ChallengeTypeOutput
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     ChallengeSpecPtrInput     `pulumi:"spec"`
	Status   ChallengeStatusPtrInput   `pulumi:"status"`
}

func (ChallengeTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeType)(nil)).Elem()
}

func (i ChallengeTypeArgs) ToChallengeTypeOutput() ChallengeTypeOutput {
	return i.ToChallengeTypeOutputWithContext(context.Background())
}

func (i ChallengeTypeArgs) ToChallengeTypeOutputWithContext(ctx context.Context) ChallengeTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeTypeOutput)
}

// ChallengeTypeArrayInput is an input type that accepts ChallengeTypeArray and ChallengeTypeArrayOutput values.
// You can construct a concrete instance of `ChallengeTypeArrayInput` via:
//
//	ChallengeTypeArray{ ChallengeTypeArgs{...} }
type ChallengeTypeArrayInput interface {
	pulumi.Input

	ToChallengeTypeArrayOutput() ChallengeTypeArrayOutput
	ToChallengeTypeArrayOutputWithContext(context.Context) ChallengeTypeArrayOutput
}

type ChallengeTypeArray []ChallengeTypeInput

func (ChallengeTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeType)(nil)).Elem()
}

func (i ChallengeTypeArray) ToChallengeTypeArrayOutput() ChallengeTypeArrayOutput {
	return i.ToChallengeTypeArrayOutputWithContext(context.Background())
}

func (i ChallengeTypeArray) ToChallengeTypeArrayOutputWithContext(ctx context.Context) ChallengeTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeTypeArrayOutput)
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeTypeOutput struct{ *pulumi.OutputState }

func (ChallengeTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeType)(nil)).Elem()
}

func (o ChallengeTypeOutput) ToChallengeTypeOutput() ChallengeTypeOutput {
	return o
}

func (o ChallengeTypeOutput) ToChallengeTypeOutputWithContext(ctx context.Context) ChallengeTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ChallengeTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChallengeTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ChallengeTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ChallengeType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o ChallengeTypeOutput) Spec() ChallengeSpecPtrOutput {
	return o.ApplyT(func(v ChallengeType) *ChallengeSpec { return v.Spec }).(ChallengeSpecPtrOutput)
}

func (o ChallengeTypeOutput) Status() ChallengeStatusPtrOutput {
	return o.ApplyT(func(v ChallengeType) *ChallengeStatus { return v.Status }).(ChallengeStatusPtrOutput)
}

type ChallengeTypeArrayOutput struct{ *pulumi.OutputState }

func (ChallengeTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeType)(nil)).Elem()
}

func (o ChallengeTypeArrayOutput) ToChallengeTypeArrayOutput() ChallengeTypeArrayOutput {
	return o
}

func (o ChallengeTypeArrayOutput) ToChallengeTypeArrayOutputWithContext(ctx context.Context) ChallengeTypeArrayOutput {
	return o
}

func (o ChallengeTypeArrayOutput) Index(i pulumi.IntInput) ChallengeTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeType {
		return vs[0].([]ChallengeType)[vs[1].(int)]
	}).(ChallengeTypeOutput)
}

// ChallengeList is a list of Challenge
type ChallengeListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of challenges. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []ChallengeType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ChallengeListTypeInput is an input type that accepts ChallengeListTypeArgs and ChallengeListTypeOutput values.
// You can construct a concrete instance of `ChallengeListTypeInput` via:
//
//	ChallengeListTypeArgs{...}
type ChallengeListTypeInput interface {
	pulumi.Input

	ToChallengeListTypeOutput() ChallengeListTypeOutput
	ToChallengeListTypeOutputWithContext(context.Context) ChallengeListTypeOutput
}

// ChallengeList is a list of Challenge
type ChallengeListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of challenges. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items ChallengeTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ChallengeListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeListType)(nil)).Elem()
}

func (i ChallengeListTypeArgs) ToChallengeListTypeOutput() ChallengeListTypeOutput {
	return i.ToChallengeListTypeOutputWithContext(context.Background())
}

func (i ChallengeListTypeArgs) ToChallengeListTypeOutputWithContext(ctx context.Context) ChallengeListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeListTypeOutput)
}

// ChallengeList is a list of Challenge
type ChallengeListTypeOutput struct{ *pulumi.OutputState }

func (ChallengeListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeListType)(nil)).Elem()
}

func (o ChallengeListTypeOutput) ToChallengeListTypeOutput() ChallengeListTypeOutput {
	return o
}

func (o ChallengeListTypeOutput) ToChallengeListTypeOutputWithContext(ctx context.Context) ChallengeListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ChallengeListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of challenges. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o ChallengeListTypeOutput) Items() ChallengeTypeArrayOutput {
	return o.ApplyT(func(v ChallengeListType) []ChallengeType { return v.Items }).(ChallengeTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChallengeListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChallengeListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ChallengeListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *ChallengeSpecPatch     `pulumi:"spec"`
	Status   *ChallengeStatusPatch   `pulumi:"status"`
}

// ChallengePatchTypeInput is an input type that accepts ChallengePatchTypeArgs and ChallengePatchTypeOutput values.
// You can construct a concrete instance of `ChallengePatchTypeInput` via:
//
//	ChallengePatchTypeArgs{...}
type ChallengePatchTypeInput interface {
	pulumi.Input

	ToChallengePatchTypeOutput() ChallengePatchTypeOutput
	ToChallengePatchTypeOutputWithContext(context.Context) ChallengePatchTypeOutput
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     ChallengeSpecPatchPtrInput     `pulumi:"spec"`
	Status   ChallengeStatusPatchPtrInput   `pulumi:"status"`
}

func (ChallengePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengePatchType)(nil)).Elem()
}

func (i ChallengePatchTypeArgs) ToChallengePatchTypeOutput() ChallengePatchTypeOutput {
	return i.ToChallengePatchTypeOutputWithContext(context.Background())
}

func (i ChallengePatchTypeArgs) ToChallengePatchTypeOutputWithContext(ctx context.Context) ChallengePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengePatchTypeOutput)
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengePatchTypeOutput struct{ *pulumi.OutputState }

func (ChallengePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengePatchType)(nil)).Elem()
}

func (o ChallengePatchTypeOutput) ToChallengePatchTypeOutput() ChallengePatchTypeOutput {
	return o
}

func (o ChallengePatchTypeOutput) ToChallengePatchTypeOutputWithContext(ctx context.Context) ChallengePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ChallengePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChallengePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ChallengePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ChallengePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o ChallengePatchTypeOutput) Spec() ChallengeSpecPatchPtrOutput {
	return o.ApplyT(func(v ChallengePatchType) *ChallengeSpecPatch { return v.Spec }).(ChallengeSpecPatchPtrOutput)
}

func (o ChallengePatchTypeOutput) Status() ChallengeStatusPatchPtrOutput {
	return o.ApplyT(func(v ChallengePatchType) *ChallengeStatusPatch { return v.Status }).(ChallengeStatusPatchPtrOutput)
}

type ChallengeSpec struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL *string `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName   *string                 `pulumi:"dnsName"`
	IssuerRef *ChallengeSpecIssuerRef `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key    *string              `pulumi:"key"`
	Solver *ChallengeSpecSolver `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token *string `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type *string `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url *string `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// ChallengeSpecInput is an input type that accepts ChallengeSpecArgs and ChallengeSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecInput` via:
//
//	ChallengeSpecArgs{...}
type ChallengeSpecInput interface {
	pulumi.Input

	ToChallengeSpecOutput() ChallengeSpecOutput
	ToChallengeSpecOutputWithContext(context.Context) ChallengeSpecOutput
}

type ChallengeSpecArgs struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL pulumi.StringPtrInput `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName   pulumi.StringPtrInput          `pulumi:"dnsName"`
	IssuerRef ChallengeSpecIssuerRefPtrInput `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key    pulumi.StringPtrInput       `pulumi:"key"`
	Solver ChallengeSpecSolverPtrInput `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token pulumi.StringPtrInput `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url pulumi.StringPtrInput `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (ChallengeSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (i ChallengeSpecArgs) ToChallengeSpecOutput() ChallengeSpecOutput {
	return i.ToChallengeSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput)
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput).ToChallengeSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecPtrInput is an input type that accepts ChallengeSpecArgs, ChallengeSpecPtr and ChallengeSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecPtrInput` via:
//
//	        ChallengeSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput
	ToChallengeSpecPtrOutputWithContext(context.Context) ChallengeSpecPtrOutput
}

type challengeSpecPtrType ChallengeSpecArgs

func ChallengeSpecPtr(v *ChallengeSpecArgs) ChallengeSpecPtrInput {
	return (*challengeSpecPtrType)(v)
}

func (*challengeSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPtrOutput)
}

type ChallengeSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecOutput) ToChallengeSpecOutput() ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpec) *ChallengeSpec {
		return &v
	}).(ChallengeSpecPtrOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *string { return v.AuthorizationURL }).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *string { return v.DnsName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecOutput) IssuerRef() ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *ChallengeSpecIssuerRef { return v.IssuerRef }).(ChallengeSpecIssuerRefPtrOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *string { return v.Key }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecOutput) Solver() ChallengeSpecSolverPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *ChallengeSpecSolver { return v.Solver }).(ChallengeSpecSolverPtrOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *string { return v.Token }).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *string { return v.Url }).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type ChallengeSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) Elem() ChallengeSpecOutput {
	return o.ApplyT(func(v *ChallengeSpec) ChallengeSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpec
		return ret
	}).(ChallengeSpecOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecPtrOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return v.AuthorizationURL
	}).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecPtrOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return v.DnsName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecPtrOutput) IssuerRef() ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecIssuerRef {
		if v == nil {
			return nil
		}
		return v.IssuerRef
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecPtrOutput) Solver() ChallengeSpecSolverPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecSolver {
		if v == nil {
			return nil
		}
		return v.Solver
	}).(ChallengeSpecSolverPtrOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecPtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return v.Token
	}).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecPtrOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *bool {
		if v == nil {
			return nil
		}
		return v.Wildcard
	}).(pulumi.BoolPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name *string `pulumi:"name"`
}

// ChallengeSpecIssuerRefInput is an input type that accepts ChallengeSpecIssuerRefArgs and ChallengeSpecIssuerRefOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefInput` via:
//
//	ChallengeSpecIssuerRefArgs{...}
type ChallengeSpecIssuerRefInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput
	ToChallengeSpecIssuerRefOutputWithContext(context.Context) ChallengeSpecIssuerRefOutput
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return i.ToChallengeSpecIssuerRefOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput)
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput).ToChallengeSpecIssuerRefPtrOutputWithContext(ctx)
}

// ChallengeSpecIssuerRefPtrInput is an input type that accepts ChallengeSpecIssuerRefArgs, ChallengeSpecIssuerRefPtr and ChallengeSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefPtrInput` via:
//
//	        ChallengeSpecIssuerRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput
	ToChallengeSpecIssuerRefPtrOutputWithContext(context.Context) ChallengeSpecIssuerRefPtrOutput
}

type challengeSpecIssuerRefPtrType ChallengeSpecIssuerRefArgs

func ChallengeSpecIssuerRefPtr(v *ChallengeSpecIssuerRefArgs) ChallengeSpecIssuerRefPtrInput {
	return (*challengeSpecIssuerRefPtrType)(v)
}

func (*challengeSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecIssuerRef) *ChallengeSpecIssuerRef {
		return &v
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) Elem() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) ChallengeSpecIssuerRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecIssuerRef
		return ret
	}).(ChallengeSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefPatch struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name *string `pulumi:"name"`
}

// ChallengeSpecIssuerRefPatchInput is an input type that accepts ChallengeSpecIssuerRefPatchArgs and ChallengeSpecIssuerRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefPatchInput` via:
//
//	ChallengeSpecIssuerRefPatchArgs{...}
type ChallengeSpecIssuerRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefPatchOutput() ChallengeSpecIssuerRefPatchOutput
	ToChallengeSpecIssuerRefPatchOutputWithContext(context.Context) ChallengeSpecIssuerRefPatchOutput
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefPatchArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecIssuerRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRefPatch)(nil)).Elem()
}

func (i ChallengeSpecIssuerRefPatchArgs) ToChallengeSpecIssuerRefPatchOutput() ChallengeSpecIssuerRefPatchOutput {
	return i.ToChallengeSpecIssuerRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefPatchArgs) ToChallengeSpecIssuerRefPatchOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPatchOutput)
}

func (i ChallengeSpecIssuerRefPatchArgs) ToChallengeSpecIssuerRefPatchPtrOutput() ChallengeSpecIssuerRefPatchPtrOutput {
	return i.ToChallengeSpecIssuerRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefPatchArgs) ToChallengeSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPatchOutput).ToChallengeSpecIssuerRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecIssuerRefPatchPtrInput is an input type that accepts ChallengeSpecIssuerRefPatchArgs, ChallengeSpecIssuerRefPatchPtr and ChallengeSpecIssuerRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefPatchPtrInput` via:
//
//	        ChallengeSpecIssuerRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecIssuerRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefPatchPtrOutput() ChallengeSpecIssuerRefPatchPtrOutput
	ToChallengeSpecIssuerRefPatchPtrOutputWithContext(context.Context) ChallengeSpecIssuerRefPatchPtrOutput
}

type challengeSpecIssuerRefPatchPtrType ChallengeSpecIssuerRefPatchArgs

func ChallengeSpecIssuerRefPatchPtr(v *ChallengeSpecIssuerRefPatchArgs) ChallengeSpecIssuerRefPatchPtrInput {
	return (*challengeSpecIssuerRefPatchPtrType)(v)
}

func (*challengeSpecIssuerRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRefPatch)(nil)).Elem()
}

func (i *challengeSpecIssuerRefPatchPtrType) ToChallengeSpecIssuerRefPatchPtrOutput() ChallengeSpecIssuerRefPatchPtrOutput {
	return i.ToChallengeSpecIssuerRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecIssuerRefPatchPtrType) ToChallengeSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPatchPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRefPatch)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefPatchOutput) ToChallengeSpecIssuerRefPatchOutput() ChallengeSpecIssuerRefPatchOutput {
	return o
}

func (o ChallengeSpecIssuerRefPatchOutput) ToChallengeSpecIssuerRefPatchOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPatchOutput {
	return o
}

func (o ChallengeSpecIssuerRefPatchOutput) ToChallengeSpecIssuerRefPatchPtrOutput() ChallengeSpecIssuerRefPatchPtrOutput {
	return o.ToChallengeSpecIssuerRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecIssuerRefPatchOutput) ToChallengeSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecIssuerRefPatch) *ChallengeSpecIssuerRefPatch {
		return &v
	}).(ChallengeSpecIssuerRefPatchPtrOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecIssuerRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRefPatch)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefPatchPtrOutput) ToChallengeSpecIssuerRefPatchPtrOutput() ChallengeSpecIssuerRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPatchPtrOutput) ToChallengeSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPatchPtrOutput) Elem() ChallengeSpecIssuerRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRefPatch) ChallengeSpecIssuerRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecIssuerRefPatch
		return ret
	}).(ChallengeSpecIssuerRefPatchOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecPatch struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL *string `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName   *string                      `pulumi:"dnsName"`
	IssuerRef *ChallengeSpecIssuerRefPatch `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key    *string                   `pulumi:"key"`
	Solver *ChallengeSpecSolverPatch `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token *string `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type *string `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url *string `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// ChallengeSpecPatchInput is an input type that accepts ChallengeSpecPatchArgs and ChallengeSpecPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecPatchInput` via:
//
//	ChallengeSpecPatchArgs{...}
type ChallengeSpecPatchInput interface {
	pulumi.Input

	ToChallengeSpecPatchOutput() ChallengeSpecPatchOutput
	ToChallengeSpecPatchOutputWithContext(context.Context) ChallengeSpecPatchOutput
}

type ChallengeSpecPatchArgs struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL pulumi.StringPtrInput `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName   pulumi.StringPtrInput               `pulumi:"dnsName"`
	IssuerRef ChallengeSpecIssuerRefPatchPtrInput `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key    pulumi.StringPtrInput            `pulumi:"key"`
	Solver ChallengeSpecSolverPatchPtrInput `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token pulumi.StringPtrInput `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url pulumi.StringPtrInput `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (ChallengeSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecPatch)(nil)).Elem()
}

func (i ChallengeSpecPatchArgs) ToChallengeSpecPatchOutput() ChallengeSpecPatchOutput {
	return i.ToChallengeSpecPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecPatchArgs) ToChallengeSpecPatchOutputWithContext(ctx context.Context) ChallengeSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPatchOutput)
}

func (i ChallengeSpecPatchArgs) ToChallengeSpecPatchPtrOutput() ChallengeSpecPatchPtrOutput {
	return i.ToChallengeSpecPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecPatchArgs) ToChallengeSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPatchOutput).ToChallengeSpecPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecPatchPtrInput is an input type that accepts ChallengeSpecPatchArgs, ChallengeSpecPatchPtr and ChallengeSpecPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecPatchPtrInput` via:
//
//	        ChallengeSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecPatchPtrOutput() ChallengeSpecPatchPtrOutput
	ToChallengeSpecPatchPtrOutputWithContext(context.Context) ChallengeSpecPatchPtrOutput
}

type challengeSpecPatchPtrType ChallengeSpecPatchArgs

func ChallengeSpecPatchPtr(v *ChallengeSpecPatchArgs) ChallengeSpecPatchPtrInput {
	return (*challengeSpecPatchPtrType)(v)
}

func (*challengeSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecPatch)(nil)).Elem()
}

func (i *challengeSpecPatchPtrType) ToChallengeSpecPatchPtrOutput() ChallengeSpecPatchPtrOutput {
	return i.ToChallengeSpecPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecPatchPtrType) ToChallengeSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPatchPtrOutput)
}

type ChallengeSpecPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecPatch)(nil)).Elem()
}

func (o ChallengeSpecPatchOutput) ToChallengeSpecPatchOutput() ChallengeSpecPatchOutput {
	return o
}

func (o ChallengeSpecPatchOutput) ToChallengeSpecPatchOutputWithContext(ctx context.Context) ChallengeSpecPatchOutput {
	return o
}

func (o ChallengeSpecPatchOutput) ToChallengeSpecPatchPtrOutput() ChallengeSpecPatchPtrOutput {
	return o.ToChallengeSpecPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecPatchOutput) ToChallengeSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecPatch) *ChallengeSpecPatch {
		return &v
	}).(ChallengeSpecPatchPtrOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecPatchOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *string { return v.AuthorizationURL }).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecPatchOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *string { return v.DnsName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecPatchOutput) IssuerRef() ChallengeSpecIssuerRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *ChallengeSpecIssuerRefPatch { return v.IssuerRef }).(ChallengeSpecIssuerRefPatchPtrOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecPatchOutput) Solver() ChallengeSpecSolverPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *ChallengeSpecSolverPatch { return v.Solver }).(ChallengeSpecSolverPatchPtrOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecPatchOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *string { return v.Token }).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecPatchOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *string { return v.Url }).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecPatchOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpecPatch) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type ChallengeSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecPatch)(nil)).Elem()
}

func (o ChallengeSpecPatchPtrOutput) ToChallengeSpecPatchPtrOutput() ChallengeSpecPatchPtrOutput {
	return o
}

func (o ChallengeSpecPatchPtrOutput) ToChallengeSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecPatchPtrOutput {
	return o
}

func (o ChallengeSpecPatchPtrOutput) Elem() ChallengeSpecPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) ChallengeSpecPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecPatch
		return ret
	}).(ChallengeSpecPatchOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecPatchPtrOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.AuthorizationURL
	}).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecPatchPtrOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.DnsName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecPatchPtrOutput) IssuerRef() ChallengeSpecIssuerRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *ChallengeSpecIssuerRefPatch {
		if v == nil {
			return nil
		}
		return v.IssuerRef
	}).(ChallengeSpecIssuerRefPatchPtrOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecPatchPtrOutput) Solver() ChallengeSpecSolverPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *ChallengeSpecSolverPatch {
		if v == nil {
			return nil
		}
		return v.Solver
	}).(ChallengeSpecSolverPatchPtrOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecPatchPtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Token
	}).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecPatchPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecPatchPtrOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.Wildcard
	}).(pulumi.BoolPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolver struct {
	Dns01    *ChallengeSpecSolverDns01    `pulumi:"dns01"`
	Http01   *ChallengeSpecSolverHttp01   `pulumi:"http01"`
	Selector *ChallengeSpecSolverSelector `pulumi:"selector"`
}

// ChallengeSpecSolverInput is an input type that accepts ChallengeSpecSolverArgs and ChallengeSpecSolverOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverInput` via:
//
//	ChallengeSpecSolverArgs{...}
type ChallengeSpecSolverInput interface {
	pulumi.Input

	ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput
	ToChallengeSpecSolverOutputWithContext(context.Context) ChallengeSpecSolverOutput
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverArgs struct {
	Dns01    ChallengeSpecSolverDns01PtrInput    `pulumi:"dns01"`
	Http01   ChallengeSpecSolverHttp01PtrInput   `pulumi:"http01"`
	Selector ChallengeSpecSolverSelectorPtrInput `pulumi:"selector"`
}

func (ChallengeSpecSolverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return i.ToChallengeSpecSolverOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput)
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput).ToChallengeSpecSolverPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverPtrInput is an input type that accepts ChallengeSpecSolverArgs, ChallengeSpecSolverPtr and ChallengeSpecSolverPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverPtrInput` via:
//
//	        ChallengeSpecSolverArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput
	ToChallengeSpecSolverPtrOutputWithContext(context.Context) ChallengeSpecSolverPtrOutput
}

type challengeSpecSolverPtrType ChallengeSpecSolverArgs

func ChallengeSpecSolverPtr(v *ChallengeSpecSolverArgs) ChallengeSpecSolverPtrInput {
	return (*challengeSpecSolverPtrType)(v)
}

func (*challengeSpecSolverPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolver) *ChallengeSpecSolver {
		return &v
	}).(ChallengeSpecSolverPtrOutput)
}

func (o ChallengeSpecSolverOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverDns01 { return v.Dns01 }).(ChallengeSpecSolverDns01PtrOutput)
}

func (o ChallengeSpecSolverOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverHttp01 { return v.Http01 }).(ChallengeSpecSolverHttp01PtrOutput)
}

func (o ChallengeSpecSolverOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverSelector { return v.Selector }).(ChallengeSpecSolverSelectorPtrOutput)
}

type ChallengeSpecSolverPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) Elem() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) ChallengeSpecSolver {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolver
		return ret
	}).(ChallengeSpecSolverOutput)
}

func (o ChallengeSpecSolverPtrOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverDns01 {
		if v == nil {
			return nil
		}
		return v.Dns01
	}).(ChallengeSpecSolverDns01PtrOutput)
}

func (o ChallengeSpecSolverPtrOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverHttp01 {
		if v == nil {
			return nil
		}
		return v.Http01
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

func (o ChallengeSpecSolverPtrOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01 struct {
	AcmeDNS    *ChallengeSpecSolverDns01AcmeDNS    `pulumi:"acmeDNS"`
	Akamai     *ChallengeSpecSolverDns01Akamai     `pulumi:"akamai"`
	AzureDNS   *ChallengeSpecSolverDns01AzureDNS   `pulumi:"azureDNS"`
	CloudDNS   *ChallengeSpecSolverDns01CloudDNS   `pulumi:"cloudDNS"`
	Cloudflare *ChallengeSpecSolverDns01Cloudflare `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy *string                               `pulumi:"cnameStrategy"`
	Digitalocean  *ChallengeSpecSolverDns01Digitalocean `pulumi:"digitalocean"`
	Rfc2136       *ChallengeSpecSolverDns01Rfc2136      `pulumi:"rfc2136"`
	Route53       *ChallengeSpecSolverDns01Route53      `pulumi:"route53"`
	Webhook       *ChallengeSpecSolverDns01Webhook      `pulumi:"webhook"`
}

// ChallengeSpecSolverDns01Input is an input type that accepts ChallengeSpecSolverDns01Args and ChallengeSpecSolverDns01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Input` via:
//
//	ChallengeSpecSolverDns01Args{...}
type ChallengeSpecSolverDns01Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output
	ToChallengeSpecSolverDns01OutputWithContext(context.Context) ChallengeSpecSolverDns01Output
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Args struct {
	AcmeDNS    ChallengeSpecSolverDns01AcmeDNSPtrInput    `pulumi:"acmeDNS"`
	Akamai     ChallengeSpecSolverDns01AkamaiPtrInput     `pulumi:"akamai"`
	AzureDNS   ChallengeSpecSolverDns01AzureDNSPtrInput   `pulumi:"azureDNS"`
	CloudDNS   ChallengeSpecSolverDns01CloudDNSPtrInput   `pulumi:"cloudDNS"`
	Cloudflare ChallengeSpecSolverDns01CloudflarePtrInput `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy pulumi.StringPtrInput                        `pulumi:"cnameStrategy"`
	Digitalocean  ChallengeSpecSolverDns01DigitaloceanPtrInput `pulumi:"digitalocean"`
	Rfc2136       ChallengeSpecSolverDns01Rfc2136PtrInput      `pulumi:"rfc2136"`
	Route53       ChallengeSpecSolverDns01Route53PtrInput      `pulumi:"route53"`
	Webhook       ChallengeSpecSolverDns01WebhookPtrInput      `pulumi:"webhook"`
}

func (ChallengeSpecSolverDns01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return i.ToChallengeSpecSolverDns01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output)
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output).ToChallengeSpecSolverDns01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01PtrInput is an input type that accepts ChallengeSpecSolverDns01Args, ChallengeSpecSolverDns01Ptr and ChallengeSpecSolverDns01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01PtrInput` via:
//
//	        ChallengeSpecSolverDns01Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput
	ToChallengeSpecSolverDns01PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01PtrOutput
}

type challengeSpecSolverDns01PtrType ChallengeSpecSolverDns01Args

func ChallengeSpecSolverDns01Ptr(v *ChallengeSpecSolverDns01Args) ChallengeSpecSolverDns01PtrInput {
	return (*challengeSpecSolverDns01PtrType)(v)
}

func (*challengeSpecSolverDns01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01 {
		return &v
	}).(ChallengeSpecSolverDns01PtrOutput)
}

func (o ChallengeSpecSolverDns01Output) AcmeDNS() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDNS { return v.AcmeDNS }).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01Output) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai { return v.Akamai }).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

func (o ChallengeSpecSolverDns01Output) AzureDNS() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDNS { return v.AzureDNS }).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01Output) CloudDNS() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDNS { return v.CloudDNS }).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01Output) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare { return v.Cloudflare }).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01Output) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *string { return v.CnameStrategy }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Output) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean { return v.Digitalocean }).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

func (o ChallengeSpecSolverDns01Output) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 { return v.Rfc2136 }).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

func (o ChallengeSpecSolverDns01Output) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 { return v.Route53 }).(ChallengeSpecSolverDns01Route53PtrOutput)
}

func (o ChallengeSpecSolverDns01Output) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook { return v.Webhook }).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

type ChallengeSpecSolverDns01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) Elem() ChallengeSpecSolverDns01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) ChallengeSpecSolverDns01 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01
		return ret
	}).(ChallengeSpecSolverDns01Output)
}

func (o ChallengeSpecSolverDns01PtrOutput) AcmeDNS() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDNS {
		if v == nil {
			return nil
		}
		return v.AcmeDNS
	}).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) AzureDNS() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDNS {
		if v == nil {
			return nil
		}
		return v.AzureDNS
	}).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) CloudDNS() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDNS {
		if v == nil {
			return nil
		}
		return v.CloudDNS
	}).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare {
		if v == nil {
			return nil
		}
		return v.Cloudflare
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01PtrOutput) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *string {
		if v == nil {
			return nil
		}
		return v.CnameStrategy
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean {
		if v == nil {
			return nil
		}
		return v.Digitalocean
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 {
		if v == nil {
			return nil
		}
		return v.Rfc2136
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 {
		if v == nil {
			return nil
		}
		return v.Route53
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

func (o ChallengeSpecSolverDns01PtrOutput) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook {
		if v == nil {
			return nil
		}
		return v.Webhook
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNS struct {
	AccountSecretRef *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef `pulumi:"accountSecretRef"`
	Host             *string                                          `pulumi:"host"`
}

// ChallengeSpecSolverDns01AcmeDNSInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSArgs and ChallengeSpecSolverDns01AcmeDNSOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSInput` via:
//
//	ChallengeSpecSolverDns01AcmeDNSArgs{...}
type ChallengeSpecSolverDns01AcmeDNSInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSOutput() ChallengeSpecSolverDns01AcmeDNSOutput
	ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSOutput
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSArgs struct {
	AccountSecretRef ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput `pulumi:"accountSecretRef"`
	Host             pulumi.StringPtrInput                                   `pulumi:"host"`
}

func (ChallengeSpecSolverDns01AcmeDNSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSOutput() ChallengeSpecSolverDns01AcmeDNSOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSOutput)
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSOutput).ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDNSPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSArgs, ChallengeSpecSolverDns01AcmeDNSPtr and ChallengeSpecSolverDns01AcmeDNSPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDNSArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDNSPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput
	ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput
}

type challengeSpecSolverDns01AcmeDNSPtrType ChallengeSpecSolverDns01AcmeDNSArgs

func ChallengeSpecSolverDns01AcmeDNSPtr(v *ChallengeSpecSolverDns01AcmeDNSArgs) ChallengeSpecSolverDns01AcmeDNSPtrInput {
	return (*challengeSpecSolverDns01AcmeDNSPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDNSPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDNSPtrType) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDNSPtrType) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSOutput() ChallengeSpecSolverDns01AcmeDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDNS) *ChallengeSpecSolverDns01AcmeDNS {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNS) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNS) *string { return v.Host }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AcmeDNSPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDNSOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNS) ChallengeSpecSolverDns01AcmeDNS {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDNS
		return ret
	}).(ChallengeSpecSolverDns01AcmeDNSOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNS) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		if v == nil {
			return nil
		}
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNS) *string {
		if v == nil {
			return nil
		}
		return v.Host
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs and ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput
	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput).ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs, ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtr and ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs

func ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtr(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDNSAccountSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs and ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput
	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput).ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs, ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtr and ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrType ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs

func ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtr(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrType) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrType) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSPatch struct {
	AccountSecretRef *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch `pulumi:"accountSecretRef"`
	Host             *string                                               `pulumi:"host"`
}

// ChallengeSpecSolverDns01AcmeDNSPatchInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSPatchArgs and ChallengeSpecSolverDns01AcmeDNSPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSPatchInput` via:
//
//	ChallengeSpecSolverDns01AcmeDNSPatchArgs{...}
type ChallengeSpecSolverDns01AcmeDNSPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSPatchOutput() ChallengeSpecSolverDns01AcmeDNSPatchOutput
	ToChallengeSpecSolverDns01AcmeDNSPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSPatchOutput
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSPatchArgs struct {
	AccountSecretRef ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrInput `pulumi:"accountSecretRef"`
	Host             pulumi.StringPtrInput                                        `pulumi:"host"`
}

func (ChallengeSpecSolverDns01AcmeDNSPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDNSPatchArgs) ToChallengeSpecSolverDns01AcmeDNSPatchOutput() ChallengeSpecSolverDns01AcmeDNSPatchOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSPatchArgs) ToChallengeSpecSolverDns01AcmeDNSPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSPatchOutput)
}

func (i ChallengeSpecSolverDns01AcmeDNSPatchArgs) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSPatchArgs) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSPatchOutput).ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDNSPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSPatchArgs, ChallengeSpecSolverDns01AcmeDNSPatchPtr and ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDNSPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDNSPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput
	ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput
}

type challengeSpecSolverDns01AcmeDNSPatchPtrType ChallengeSpecSolverDns01AcmeDNSPatchArgs

func ChallengeSpecSolverDns01AcmeDNSPatchPtr(v *ChallengeSpecSolverDns01AcmeDNSPatchArgs) ChallengeSpecSolverDns01AcmeDNSPatchPtrInput {
	return (*challengeSpecSolverDns01AcmeDNSPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDNSPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDNSPatchPtrType) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDNSPatchPtrType) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchOutput) ToChallengeSpecSolverDns01AcmeDNSPatchOutput() ChallengeSpecSolverDns01AcmeDNSPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchOutput) ToChallengeSpecSolverDns01AcmeDNSPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchOutput) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchOutput) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDNSPatch) *ChallengeSpecSolverDns01AcmeDNSPatch {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSPatch) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch {
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSPatch) *string { return v.Host }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutput() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput) ToChallengeSpecSolverDns01AcmeDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDNSPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSPatch) ChallengeSpecSolverDns01AcmeDNSPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDNSPatch
		return ret
	}).(ChallengeSpecSolverDns01AcmeDNSPatchOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSPatch) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.Host
	}).(pulumi.StringPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Akamai struct {
	AccessTokenSecretRef  *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef  `pulumi:"accessTokenSecretRef"`
	ClientSecretSecretRef *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	ClientTokenSecretRef  *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef  `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain *string                                              `pulumi:"serviceConsumerDomain"`
}

// ChallengeSpecSolverDns01AkamaiInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs and ChallengeSpecSolverDns01AkamaiOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiInput` via:
//
//	ChallengeSpecSolverDns01AkamaiArgs{...}
type ChallengeSpecSolverDns01AkamaiInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput
	ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiOutput
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiArgs struct {
	AccessTokenSecretRef  ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput  `pulumi:"accessTokenSecretRef"`
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput `pulumi:"clientSecretSecretRef"`
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput  `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain pulumi.StringPtrInput                                       `pulumi:"serviceConsumerDomain"`
}

func (ChallengeSpecSolverDns01AkamaiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return i.ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput)
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput).ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs, ChallengeSpecSolverDns01AkamaiPtr and ChallengeSpecSolverDns01AkamaiPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput
	ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput
}

type challengeSpecSolverDns01AkamaiPtrType ChallengeSpecSolverDns01AkamaiArgs

func ChallengeSpecSolverDns01AkamaiPtr(v *ChallengeSpecSolverDns01AkamaiArgs) ChallengeSpecSolverDns01AkamaiPtrInput {
	return (*challengeSpecSolverDns01AkamaiPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01Akamai {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) *string { return v.ServiceConsumerDomain }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01Akamai {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Akamai
		return ret
	}).(ChallengeSpecSolverDns01AkamaiOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *string {
		if v == nil {
			return nil
		}
		return v.ServiceConsumerDomain
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput).ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs, ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtr and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrType ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs

func ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtr(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput).ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs, ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtr and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrType ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs

func ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtr(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput).ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs, ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtr and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrType ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs

func ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtr(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiPatch struct {
	AccessTokenSecretRef  *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch  `pulumi:"accessTokenSecretRef"`
	ClientSecretSecretRef *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch `pulumi:"clientSecretSecretRef"`
	ClientTokenSecretRef  *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch  `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain *string                                                   `pulumi:"serviceConsumerDomain"`
}

// ChallengeSpecSolverDns01AkamaiPatchInput is an input type that accepts ChallengeSpecSolverDns01AkamaiPatchArgs and ChallengeSpecSolverDns01AkamaiPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiPatchInput` via:
//
//	ChallengeSpecSolverDns01AkamaiPatchArgs{...}
type ChallengeSpecSolverDns01AkamaiPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiPatchOutput() ChallengeSpecSolverDns01AkamaiPatchOutput
	ToChallengeSpecSolverDns01AkamaiPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiPatchOutput
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiPatchArgs struct {
	AccessTokenSecretRef  ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrInput  `pulumi:"accessTokenSecretRef"`
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrInput `pulumi:"clientSecretSecretRef"`
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrInput  `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain pulumi.StringPtrInput                                            `pulumi:"serviceConsumerDomain"`
}

func (ChallengeSpecSolverDns01AkamaiPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiPatchArgs) ToChallengeSpecSolverDns01AkamaiPatchOutput() ChallengeSpecSolverDns01AkamaiPatchOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiPatchArgs) ToChallengeSpecSolverDns01AkamaiPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPatchOutput)
}

func (i ChallengeSpecSolverDns01AkamaiPatchArgs) ToChallengeSpecSolverDns01AkamaiPatchPtrOutput() ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiPatchArgs) ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPatchOutput).ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiPatchArgs, ChallengeSpecSolverDns01AkamaiPatchPtr and ChallengeSpecSolverDns01AkamaiPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiPatchPtrOutput() ChallengeSpecSolverDns01AkamaiPatchPtrOutput
	ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiPatchPtrOutput
}

type challengeSpecSolverDns01AkamaiPatchPtrType ChallengeSpecSolverDns01AkamaiPatchArgs

func ChallengeSpecSolverDns01AkamaiPatchPtr(v *ChallengeSpecSolverDns01AkamaiPatchArgs) ChallengeSpecSolverDns01AkamaiPatchPtrInput {
	return (*challengeSpecSolverDns01AkamaiPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiPatchPtrType) ToChallengeSpecSolverDns01AkamaiPatchPtrOutput() ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiPatchPtrType) ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPatchPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ToChallengeSpecSolverDns01AkamaiPatchOutput() ChallengeSpecSolverDns01AkamaiPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ToChallengeSpecSolverDns01AkamaiPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ToChallengeSpecSolverDns01AkamaiPatchPtrOutput() ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiPatch {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch {
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch {
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiPatch) *string { return v.ServiceConsumerDomain }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AkamaiPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiPatchPtrOutput() ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) ToChallengeSpecSolverDns01AkamaiPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiPatch) ChallengeSpecSolverDns01AkamaiPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiPatch
		return ret
	}).(ChallengeSpecSolverDns01AkamaiPatchOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiPatch) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPatchPtrOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceConsumerDomain
	}).(pulumi.StringPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNS struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID              *string                                                `pulumi:"clientID"`
	ClientSecretSecretRef *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment *string `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName  *string                                          `pulumi:"hostedZoneName"`
	ManagedIdentity *ChallengeSpecSolverDns01AzureDNSManagedIdentity `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID *string `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID *string `pulumi:"tenantID"`
}

// ChallengeSpecSolverDns01AzureDNSInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSArgs and ChallengeSpecSolverDns01AzureDNSOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSInput` via:
//
//	ChallengeSpecSolverDns01AzureDNSArgs{...}
type ChallengeSpecSolverDns01AzureDNSInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSOutput() ChallengeSpecSolverDns01AzureDNSOutput
	ToChallengeSpecSolverDns01AzureDNSOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSOutput
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSArgs struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID              pulumi.StringPtrInput                                         `pulumi:"clientID"`
	ClientSecretSecretRef ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment pulumi.StringPtrInput `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName  pulumi.StringPtrInput                                   `pulumi:"hostedZoneName"`
	ManagedIdentity ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrInput `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName pulumi.StringPtrInput `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID pulumi.StringPtrInput `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID pulumi.StringPtrInput `pulumi:"tenantID"`
}

func (ChallengeSpecSolverDns01AzureDNSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSOutput() ChallengeSpecSolverDns01AzureDNSOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSOutput).ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSArgs, ChallengeSpecSolverDns01AzureDNSPtr and ChallengeSpecSolverDns01AzureDNSPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDNSArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDNSPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput
	ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput
}

type challengeSpecSolverDns01AzureDNSPtrType ChallengeSpecSolverDns01AzureDNSArgs

func ChallengeSpecSolverDns01AzureDNSPtr(v *ChallengeSpecSolverDns01AzureDNSArgs) ChallengeSpecSolverDns01AzureDNSPtrInput {
	return (*challengeSpecSolverDns01AzureDNSPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSPtrType) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSPtrType) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSOutput() ChallengeSpecSolverDns01AzureDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNS {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDNSOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDNSOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.Environment }).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDNSOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNSManagedIdentity {
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDNSOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.ResourceGroupName }).(pulumi.StringPtrOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDNSOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.SubscriptionID }).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDNSOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.TenantID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) ChallengeSpecSolverDns01AzureDNS {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDNS
		return ret
	}).(ChallengeSpecSolverDns01AzureDNSOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.Environment
	}).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNSManagedIdentity {
		if v == nil {
			return nil
		}
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.ResourceGroupName
	}).(pulumi.StringPtrOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.SubscriptionID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.TenantID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs and ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs, ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtr and ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs and ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput
	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput).ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs, ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtr and ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrType ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs

func ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtr(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrType) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrType) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDNSManagedIdentity struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID *string `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID *string `pulumi:"resourceID"`
}

// ChallengeSpecSolverDns01AzureDNSManagedIdentityInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs and ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSManagedIdentityInput` via:
//
//	ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs{...}
type ChallengeSpecSolverDns01AzureDNSManagedIdentityInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput
	ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID pulumi.StringPtrInput `pulumi:"resourceID"`
}

func (ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentity)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput).ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs, ChallengeSpecSolverDns01AzureDNSManagedIdentityPtr and ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput
	ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput
}

type challengeSpecSolverDns01AzureDNSManagedIdentityPtrType ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs

func ChallengeSpecSolverDns01AzureDNSManagedIdentityPtr(v *ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs) ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrInput {
	return (*challengeSpecSolverDns01AzureDNSManagedIdentityPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSManagedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSManagedIdentity)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSManagedIdentityPtrType) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSManagedIdentityPtrType) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentity)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDNSManagedIdentity) *ChallengeSpecSolverDns01AzureDNSManagedIdentity {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSManagedIdentity) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSManagedIdentity) *string { return v.ResourceID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSManagedIdentity)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSManagedIdentity) ChallengeSpecSolverDns01AzureDNSManagedIdentity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDNSManagedIdentity
		return ret
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.ResourceID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID *string `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID *string `pulumi:"resourceID"`
}

// ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs and ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchInput` via:
//
//	ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs{...}
type ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput
	ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID pulumi.StringPtrInput `pulumi:"resourceID"`
}

func (ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput).ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs, ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtr and ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput
	ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput
}

type challengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrType ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs

func ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtr(v *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrInput {
	return (*challengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrType) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrType) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch) *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch) *string { return v.ResourceID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput) ToChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch) ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch
		return ret
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch) *string {
		if v == nil {
			return nil
		}
		return v.ResourceID
	}).(pulumi.StringPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSPatch struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID              *string                                                     `pulumi:"clientID"`
	ClientSecretSecretRef *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment *string `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName  *string                                               `pulumi:"hostedZoneName"`
	ManagedIdentity *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID *string `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID *string `pulumi:"tenantID"`
}

// ChallengeSpecSolverDns01AzureDNSPatchInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSPatchArgs and ChallengeSpecSolverDns01AzureDNSPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSPatchInput` via:
//
//	ChallengeSpecSolverDns01AzureDNSPatchArgs{...}
type ChallengeSpecSolverDns01AzureDNSPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSPatchOutput() ChallengeSpecSolverDns01AzureDNSPatchOutput
	ToChallengeSpecSolverDns01AzureDNSPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSPatchOutput
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSPatchArgs struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID              pulumi.StringPtrInput                                              `pulumi:"clientID"`
	ClientSecretSecretRef ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrInput `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment pulumi.StringPtrInput `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName  pulumi.StringPtrInput                                        `pulumi:"hostedZoneName"`
	ManagedIdentity ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrInput `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName pulumi.StringPtrInput `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID pulumi.StringPtrInput `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID pulumi.StringPtrInput `pulumi:"tenantID"`
}

func (ChallengeSpecSolverDns01AzureDNSPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSPatchArgs) ToChallengeSpecSolverDns01AzureDNSPatchOutput() ChallengeSpecSolverDns01AzureDNSPatchOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSPatchArgs) ToChallengeSpecSolverDns01AzureDNSPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSPatchOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSPatchArgs) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSPatchArgs) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSPatchOutput).ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSPatchArgs, ChallengeSpecSolverDns01AzureDNSPatchPtr and ChallengeSpecSolverDns01AzureDNSPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDNSPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDNSPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput
	ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSPatchPtrOutput
}

type challengeSpecSolverDns01AzureDNSPatchPtrType ChallengeSpecSolverDns01AzureDNSPatchArgs

func ChallengeSpecSolverDns01AzureDNSPatchPtr(v *ChallengeSpecSolverDns01AzureDNSPatchArgs) ChallengeSpecSolverDns01AzureDNSPatchPtrInput {
	return (*challengeSpecSolverDns01AzureDNSPatchPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSPatchPtrType) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSPatchPtrType) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSPatchPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ToChallengeSpecSolverDns01AzureDNSPatchOutput() ChallengeSpecSolverDns01AzureDNSPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ToChallengeSpecSolverDns01AzureDNSPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDNSPatch) *ChallengeSpecSolverDns01AzureDNSPatch {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSPatchPtrOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *string { return v.Environment }).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch {
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *string { return v.ResourceGroupName }).(pulumi.StringPtrOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *string { return v.SubscriptionID }).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDNSPatchOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSPatch) *string { return v.TenantID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutput() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ToChallengeSpecSolverDns01AzureDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) ChallengeSpecSolverDns01AzureDNSPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDNSPatch
		return ret
	}).(ChallengeSpecSolverDns01AzureDNSPatchOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.Environment
	}).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *ChallengeSpecSolverDns01AzureDNSManagedIdentityPatch {
		if v == nil {
			return nil
		}
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.ResourceGroupName
	}).(pulumi.StringPtrOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.SubscriptionID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDNSPatchPtrOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.TenantID
	}).(pulumi.StringPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNS struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName          *string                                                  `pulumi:"hostedZoneName"`
	Project                 *string                                                  `pulumi:"project"`
	ServiceAccountSecretRef *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef `pulumi:"serviceAccountSecretRef"`
}

// ChallengeSpecSolverDns01CloudDNSInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSArgs and ChallengeSpecSolverDns01CloudDNSOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSInput` via:
//
//	ChallengeSpecSolverDns01CloudDNSArgs{...}
type ChallengeSpecSolverDns01CloudDNSInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSOutput() ChallengeSpecSolverDns01CloudDNSOutput
	ToChallengeSpecSolverDns01CloudDNSOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSOutput
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSArgs struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName          pulumi.StringPtrInput                                           `pulumi:"hostedZoneName"`
	Project                 pulumi.StringPtrInput                                           `pulumi:"project"`
	ServiceAccountSecretRef ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput `pulumi:"serviceAccountSecretRef"`
}

func (ChallengeSpecSolverDns01CloudDNSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSOutput() ChallengeSpecSolverDns01CloudDNSOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSOutput)
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSOutput).ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDNSPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSArgs, ChallengeSpecSolverDns01CloudDNSPtr and ChallengeSpecSolverDns01CloudDNSPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDNSArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDNSPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput
	ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput
}

type challengeSpecSolverDns01CloudDNSPtrType ChallengeSpecSolverDns01CloudDNSArgs

func ChallengeSpecSolverDns01CloudDNSPtr(v *ChallengeSpecSolverDns01CloudDNSArgs) ChallengeSpecSolverDns01CloudDNSPtrInput {
	return (*challengeSpecSolverDns01CloudDNSPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDNSPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDNSPtrType) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDNSPtrType) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSOutput() ChallengeSpecSolverDns01CloudDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDNS) *ChallengeSpecSolverDns01CloudDNS {
		return &v
	}).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDNSOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) *string { return v.Project }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01CloudDNSPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) Elem() ChallengeSpecSolverDns01CloudDNSOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) ChallengeSpecSolverDns01CloudDNS {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDNS
		return ret
	}).(ChallengeSpecSolverDns01CloudDNSOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) *string {
		if v == nil {
			return nil
		}
		return v.Project
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		if v == nil {
			return nil
		}
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSPatch struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName          *string                                                       `pulumi:"hostedZoneName"`
	Project                 *string                                                       `pulumi:"project"`
	ServiceAccountSecretRef *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch `pulumi:"serviceAccountSecretRef"`
}

// ChallengeSpecSolverDns01CloudDNSPatchInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSPatchArgs and ChallengeSpecSolverDns01CloudDNSPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSPatchInput` via:
//
//	ChallengeSpecSolverDns01CloudDNSPatchArgs{...}
type ChallengeSpecSolverDns01CloudDNSPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSPatchOutput() ChallengeSpecSolverDns01CloudDNSPatchOutput
	ToChallengeSpecSolverDns01CloudDNSPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSPatchOutput
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSPatchArgs struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName          pulumi.StringPtrInput                                                `pulumi:"hostedZoneName"`
	Project                 pulumi.StringPtrInput                                                `pulumi:"project"`
	ServiceAccountSecretRef ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrInput `pulumi:"serviceAccountSecretRef"`
}

func (ChallengeSpecSolverDns01CloudDNSPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDNSPatchArgs) ToChallengeSpecSolverDns01CloudDNSPatchOutput() ChallengeSpecSolverDns01CloudDNSPatchOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSPatchArgs) ToChallengeSpecSolverDns01CloudDNSPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSPatchOutput)
}

func (i ChallengeSpecSolverDns01CloudDNSPatchArgs) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSPatchArgs) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSPatchOutput).ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDNSPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSPatchArgs, ChallengeSpecSolverDns01CloudDNSPatchPtr and ChallengeSpecSolverDns01CloudDNSPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDNSPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDNSPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput
	ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSPatchPtrOutput
}

type challengeSpecSolverDns01CloudDNSPatchPtrType ChallengeSpecSolverDns01CloudDNSPatchArgs

func ChallengeSpecSolverDns01CloudDNSPatchPtr(v *ChallengeSpecSolverDns01CloudDNSPatchArgs) ChallengeSpecSolverDns01CloudDNSPatchPtrInput {
	return (*challengeSpecSolverDns01CloudDNSPatchPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDNSPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDNSPatchPtrType) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDNSPatchPtrType) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSPatchPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) ToChallengeSpecSolverDns01CloudDNSPatchOutput() ChallengeSpecSolverDns01CloudDNSPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) ToChallengeSpecSolverDns01CloudDNSPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDNSPatch) *ChallengeSpecSolverDns01CloudDNSPatch {
		return &v
	}).(ChallengeSpecSolverDns01CloudDNSPatchPtrOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSPatch) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSPatch) *string { return v.Project }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPatchOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSPatch) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch {
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput)
}

type ChallengeSpecSolverDns01CloudDNSPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) ToChallengeSpecSolverDns01CloudDNSPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) Elem() ChallengeSpecSolverDns01CloudDNSPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSPatch) ChallengeSpecSolverDns01CloudDNSPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDNSPatch
		return ret
	}).(ChallengeSpecSolverDns01CloudDNSPatchOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSPatch) *string {
		if v == nil {
			return nil
		}
		return v.Project
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPatchPtrOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSPatch) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs and ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput
	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput).ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs, ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtr and ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs

func ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtr(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs and ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput
	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput).ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs, ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtr and ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrType ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs

func ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtr(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrType) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrType) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Cloudflare struct {
	ApiKeySecretRef   *ChallengeSpecSolverDns01CloudflareApiKeySecretRef   `pulumi:"apiKeySecretRef"`
	ApiTokenSecretRef *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email *string `pulumi:"email"`
}

// ChallengeSpecSolverDns01CloudflareInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs and ChallengeSpecSolverDns01CloudflareOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareInput` via:
//
//	ChallengeSpecSolverDns01CloudflareArgs{...}
type ChallengeSpecSolverDns01CloudflareInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput
	ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareOutput
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareArgs struct {
	ApiKeySecretRef   ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput   `pulumi:"apiKeySecretRef"`
	ApiTokenSecretRef ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email pulumi.StringPtrInput `pulumi:"email"`
}

func (ChallengeSpecSolverDns01CloudflareArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return i.ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput)
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput).ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflarePtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs, ChallengeSpecSolverDns01CloudflarePtr and ChallengeSpecSolverDns01CloudflarePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflarePtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflarePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput
	ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput
}

type challengeSpecSolverDns01CloudflarePtrType ChallengeSpecSolverDns01CloudflareArgs

func ChallengeSpecSolverDns01CloudflarePtr(v *ChallengeSpecSolverDns01CloudflareArgs) ChallengeSpecSolverDns01CloudflarePtrInput {
	return (*challengeSpecSolverDns01CloudflarePtrType)(v)
}

func (*challengeSpecSolverDns01CloudflarePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01Cloudflare {
		return &v
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflareOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *string { return v.Email }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflarePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflarePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Elem() ChallengeSpecSolverDns01CloudflareOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) ChallengeSpecSolverDns01Cloudflare {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Cloudflare
		return ret
	}).(ChallengeSpecSolverDns01CloudflareOutput)
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v == nil {
			return nil
		}
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *string {
		if v == nil {
			return nil
		}
		return v.Email
	}).(pulumi.StringPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs and ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs, ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr and ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiKeySecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs and ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs{...}
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput).ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs, ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtr and ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput
}

type challengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrType ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs

func ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtr(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch) *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs, ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput).ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs, ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtr and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrType ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs

func ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtr(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflarePatch struct {
	ApiKeySecretRef   *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch   `pulumi:"apiKeySecretRef"`
	ApiTokenSecretRef *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email *string `pulumi:"email"`
}

// ChallengeSpecSolverDns01CloudflarePatchInput is an input type that accepts ChallengeSpecSolverDns01CloudflarePatchArgs and ChallengeSpecSolverDns01CloudflarePatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflarePatchInput` via:
//
//	ChallengeSpecSolverDns01CloudflarePatchArgs{...}
type ChallengeSpecSolverDns01CloudflarePatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflarePatchOutput() ChallengeSpecSolverDns01CloudflarePatchOutput
	ToChallengeSpecSolverDns01CloudflarePatchOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflarePatchOutput
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflarePatchArgs struct {
	ApiKeySecretRef   ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrInput   `pulumi:"apiKeySecretRef"`
	ApiTokenSecretRef ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrInput `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email pulumi.StringPtrInput `pulumi:"email"`
}

func (ChallengeSpecSolverDns01CloudflarePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflarePatchArgs) ToChallengeSpecSolverDns01CloudflarePatchOutput() ChallengeSpecSolverDns01CloudflarePatchOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflarePatchArgs) ToChallengeSpecSolverDns01CloudflarePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePatchOutput)
}

func (i ChallengeSpecSolverDns01CloudflarePatchArgs) ToChallengeSpecSolverDns01CloudflarePatchPtrOutput() ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflarePatchArgs) ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePatchOutput).ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflarePatchPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflarePatchArgs, ChallengeSpecSolverDns01CloudflarePatchPtr and ChallengeSpecSolverDns01CloudflarePatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflarePatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflarePatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflarePatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflarePatchPtrOutput() ChallengeSpecSolverDns01CloudflarePatchPtrOutput
	ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflarePatchPtrOutput
}

type challengeSpecSolverDns01CloudflarePatchPtrType ChallengeSpecSolverDns01CloudflarePatchArgs

func ChallengeSpecSolverDns01CloudflarePatchPtr(v *ChallengeSpecSolverDns01CloudflarePatchArgs) ChallengeSpecSolverDns01CloudflarePatchPtrInput {
	return (*challengeSpecSolverDns01CloudflarePatchPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflarePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflarePatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflarePatchPtrType) ToChallengeSpecSolverDns01CloudflarePatchPtrOutput() ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflarePatchPtrType) ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePatchPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflarePatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflarePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflarePatchOutput) ToChallengeSpecSolverDns01CloudflarePatchOutput() ChallengeSpecSolverDns01CloudflarePatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePatchOutput) ToChallengeSpecSolverDns01CloudflarePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePatchOutput) ToChallengeSpecSolverDns01CloudflarePatchPtrOutput() ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflarePatchOutput) ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflarePatch) *ChallengeSpecSolverDns01CloudflarePatch {
		return &v
	}).(ChallengeSpecSolverDns01CloudflarePatchPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudflarePatchOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflarePatch) *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch {
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudflarePatchOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflarePatch) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch {
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflarePatchOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflarePatch) *string { return v.Email }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflarePatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflarePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflarePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflarePatchPtrOutput) ToChallengeSpecSolverDns01CloudflarePatchPtrOutput() ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePatchPtrOutput) ToChallengeSpecSolverDns01CloudflarePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePatchPtrOutput) Elem() ChallengeSpecSolverDns01CloudflarePatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflarePatch) ChallengeSpecSolverDns01CloudflarePatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflarePatch
		return ret
	}).(ChallengeSpecSolverDns01CloudflarePatchOutput)
}

func (o ChallengeSpecSolverDns01CloudflarePatchPtrOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflarePatch) *ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatch {
		if v == nil {
			return nil
		}
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudflarePatchPtrOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflarePatch) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflarePatchPtrOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflarePatch) *string {
		if v == nil {
			return nil
		}
		return v.Email
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Digitalocean struct {
	TokenSecretRef *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef `pulumi:"tokenSecretRef"`
}

// ChallengeSpecSolverDns01DigitaloceanInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs and ChallengeSpecSolverDns01DigitaloceanOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanArgs{...}
type ChallengeSpecSolverDns01DigitaloceanInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput
	ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanOutput
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanArgs struct {
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput `pulumi:"tokenSecretRef"`
}

func (ChallengeSpecSolverDns01DigitaloceanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput).ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs, ChallengeSpecSolverDns01DigitaloceanPtr and ChallengeSpecSolverDns01DigitaloceanPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput
}

type challengeSpecSolverDns01DigitaloceanPtrType ChallengeSpecSolverDns01DigitaloceanArgs

func ChallengeSpecSolverDns01DigitaloceanPtr(v *ChallengeSpecSolverDns01DigitaloceanArgs) ChallengeSpecSolverDns01DigitaloceanPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01Digitalocean {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01DigitaloceanPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01Digitalocean {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Digitalocean
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanPatch struct {
	TokenSecretRef *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch `pulumi:"tokenSecretRef"`
}

// ChallengeSpecSolverDns01DigitaloceanPatchInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanPatchArgs and ChallengeSpecSolverDns01DigitaloceanPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanPatchInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanPatchArgs{...}
type ChallengeSpecSolverDns01DigitaloceanPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanPatchOutput() ChallengeSpecSolverDns01DigitaloceanPatchOutput
	ToChallengeSpecSolverDns01DigitaloceanPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanPatchOutput
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanPatchArgs struct {
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrInput `pulumi:"tokenSecretRef"`
}

func (ChallengeSpecSolverDns01DigitaloceanPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanPatchArgs) ToChallengeSpecSolverDns01DigitaloceanPatchOutput() ChallengeSpecSolverDns01DigitaloceanPatchOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanPatchArgs) ToChallengeSpecSolverDns01DigitaloceanPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPatchOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanPatchArgs) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanPatchArgs) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPatchOutput).ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanPatchArgs, ChallengeSpecSolverDns01DigitaloceanPatchPtr and ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput
}

type challengeSpecSolverDns01DigitaloceanPatchPtrType ChallengeSpecSolverDns01DigitaloceanPatchArgs

func ChallengeSpecSolverDns01DigitaloceanPatchPtr(v *ChallengeSpecSolverDns01DigitaloceanPatchArgs) ChallengeSpecSolverDns01DigitaloceanPatchPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanPatchPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanPatchPtrType) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanPatchPtrType) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchOutput) ToChallengeSpecSolverDns01DigitaloceanPatchOutput() ChallengeSpecSolverDns01DigitaloceanPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchOutput) ToChallengeSpecSolverDns01DigitaloceanPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchOutput) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchOutput) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01DigitaloceanPatch) *ChallengeSpecSolverDns01DigitaloceanPatch {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanPatch) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch {
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput)
}

type ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanPatch) ChallengeSpecSolverDns01DigitaloceanPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01DigitaloceanPatch
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanPatchOutput)
}

func (o ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanPatch) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput).ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs, ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs

func ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01DigitaloceanTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput).ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs, ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtr and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrType ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs

func ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtr(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Patch struct {
	AcmeDNS    *ChallengeSpecSolverDns01AcmeDNSPatch    `pulumi:"acmeDNS"`
	Akamai     *ChallengeSpecSolverDns01AkamaiPatch     `pulumi:"akamai"`
	AzureDNS   *ChallengeSpecSolverDns01AzureDNSPatch   `pulumi:"azureDNS"`
	CloudDNS   *ChallengeSpecSolverDns01CloudDNSPatch   `pulumi:"cloudDNS"`
	Cloudflare *ChallengeSpecSolverDns01CloudflarePatch `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy *string                                    `pulumi:"cnameStrategy"`
	Digitalocean  *ChallengeSpecSolverDns01DigitaloceanPatch `pulumi:"digitalocean"`
	Rfc2136       *ChallengeSpecSolverDns01Rfc2136Patch      `pulumi:"rfc2136"`
	Route53       *ChallengeSpecSolverDns01Route53Patch      `pulumi:"route53"`
	Webhook       *ChallengeSpecSolverDns01WebhookPatch      `pulumi:"webhook"`
}

// ChallengeSpecSolverDns01PatchInput is an input type that accepts ChallengeSpecSolverDns01PatchArgs and ChallengeSpecSolverDns01PatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01PatchInput` via:
//
//	ChallengeSpecSolverDns01PatchArgs{...}
type ChallengeSpecSolverDns01PatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01PatchOutput() ChallengeSpecSolverDns01PatchOutput
	ToChallengeSpecSolverDns01PatchOutputWithContext(context.Context) ChallengeSpecSolverDns01PatchOutput
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01PatchArgs struct {
	AcmeDNS    ChallengeSpecSolverDns01AcmeDNSPatchPtrInput    `pulumi:"acmeDNS"`
	Akamai     ChallengeSpecSolverDns01AkamaiPatchPtrInput     `pulumi:"akamai"`
	AzureDNS   ChallengeSpecSolverDns01AzureDNSPatchPtrInput   `pulumi:"azureDNS"`
	CloudDNS   ChallengeSpecSolverDns01CloudDNSPatchPtrInput   `pulumi:"cloudDNS"`
	Cloudflare ChallengeSpecSolverDns01CloudflarePatchPtrInput `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy pulumi.StringPtrInput                             `pulumi:"cnameStrategy"`
	Digitalocean  ChallengeSpecSolverDns01DigitaloceanPatchPtrInput `pulumi:"digitalocean"`
	Rfc2136       ChallengeSpecSolverDns01Rfc2136PatchPtrInput      `pulumi:"rfc2136"`
	Route53       ChallengeSpecSolverDns01Route53PatchPtrInput      `pulumi:"route53"`
	Webhook       ChallengeSpecSolverDns01WebhookPatchPtrInput      `pulumi:"webhook"`
}

func (ChallengeSpecSolverDns01PatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Patch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01PatchArgs) ToChallengeSpecSolverDns01PatchOutput() ChallengeSpecSolverDns01PatchOutput {
	return i.ToChallengeSpecSolverDns01PatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01PatchArgs) ToChallengeSpecSolverDns01PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PatchOutput)
}

func (i ChallengeSpecSolverDns01PatchArgs) ToChallengeSpecSolverDns01PatchPtrOutput() ChallengeSpecSolverDns01PatchPtrOutput {
	return i.ToChallengeSpecSolverDns01PatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01PatchArgs) ToChallengeSpecSolverDns01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PatchOutput).ToChallengeSpecSolverDns01PatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01PatchPtrInput is an input type that accepts ChallengeSpecSolverDns01PatchArgs, ChallengeSpecSolverDns01PatchPtr and ChallengeSpecSolverDns01PatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01PatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01PatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01PatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01PatchPtrOutput() ChallengeSpecSolverDns01PatchPtrOutput
	ToChallengeSpecSolverDns01PatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01PatchPtrOutput
}

type challengeSpecSolverDns01PatchPtrType ChallengeSpecSolverDns01PatchArgs

func ChallengeSpecSolverDns01PatchPtr(v *ChallengeSpecSolverDns01PatchArgs) ChallengeSpecSolverDns01PatchPtrInput {
	return (*challengeSpecSolverDns01PatchPtrType)(v)
}

func (*challengeSpecSolverDns01PatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Patch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01PatchPtrType) ToChallengeSpecSolverDns01PatchPtrOutput() ChallengeSpecSolverDns01PatchPtrOutput {
	return i.ToChallengeSpecSolverDns01PatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01PatchPtrType) ToChallengeSpecSolverDns01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PatchPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01PatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01PatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01PatchOutput) ToChallengeSpecSolverDns01PatchOutput() ChallengeSpecSolverDns01PatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01PatchOutput) ToChallengeSpecSolverDns01PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01PatchOutput) ToChallengeSpecSolverDns01PatchPtrOutput() ChallengeSpecSolverDns01PatchPtrOutput {
	return o.ToChallengeSpecSolverDns01PatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01PatchOutput) ToChallengeSpecSolverDns01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01Patch {
		return &v
	}).(ChallengeSpecSolverDns01PatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) AcmeDNS() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01AcmeDNSPatch { return v.AcmeDNS }).(ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) Akamai() ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01AkamaiPatch { return v.Akamai }).(ChallengeSpecSolverDns01AkamaiPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) AzureDNS() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01AzureDNSPatch { return v.AzureDNS }).(ChallengeSpecSolverDns01AzureDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) CloudDNS() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01CloudDNSPatch { return v.CloudDNS }).(ChallengeSpecSolverDns01CloudDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) Cloudflare() ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01CloudflarePatch { return v.Cloudflare }).(ChallengeSpecSolverDns01CloudflarePatchPtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01PatchOutput) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *string { return v.CnameStrategy }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01DigitaloceanPatch {
		return v.Digitalocean
	}).(ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) Rfc2136() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01Rfc2136Patch { return v.Rfc2136 }).(ChallengeSpecSolverDns01Rfc2136PatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) Route53() ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01Route53Patch { return v.Route53 }).(ChallengeSpecSolverDns01Route53PatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchOutput) Webhook() ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01WebhookPatch { return v.Webhook }).(ChallengeSpecSolverDns01WebhookPatchPtrOutput)
}

type ChallengeSpecSolverDns01PatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01PatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) ToChallengeSpecSolverDns01PatchPtrOutput() ChallengeSpecSolverDns01PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) ToChallengeSpecSolverDns01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Elem() ChallengeSpecSolverDns01PatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) ChallengeSpecSolverDns01Patch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Patch
		return ret
	}).(ChallengeSpecSolverDns01PatchOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) AcmeDNS() ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01AcmeDNSPatch {
		if v == nil {
			return nil
		}
		return v.AcmeDNS
	}).(ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Akamai() ChallengeSpecSolverDns01AkamaiPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01AkamaiPatch {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(ChallengeSpecSolverDns01AkamaiPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) AzureDNS() ChallengeSpecSolverDns01AzureDNSPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01AzureDNSPatch {
		if v == nil {
			return nil
		}
		return v.AzureDNS
	}).(ChallengeSpecSolverDns01AzureDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) CloudDNS() ChallengeSpecSolverDns01CloudDNSPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01CloudDNSPatch {
		if v == nil {
			return nil
		}
		return v.CloudDNS
	}).(ChallengeSpecSolverDns01CloudDNSPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Cloudflare() ChallengeSpecSolverDns01CloudflarePatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01CloudflarePatch {
		if v == nil {
			return nil
		}
		return v.Cloudflare
	}).(ChallengeSpecSolverDns01CloudflarePatchPtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01PatchPtrOutput) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *string {
		if v == nil {
			return nil
		}
		return v.CnameStrategy
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01DigitaloceanPatch {
		if v == nil {
			return nil
		}
		return v.Digitalocean
	}).(ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Rfc2136() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01Rfc2136Patch {
		if v == nil {
			return nil
		}
		return v.Rfc2136
	}).(ChallengeSpecSolverDns01Rfc2136PatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Route53() ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01Route53Patch {
		if v == nil {
			return nil
		}
		return v.Route53
	}).(ChallengeSpecSolverDns01Route53PatchPtrOutput)
}

func (o ChallengeSpecSolverDns01PatchPtrOutput) Webhook() ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Patch) *ChallengeSpecSolverDns01WebhookPatch {
		if v == nil {
			return nil
		}
		return v.Webhook
	}).(ChallengeSpecSolverDns01WebhookPatchPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136 struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver *string `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm *string `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName         *string                                             `pulumi:"tsigKeyName"`
	TsigSecretSecretRef *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef `pulumi:"tsigSecretSecretRef"`
}

// ChallengeSpecSolverDns01Rfc2136Input is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args and ChallengeSpecSolverDns01Rfc2136Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136Input` via:
//
//	ChallengeSpecSolverDns01Rfc2136Args{...}
type ChallengeSpecSolverDns01Rfc2136Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output
	ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136Output
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Args struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver pulumi.StringPtrInput `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm pulumi.StringPtrInput `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName         pulumi.StringPtrInput                                      `pulumi:"tsigKeyName"`
	TsigSecretSecretRef ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput `pulumi:"tsigSecretSecretRef"`
}

func (ChallengeSpecSolverDns01Rfc2136Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return i.ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output)
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output).ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136PtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args, ChallengeSpecSolverDns01Rfc2136Ptr and ChallengeSpecSolverDns01Rfc2136PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136PtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput
	ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput
}

type challengeSpecSolverDns01Rfc2136PtrType ChallengeSpecSolverDns01Rfc2136Args

func ChallengeSpecSolverDns01Rfc2136Ptr(v *ChallengeSpecSolverDns01Rfc2136Args) ChallengeSpecSolverDns01Rfc2136PtrInput {
	return (*challengeSpecSolverDns01Rfc2136PtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136 {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.Nameserver }).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigAlgorithm }).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigKeyName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Rfc2136Output) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) ChallengeSpecSolverDns01Rfc2136 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136Output)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.Nameserver
	}).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigAlgorithm
	}).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigKeyName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Patch struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver *string `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm *string `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName         *string                                                  `pulumi:"tsigKeyName"`
	TsigSecretSecretRef *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch `pulumi:"tsigSecretSecretRef"`
}

// ChallengeSpecSolverDns01Rfc2136PatchInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136PatchArgs and ChallengeSpecSolverDns01Rfc2136PatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136PatchInput` via:
//
//	ChallengeSpecSolverDns01Rfc2136PatchArgs{...}
type ChallengeSpecSolverDns01Rfc2136PatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136PatchOutput() ChallengeSpecSolverDns01Rfc2136PatchOutput
	ToChallengeSpecSolverDns01Rfc2136PatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136PatchOutput
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136PatchArgs struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver pulumi.StringPtrInput `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm pulumi.StringPtrInput `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName         pulumi.StringPtrInput                                           `pulumi:"tsigKeyName"`
	TsigSecretSecretRef ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrInput `pulumi:"tsigSecretSecretRef"`
}

func (ChallengeSpecSolverDns01Rfc2136PatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136Patch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136PatchArgs) ToChallengeSpecSolverDns01Rfc2136PatchOutput() ChallengeSpecSolverDns01Rfc2136PatchOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136PatchArgs) ToChallengeSpecSolverDns01Rfc2136PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PatchOutput)
}

func (i ChallengeSpecSolverDns01Rfc2136PatchArgs) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutput() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136PatchArgs) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PatchOutput).ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136PatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136PatchArgs, ChallengeSpecSolverDns01Rfc2136PatchPtr and ChallengeSpecSolverDns01Rfc2136PatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136PatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136PatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136PatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136PatchPtrOutput() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput
	ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136PatchPtrOutput
}

type challengeSpecSolverDns01Rfc2136PatchPtrType ChallengeSpecSolverDns01Rfc2136PatchArgs

func ChallengeSpecSolverDns01Rfc2136PatchPtr(v *ChallengeSpecSolverDns01Rfc2136PatchArgs) ChallengeSpecSolverDns01Rfc2136PatchPtrInput {
	return (*challengeSpecSolverDns01Rfc2136PatchPtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136PatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136Patch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136PatchPtrType) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutput() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136PatchPtrType) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PatchPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136PatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136PatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) ToChallengeSpecSolverDns01Rfc2136PatchOutput() ChallengeSpecSolverDns01Rfc2136PatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) ToChallengeSpecSolverDns01Rfc2136PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutput() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136Patch) *ChallengeSpecSolverDns01Rfc2136Patch {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136PatchPtrOutput)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136Patch) *string { return v.Nameserver }).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136Patch) *string { return v.TsigAlgorithm }).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136Patch) *string { return v.TsigKeyName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Rfc2136PatchOutput) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136Patch) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch {
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136PatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutput() ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) ToChallengeSpecSolverDns01Rfc2136PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136PatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136Patch) ChallengeSpecSolverDns01Rfc2136Patch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136Patch
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136PatchOutput)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136Patch) *string {
		if v == nil {
			return nil
		}
		return v.Nameserver
	}).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136Patch) *string {
		if v == nil {
			return nil
		}
		return v.TsigAlgorithm
	}).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136Patch) *string {
		if v == nil {
			return nil
		}
		return v.TsigKeyName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Rfc2136PatchPtrOutput) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136Patch) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput).ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs, ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs

func ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput).ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs, ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtr and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrType ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs

func ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtr(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53 struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID          *string                                              `pulumi:"accessKeyID"`
	AccessKeyIDSecretRef *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef `pulumi:"accessKeyIDSecretRef"`
	Auth                 *ChallengeSpecSolverDns01Route53Auth                 `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID *string `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region *string `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role                     *string                                                  `pulumi:"role"`
	SecretAccessKeySecretRef *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef `pulumi:"secretAccessKeySecretRef"`
}

// ChallengeSpecSolverDns01Route53Input is an input type that accepts ChallengeSpecSolverDns01Route53Args and ChallengeSpecSolverDns01Route53Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53Input` via:
//
//	ChallengeSpecSolverDns01Route53Args{...}
type ChallengeSpecSolverDns01Route53Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output
	ToChallengeSpecSolverDns01Route53OutputWithContext(context.Context) ChallengeSpecSolverDns01Route53Output
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Args struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID          pulumi.StringPtrInput                                       `pulumi:"accessKeyID"`
	AccessKeyIDSecretRef ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrInput `pulumi:"accessKeyIDSecretRef"`
	Auth                 ChallengeSpecSolverDns01Route53AuthPtrInput                 `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID pulumi.StringPtrInput `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region pulumi.StringPtrInput `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role                     pulumi.StringPtrInput                                           `pulumi:"role"`
	SecretAccessKeySecretRef ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput `pulumi:"secretAccessKeySecretRef"`
}

func (ChallengeSpecSolverDns01Route53Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return i.ToChallengeSpecSolverDns01Route53OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output)
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output).ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53PtrInput is an input type that accepts ChallengeSpecSolverDns01Route53Args, ChallengeSpecSolverDns01Route53Ptr and ChallengeSpecSolverDns01Route53PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53PtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput
	ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53PtrOutput
}

type challengeSpecSolverDns01Route53PtrType ChallengeSpecSolverDns01Route53Args

func ChallengeSpecSolverDns01Route53Ptr(v *ChallengeSpecSolverDns01Route53Args) ChallengeSpecSolverDns01Route53PtrInput {
	return (*challengeSpecSolverDns01Route53PtrType)(v)
}

func (*challengeSpecSolverDns01Route53PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53 {
		return &v
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.AccessKeyID }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53Output) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef {
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53Output) Auth() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53Auth { return v.Auth }).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53Output) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.HostedZoneID }).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53Output) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.Region }).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53Output) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.Role }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53Output) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Route53PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) Elem() ChallengeSpecSolverDns01Route53Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) ChallengeSpecSolverDns01Route53 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53
		return ret
	}).(ChallengeSpecSolverDns01Route53Output)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.AccessKeyID
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef {
		if v == nil {
			return nil
		}
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) Auth() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53Auth {
		if v == nil {
			return nil
		}
		return v.Auth
	}).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53PtrOutput) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneID
	}).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53PtrOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.Region
	}).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53PtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v == nil {
			return nil
		}
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs and ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefInput` via:
//
//	ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs{...}
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput).ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs, ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtr and ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput
}

type challengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrType ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs

func ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtr(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef) *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef
		return ret
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs and ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs{...}
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput).ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs, ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtr and ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput
}

type challengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrType ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs

func ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtr(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch) *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch) ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53Auth struct {
	Kubernetes *ChallengeSpecSolverDns01Route53AuthKubernetes `pulumi:"kubernetes"`
}

// ChallengeSpecSolverDns01Route53AuthInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthArgs and ChallengeSpecSolverDns01Route53AuthOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthArgs{...}
type ChallengeSpecSolverDns01Route53AuthInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput
	ToChallengeSpecSolverDns01Route53AuthOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthOutput
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthArgs struct {
	Kubernetes ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput `pulumi:"kubernetes"`
}

func (ChallengeSpecSolverDns01Route53AuthArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthOutput).ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthArgs, ChallengeSpecSolverDns01Route53AuthPtr and ChallengeSpecSolverDns01Route53AuthPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput
	ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput
}

type challengeSpecSolverDns01Route53AuthPtrType ChallengeSpecSolverDns01Route53AuthArgs

func ChallengeSpecSolverDns01Route53AuthPtr(v *ChallengeSpecSolverDns01Route53AuthArgs) ChallengeSpecSolverDns01Route53AuthPtrInput {
	return (*challengeSpecSolverDns01Route53AuthPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthPtrType) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthPtrType) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53Auth {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		return v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

type ChallengeSpecSolverDns01Route53AuthPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Auth) ChallengeSpecSolverDns01Route53Auth {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53Auth
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		if v == nil {
			return nil
		}
		return v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetes struct {
	ServiceAccountRef *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef `pulumi:"serviceAccountRef"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesArgs and ChallengeSpecSolverDns01Route53AuthKubernetesOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesArgs struct {
	ServiceAccountRef ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput `pulumi:"serviceAccountRef"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesArgs, ChallengeSpecSolverDns01Route53AuthKubernetesPtr and ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesPtrType ChallengeSpecSolverDns01Route53AuthKubernetesArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		return v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetes) ChallengeSpecSolverDns01Route53AuthKubernetes {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetes
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		if v == nil {
			return nil
		}
		return v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesPatch struct {
	ServiceAccountRef *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch `pulumi:"serviceAccountRef"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesPatchInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs and ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesPatchInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs struct {
	ServiceAccountRef ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrInput `pulumi:"serviceAccountRef"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs, ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtr and ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesPatchPtrType ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs) ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesPatchPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPatchPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPatchPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetesPatch) *ChallengeSpecSolverDns01Route53AuthKubernetesPatch {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesPatch) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch {
		return v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesPatch) ChallengeSpecSolverDns01Route53AuthKubernetesPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetesPatch
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesPatch) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch {
		if v == nil {
			return nil
		}
		return v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences []string `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences pulumi.StringArrayInput `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs, ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtr and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) []string { return v.Audiences }).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) []string {
		if v == nil {
			return nil
		}
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences []string `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences pulumi.StringArrayInput `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs, ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtr and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrType ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch) []string {
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch) []string {
		if v == nil {
			return nil
		}
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthPatch struct {
	Kubernetes *ChallengeSpecSolverDns01Route53AuthKubernetesPatch `pulumi:"kubernetes"`
}

// ChallengeSpecSolverDns01Route53AuthPatchInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthPatchArgs and ChallengeSpecSolverDns01Route53AuthPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthPatchInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthPatchArgs{...}
type ChallengeSpecSolverDns01Route53AuthPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthPatchOutput() ChallengeSpecSolverDns01Route53AuthPatchOutput
	ToChallengeSpecSolverDns01Route53AuthPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthPatchOutput
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthPatchArgs struct {
	Kubernetes ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrInput `pulumi:"kubernetes"`
}

func (ChallengeSpecSolverDns01Route53AuthPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthPatchArgs) ToChallengeSpecSolverDns01Route53AuthPatchOutput() ChallengeSpecSolverDns01Route53AuthPatchOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthPatchArgs) ToChallengeSpecSolverDns01Route53AuthPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthPatchOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthPatchArgs) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthPatchArgs) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthPatchOutput).ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthPatchArgs, ChallengeSpecSolverDns01Route53AuthPatchPtr and ChallengeSpecSolverDns01Route53AuthPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput
	ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthPatchPtrOutput
}

type challengeSpecSolverDns01Route53AuthPatchPtrType ChallengeSpecSolverDns01Route53AuthPatchArgs

func ChallengeSpecSolverDns01Route53AuthPatchPtr(v *ChallengeSpecSolverDns01Route53AuthPatchArgs) ChallengeSpecSolverDns01Route53AuthPatchPtrInput {
	return (*challengeSpecSolverDns01Route53AuthPatchPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthPatchPtrType) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthPatchPtrType) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthPatchPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthPatchOutput) ToChallengeSpecSolverDns01Route53AuthPatchOutput() ChallengeSpecSolverDns01Route53AuthPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPatchOutput) ToChallengeSpecSolverDns01Route53AuthPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPatchOutput) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthPatchOutput) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthPatch) *ChallengeSpecSolverDns01Route53AuthPatch {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthPatchOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthPatch) *ChallengeSpecSolverDns01Route53AuthKubernetesPatch {
		return v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput)
}

type ChallengeSpecSolverDns01Route53AuthPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthPatchPtrOutput) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutput() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPatchPtrOutput) ToChallengeSpecSolverDns01Route53AuthPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPatchPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthPatch) ChallengeSpecSolverDns01Route53AuthPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthPatch
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthPatchOutput)
}

func (o ChallengeSpecSolverDns01Route53AuthPatchPtrOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthPatch) *ChallengeSpecSolverDns01Route53AuthKubernetesPatch {
		if v == nil {
			return nil
		}
		return v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Patch struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID          *string                                                   `pulumi:"accessKeyID"`
	AccessKeyIDSecretRef *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch `pulumi:"accessKeyIDSecretRef"`
	Auth                 *ChallengeSpecSolverDns01Route53AuthPatch                 `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID *string `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region *string `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role                     *string                                                       `pulumi:"role"`
	SecretAccessKeySecretRef *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch `pulumi:"secretAccessKeySecretRef"`
}

// ChallengeSpecSolverDns01Route53PatchInput is an input type that accepts ChallengeSpecSolverDns01Route53PatchArgs and ChallengeSpecSolverDns01Route53PatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53PatchInput` via:
//
//	ChallengeSpecSolverDns01Route53PatchArgs{...}
type ChallengeSpecSolverDns01Route53PatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53PatchOutput() ChallengeSpecSolverDns01Route53PatchOutput
	ToChallengeSpecSolverDns01Route53PatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53PatchOutput
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53PatchArgs struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID          pulumi.StringPtrInput                                            `pulumi:"accessKeyID"`
	AccessKeyIDSecretRef ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrInput `pulumi:"accessKeyIDSecretRef"`
	Auth                 ChallengeSpecSolverDns01Route53AuthPatchPtrInput                 `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID pulumi.StringPtrInput `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region pulumi.StringPtrInput `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role                     pulumi.StringPtrInput                                                `pulumi:"role"`
	SecretAccessKeySecretRef ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrInput `pulumi:"secretAccessKeySecretRef"`
}

func (ChallengeSpecSolverDns01Route53PatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Patch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53PatchArgs) ToChallengeSpecSolverDns01Route53PatchOutput() ChallengeSpecSolverDns01Route53PatchOutput {
	return i.ToChallengeSpecSolverDns01Route53PatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53PatchArgs) ToChallengeSpecSolverDns01Route53PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PatchOutput)
}

func (i ChallengeSpecSolverDns01Route53PatchArgs) ToChallengeSpecSolverDns01Route53PatchPtrOutput() ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53PatchArgs) ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PatchOutput).ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53PatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53PatchArgs, ChallengeSpecSolverDns01Route53PatchPtr and ChallengeSpecSolverDns01Route53PatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53PatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53PatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53PatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53PatchPtrOutput() ChallengeSpecSolverDns01Route53PatchPtrOutput
	ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53PatchPtrOutput
}

type challengeSpecSolverDns01Route53PatchPtrType ChallengeSpecSolverDns01Route53PatchArgs

func ChallengeSpecSolverDns01Route53PatchPtr(v *ChallengeSpecSolverDns01Route53PatchArgs) ChallengeSpecSolverDns01Route53PatchPtrInput {
	return (*challengeSpecSolverDns01Route53PatchPtrType)(v)
}

func (*challengeSpecSolverDns01Route53PatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Patch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53PatchPtrType) ToChallengeSpecSolverDns01Route53PatchPtrOutput() ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53PatchPtrType) ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PatchPtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53PatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53PatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) ToChallengeSpecSolverDns01Route53PatchOutput() ChallengeSpecSolverDns01Route53PatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) ToChallengeSpecSolverDns01Route53PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) ToChallengeSpecSolverDns01Route53PatchPtrOutput() ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53Patch {
		return &v
	}).(ChallengeSpecSolverDns01Route53PatchPtrOutput)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PatchOutput) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *string { return v.AccessKeyID }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch {
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) Auth() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53AuthPatch { return v.Auth }).(ChallengeSpecSolverDns01Route53AuthPatchPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53PatchOutput) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *string { return v.HostedZoneID }).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53PatchOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *string { return v.Region }).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53PatchOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *string { return v.Role }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PatchOutput) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch {
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput)
}

type ChallengeSpecSolverDns01Route53PatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53PatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) ToChallengeSpecSolverDns01Route53PatchPtrOutput() ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) ToChallengeSpecSolverDns01Route53PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) Elem() ChallengeSpecSolverDns01Route53PatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) ChallengeSpecSolverDns01Route53Patch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53Patch
		return ret
	}).(ChallengeSpecSolverDns01Route53PatchOutput)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *string {
		if v == nil {
			return nil
		}
		return v.AccessKeyID
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatch {
		if v == nil {
			return nil
		}
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) Auth() ChallengeSpecSolverDns01Route53AuthPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53AuthPatch {
		if v == nil {
			return nil
		}
		return v.Auth
	}).(ChallengeSpecSolverDns01Route53AuthPatchPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneID
	}).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *string {
		if v == nil {
			return nil
		}
		return v.Region
	}).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01Route53PatchPtrOutput) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Patch) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch {
		if v == nil {
			return nil
		}
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput` via:
//
//	ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput).ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs, ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
}

type challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs

func ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef
		return ret
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchInput` via:
//
//	ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs{...}
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput)
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput).ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs, ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtr and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput
}

type challengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrType ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs

func ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtr(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrInput {
	return (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrType)(v)
}

func (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch {
		return &v
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput) Elem() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch
		return ret
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01Webhook struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config map[string]interface{} `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName *string `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName *string `pulumi:"solverName"`
}

// ChallengeSpecSolverDns01WebhookInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs and ChallengeSpecSolverDns01WebhookOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookInput` via:
//
//	ChallengeSpecSolverDns01WebhookArgs{...}
type ChallengeSpecSolverDns01WebhookInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput
	ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookOutput
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookArgs struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config pulumi.MapInput `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName pulumi.StringPtrInput `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName pulumi.StringPtrInput `pulumi:"solverName"`
}

func (ChallengeSpecSolverDns01WebhookArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return i.ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput)
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput).ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01WebhookPtrInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs, ChallengeSpecSolverDns01WebhookPtr and ChallengeSpecSolverDns01WebhookPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookPtrInput` via:
//
//	        ChallengeSpecSolverDns01WebhookArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01WebhookPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput
	ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookPtrOutput
}

type challengeSpecSolverDns01WebhookPtrType ChallengeSpecSolverDns01WebhookArgs

func ChallengeSpecSolverDns01WebhookPtr(v *ChallengeSpecSolverDns01WebhookArgs) ChallengeSpecSolverDns01WebhookPtrInput {
	return (*challengeSpecSolverDns01WebhookPtrType)(v)
}

func (*challengeSpecSolverDns01WebhookPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Webhook) *ChallengeSpecSolverDns01Webhook {
		return &v
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) *string { return v.GroupName }).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) *string { return v.SolverName }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01WebhookPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) Elem() ChallengeSpecSolverDns01WebhookOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) ChallengeSpecSolverDns01Webhook {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Webhook
		return ret
	}).(ChallengeSpecSolverDns01WebhookOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return v.GroupName
	}).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return v.SolverName
	}).(pulumi.StringPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookPatch struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config map[string]interface{} `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName *string `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName *string `pulumi:"solverName"`
}

// ChallengeSpecSolverDns01WebhookPatchInput is an input type that accepts ChallengeSpecSolverDns01WebhookPatchArgs and ChallengeSpecSolverDns01WebhookPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookPatchInput` via:
//
//	ChallengeSpecSolverDns01WebhookPatchArgs{...}
type ChallengeSpecSolverDns01WebhookPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookPatchOutput() ChallengeSpecSolverDns01WebhookPatchOutput
	ToChallengeSpecSolverDns01WebhookPatchOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookPatchOutput
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookPatchArgs struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config pulumi.MapInput `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName pulumi.StringPtrInput `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName pulumi.StringPtrInput `pulumi:"solverName"`
}

func (ChallengeSpecSolverDns01WebhookPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01WebhookPatchArgs) ToChallengeSpecSolverDns01WebhookPatchOutput() ChallengeSpecSolverDns01WebhookPatchOutput {
	return i.ToChallengeSpecSolverDns01WebhookPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookPatchArgs) ToChallengeSpecSolverDns01WebhookPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPatchOutput)
}

func (i ChallengeSpecSolverDns01WebhookPatchArgs) ToChallengeSpecSolverDns01WebhookPatchPtrOutput() ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookPatchArgs) ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPatchOutput).ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01WebhookPatchPtrInput is an input type that accepts ChallengeSpecSolverDns01WebhookPatchArgs, ChallengeSpecSolverDns01WebhookPatchPtr and ChallengeSpecSolverDns01WebhookPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookPatchPtrInput` via:
//
//	        ChallengeSpecSolverDns01WebhookPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01WebhookPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookPatchPtrOutput() ChallengeSpecSolverDns01WebhookPatchPtrOutput
	ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookPatchPtrOutput
}

type challengeSpecSolverDns01WebhookPatchPtrType ChallengeSpecSolverDns01WebhookPatchArgs

func ChallengeSpecSolverDns01WebhookPatchPtr(v *ChallengeSpecSolverDns01WebhookPatchArgs) ChallengeSpecSolverDns01WebhookPatchPtrInput {
	return (*challengeSpecSolverDns01WebhookPatchPtrType)(v)
}

func (*challengeSpecSolverDns01WebhookPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01WebhookPatch)(nil)).Elem()
}

func (i *challengeSpecSolverDns01WebhookPatchPtrType) ToChallengeSpecSolverDns01WebhookPatchPtrOutput() ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01WebhookPatchPtrType) ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPatchPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookPatchOutput) ToChallengeSpecSolverDns01WebhookPatchOutput() ChallengeSpecSolverDns01WebhookPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPatchOutput) ToChallengeSpecSolverDns01WebhookPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPatchOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPatchOutput) ToChallengeSpecSolverDns01WebhookPatchPtrOutput() ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return o.ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01WebhookPatchOutput) ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01WebhookPatch) *ChallengeSpecSolverDns01WebhookPatch {
		return &v
	}).(ChallengeSpecSolverDns01WebhookPatchPtrOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookPatchOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01WebhookPatch) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookPatchOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01WebhookPatch) *string { return v.GroupName }).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookPatchOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01WebhookPatch) *string { return v.SolverName }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01WebhookPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01WebhookPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookPatchPtrOutput) ToChallengeSpecSolverDns01WebhookPatchPtrOutput() ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPatchPtrOutput) ToChallengeSpecSolverDns01WebhookPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPatchPtrOutput) Elem() ChallengeSpecSolverDns01WebhookPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01WebhookPatch) ChallengeSpecSolverDns01WebhookPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01WebhookPatch
		return ret
	}).(ChallengeSpecSolverDns01WebhookPatchOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookPatchPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01WebhookPatch) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookPatchPtrOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01WebhookPatch) *string {
		if v == nil {
			return nil
		}
		return v.GroupName
	}).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookPatchPtrOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01WebhookPatch) *string {
		if v == nil {
			return nil
		}
		return v.SolverName
	}).(pulumi.StringPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01 struct {
	GatewayHTTPRoute *ChallengeSpecSolverHttp01GatewayHTTPRoute `pulumi:"gatewayHTTPRoute"`
	Ingress          *ChallengeSpecSolverHttp01Ingress          `pulumi:"ingress"`
}

// ChallengeSpecSolverHttp01Input is an input type that accepts ChallengeSpecSolverHttp01Args and ChallengeSpecSolverHttp01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01Input` via:
//
//	ChallengeSpecSolverHttp01Args{...}
type ChallengeSpecSolverHttp01Input interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output
	ToChallengeSpecSolverHttp01OutputWithContext(context.Context) ChallengeSpecSolverHttp01Output
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Args struct {
	GatewayHTTPRoute ChallengeSpecSolverHttp01GatewayHTTPRoutePtrInput `pulumi:"gatewayHTTPRoute"`
	Ingress          ChallengeSpecSolverHttp01IngressPtrInput          `pulumi:"ingress"`
}

func (ChallengeSpecSolverHttp01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return i.ToChallengeSpecSolverHttp01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output)
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output).ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01PtrInput is an input type that accepts ChallengeSpecSolverHttp01Args, ChallengeSpecSolverHttp01Ptr and ChallengeSpecSolverHttp01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01PtrInput` via:
//
//	        ChallengeSpecSolverHttp01Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput
	ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01PtrOutput
}

type challengeSpecSolverHttp01PtrType ChallengeSpecSolverHttp01Args

func ChallengeSpecSolverHttp01Ptr(v *ChallengeSpecSolverHttp01Args) ChallengeSpecSolverHttp01PtrInput {
	return (*challengeSpecSolverHttp01PtrType)(v)
}

func (*challengeSpecSolverHttp01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01 {
		return &v
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

func (o ChallengeSpecSolverHttp01Output) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01GatewayHTTPRoute {
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput)
}

func (o ChallengeSpecSolverHttp01Output) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress { return v.Ingress }).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

type ChallengeSpecSolverHttp01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) Elem() ChallengeSpecSolverHttp01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) ChallengeSpecSolverHttp01 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01
		return ret
	}).(ChallengeSpecSolverHttp01Output)
}

func (o ChallengeSpecSolverHttp01PtrOutput) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01GatewayHTTPRoute {
		if v == nil {
			return nil
		}
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput)
}

func (o ChallengeSpecSolverHttp01PtrOutput) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress {
		if v == nil {
			return nil
		}
		return v.Ingress
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHTTPRoute struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels map[string]string `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs `pulumi:"parentRefs"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01GatewayHTTPRouteInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRouteArgs and ChallengeSpecSolverHttp01GatewayHTTPRouteOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRouteInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHTTPRouteArgs{...}
type ChallengeSpecSolverHttp01GatewayHTTPRouteInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRouteOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRouteOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteOutput
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHTTPRouteArgs struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayInput `pulumi:"parentRefs"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01GatewayHTTPRouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoute)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteArgs) ToChallengeSpecSolverHttp01GatewayHTTPRouteOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRouteOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteArgs) ToChallengeSpecSolverHttp01GatewayHTTPRouteOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRouteOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteArgs) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteArgs) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRouteOutput).ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHTTPRoutePtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRouteArgs, ChallengeSpecSolverHttp01GatewayHTTPRoutePtr and ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRoutePtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHTTPRouteArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHTTPRoutePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput
}

type challengeSpecSolverHttp01GatewayHTTPRoutePtrType ChallengeSpecSolverHttp01GatewayHTTPRouteArgs

func ChallengeSpecSolverHttp01GatewayHTTPRoutePtr(v *ChallengeSpecSolverHttp01GatewayHTTPRouteArgs) ChallengeSpecSolverHttp01GatewayHTTPRoutePtrInput {
	return (*challengeSpecSolverHttp01GatewayHTTPRoutePtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHTTPRoutePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHTTPRoute)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHTTPRoutePtrType) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHTTPRoutePtrType) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHTTPRouteOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoute)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHTTPRoute) *ChallengeSpecSolverHttp01GatewayHTTPRoute {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRoute) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRoute) []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs {
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRoute) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHTTPRoute)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHTTPRouteOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoute) ChallengeSpecSolverHttp01GatewayHTTPRoute {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHTTPRoute
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoute) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoute) []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoute) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs and ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs{...}
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput)
}

// ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray and ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray{ ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsInput

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// <gateway:experimental:description>
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
// </gateway:experimental:description>
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// <gateway:experimental:description>
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
// </gateway:experimental:description>
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefs)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs and ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs{...}
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput)
}

// ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray and ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray{ ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs{...} }
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchInput

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// <gateway:experimental:description>
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
// </gateway:experimental:description>
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// <gateway:experimental:description>
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
// </gateway:experimental:description>
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput) ToChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHTTPRoutePatch struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels map[string]string `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch `pulumi:"parentRefs"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01GatewayHTTPRoutePatchInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs and ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRoutePatchInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs{...}
type ChallengeSpecSolverHttp01GatewayHTTPRoutePatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoutePatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput).ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs, ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtr and ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput
	ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput
}

type challengeSpecSolverHttp01GatewayHTTPRoutePatchPtrType ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs

func ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtr(v *ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrInput {
	return (*challengeSpecSolverHttp01GatewayHTTPRoutePatchPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHTTPRoutePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHTTPRoutePatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHTTPRoutePatchPtrType) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHTTPRoutePatchPtrType) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoutePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch {
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHTTPRoutePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) ToChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) ChallengeSpecSolverHttp01GatewayHTTPRoutePatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHTTPRoutePatch
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) []ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01Ingress struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class *string `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName *string                                          `pulumi:"ingressClassName"`
	IngressTemplate  *ChallengeSpecSolverHttp01IngressIngressTemplate `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name        *string                                      `pulumi:"name"`
	PodTemplate *ChallengeSpecSolverHttp01IngressPodTemplate `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01IngressInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs and ChallengeSpecSolverHttp01IngressOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressInput` via:
//
//	ChallengeSpecSolverHttp01IngressArgs{...}
type ChallengeSpecSolverHttp01IngressInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput
	ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressOutput
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressArgs struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class pulumi.StringPtrInput `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName pulumi.StringPtrInput                                   `pulumi:"ingressClassName"`
	IngressTemplate  ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name        pulumi.StringPtrInput                               `pulumi:"name"`
	PodTemplate ChallengeSpecSolverHttp01IngressPodTemplatePtrInput `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01IngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return i.ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput)
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput).ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs, ChallengeSpecSolverHttp01IngressPtr and ChallengeSpecSolverHttp01IngressPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput
	ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPtrOutput
}

type challengeSpecSolverHttp01IngressPtrType ChallengeSpecSolverHttp01IngressArgs

func ChallengeSpecSolverHttp01IngressPtr(v *ChallengeSpecSolverHttp01IngressArgs) ChallengeSpecSolverHttp01IngressPtrInput {
	return (*challengeSpecSolverHttp01IngressPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01Ingress {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Class }).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.IngressClassName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) Elem() ChallengeSpecSolverHttp01IngressOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) ChallengeSpecSolverHttp01Ingress {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01Ingress
		return ret
	}).(ChallengeSpecSolverHttp01IngressOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Class
	}).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.IngressClassName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v == nil {
			return nil
		}
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplate struct {
	Metadata *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata `pulumi:"metadata"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs and ChallengeSpecSolverHttp01IngressIngressTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplateArgs struct {
	Metadata ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput `pulumi:"metadata"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput).ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs, ChallengeSpecSolverHttp01IngressIngressTemplatePtr and ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplatePtrType ChallengeSpecSolverHttp01IngressIngressTemplateArgs

func ChallengeSpecSolverHttp01IngressIngressTemplatePtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplate
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadata struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput).ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs, ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtr and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrType ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs

func ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch) map[string]string {
		return v.Labels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplatePatch struct {
	Metadata *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch `pulumi:"metadata"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplatePatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs and ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplatePatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplatePatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs struct {
	Metadata ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrInput `pulumi:"metadata"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput).ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs, ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtr and ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplatePatchPtrType ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs

func ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtr(v *ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs) ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplatePatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplatePatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePatchPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePatchPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplatePatch) *ChallengeSpecSolverHttp01IngressIngressTemplatePatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplatePatch) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplatePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplatePatch) ChallengeSpecSolverHttp01IngressIngressTemplatePatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplatePatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput)
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplatePatch) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressPatch struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class *string `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName *string                                               `pulumi:"ingressClassName"`
	IngressTemplate  *ChallengeSpecSolverHttp01IngressIngressTemplatePatch `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name        *string                                           `pulumi:"name"`
	PodTemplate *ChallengeSpecSolverHttp01IngressPodTemplatePatch `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01IngressPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPatchArgs and ChallengeSpecSolverHttp01IngressPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPatchOutput() ChallengeSpecSolverHttp01IngressPatchOutput
	ToChallengeSpecSolverHttp01IngressPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPatchOutput
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressPatchArgs struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class pulumi.StringPtrInput `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName pulumi.StringPtrInput                                        `pulumi:"ingressClassName"`
	IngressTemplate  ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrInput `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name        pulumi.StringPtrInput                                    `pulumi:"name"`
	PodTemplate ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrInput `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01IngressPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPatchArgs) ToChallengeSpecSolverHttp01IngressPatchOutput() ChallengeSpecSolverHttp01IngressPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPatchArgs) ToChallengeSpecSolverHttp01IngressPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPatchArgs) ToChallengeSpecSolverHttp01IngressPatchPtrOutput() ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPatchArgs) ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPatchOutput).ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPatchArgs, ChallengeSpecSolverHttp01IngressPatchPtr and ChallengeSpecSolverHttp01IngressPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPatchPtrOutput() ChallengeSpecSolverHttp01IngressPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPatchPtrType ChallengeSpecSolverHttp01IngressPatchArgs

func ChallengeSpecSolverHttp01IngressPatchPtr(v *ChallengeSpecSolverHttp01IngressPatchArgs) ChallengeSpecSolverHttp01IngressPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPatchPtrType) ToChallengeSpecSolverHttp01IngressPatchPtrOutput() ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPatchPtrType) ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPatchPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPatchOutput) ToChallengeSpecSolverHttp01IngressPatchOutput() ChallengeSpecSolverHttp01IngressPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPatchOutput) ToChallengeSpecSolverHttp01IngressPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPatchOutput) ToChallengeSpecSolverHttp01IngressPatchPtrOutput() ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPatchOutput) ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPatch) *ChallengeSpecSolverHttp01IngressPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPatchPtrOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPatchOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPatch) *string { return v.Class }).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressPatchOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPatch) *string { return v.IngressClassName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPatchOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPatch) *ChallengeSpecSolverHttp01IngressIngressTemplatePatch {
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPatchOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPatch) *ChallengeSpecSolverHttp01IngressPodTemplatePatch {
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressPatchOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPatch) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPatchPtrOutput() ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) ChallengeSpecSolverHttp01IngressPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPatchOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) *string {
		if v == nil {
			return nil
		}
		return v.Class
	}).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) *string {
		if v == nil {
			return nil
		}
		return v.IngressClassName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) *ChallengeSpecSolverHttp01IngressIngressTemplatePatch {
		if v == nil {
			return nil
		}
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) *ChallengeSpecSolverHttp01IngressPodTemplatePatch {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressPatchPtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplate struct {
	Metadata *ChallengeSpecSolverHttp01IngressPodTemplateMetadata `pulumi:"metadata"`
	Spec     *ChallengeSpecSolverHttp01IngressPodTemplateSpec     `pulumi:"spec"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs and ChallengeSpecSolverHttp01IngressPodTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplateArgs struct {
	Metadata ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput `pulumi:"metadata"`
	Spec     ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput     `pulumi:"spec"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput).ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs, ChallengeSpecSolverHttp01IngressPodTemplatePtr and ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplatePtrType ChallengeSpecSolverHttp01IngressPodTemplateArgs

func ChallengeSpecSolverHttp01IngressPodTemplatePtr(v *ChallengeSpecSolverHttp01IngressPodTemplateArgs) ChallengeSpecSolverHttp01IngressPodTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) ChallengeSpecSolverHttp01IngressPodTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplate
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadata struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch) *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplatePatch struct {
	Metadata *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch `pulumi:"metadata"`
	Spec     *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch     `pulumi:"spec"`
}

// ChallengeSpecSolverHttp01IngressPodTemplatePatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs and ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplatePatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplatePatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs struct {
	Metadata ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrInput `pulumi:"metadata"`
	Spec     ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrInput     `pulumi:"spec"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs, ChallengeSpecSolverHttp01IngressPodTemplatePatchPtr and ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplatePatchPtrType ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplatePatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs) ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplatePatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplatePatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplatePatch) *ChallengeSpecSolverHttp01IngressPodTemplatePatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplatePatch) *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplatePatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch {
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplatePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplatePatch) ChallengeSpecSolverHttp01IngressPodTemplatePatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplatePatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplatePatch) *ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplatePatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpec struct {
	Affinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName *string `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations `pulumi:"tolerations"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs struct {
	Affinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector pulumi.StringMapInput `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName pulumi.StringPtrInput `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput `pulumi:"tolerations"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string { return v.NodeSelector }).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.PriorityClassName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpec
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		if v == nil {
			return nil
		}
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.PriorityClassName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		if v == nil {
			return nil
		}
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity struct {
	NodeAffinity    *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity    `pulumi:"nodeAffinity"`
	PodAffinity     *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity     `pulumi:"podAffinity"`
	PodAntiAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity `pulumi:"podAntiAffinity"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs struct {
	NodeAffinity    ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput    `pulumi:"nodeAffinity"`
	PodAffinity     ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput     `pulumi:"podAffinity"`
	PodAntiAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput `pulumi:"podAntiAffinity"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	RequiredDuringSchedulingIgnoredDuringExecution  *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution   `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	RequiredDuringSchedulingIgnoredDuringExecution  ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput    `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	RequiredDuringSchedulingIgnoredDuringExecution  *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch   `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	RequiredDuringSchedulingIgnoredDuringExecution  ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrInput    `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	Preference *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight *int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Preference() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return v.Preference
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) *int {
		return v.Weight
	}).(pulumi.IntPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch struct {
	Preference *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight *int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs struct {
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) Preference() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch {
		return v.Preference
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch) *int {
		return v.Weight
	}).(pulumi.IntPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput)
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		if v == nil {
			return nil
		}
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput)
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput)
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatch {
		if v == nil {
			return nil
		}
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms `pulumi:"nodeSelectorTerms"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput `pulumi:"nodeSelectorTerms"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch struct {
	// The label key that the selector applies to.
	Key *string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator *string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatch {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch `pulumi:"nodeSelectorTerms"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayInput `pulumi:"nodeSelectorTerms"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch {
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatch {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch struct {
	NodeAffinity    *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch    `pulumi:"nodeAffinity"`
	PodAffinity     *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch     `pulumi:"podAffinity"`
	PodAntiAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch `pulumi:"podAntiAffinity"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs struct {
	NodeAffinity    ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrInput    `pulumi:"nodeAffinity"`
	PodAffinity     ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrInput     `pulumi:"podAffinity"`
	PodAntiAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrInput `pulumi:"podAntiAffinity"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch {
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch {
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch {
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatch {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	PodAffinityTerm *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight *int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) *int {
		return v.Weight
	}).(pulumi.IntPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch struct {
	PodAffinityTerm *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight *int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs struct {
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch) *int {
		return v.Weight
	}).(pulumi.IntPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                                           `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                                   `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		if v == nil {
			return nil
		}
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		if v == nil {
			return nil
		}
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v == nil {
			return nil
		}
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *string {
		if v == nil {
			return nil
		}
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                                                `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                                        `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		if v == nil {
			return nil
		}
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		if v == nil {
			return nil
		}
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *string {
		if v == nil {
			return nil
		}
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                           `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                   `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                                `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                        `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	PodAffinityTerm *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight *int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) *int {
		return v.Weight
	}).(pulumi.IntPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch struct {
	PodAffinityTerm *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight *int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs struct {
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch) *int {
		return v.Weight
	}).(pulumi.IntPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                                               `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                                       `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		if v == nil {
			return nil
		}
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		if v == nil {
			return nil
		}
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v == nil {
			return nil
		}
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *string {
		if v == nil {
			return nil
		}
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                                                    `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                                            `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatch {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		if v == nil {
			return nil
		}
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		if v == nil {
			return nil
		}
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) []string {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatch) *string {
		if v == nil {
			return nil
		}
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                               `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                       `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch struct {
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string                                                                                                                                    `pulumi:"mismatchLabelKeys"`
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey *string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs struct {
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput                                                                                                                            `pulumi:"mismatchLabelKeys"`
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringPtrInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatch {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatch {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput) TopologyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch) *string {
		return v.TopologyKey
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return o
}

// Name of the referent.
// This field is effectively required, but due to backwards compatibility is
// allowed to be empty. Instances of this type with an empty value here are
// almost certainly wrong.
// TODO: Add other useful fields. apiVersion, kind, uid?
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
	Name *string `pulumi:"name"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput {
	return o
}

// Name of the referent.
// This field is effectively required, but due to backwards compatibility is
// allowed to be empty. Instances of this type with an empty value here are
// almost certainly wrong.
// TODO: Add other useful fields. apiVersion, kind, uid?
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch struct {
	Affinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName *string `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch `pulumi:"tolerations"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs struct {
	Affinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrInput `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayInput `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector pulumi.StringMapInput `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName pulumi.StringPtrInput `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayInput `pulumi:"tolerations"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch {
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch {
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) map[string]string { return v.NodeSelector }).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *string { return v.PriorityClassName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch {
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput)
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatch {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatch {
		if v == nil {
			return nil
		}
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.PriorityClassName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecPatch) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch {
		if v == nil {
			return nil
		}
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects.
// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys.
// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value.
// Valid operators are Exists and Equal. Defaults to Equal.
// Exists is equivalent to wildcard for value, so that a pod can
// tolerate all taints of a particular category.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be
// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
// it is not set, which means tolerate the taint forever (do not evict). Zero and
// negative values will be treated as 0 (evict immediately) by the system.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *int { return v.TolerationSeconds }).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to.
// If the operator is Exists, the value should be empty, otherwise just a regular string.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects.
// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys.
// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value.
// Valid operators are Exists and Equal. Defaults to Equal.
// Exists is equivalent to wildcard for value, so that a pod can
// tolerate all taints of a particular category.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be
// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
// it is not set, which means tolerate the taint forever (do not evict). Zero and
// negative values will be treated as 0 (evict immediately) by the system.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch) *int {
		return v.TolerationSeconds
	}).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to.
// If the operator is Exists, the value should be empty, otherwise just a regular string.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatch)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Patch struct {
	GatewayHTTPRoute *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch `pulumi:"gatewayHTTPRoute"`
	Ingress          *ChallengeSpecSolverHttp01IngressPatch          `pulumi:"ingress"`
}

// ChallengeSpecSolverHttp01PatchInput is an input type that accepts ChallengeSpecSolverHttp01PatchArgs and ChallengeSpecSolverHttp01PatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01PatchInput` via:
//
//	ChallengeSpecSolverHttp01PatchArgs{...}
type ChallengeSpecSolverHttp01PatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01PatchOutput() ChallengeSpecSolverHttp01PatchOutput
	ToChallengeSpecSolverHttp01PatchOutputWithContext(context.Context) ChallengeSpecSolverHttp01PatchOutput
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01PatchArgs struct {
	GatewayHTTPRoute ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrInput `pulumi:"gatewayHTTPRoute"`
	Ingress          ChallengeSpecSolverHttp01IngressPatchPtrInput          `pulumi:"ingress"`
}

func (ChallengeSpecSolverHttp01PatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Patch)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01PatchArgs) ToChallengeSpecSolverHttp01PatchOutput() ChallengeSpecSolverHttp01PatchOutput {
	return i.ToChallengeSpecSolverHttp01PatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01PatchArgs) ToChallengeSpecSolverHttp01PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PatchOutput)
}

func (i ChallengeSpecSolverHttp01PatchArgs) ToChallengeSpecSolverHttp01PatchPtrOutput() ChallengeSpecSolverHttp01PatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01PatchArgs) ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PatchOutput).ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01PatchPtrInput is an input type that accepts ChallengeSpecSolverHttp01PatchArgs, ChallengeSpecSolverHttp01PatchPtr and ChallengeSpecSolverHttp01PatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01PatchPtrInput` via:
//
//	        ChallengeSpecSolverHttp01PatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01PatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01PatchPtrOutput() ChallengeSpecSolverHttp01PatchPtrOutput
	ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01PatchPtrOutput
}

type challengeSpecSolverHttp01PatchPtrType ChallengeSpecSolverHttp01PatchArgs

func ChallengeSpecSolverHttp01PatchPtr(v *ChallengeSpecSolverHttp01PatchArgs) ChallengeSpecSolverHttp01PatchPtrInput {
	return (*challengeSpecSolverHttp01PatchPtrType)(v)
}

func (*challengeSpecSolverHttp01PatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Patch)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01PatchPtrType) ToChallengeSpecSolverHttp01PatchPtrOutput() ChallengeSpecSolverHttp01PatchPtrOutput {
	return i.ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01PatchPtrType) ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PatchPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01PatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01PatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01PatchOutput) ToChallengeSpecSolverHttp01PatchOutput() ChallengeSpecSolverHttp01PatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PatchOutput) ToChallengeSpecSolverHttp01PatchOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PatchOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PatchOutput) ToChallengeSpecSolverHttp01PatchPtrOutput() ChallengeSpecSolverHttp01PatchPtrOutput {
	return o.ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01PatchOutput) ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01Patch) *ChallengeSpecSolverHttp01Patch {
		return &v
	}).(ChallengeSpecSolverHttp01PatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01PatchOutput) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Patch) *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch {
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01PatchOutput) Ingress() ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Patch) *ChallengeSpecSolverHttp01IngressPatch { return v.Ingress }).(ChallengeSpecSolverHttp01IngressPatchPtrOutput)
}

type ChallengeSpecSolverHttp01PatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01PatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Patch)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01PatchPtrOutput) ToChallengeSpecSolverHttp01PatchPtrOutput() ChallengeSpecSolverHttp01PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PatchPtrOutput) ToChallengeSpecSolverHttp01PatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PatchPtrOutput) Elem() ChallengeSpecSolverHttp01PatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Patch) ChallengeSpecSolverHttp01Patch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01Patch
		return ret
	}).(ChallengeSpecSolverHttp01PatchOutput)
}

func (o ChallengeSpecSolverHttp01PatchPtrOutput) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Patch) *ChallengeSpecSolverHttp01GatewayHTTPRoutePatch {
		if v == nil {
			return nil
		}
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput)
}

func (o ChallengeSpecSolverHttp01PatchPtrOutput) Ingress() ChallengeSpecSolverHttp01IngressPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Patch) *ChallengeSpecSolverHttp01IngressPatch {
		if v == nil {
			return nil
		}
		return v.Ingress
	}).(ChallengeSpecSolverHttp01IngressPatchPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverPatch struct {
	Dns01    *ChallengeSpecSolverDns01Patch    `pulumi:"dns01"`
	Http01   *ChallengeSpecSolverHttp01Patch   `pulumi:"http01"`
	Selector *ChallengeSpecSolverSelectorPatch `pulumi:"selector"`
}

// ChallengeSpecSolverPatchInput is an input type that accepts ChallengeSpecSolverPatchArgs and ChallengeSpecSolverPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverPatchInput` via:
//
//	ChallengeSpecSolverPatchArgs{...}
type ChallengeSpecSolverPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverPatchOutput() ChallengeSpecSolverPatchOutput
	ToChallengeSpecSolverPatchOutputWithContext(context.Context) ChallengeSpecSolverPatchOutput
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverPatchArgs struct {
	Dns01    ChallengeSpecSolverDns01PatchPtrInput    `pulumi:"dns01"`
	Http01   ChallengeSpecSolverHttp01PatchPtrInput   `pulumi:"http01"`
	Selector ChallengeSpecSolverSelectorPatchPtrInput `pulumi:"selector"`
}

func (ChallengeSpecSolverPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverPatchArgs) ToChallengeSpecSolverPatchOutput() ChallengeSpecSolverPatchOutput {
	return i.ToChallengeSpecSolverPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverPatchArgs) ToChallengeSpecSolverPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPatchOutput)
}

func (i ChallengeSpecSolverPatchArgs) ToChallengeSpecSolverPatchPtrOutput() ChallengeSpecSolverPatchPtrOutput {
	return i.ToChallengeSpecSolverPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverPatchArgs) ToChallengeSpecSolverPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPatchOutput).ToChallengeSpecSolverPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverPatchPtrInput is an input type that accepts ChallengeSpecSolverPatchArgs, ChallengeSpecSolverPatchPtr and ChallengeSpecSolverPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverPatchPtrInput` via:
//
//	        ChallengeSpecSolverPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverPatchPtrOutput() ChallengeSpecSolverPatchPtrOutput
	ToChallengeSpecSolverPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverPatchPtrOutput
}

type challengeSpecSolverPatchPtrType ChallengeSpecSolverPatchArgs

func ChallengeSpecSolverPatchPtr(v *ChallengeSpecSolverPatchArgs) ChallengeSpecSolverPatchPtrInput {
	return (*challengeSpecSolverPatchPtrType)(v)
}

func (*challengeSpecSolverPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverPatch)(nil)).Elem()
}

func (i *challengeSpecSolverPatchPtrType) ToChallengeSpecSolverPatchPtrOutput() ChallengeSpecSolverPatchPtrOutput {
	return i.ToChallengeSpecSolverPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverPatchPtrType) ToChallengeSpecSolverPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPatchPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverPatchOutput) ToChallengeSpecSolverPatchOutput() ChallengeSpecSolverPatchOutput {
	return o
}

func (o ChallengeSpecSolverPatchOutput) ToChallengeSpecSolverPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverPatchOutput {
	return o
}

func (o ChallengeSpecSolverPatchOutput) ToChallengeSpecSolverPatchPtrOutput() ChallengeSpecSolverPatchPtrOutput {
	return o.ToChallengeSpecSolverPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverPatchOutput) ToChallengeSpecSolverPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverPatch) *ChallengeSpecSolverPatch {
		return &v
	}).(ChallengeSpecSolverPatchPtrOutput)
}

func (o ChallengeSpecSolverPatchOutput) Dns01() ChallengeSpecSolverDns01PatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverPatch) *ChallengeSpecSolverDns01Patch { return v.Dns01 }).(ChallengeSpecSolverDns01PatchPtrOutput)
}

func (o ChallengeSpecSolverPatchOutput) Http01() ChallengeSpecSolverHttp01PatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverPatch) *ChallengeSpecSolverHttp01Patch { return v.Http01 }).(ChallengeSpecSolverHttp01PatchPtrOutput)
}

func (o ChallengeSpecSolverPatchOutput) Selector() ChallengeSpecSolverSelectorPatchPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverPatch) *ChallengeSpecSolverSelectorPatch { return v.Selector }).(ChallengeSpecSolverSelectorPatchPtrOutput)
}

type ChallengeSpecSolverPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverPatchPtrOutput) ToChallengeSpecSolverPatchPtrOutput() ChallengeSpecSolverPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverPatchPtrOutput) ToChallengeSpecSolverPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverPatchPtrOutput) Elem() ChallengeSpecSolverPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverPatch) ChallengeSpecSolverPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverPatch
		return ret
	}).(ChallengeSpecSolverPatchOutput)
}

func (o ChallengeSpecSolverPatchPtrOutput) Dns01() ChallengeSpecSolverDns01PatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverPatch) *ChallengeSpecSolverDns01Patch {
		if v == nil {
			return nil
		}
		return v.Dns01
	}).(ChallengeSpecSolverDns01PatchPtrOutput)
}

func (o ChallengeSpecSolverPatchPtrOutput) Http01() ChallengeSpecSolverHttp01PatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverPatch) *ChallengeSpecSolverHttp01Patch {
		if v == nil {
			return nil
		}
		return v.Http01
	}).(ChallengeSpecSolverHttp01PatchPtrOutput)
}

func (o ChallengeSpecSolverPatchPtrOutput) Selector() ChallengeSpecSolverSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverPatch) *ChallengeSpecSolverSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ChallengeSpecSolverSelectorPatchPtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelector struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames []string `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones []string `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverSelectorInput is an input type that accepts ChallengeSpecSolverSelectorArgs and ChallengeSpecSolverSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorInput` via:
//
//	ChallengeSpecSolverSelectorArgs{...}
type ChallengeSpecSolverSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput
	ToChallengeSpecSolverSelectorOutputWithContext(context.Context) ChallengeSpecSolverSelectorOutput
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorArgs struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones pulumi.StringArrayInput `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return i.ToChallengeSpecSolverSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput)
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput).ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverSelectorPtrInput is an input type that accepts ChallengeSpecSolverSelectorArgs, ChallengeSpecSolverSelectorPtr and ChallengeSpecSolverSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorPtrInput` via:
//
//	        ChallengeSpecSolverSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput
	ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverSelectorPtrOutput
}

type challengeSpecSolverSelectorPtrType ChallengeSpecSolverSelectorArgs

func ChallengeSpecSolverSelectorPtr(v *ChallengeSpecSolverSelectorArgs) ChallengeSpecSolverSelectorPtrInput {
	return (*challengeSpecSolverSelectorPtrType)(v)
}

func (*challengeSpecSolverSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverSelector) *ChallengeSpecSolverSelector {
		return &v
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsZones }).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) Elem() ChallengeSpecSolverSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) ChallengeSpecSolverSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverSelector
		return ret
	}).(ChallengeSpecSolverSelectorOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsZones
	}).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorPatch struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames []string `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones []string `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverSelectorPatchInput is an input type that accepts ChallengeSpecSolverSelectorPatchArgs and ChallengeSpecSolverSelectorPatchOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorPatchInput` via:
//
//	ChallengeSpecSolverSelectorPatchArgs{...}
type ChallengeSpecSolverSelectorPatchInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorPatchOutput() ChallengeSpecSolverSelectorPatchOutput
	ToChallengeSpecSolverSelectorPatchOutputWithContext(context.Context) ChallengeSpecSolverSelectorPatchOutput
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorPatchArgs struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones pulumi.StringArrayInput `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelectorPatch)(nil)).Elem()
}

func (i ChallengeSpecSolverSelectorPatchArgs) ToChallengeSpecSolverSelectorPatchOutput() ChallengeSpecSolverSelectorPatchOutput {
	return i.ToChallengeSpecSolverSelectorPatchOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorPatchArgs) ToChallengeSpecSolverSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPatchOutput)
}

func (i ChallengeSpecSolverSelectorPatchArgs) ToChallengeSpecSolverSelectorPatchPtrOutput() ChallengeSpecSolverSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorPatchArgs) ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPatchOutput).ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverSelectorPatchPtrInput is an input type that accepts ChallengeSpecSolverSelectorPatchArgs, ChallengeSpecSolverSelectorPatchPtr and ChallengeSpecSolverSelectorPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorPatchPtrInput` via:
//
//	        ChallengeSpecSolverSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverSelectorPatchPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorPatchPtrOutput() ChallengeSpecSolverSelectorPatchPtrOutput
	ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(context.Context) ChallengeSpecSolverSelectorPatchPtrOutput
}

type challengeSpecSolverSelectorPatchPtrType ChallengeSpecSolverSelectorPatchArgs

func ChallengeSpecSolverSelectorPatchPtr(v *ChallengeSpecSolverSelectorPatchArgs) ChallengeSpecSolverSelectorPatchPtrInput {
	return (*challengeSpecSolverSelectorPatchPtrType)(v)
}

func (*challengeSpecSolverSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelectorPatch)(nil)).Elem()
}

func (i *challengeSpecSolverSelectorPatchPtrType) ToChallengeSpecSolverSelectorPatchPtrOutput() ChallengeSpecSolverSelectorPatchPtrOutput {
	return i.ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverSelectorPatchPtrType) ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPatchPtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorPatchOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorPatchOutput) ToChallengeSpecSolverSelectorPatchOutput() ChallengeSpecSolverSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPatchOutput) ToChallengeSpecSolverSelectorPatchOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPatchOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPatchOutput) ToChallengeSpecSolverSelectorPatchPtrOutput() ChallengeSpecSolverSelectorPatchPtrOutput {
	return o.ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverSelectorPatchOutput) ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverSelectorPatch) *ChallengeSpecSolverSelectorPatch {
		return &v
	}).(ChallengeSpecSolverSelectorPatchPtrOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPatchOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelectorPatch) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPatchOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelectorPatch) []string { return v.DnsZones }).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelectorPatch) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelectorPatch)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorPatchPtrOutput) ToChallengeSpecSolverSelectorPatchPtrOutput() ChallengeSpecSolverSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPatchPtrOutput) ToChallengeSpecSolverSelectorPatchPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPatchPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPatchPtrOutput) Elem() ChallengeSpecSolverSelectorPatchOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelectorPatch) ChallengeSpecSolverSelectorPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverSelectorPatch
		return ret
	}).(ChallengeSpecSolverSelectorPatchOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPatchPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelectorPatch) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPatchPtrOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelectorPatch) []string {
		if v == nil {
			return nil
		}
		return v.DnsZones
	}).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeStatus struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented *bool `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing *bool `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason *string `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State *string `pulumi:"state"`
}

// ChallengeStatusInput is an input type that accepts ChallengeStatusArgs and ChallengeStatusOutput values.
// You can construct a concrete instance of `ChallengeStatusInput` via:
//
//	ChallengeStatusArgs{...}
type ChallengeStatusInput interface {
	pulumi.Input

	ToChallengeStatusOutput() ChallengeStatusOutput
	ToChallengeStatusOutputWithContext(context.Context) ChallengeStatusOutput
}

type ChallengeStatusArgs struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented pulumi.BoolPtrInput `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing pulumi.BoolPtrInput `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (ChallengeStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (i ChallengeStatusArgs) ToChallengeStatusOutput() ChallengeStatusOutput {
	return i.ToChallengeStatusOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput)
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput).ToChallengeStatusPtrOutputWithContext(ctx)
}

// ChallengeStatusPtrInput is an input type that accepts ChallengeStatusArgs, ChallengeStatusPtr and ChallengeStatusPtrOutput values.
// You can construct a concrete instance of `ChallengeStatusPtrInput` via:
//
//	        ChallengeStatusArgs{...}
//
//	or:
//
//	        nil
type ChallengeStatusPtrInput interface {
	pulumi.Input

	ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput
	ToChallengeStatusPtrOutputWithContext(context.Context) ChallengeStatusPtrOutput
}

type challengeStatusPtrType ChallengeStatusArgs

func ChallengeStatusPtr(v *ChallengeStatusArgs) ChallengeStatusPtrInput {
	return (*challengeStatusPtrType)(v)
}

func (*challengeStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPtrOutput)
}

type ChallengeStatusOutput struct{ *pulumi.OutputState }

func (ChallengeStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusOutput) ToChallengeStatusOutput() ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeStatus) *ChallengeStatus {
		return &v
	}).(ChallengeStatusPtrOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Presented }).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Processing }).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

type ChallengeStatusPtrOutput struct{ *pulumi.OutputState }

func (ChallengeStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) Elem() ChallengeStatusOutput {
	return o.ApplyT(func(v *ChallengeStatus) ChallengeStatus {
		if v != nil {
			return *v
		}
		var ret ChallengeStatus
		return ret
	}).(ChallengeStatusOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusPtrOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Presented
	}).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusPtrOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Processing
	}).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

type ChallengeStatusPatch struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented *bool `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing *bool `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason *string `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State *string `pulumi:"state"`
}

// ChallengeStatusPatchInput is an input type that accepts ChallengeStatusPatchArgs and ChallengeStatusPatchOutput values.
// You can construct a concrete instance of `ChallengeStatusPatchInput` via:
//
//	ChallengeStatusPatchArgs{...}
type ChallengeStatusPatchInput interface {
	pulumi.Input

	ToChallengeStatusPatchOutput() ChallengeStatusPatchOutput
	ToChallengeStatusPatchOutputWithContext(context.Context) ChallengeStatusPatchOutput
}

type ChallengeStatusPatchArgs struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented pulumi.BoolPtrInput `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing pulumi.BoolPtrInput `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (ChallengeStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatusPatch)(nil)).Elem()
}

func (i ChallengeStatusPatchArgs) ToChallengeStatusPatchOutput() ChallengeStatusPatchOutput {
	return i.ToChallengeStatusPatchOutputWithContext(context.Background())
}

func (i ChallengeStatusPatchArgs) ToChallengeStatusPatchOutputWithContext(ctx context.Context) ChallengeStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPatchOutput)
}

func (i ChallengeStatusPatchArgs) ToChallengeStatusPatchPtrOutput() ChallengeStatusPatchPtrOutput {
	return i.ToChallengeStatusPatchPtrOutputWithContext(context.Background())
}

func (i ChallengeStatusPatchArgs) ToChallengeStatusPatchPtrOutputWithContext(ctx context.Context) ChallengeStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPatchOutput).ToChallengeStatusPatchPtrOutputWithContext(ctx)
}

// ChallengeStatusPatchPtrInput is an input type that accepts ChallengeStatusPatchArgs, ChallengeStatusPatchPtr and ChallengeStatusPatchPtrOutput values.
// You can construct a concrete instance of `ChallengeStatusPatchPtrInput` via:
//
//	        ChallengeStatusPatchArgs{...}
//
//	or:
//
//	        nil
type ChallengeStatusPatchPtrInput interface {
	pulumi.Input

	ToChallengeStatusPatchPtrOutput() ChallengeStatusPatchPtrOutput
	ToChallengeStatusPatchPtrOutputWithContext(context.Context) ChallengeStatusPatchPtrOutput
}

type challengeStatusPatchPtrType ChallengeStatusPatchArgs

func ChallengeStatusPatchPtr(v *ChallengeStatusPatchArgs) ChallengeStatusPatchPtrInput {
	return (*challengeStatusPatchPtrType)(v)
}

func (*challengeStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatusPatch)(nil)).Elem()
}

func (i *challengeStatusPatchPtrType) ToChallengeStatusPatchPtrOutput() ChallengeStatusPatchPtrOutput {
	return i.ToChallengeStatusPatchPtrOutputWithContext(context.Background())
}

func (i *challengeStatusPatchPtrType) ToChallengeStatusPatchPtrOutputWithContext(ctx context.Context) ChallengeStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPatchPtrOutput)
}

type ChallengeStatusPatchOutput struct{ *pulumi.OutputState }

func (ChallengeStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatusPatch)(nil)).Elem()
}

func (o ChallengeStatusPatchOutput) ToChallengeStatusPatchOutput() ChallengeStatusPatchOutput {
	return o
}

func (o ChallengeStatusPatchOutput) ToChallengeStatusPatchOutputWithContext(ctx context.Context) ChallengeStatusPatchOutput {
	return o
}

func (o ChallengeStatusPatchOutput) ToChallengeStatusPatchPtrOutput() ChallengeStatusPatchPtrOutput {
	return o.ToChallengeStatusPatchPtrOutputWithContext(context.Background())
}

func (o ChallengeStatusPatchOutput) ToChallengeStatusPatchPtrOutputWithContext(ctx context.Context) ChallengeStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeStatusPatch) *ChallengeStatusPatch {
		return &v
	}).(ChallengeStatusPatchPtrOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusPatchOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatusPatch) *bool { return v.Presented }).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusPatchOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatusPatch) *bool { return v.Processing }).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatusPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusPatchOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatusPatch) *string { return v.State }).(pulumi.StringPtrOutput)
}

type ChallengeStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (ChallengeStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatusPatch)(nil)).Elem()
}

func (o ChallengeStatusPatchPtrOutput) ToChallengeStatusPatchPtrOutput() ChallengeStatusPatchPtrOutput {
	return o
}

func (o ChallengeStatusPatchPtrOutput) ToChallengeStatusPatchPtrOutputWithContext(ctx context.Context) ChallengeStatusPatchPtrOutput {
	return o
}

func (o ChallengeStatusPatchPtrOutput) Elem() ChallengeStatusPatchOutput {
	return o.ApplyT(func(v *ChallengeStatusPatch) ChallengeStatusPatch {
		if v != nil {
			return *v
		}
		var ret ChallengeStatusPatch
		return ret
	}).(ChallengeStatusPatchOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusPatchPtrOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatusPatch) *bool {
		if v == nil {
			return nil
		}
		return v.Presented
	}).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusPatchPtrOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatusPatch) *bool {
		if v == nil {
			return nil
		}
		return v.Processing
	}).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusPatchPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusPatchPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *OrderSpec         `pulumi:"spec"`
	Status   *OrderStatus       `pulumi:"status"`
}

// OrderTypeInput is an input type that accepts OrderTypeArgs and OrderTypeOutput values.
// You can construct a concrete instance of `OrderTypeInput` via:
//
//	OrderTypeArgs{...}
type OrderTypeInput interface {
	pulumi.Input

	ToOrderTypeOutput() OrderTypeOutput
	ToOrderTypeOutputWithContext(context.Context) OrderTypeOutput
}

// Order is a type to represent an Order with an ACME server
type OrderTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     OrderSpecPtrInput         `pulumi:"spec"`
	Status   OrderStatusPtrInput       `pulumi:"status"`
}

func (OrderTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderType)(nil)).Elem()
}

func (i OrderTypeArgs) ToOrderTypeOutput() OrderTypeOutput {
	return i.ToOrderTypeOutputWithContext(context.Background())
}

func (i OrderTypeArgs) ToOrderTypeOutputWithContext(ctx context.Context) OrderTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderTypeOutput)
}

// OrderTypeArrayInput is an input type that accepts OrderTypeArray and OrderTypeArrayOutput values.
// You can construct a concrete instance of `OrderTypeArrayInput` via:
//
//	OrderTypeArray{ OrderTypeArgs{...} }
type OrderTypeArrayInput interface {
	pulumi.Input

	ToOrderTypeArrayOutput() OrderTypeArrayOutput
	ToOrderTypeArrayOutputWithContext(context.Context) OrderTypeArrayOutput
}

type OrderTypeArray []OrderTypeInput

func (OrderTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderType)(nil)).Elem()
}

func (i OrderTypeArray) ToOrderTypeArrayOutput() OrderTypeArrayOutput {
	return i.ToOrderTypeArrayOutputWithContext(context.Background())
}

func (i OrderTypeArray) ToOrderTypeArrayOutputWithContext(ctx context.Context) OrderTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderTypeArrayOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderTypeOutput struct{ *pulumi.OutputState }

func (OrderTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderType)(nil)).Elem()
}

func (o OrderTypeOutput) ToOrderTypeOutput() OrderTypeOutput {
	return o
}

func (o OrderTypeOutput) ToOrderTypeOutputWithContext(ctx context.Context) OrderTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o OrderTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o OrderTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o OrderTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v OrderType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o OrderTypeOutput) Spec() OrderSpecPtrOutput {
	return o.ApplyT(func(v OrderType) *OrderSpec { return v.Spec }).(OrderSpecPtrOutput)
}

func (o OrderTypeOutput) Status() OrderStatusPtrOutput {
	return o.ApplyT(func(v OrderType) *OrderStatus { return v.Status }).(OrderStatusPtrOutput)
}

type OrderTypeArrayOutput struct{ *pulumi.OutputState }

func (OrderTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderType)(nil)).Elem()
}

func (o OrderTypeArrayOutput) ToOrderTypeArrayOutput() OrderTypeArrayOutput {
	return o
}

func (o OrderTypeArrayOutput) ToOrderTypeArrayOutputWithContext(ctx context.Context) OrderTypeArrayOutput {
	return o
}

func (o OrderTypeArrayOutput) Index(i pulumi.IntInput) OrderTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderType {
		return vs[0].([]OrderType)[vs[1].(int)]
	}).(OrderTypeOutput)
}

// OrderList is a list of Order
type OrderListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of orders. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []OrderType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// OrderListTypeInput is an input type that accepts OrderListTypeArgs and OrderListTypeOutput values.
// You can construct a concrete instance of `OrderListTypeInput` via:
//
//	OrderListTypeArgs{...}
type OrderListTypeInput interface {
	pulumi.Input

	ToOrderListTypeOutput() OrderListTypeOutput
	ToOrderListTypeOutputWithContext(context.Context) OrderListTypeOutput
}

// OrderList is a list of Order
type OrderListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of orders. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items OrderTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (OrderListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderListType)(nil)).Elem()
}

func (i OrderListTypeArgs) ToOrderListTypeOutput() OrderListTypeOutput {
	return i.ToOrderListTypeOutputWithContext(context.Background())
}

func (i OrderListTypeArgs) ToOrderListTypeOutputWithContext(ctx context.Context) OrderListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderListTypeOutput)
}

// OrderList is a list of Order
type OrderListTypeOutput struct{ *pulumi.OutputState }

func (OrderListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderListType)(nil)).Elem()
}

func (o OrderListTypeOutput) ToOrderListTypeOutput() OrderListTypeOutput {
	return o
}

func (o OrderListTypeOutput) ToOrderListTypeOutputWithContext(ctx context.Context) OrderListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o OrderListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of orders. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o OrderListTypeOutput) Items() OrderTypeArrayOutput {
	return o.ApplyT(func(v OrderListType) []OrderType { return v.Items }).(OrderTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o OrderListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o OrderListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v OrderListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *OrderSpecPatch         `pulumi:"spec"`
	Status   *OrderStatusPatch       `pulumi:"status"`
}

// OrderPatchTypeInput is an input type that accepts OrderPatchTypeArgs and OrderPatchTypeOutput values.
// You can construct a concrete instance of `OrderPatchTypeInput` via:
//
//	OrderPatchTypeArgs{...}
type OrderPatchTypeInput interface {
	pulumi.Input

	ToOrderPatchTypeOutput() OrderPatchTypeOutput
	ToOrderPatchTypeOutputWithContext(context.Context) OrderPatchTypeOutput
}

// Order is a type to represent an Order with an ACME server
type OrderPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     OrderSpecPatchPtrInput         `pulumi:"spec"`
	Status   OrderStatusPatchPtrInput       `pulumi:"status"`
}

func (OrderPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderPatchType)(nil)).Elem()
}

func (i OrderPatchTypeArgs) ToOrderPatchTypeOutput() OrderPatchTypeOutput {
	return i.ToOrderPatchTypeOutputWithContext(context.Background())
}

func (i OrderPatchTypeArgs) ToOrderPatchTypeOutputWithContext(ctx context.Context) OrderPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderPatchTypeOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderPatchTypeOutput struct{ *pulumi.OutputState }

func (OrderPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderPatchType)(nil)).Elem()
}

func (o OrderPatchTypeOutput) ToOrderPatchTypeOutput() OrderPatchTypeOutput {
	return o
}

func (o OrderPatchTypeOutput) ToOrderPatchTypeOutputWithContext(ctx context.Context) OrderPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o OrderPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o OrderPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o OrderPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v OrderPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o OrderPatchTypeOutput) Spec() OrderSpecPatchPtrOutput {
	return o.ApplyT(func(v OrderPatchType) *OrderSpecPatch { return v.Spec }).(OrderSpecPatchPtrOutput)
}

func (o OrderPatchTypeOutput) Status() OrderStatusPatchPtrOutput {
	return o.ApplyT(func(v OrderPatchType) *OrderStatusPatch { return v.Status }).(OrderStatusPatchPtrOutput)
}

type OrderSpec struct {
	// CommonName is the common name as specified on the DER encoded CSR.
	// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
	// This field must match the corresponding field on the DER encoded CSR.
	CommonName *string `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	DnsNames []string `pulumi:"dnsNames"`
	// Duration is the duration for the not after date for the requested certificate.
	// this is set on order creation as pe the ACME spec.
	Duration *string `pulumi:"duration"`
	// IPAddresses is a list of IP addresses that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	IpAddresses []string            `pulumi:"ipAddresses"`
	IssuerRef   *OrderSpecIssuerRef `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding.
	// This will be used when finalizing the order.
	// This field must be set on the order.
	Request *string `pulumi:"request"`
}

// OrderSpecInput is an input type that accepts OrderSpecArgs and OrderSpecOutput values.
// You can construct a concrete instance of `OrderSpecInput` via:
//
//	OrderSpecArgs{...}
type OrderSpecInput interface {
	pulumi.Input

	ToOrderSpecOutput() OrderSpecOutput
	ToOrderSpecOutputWithContext(context.Context) OrderSpecOutput
}

type OrderSpecArgs struct {
	// CommonName is the common name as specified on the DER encoded CSR.
	// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
	// This field must match the corresponding field on the DER encoded CSR.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// Duration is the duration for the not after date for the requested certificate.
	// this is set on order creation as pe the ACME spec.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// IPAddresses is a list of IP addresses that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	IpAddresses pulumi.StringArrayInput    `pulumi:"ipAddresses"`
	IssuerRef   OrderSpecIssuerRefPtrInput `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding.
	// This will be used when finalizing the order.
	// This field must be set on the order.
	Request pulumi.StringPtrInput `pulumi:"request"`
}

func (OrderSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpec)(nil)).Elem()
}

func (i OrderSpecArgs) ToOrderSpecOutput() OrderSpecOutput {
	return i.ToOrderSpecOutputWithContext(context.Background())
}

func (i OrderSpecArgs) ToOrderSpecOutputWithContext(ctx context.Context) OrderSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecOutput)
}

func (i OrderSpecArgs) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return i.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (i OrderSpecArgs) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecOutput).ToOrderSpecPtrOutputWithContext(ctx)
}

// OrderSpecPtrInput is an input type that accepts OrderSpecArgs, OrderSpecPtr and OrderSpecPtrOutput values.
// You can construct a concrete instance of `OrderSpecPtrInput` via:
//
//	        OrderSpecArgs{...}
//
//	or:
//
//	        nil
type OrderSpecPtrInput interface {
	pulumi.Input

	ToOrderSpecPtrOutput() OrderSpecPtrOutput
	ToOrderSpecPtrOutputWithContext(context.Context) OrderSpecPtrOutput
}

type orderSpecPtrType OrderSpecArgs

func OrderSpecPtr(v *OrderSpecArgs) OrderSpecPtrInput {
	return (*orderSpecPtrType)(v)
}

func (*orderSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpec)(nil)).Elem()
}

func (i *orderSpecPtrType) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return i.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (i *orderSpecPtrType) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecPtrOutput)
}

type OrderSpecOutput struct{ *pulumi.OutputState }

func (OrderSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpec)(nil)).Elem()
}

func (o OrderSpecOutput) ToOrderSpecOutput() OrderSpecOutput {
	return o
}

func (o OrderSpecOutput) ToOrderSpecOutputWithContext(ctx context.Context) OrderSpecOutput {
	return o
}

func (o OrderSpecOutput) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return o.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (o OrderSpecOutput) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderSpec) *OrderSpec {
		return &v
	}).(OrderSpecPtrOutput)
}

// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpec) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpec) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
func (o OrderSpecOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpec) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) IpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpec) []string { return v.IpAddresses }).(pulumi.StringArrayOutput)
}

func (o OrderSpecOutput) IssuerRef() OrderSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v OrderSpec) *OrderSpecIssuerRef { return v.IssuerRef }).(OrderSpecIssuerRefPtrOutput)
}

// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
func (o OrderSpecOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpec) *string { return v.Request }).(pulumi.StringPtrOutput)
}

type OrderSpecPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpec)(nil)).Elem()
}

func (o OrderSpecPtrOutput) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return o
}

func (o OrderSpecPtrOutput) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return o
}

func (o OrderSpecPtrOutput) Elem() OrderSpecOutput {
	return o.ApplyT(func(v *OrderSpec) OrderSpec {
		if v != nil {
			return *v
		}
		var ret OrderSpec
		return ret
	}).(OrderSpecOutput)
}

// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return v.CommonName
	}).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpec) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
func (o OrderSpecPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) IpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpAddresses
	}).(pulumi.StringArrayOutput)
}

func (o OrderSpecPtrOutput) IssuerRef() OrderSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *OrderSpecIssuerRef {
		if v == nil {
			return nil
		}
		return v.IssuerRef
	}).(OrderSpecIssuerRefPtrOutput)
}

// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
func (o OrderSpecPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return v.Request
	}).(pulumi.StringPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name *string `pulumi:"name"`
}

// OrderSpecIssuerRefInput is an input type that accepts OrderSpecIssuerRefArgs and OrderSpecIssuerRefOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefInput` via:
//
//	OrderSpecIssuerRefArgs{...}
type OrderSpecIssuerRefInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput
	ToOrderSpecIssuerRefOutputWithContext(context.Context) OrderSpecIssuerRefOutput
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (OrderSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRef)(nil)).Elem()
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput {
	return i.ToOrderSpecIssuerRefOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefOutputWithContext(ctx context.Context) OrderSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefOutput)
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return i.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefOutput).ToOrderSpecIssuerRefPtrOutputWithContext(ctx)
}

// OrderSpecIssuerRefPtrInput is an input type that accepts OrderSpecIssuerRefArgs, OrderSpecIssuerRefPtr and OrderSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefPtrInput` via:
//
//	        OrderSpecIssuerRefArgs{...}
//
//	or:
//
//	        nil
type OrderSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput
	ToOrderSpecIssuerRefPtrOutputWithContext(context.Context) OrderSpecIssuerRefPtrOutput
}

type orderSpecIssuerRefPtrType OrderSpecIssuerRefArgs

func OrderSpecIssuerRefPtr(v *OrderSpecIssuerRefArgs) OrderSpecIssuerRefPtrInput {
	return (*orderSpecIssuerRefPtrType)(v)
}

func (*orderSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRef)(nil)).Elem()
}

func (i *orderSpecIssuerRefPtrType) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return i.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *orderSpecIssuerRefPtrType) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRef)(nil)).Elem()
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput {
	return o
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefOutputWithContext(ctx context.Context) OrderSpecIssuerRefOutput {
	return o
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return o.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderSpecIssuerRef) *OrderSpecIssuerRef {
		return &v
	}).(OrderSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type OrderSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRef)(nil)).Elem()
}

func (o OrderSpecIssuerRefPtrOutput) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPtrOutput) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPtrOutput) Elem() OrderSpecIssuerRefOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) OrderSpecIssuerRef {
		if v != nil {
			return *v
		}
		var ret OrderSpecIssuerRef
		return ret
	}).(OrderSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefPatch struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name *string `pulumi:"name"`
}

// OrderSpecIssuerRefPatchInput is an input type that accepts OrderSpecIssuerRefPatchArgs and OrderSpecIssuerRefPatchOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefPatchInput` via:
//
//	OrderSpecIssuerRefPatchArgs{...}
type OrderSpecIssuerRefPatchInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefPatchOutput() OrderSpecIssuerRefPatchOutput
	ToOrderSpecIssuerRefPatchOutputWithContext(context.Context) OrderSpecIssuerRefPatchOutput
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefPatchArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (OrderSpecIssuerRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRefPatch)(nil)).Elem()
}

func (i OrderSpecIssuerRefPatchArgs) ToOrderSpecIssuerRefPatchOutput() OrderSpecIssuerRefPatchOutput {
	return i.ToOrderSpecIssuerRefPatchOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefPatchArgs) ToOrderSpecIssuerRefPatchOutputWithContext(ctx context.Context) OrderSpecIssuerRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefPatchOutput)
}

func (i OrderSpecIssuerRefPatchArgs) ToOrderSpecIssuerRefPatchPtrOutput() OrderSpecIssuerRefPatchPtrOutput {
	return i.ToOrderSpecIssuerRefPatchPtrOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefPatchArgs) ToOrderSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefPatchOutput).ToOrderSpecIssuerRefPatchPtrOutputWithContext(ctx)
}

// OrderSpecIssuerRefPatchPtrInput is an input type that accepts OrderSpecIssuerRefPatchArgs, OrderSpecIssuerRefPatchPtr and OrderSpecIssuerRefPatchPtrOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefPatchPtrInput` via:
//
//	        OrderSpecIssuerRefPatchArgs{...}
//
//	or:
//
//	        nil
type OrderSpecIssuerRefPatchPtrInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefPatchPtrOutput() OrderSpecIssuerRefPatchPtrOutput
	ToOrderSpecIssuerRefPatchPtrOutputWithContext(context.Context) OrderSpecIssuerRefPatchPtrOutput
}

type orderSpecIssuerRefPatchPtrType OrderSpecIssuerRefPatchArgs

func OrderSpecIssuerRefPatchPtr(v *OrderSpecIssuerRefPatchArgs) OrderSpecIssuerRefPatchPtrInput {
	return (*orderSpecIssuerRefPatchPtrType)(v)
}

func (*orderSpecIssuerRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRefPatch)(nil)).Elem()
}

func (i *orderSpecIssuerRefPatchPtrType) ToOrderSpecIssuerRefPatchPtrOutput() OrderSpecIssuerRefPatchPtrOutput {
	return i.ToOrderSpecIssuerRefPatchPtrOutputWithContext(context.Background())
}

func (i *orderSpecIssuerRefPatchPtrType) ToOrderSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefPatchPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefPatchOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRefPatch)(nil)).Elem()
}

func (o OrderSpecIssuerRefPatchOutput) ToOrderSpecIssuerRefPatchOutput() OrderSpecIssuerRefPatchOutput {
	return o
}

func (o OrderSpecIssuerRefPatchOutput) ToOrderSpecIssuerRefPatchOutputWithContext(ctx context.Context) OrderSpecIssuerRefPatchOutput {
	return o
}

func (o OrderSpecIssuerRefPatchOutput) ToOrderSpecIssuerRefPatchPtrOutput() OrderSpecIssuerRefPatchPtrOutput {
	return o.ToOrderSpecIssuerRefPatchPtrOutputWithContext(context.Background())
}

func (o OrderSpecIssuerRefPatchOutput) ToOrderSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderSpecIssuerRefPatch) *OrderSpecIssuerRefPatch {
		return &v
	}).(OrderSpecIssuerRefPatchPtrOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type OrderSpecIssuerRefPatchPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRefPatch)(nil)).Elem()
}

func (o OrderSpecIssuerRefPatchPtrOutput) ToOrderSpecIssuerRefPatchPtrOutput() OrderSpecIssuerRefPatchPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPatchPtrOutput) ToOrderSpecIssuerRefPatchPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPatchPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPatchPtrOutput) Elem() OrderSpecIssuerRefPatchOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRefPatch) OrderSpecIssuerRefPatch {
		if v != nil {
			return *v
		}
		var ret OrderSpecIssuerRefPatch
		return ret
	}).(OrderSpecIssuerRefPatchOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type OrderSpecPatch struct {
	// CommonName is the common name as specified on the DER encoded CSR.
	// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
	// This field must match the corresponding field on the DER encoded CSR.
	CommonName *string `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	DnsNames []string `pulumi:"dnsNames"`
	// Duration is the duration for the not after date for the requested certificate.
	// this is set on order creation as pe the ACME spec.
	Duration *string `pulumi:"duration"`
	// IPAddresses is a list of IP addresses that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	IpAddresses []string                 `pulumi:"ipAddresses"`
	IssuerRef   *OrderSpecIssuerRefPatch `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding.
	// This will be used when finalizing the order.
	// This field must be set on the order.
	Request *string `pulumi:"request"`
}

// OrderSpecPatchInput is an input type that accepts OrderSpecPatchArgs and OrderSpecPatchOutput values.
// You can construct a concrete instance of `OrderSpecPatchInput` via:
//
//	OrderSpecPatchArgs{...}
type OrderSpecPatchInput interface {
	pulumi.Input

	ToOrderSpecPatchOutput() OrderSpecPatchOutput
	ToOrderSpecPatchOutputWithContext(context.Context) OrderSpecPatchOutput
}

type OrderSpecPatchArgs struct {
	// CommonName is the common name as specified on the DER encoded CSR.
	// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
	// This field must match the corresponding field on the DER encoded CSR.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// Duration is the duration for the not after date for the requested certificate.
	// this is set on order creation as pe the ACME spec.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// IPAddresses is a list of IP addresses that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	IpAddresses pulumi.StringArrayInput         `pulumi:"ipAddresses"`
	IssuerRef   OrderSpecIssuerRefPatchPtrInput `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding.
	// This will be used when finalizing the order.
	// This field must be set on the order.
	Request pulumi.StringPtrInput `pulumi:"request"`
}

func (OrderSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecPatch)(nil)).Elem()
}

func (i OrderSpecPatchArgs) ToOrderSpecPatchOutput() OrderSpecPatchOutput {
	return i.ToOrderSpecPatchOutputWithContext(context.Background())
}

func (i OrderSpecPatchArgs) ToOrderSpecPatchOutputWithContext(ctx context.Context) OrderSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecPatchOutput)
}

func (i OrderSpecPatchArgs) ToOrderSpecPatchPtrOutput() OrderSpecPatchPtrOutput {
	return i.ToOrderSpecPatchPtrOutputWithContext(context.Background())
}

func (i OrderSpecPatchArgs) ToOrderSpecPatchPtrOutputWithContext(ctx context.Context) OrderSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecPatchOutput).ToOrderSpecPatchPtrOutputWithContext(ctx)
}

// OrderSpecPatchPtrInput is an input type that accepts OrderSpecPatchArgs, OrderSpecPatchPtr and OrderSpecPatchPtrOutput values.
// You can construct a concrete instance of `OrderSpecPatchPtrInput` via:
//
//	        OrderSpecPatchArgs{...}
//
//	or:
//
//	        nil
type OrderSpecPatchPtrInput interface {
	pulumi.Input

	ToOrderSpecPatchPtrOutput() OrderSpecPatchPtrOutput
	ToOrderSpecPatchPtrOutputWithContext(context.Context) OrderSpecPatchPtrOutput
}

type orderSpecPatchPtrType OrderSpecPatchArgs

func OrderSpecPatchPtr(v *OrderSpecPatchArgs) OrderSpecPatchPtrInput {
	return (*orderSpecPatchPtrType)(v)
}

func (*orderSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecPatch)(nil)).Elem()
}

func (i *orderSpecPatchPtrType) ToOrderSpecPatchPtrOutput() OrderSpecPatchPtrOutput {
	return i.ToOrderSpecPatchPtrOutputWithContext(context.Background())
}

func (i *orderSpecPatchPtrType) ToOrderSpecPatchPtrOutputWithContext(ctx context.Context) OrderSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecPatchPtrOutput)
}

type OrderSpecPatchOutput struct{ *pulumi.OutputState }

func (OrderSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecPatch)(nil)).Elem()
}

func (o OrderSpecPatchOutput) ToOrderSpecPatchOutput() OrderSpecPatchOutput {
	return o
}

func (o OrderSpecPatchOutput) ToOrderSpecPatchOutputWithContext(ctx context.Context) OrderSpecPatchOutput {
	return o
}

func (o OrderSpecPatchOutput) ToOrderSpecPatchPtrOutput() OrderSpecPatchPtrOutput {
	return o.ToOrderSpecPatchPtrOutputWithContext(context.Background())
}

func (o OrderSpecPatchOutput) ToOrderSpecPatchPtrOutputWithContext(ctx context.Context) OrderSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderSpecPatch) *OrderSpecPatch {
		return &v
	}).(OrderSpecPatchPtrOutput)
}

// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPatchOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecPatch) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPatchOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpecPatch) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
func (o OrderSpecPatchOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecPatch) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPatchOutput) IpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpecPatch) []string { return v.IpAddresses }).(pulumi.StringArrayOutput)
}

func (o OrderSpecPatchOutput) IssuerRef() OrderSpecIssuerRefPatchPtrOutput {
	return o.ApplyT(func(v OrderSpecPatch) *OrderSpecIssuerRefPatch { return v.IssuerRef }).(OrderSpecIssuerRefPatchPtrOutput)
}

// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
func (o OrderSpecPatchOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecPatch) *string { return v.Request }).(pulumi.StringPtrOutput)
}

type OrderSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecPatch)(nil)).Elem()
}

func (o OrderSpecPatchPtrOutput) ToOrderSpecPatchPtrOutput() OrderSpecPatchPtrOutput {
	return o
}

func (o OrderSpecPatchPtrOutput) ToOrderSpecPatchPtrOutputWithContext(ctx context.Context) OrderSpecPatchPtrOutput {
	return o
}

func (o OrderSpecPatchPtrOutput) Elem() OrderSpecPatchOutput {
	return o.ApplyT(func(v *OrderSpecPatch) OrderSpecPatch {
		if v != nil {
			return *v
		}
		var ret OrderSpecPatch
		return ret
	}).(OrderSpecPatchOutput)
}

// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPatchPtrOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.CommonName
	}).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPatchPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
func (o OrderSpecPatchPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPatchPtrOutput) IpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.IpAddresses
	}).(pulumi.StringArrayOutput)
}

func (o OrderSpecPatchPtrOutput) IssuerRef() OrderSpecIssuerRefPatchPtrOutput {
	return o.ApplyT(func(v *OrderSpecPatch) *OrderSpecIssuerRefPatch {
		if v == nil {
			return nil
		}
		return v.IssuerRef
	}).(OrderSpecIssuerRefPatchPtrOutput)
}

// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
func (o OrderSpecPatchPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Request
	}).(pulumi.StringPtrOutput)
}

type OrderStatus struct {
	// Authorizations contains data returned from the ACME server on what
	// authorizations must be completed in order to validate the DNS names
	// specified on the Order.
	Authorizations []OrderStatusAuthorizations `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order.
	// This field will be populated after the order has been successfully
	// finalized with the ACME server, and the order has transitioned to the
	// 'valid' state.
	Certificate *string `pulumi:"certificate"`
	// FailureTime stores the time that this order failed.
	// This is used to influence garbage collection and back-off.
	FailureTime *string `pulumi:"failureTime"`
	// FinalizeURL of the Order.
	// This is used to obtain certificates for this order once it has been completed.
	FinalizeURL *string `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in
	// the current state.
	Reason *string `pulumi:"reason"`
	// State contains the current state of this Order resource.
	// States 'success' and 'expired' are 'final'
	State *string `pulumi:"state"`
	// URL of the Order.
	// This will initially be empty when the resource is first created.
	// The Order controller will populate this field when the Order is first processed.
	// This field will be immutable after it is initially set.
	Url *string `pulumi:"url"`
}

// OrderStatusInput is an input type that accepts OrderStatusArgs and OrderStatusOutput values.
// You can construct a concrete instance of `OrderStatusInput` via:
//
//	OrderStatusArgs{...}
type OrderStatusInput interface {
	pulumi.Input

	ToOrderStatusOutput() OrderStatusOutput
	ToOrderStatusOutputWithContext(context.Context) OrderStatusOutput
}

type OrderStatusArgs struct {
	// Authorizations contains data returned from the ACME server on what
	// authorizations must be completed in order to validate the DNS names
	// specified on the Order.
	Authorizations OrderStatusAuthorizationsArrayInput `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order.
	// This field will be populated after the order has been successfully
	// finalized with the ACME server, and the order has transitioned to the
	// 'valid' state.
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// FailureTime stores the time that this order failed.
	// This is used to influence garbage collection and back-off.
	FailureTime pulumi.StringPtrInput `pulumi:"failureTime"`
	// FinalizeURL of the Order.
	// This is used to obtain certificates for this order once it has been completed.
	FinalizeURL pulumi.StringPtrInput `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in
	// the current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// State contains the current state of this Order resource.
	// States 'success' and 'expired' are 'final'
	State pulumi.StringPtrInput `pulumi:"state"`
	// URL of the Order.
	// This will initially be empty when the resource is first created.
	// The Order controller will populate this field when the Order is first processed.
	// This field will be immutable after it is initially set.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (OrderStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatus)(nil)).Elem()
}

func (i OrderStatusArgs) ToOrderStatusOutput() OrderStatusOutput {
	return i.ToOrderStatusOutputWithContext(context.Background())
}

func (i OrderStatusArgs) ToOrderStatusOutputWithContext(ctx context.Context) OrderStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusOutput)
}

func (i OrderStatusArgs) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return i.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (i OrderStatusArgs) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusOutput).ToOrderStatusPtrOutputWithContext(ctx)
}

// OrderStatusPtrInput is an input type that accepts OrderStatusArgs, OrderStatusPtr and OrderStatusPtrOutput values.
// You can construct a concrete instance of `OrderStatusPtrInput` via:
//
//	        OrderStatusArgs{...}
//
//	or:
//
//	        nil
type OrderStatusPtrInput interface {
	pulumi.Input

	ToOrderStatusPtrOutput() OrderStatusPtrOutput
	ToOrderStatusPtrOutputWithContext(context.Context) OrderStatusPtrOutput
}

type orderStatusPtrType OrderStatusArgs

func OrderStatusPtr(v *OrderStatusArgs) OrderStatusPtrInput {
	return (*orderStatusPtrType)(v)
}

func (*orderStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatus)(nil)).Elem()
}

func (i *orderStatusPtrType) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return i.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (i *orderStatusPtrType) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusPtrOutput)
}

type OrderStatusOutput struct{ *pulumi.OutputState }

func (OrderStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatus)(nil)).Elem()
}

func (o OrderStatusOutput) ToOrderStatusOutput() OrderStatusOutput {
	return o
}

func (o OrderStatusOutput) ToOrderStatusOutputWithContext(ctx context.Context) OrderStatusOutput {
	return o
}

func (o OrderStatusOutput) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return o.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (o OrderStatusOutput) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderStatus) *OrderStatus {
		return &v
	}).(OrderStatusPtrOutput)
}

// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
func (o OrderStatusOutput) Authorizations() OrderStatusAuthorizationsArrayOutput {
	return o.ApplyT(func(v OrderStatus) []OrderStatusAuthorizations { return v.Authorizations }).(OrderStatusAuthorizationsArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
func (o OrderStatusOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
func (o OrderStatusOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.FailureTime }).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.FinalizeURL }).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in
// the current state.
func (o OrderStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
func (o OrderStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
func (o OrderStatusOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type OrderStatusPtrOutput struct{ *pulumi.OutputState }

func (OrderStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatus)(nil)).Elem()
}

func (o OrderStatusPtrOutput) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return o
}

func (o OrderStatusPtrOutput) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return o
}

func (o OrderStatusPtrOutput) Elem() OrderStatusOutput {
	return o.ApplyT(func(v *OrderStatus) OrderStatus {
		if v != nil {
			return *v
		}
		var ret OrderStatus
		return ret
	}).(OrderStatusOutput)
}

// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
func (o OrderStatusPtrOutput) Authorizations() OrderStatusAuthorizationsArrayOutput {
	return o.ApplyT(func(v *OrderStatus) []OrderStatusAuthorizations {
		if v == nil {
			return nil
		}
		return v.Authorizations
	}).(OrderStatusAuthorizationsArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
func (o OrderStatusPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
func (o OrderStatusPtrOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.FailureTime
	}).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusPtrOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.FinalizeURL
	}).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in
// the current state.
func (o OrderStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
func (o OrderStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
func (o OrderStatusPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizations struct {
	// Challenges specifies the challenge types offered by the ACME server.
	// One of these challenge types will be selected when validating the DNS
	// name and an appropriate Challenge resource will be created to perform
	// the ACME challenge process.
	Challenges []OrderStatusAuthorizationsChallenges `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier *string `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first
	// fetched from the ACME server.
	// If an Authorization is already 'valid', the Order controller will not
	// create a Challenge resource for the authorization. This will occur when
	// working with an ACME server that enables 'authz reuse' (such as Let's
	// Encrypt's production endpoint).
	// If not set and 'identifier' is set, the state is assumed to be pending
	// and a Challenge will be created.
	InitialState *string `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url *string `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name.
	// If this is true, the identifier will be the *non-wildcard* version of
	// the DNS name.
	// For example, if '*.example.com' is the DNS name being validated, this
	// field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// OrderStatusAuthorizationsInput is an input type that accepts OrderStatusAuthorizationsArgs and OrderStatusAuthorizationsOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsInput` via:
//
//	OrderStatusAuthorizationsArgs{...}
type OrderStatusAuthorizationsInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput
	ToOrderStatusAuthorizationsOutputWithContext(context.Context) OrderStatusAuthorizationsOutput
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsArgs struct {
	// Challenges specifies the challenge types offered by the ACME server.
	// One of these challenge types will be selected when validating the DNS
	// name and an appropriate Challenge resource will be created to perform
	// the ACME challenge process.
	Challenges OrderStatusAuthorizationsChallengesArrayInput `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first
	// fetched from the ACME server.
	// If an Authorization is already 'valid', the Order controller will not
	// create a Challenge resource for the authorization. This will occur when
	// working with an ACME server that enables 'authz reuse' (such as Let's
	// Encrypt's production endpoint).
	// If not set and 'identifier' is set, the state is assumed to be pending
	// and a Challenge will be created.
	InitialState pulumi.StringPtrInput `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url pulumi.StringPtrInput `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name.
	// If this is true, the identifier will be the *non-wildcard* version of
	// the DNS name.
	// For example, if '*.example.com' is the DNS name being validated, this
	// field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (OrderStatusAuthorizationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizations)(nil)).Elem()
}

func (i OrderStatusAuthorizationsArgs) ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput {
	return i.ToOrderStatusAuthorizationsOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsArgs) ToOrderStatusAuthorizationsOutputWithContext(ctx context.Context) OrderStatusAuthorizationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsOutput)
}

// OrderStatusAuthorizationsArrayInput is an input type that accepts OrderStatusAuthorizationsArray and OrderStatusAuthorizationsArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsArrayInput` via:
//
//	OrderStatusAuthorizationsArray{ OrderStatusAuthorizationsArgs{...} }
type OrderStatusAuthorizationsArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput
	ToOrderStatusAuthorizationsArrayOutputWithContext(context.Context) OrderStatusAuthorizationsArrayOutput
}

type OrderStatusAuthorizationsArray []OrderStatusAuthorizationsInput

func (OrderStatusAuthorizationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizations)(nil)).Elem()
}

func (i OrderStatusAuthorizationsArray) ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput {
	return i.ToOrderStatusAuthorizationsArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsArray) ToOrderStatusAuthorizationsArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsArrayOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizations)(nil)).Elem()
}

func (o OrderStatusAuthorizationsOutput) ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput {
	return o
}

func (o OrderStatusAuthorizationsOutput) ToOrderStatusAuthorizationsOutputWithContext(ctx context.Context) OrderStatusAuthorizationsOutput {
	return o
}

// Challenges specifies the challenge types offered by the ACME server.
// One of these challenge types will be selected when validating the DNS
// name and an appropriate Challenge resource will be created to perform
// the ACME challenge process.
func (o OrderStatusAuthorizationsOutput) Challenges() OrderStatusAuthorizationsChallengesArrayOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) []OrderStatusAuthorizationsChallenges { return v.Challenges }).(OrderStatusAuthorizationsChallengesArrayOutput)
}

// Identifier is the DNS name to be validated as part of this authorization
func (o OrderStatusAuthorizationsOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

// InitialState is the initial state of the ACME authorization when first
// fetched from the ACME server.
// If an Authorization is already 'valid', the Order controller will not
// create a Challenge resource for the authorization. This will occur when
// working with an ACME server that enables 'authz reuse' (such as Let's
// Encrypt's production endpoint).
// If not set and 'identifier' is set, the state is assumed to be pending
// and a Challenge will be created.
func (o OrderStatusAuthorizationsOutput) InitialState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.InitialState }).(pulumi.StringPtrOutput)
}

// URL is the URL of the Authorization that must be completed
func (o OrderStatusAuthorizationsOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.Url }).(pulumi.StringPtrOutput)
}

// Wildcard will be true if this authorization is for a wildcard DNS name.
// If this is true, the identifier will be the *non-wildcard* version of
// the DNS name.
// For example, if '*.example.com' is the DNS name being validated, this
// field will be 'true' and the 'identifier' field will be 'example.com'.
func (o OrderStatusAuthorizationsOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type OrderStatusAuthorizationsArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizations)(nil)).Elem()
}

func (o OrderStatusAuthorizationsArrayOutput) ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsArrayOutput) ToOrderStatusAuthorizationsArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizations {
		return vs[0].([]OrderStatusAuthorizations)[vs[1].(int)]
	}).(OrderStatusAuthorizationsOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallenges struct {
	// Token is the token that must be presented for this challenge.
	// This is used to compute the 'key' that must also be presented.
	Token *string `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
	// 'tls-sni-01', etc.
	// This is the raw value retrieved from the ACME server.
	// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
	// will be ignored.
	Type *string `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional
	// metadata about the Challenge from the ACME server.
	Url *string `pulumi:"url"`
}

// OrderStatusAuthorizationsChallengesInput is an input type that accepts OrderStatusAuthorizationsChallengesArgs and OrderStatusAuthorizationsChallengesOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesInput` via:
//
//	OrderStatusAuthorizationsChallengesArgs{...}
type OrderStatusAuthorizationsChallengesInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput
	ToOrderStatusAuthorizationsChallengesOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesOutput
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesArgs struct {
	// Token is the token that must be presented for this challenge.
	// This is used to compute the 'key' that must also be presented.
	Token pulumi.StringPtrInput `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
	// 'tls-sni-01', etc.
	// This is the raw value retrieved from the ACME server.
	// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
	// will be ignored.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional
	// metadata about the Challenge from the ACME server.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (OrderStatusAuthorizationsChallengesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesArgs) ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput {
	return i.ToOrderStatusAuthorizationsChallengesOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesArgs) ToOrderStatusAuthorizationsChallengesOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesOutput)
}

// OrderStatusAuthorizationsChallengesArrayInput is an input type that accepts OrderStatusAuthorizationsChallengesArray and OrderStatusAuthorizationsChallengesArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesArrayInput` via:
//
//	OrderStatusAuthorizationsChallengesArray{ OrderStatusAuthorizationsChallengesArgs{...} }
type OrderStatusAuthorizationsChallengesArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput
	ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesArrayOutput
}

type OrderStatusAuthorizationsChallengesArray []OrderStatusAuthorizationsChallengesInput

func (OrderStatusAuthorizationsChallengesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesArray) ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput {
	return i.ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesArray) ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesArrayOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesOutput) ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesOutput) ToOrderStatusAuthorizationsChallengesOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesOutput {
	return o
}

// Token is the token that must be presented for this challenge.
// This is used to compute the 'key' that must also be presented.
func (o OrderStatusAuthorizationsChallengesOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) *string { return v.Token }).(pulumi.StringPtrOutput)
}

// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
// 'tls-sni-01', etc.
// This is the raw value retrieved from the ACME server.
// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
// will be ignored.
func (o OrderStatusAuthorizationsChallengesOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// URL is the URL of this challenge. It can be used to retrieve additional
// metadata about the Challenge from the ACME server.
func (o OrderStatusAuthorizationsChallengesOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type OrderStatusAuthorizationsChallengesArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsChallengesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizationsChallenges {
		return vs[0].([]OrderStatusAuthorizationsChallenges)[vs[1].(int)]
	}).(OrderStatusAuthorizationsChallengesOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesPatch struct {
	// Token is the token that must be presented for this challenge.
	// This is used to compute the 'key' that must also be presented.
	Token *string `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
	// 'tls-sni-01', etc.
	// This is the raw value retrieved from the ACME server.
	// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
	// will be ignored.
	Type *string `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional
	// metadata about the Challenge from the ACME server.
	Url *string `pulumi:"url"`
}

// OrderStatusAuthorizationsChallengesPatchInput is an input type that accepts OrderStatusAuthorizationsChallengesPatchArgs and OrderStatusAuthorizationsChallengesPatchOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesPatchInput` via:
//
//	OrderStatusAuthorizationsChallengesPatchArgs{...}
type OrderStatusAuthorizationsChallengesPatchInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesPatchOutput() OrderStatusAuthorizationsChallengesPatchOutput
	ToOrderStatusAuthorizationsChallengesPatchOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesPatchOutput
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesPatchArgs struct {
	// Token is the token that must be presented for this challenge.
	// This is used to compute the 'key' that must also be presented.
	Token pulumi.StringPtrInput `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
	// 'tls-sni-01', etc.
	// This is the raw value retrieved from the ACME server.
	// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
	// will be ignored.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional
	// metadata about the Challenge from the ACME server.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (OrderStatusAuthorizationsChallengesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallengesPatch)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesPatchArgs) ToOrderStatusAuthorizationsChallengesPatchOutput() OrderStatusAuthorizationsChallengesPatchOutput {
	return i.ToOrderStatusAuthorizationsChallengesPatchOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesPatchArgs) ToOrderStatusAuthorizationsChallengesPatchOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesPatchOutput)
}

// OrderStatusAuthorizationsChallengesPatchArrayInput is an input type that accepts OrderStatusAuthorizationsChallengesPatchArray and OrderStatusAuthorizationsChallengesPatchArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesPatchArrayInput` via:
//
//	OrderStatusAuthorizationsChallengesPatchArray{ OrderStatusAuthorizationsChallengesPatchArgs{...} }
type OrderStatusAuthorizationsChallengesPatchArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesPatchArrayOutput() OrderStatusAuthorizationsChallengesPatchArrayOutput
	ToOrderStatusAuthorizationsChallengesPatchArrayOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesPatchArrayOutput
}

type OrderStatusAuthorizationsChallengesPatchArray []OrderStatusAuthorizationsChallengesPatchInput

func (OrderStatusAuthorizationsChallengesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallengesPatch)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesPatchArray) ToOrderStatusAuthorizationsChallengesPatchArrayOutput() OrderStatusAuthorizationsChallengesPatchArrayOutput {
	return i.ToOrderStatusAuthorizationsChallengesPatchArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesPatchArray) ToOrderStatusAuthorizationsChallengesPatchArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesPatchArrayOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesPatchOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallengesPatch)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesPatchOutput) ToOrderStatusAuthorizationsChallengesPatchOutput() OrderStatusAuthorizationsChallengesPatchOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesPatchOutput) ToOrderStatusAuthorizationsChallengesPatchOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesPatchOutput {
	return o
}

// Token is the token that must be presented for this challenge.
// This is used to compute the 'key' that must also be presented.
func (o OrderStatusAuthorizationsChallengesPatchOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallengesPatch) *string { return v.Token }).(pulumi.StringPtrOutput)
}

// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
// 'tls-sni-01', etc.
// This is the raw value retrieved from the ACME server.
// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
// will be ignored.
func (o OrderStatusAuthorizationsChallengesPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallengesPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// URL is the URL of this challenge. It can be used to retrieve additional
// metadata about the Challenge from the ACME server.
func (o OrderStatusAuthorizationsChallengesPatchOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallengesPatch) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type OrderStatusAuthorizationsChallengesPatchArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallengesPatch)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesPatchArrayOutput) ToOrderStatusAuthorizationsChallengesPatchArrayOutput() OrderStatusAuthorizationsChallengesPatchArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesPatchArrayOutput) ToOrderStatusAuthorizationsChallengesPatchArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesPatchArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesPatchArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsChallengesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizationsChallengesPatch {
		return vs[0].([]OrderStatusAuthorizationsChallengesPatch)[vs[1].(int)]
	}).(OrderStatusAuthorizationsChallengesPatchOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsPatch struct {
	// Challenges specifies the challenge types offered by the ACME server.
	// One of these challenge types will be selected when validating the DNS
	// name and an appropriate Challenge resource will be created to perform
	// the ACME challenge process.
	Challenges []OrderStatusAuthorizationsChallengesPatch `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier *string `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first
	// fetched from the ACME server.
	// If an Authorization is already 'valid', the Order controller will not
	// create a Challenge resource for the authorization. This will occur when
	// working with an ACME server that enables 'authz reuse' (such as Let's
	// Encrypt's production endpoint).
	// If not set and 'identifier' is set, the state is assumed to be pending
	// and a Challenge will be created.
	InitialState *string `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url *string `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name.
	// If this is true, the identifier will be the *non-wildcard* version of
	// the DNS name.
	// For example, if '*.example.com' is the DNS name being validated, this
	// field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// OrderStatusAuthorizationsPatchInput is an input type that accepts OrderStatusAuthorizationsPatchArgs and OrderStatusAuthorizationsPatchOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsPatchInput` via:
//
//	OrderStatusAuthorizationsPatchArgs{...}
type OrderStatusAuthorizationsPatchInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsPatchOutput() OrderStatusAuthorizationsPatchOutput
	ToOrderStatusAuthorizationsPatchOutputWithContext(context.Context) OrderStatusAuthorizationsPatchOutput
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsPatchArgs struct {
	// Challenges specifies the challenge types offered by the ACME server.
	// One of these challenge types will be selected when validating the DNS
	// name and an appropriate Challenge resource will be created to perform
	// the ACME challenge process.
	Challenges OrderStatusAuthorizationsChallengesPatchArrayInput `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first
	// fetched from the ACME server.
	// If an Authorization is already 'valid', the Order controller will not
	// create a Challenge resource for the authorization. This will occur when
	// working with an ACME server that enables 'authz reuse' (such as Let's
	// Encrypt's production endpoint).
	// If not set and 'identifier' is set, the state is assumed to be pending
	// and a Challenge will be created.
	InitialState pulumi.StringPtrInput `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url pulumi.StringPtrInput `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name.
	// If this is true, the identifier will be the *non-wildcard* version of
	// the DNS name.
	// For example, if '*.example.com' is the DNS name being validated, this
	// field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (OrderStatusAuthorizationsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsPatch)(nil)).Elem()
}

func (i OrderStatusAuthorizationsPatchArgs) ToOrderStatusAuthorizationsPatchOutput() OrderStatusAuthorizationsPatchOutput {
	return i.ToOrderStatusAuthorizationsPatchOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsPatchArgs) ToOrderStatusAuthorizationsPatchOutputWithContext(ctx context.Context) OrderStatusAuthorizationsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsPatchOutput)
}

// OrderStatusAuthorizationsPatchArrayInput is an input type that accepts OrderStatusAuthorizationsPatchArray and OrderStatusAuthorizationsPatchArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsPatchArrayInput` via:
//
//	OrderStatusAuthorizationsPatchArray{ OrderStatusAuthorizationsPatchArgs{...} }
type OrderStatusAuthorizationsPatchArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsPatchArrayOutput() OrderStatusAuthorizationsPatchArrayOutput
	ToOrderStatusAuthorizationsPatchArrayOutputWithContext(context.Context) OrderStatusAuthorizationsPatchArrayOutput
}

type OrderStatusAuthorizationsPatchArray []OrderStatusAuthorizationsPatchInput

func (OrderStatusAuthorizationsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsPatch)(nil)).Elem()
}

func (i OrderStatusAuthorizationsPatchArray) ToOrderStatusAuthorizationsPatchArrayOutput() OrderStatusAuthorizationsPatchArrayOutput {
	return i.ToOrderStatusAuthorizationsPatchArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsPatchArray) ToOrderStatusAuthorizationsPatchArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsPatchArrayOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsPatchOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsPatch)(nil)).Elem()
}

func (o OrderStatusAuthorizationsPatchOutput) ToOrderStatusAuthorizationsPatchOutput() OrderStatusAuthorizationsPatchOutput {
	return o
}

func (o OrderStatusAuthorizationsPatchOutput) ToOrderStatusAuthorizationsPatchOutputWithContext(ctx context.Context) OrderStatusAuthorizationsPatchOutput {
	return o
}

// Challenges specifies the challenge types offered by the ACME server.
// One of these challenge types will be selected when validating the DNS
// name and an appropriate Challenge resource will be created to perform
// the ACME challenge process.
func (o OrderStatusAuthorizationsPatchOutput) Challenges() OrderStatusAuthorizationsChallengesPatchArrayOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsPatch) []OrderStatusAuthorizationsChallengesPatch { return v.Challenges }).(OrderStatusAuthorizationsChallengesPatchArrayOutput)
}

// Identifier is the DNS name to be validated as part of this authorization
func (o OrderStatusAuthorizationsPatchOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsPatch) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

// InitialState is the initial state of the ACME authorization when first
// fetched from the ACME server.
// If an Authorization is already 'valid', the Order controller will not
// create a Challenge resource for the authorization. This will occur when
// working with an ACME server that enables 'authz reuse' (such as Let's
// Encrypt's production endpoint).
// If not set and 'identifier' is set, the state is assumed to be pending
// and a Challenge will be created.
func (o OrderStatusAuthorizationsPatchOutput) InitialState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsPatch) *string { return v.InitialState }).(pulumi.StringPtrOutput)
}

// URL is the URL of the Authorization that must be completed
func (o OrderStatusAuthorizationsPatchOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsPatch) *string { return v.Url }).(pulumi.StringPtrOutput)
}

// Wildcard will be true if this authorization is for a wildcard DNS name.
// If this is true, the identifier will be the *non-wildcard* version of
// the DNS name.
// For example, if '*.example.com' is the DNS name being validated, this
// field will be 'true' and the 'identifier' field will be 'example.com'.
func (o OrderStatusAuthorizationsPatchOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsPatch) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type OrderStatusAuthorizationsPatchArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsPatch)(nil)).Elem()
}

func (o OrderStatusAuthorizationsPatchArrayOutput) ToOrderStatusAuthorizationsPatchArrayOutput() OrderStatusAuthorizationsPatchArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsPatchArrayOutput) ToOrderStatusAuthorizationsPatchArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsPatchArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsPatchArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizationsPatch {
		return vs[0].([]OrderStatusAuthorizationsPatch)[vs[1].(int)]
	}).(OrderStatusAuthorizationsPatchOutput)
}

type OrderStatusPatch struct {
	// Authorizations contains data returned from the ACME server on what
	// authorizations must be completed in order to validate the DNS names
	// specified on the Order.
	Authorizations []OrderStatusAuthorizationsPatch `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order.
	// This field will be populated after the order has been successfully
	// finalized with the ACME server, and the order has transitioned to the
	// 'valid' state.
	Certificate *string `pulumi:"certificate"`
	// FailureTime stores the time that this order failed.
	// This is used to influence garbage collection and back-off.
	FailureTime *string `pulumi:"failureTime"`
	// FinalizeURL of the Order.
	// This is used to obtain certificates for this order once it has been completed.
	FinalizeURL *string `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in
	// the current state.
	Reason *string `pulumi:"reason"`
	// State contains the current state of this Order resource.
	// States 'success' and 'expired' are 'final'
	State *string `pulumi:"state"`
	// URL of the Order.
	// This will initially be empty when the resource is first created.
	// The Order controller will populate this field when the Order is first processed.
	// This field will be immutable after it is initially set.
	Url *string `pulumi:"url"`
}

// OrderStatusPatchInput is an input type that accepts OrderStatusPatchArgs and OrderStatusPatchOutput values.
// You can construct a concrete instance of `OrderStatusPatchInput` via:
//
//	OrderStatusPatchArgs{...}
type OrderStatusPatchInput interface {
	pulumi.Input

	ToOrderStatusPatchOutput() OrderStatusPatchOutput
	ToOrderStatusPatchOutputWithContext(context.Context) OrderStatusPatchOutput
}

type OrderStatusPatchArgs struct {
	// Authorizations contains data returned from the ACME server on what
	// authorizations must be completed in order to validate the DNS names
	// specified on the Order.
	Authorizations OrderStatusAuthorizationsPatchArrayInput `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order.
	// This field will be populated after the order has been successfully
	// finalized with the ACME server, and the order has transitioned to the
	// 'valid' state.
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// FailureTime stores the time that this order failed.
	// This is used to influence garbage collection and back-off.
	FailureTime pulumi.StringPtrInput `pulumi:"failureTime"`
	// FinalizeURL of the Order.
	// This is used to obtain certificates for this order once it has been completed.
	FinalizeURL pulumi.StringPtrInput `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in
	// the current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// State contains the current state of this Order resource.
	// States 'success' and 'expired' are 'final'
	State pulumi.StringPtrInput `pulumi:"state"`
	// URL of the Order.
	// This will initially be empty when the resource is first created.
	// The Order controller will populate this field when the Order is first processed.
	// This field will be immutable after it is initially set.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (OrderStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusPatch)(nil)).Elem()
}

func (i OrderStatusPatchArgs) ToOrderStatusPatchOutput() OrderStatusPatchOutput {
	return i.ToOrderStatusPatchOutputWithContext(context.Background())
}

func (i OrderStatusPatchArgs) ToOrderStatusPatchOutputWithContext(ctx context.Context) OrderStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusPatchOutput)
}

func (i OrderStatusPatchArgs) ToOrderStatusPatchPtrOutput() OrderStatusPatchPtrOutput {
	return i.ToOrderStatusPatchPtrOutputWithContext(context.Background())
}

func (i OrderStatusPatchArgs) ToOrderStatusPatchPtrOutputWithContext(ctx context.Context) OrderStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusPatchOutput).ToOrderStatusPatchPtrOutputWithContext(ctx)
}

// OrderStatusPatchPtrInput is an input type that accepts OrderStatusPatchArgs, OrderStatusPatchPtr and OrderStatusPatchPtrOutput values.
// You can construct a concrete instance of `OrderStatusPatchPtrInput` via:
//
//	        OrderStatusPatchArgs{...}
//
//	or:
//
//	        nil
type OrderStatusPatchPtrInput interface {
	pulumi.Input

	ToOrderStatusPatchPtrOutput() OrderStatusPatchPtrOutput
	ToOrderStatusPatchPtrOutputWithContext(context.Context) OrderStatusPatchPtrOutput
}

type orderStatusPatchPtrType OrderStatusPatchArgs

func OrderStatusPatchPtr(v *OrderStatusPatchArgs) OrderStatusPatchPtrInput {
	return (*orderStatusPatchPtrType)(v)
}

func (*orderStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatusPatch)(nil)).Elem()
}

func (i *orderStatusPatchPtrType) ToOrderStatusPatchPtrOutput() OrderStatusPatchPtrOutput {
	return i.ToOrderStatusPatchPtrOutputWithContext(context.Background())
}

func (i *orderStatusPatchPtrType) ToOrderStatusPatchPtrOutputWithContext(ctx context.Context) OrderStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusPatchPtrOutput)
}

type OrderStatusPatchOutput struct{ *pulumi.OutputState }

func (OrderStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusPatch)(nil)).Elem()
}

func (o OrderStatusPatchOutput) ToOrderStatusPatchOutput() OrderStatusPatchOutput {
	return o
}

func (o OrderStatusPatchOutput) ToOrderStatusPatchOutputWithContext(ctx context.Context) OrderStatusPatchOutput {
	return o
}

func (o OrderStatusPatchOutput) ToOrderStatusPatchPtrOutput() OrderStatusPatchPtrOutput {
	return o.ToOrderStatusPatchPtrOutputWithContext(context.Background())
}

func (o OrderStatusPatchOutput) ToOrderStatusPatchPtrOutputWithContext(ctx context.Context) OrderStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderStatusPatch) *OrderStatusPatch {
		return &v
	}).(OrderStatusPatchPtrOutput)
}

// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
func (o OrderStatusPatchOutput) Authorizations() OrderStatusAuthorizationsPatchArrayOutput {
	return o.ApplyT(func(v OrderStatusPatch) []OrderStatusAuthorizationsPatch { return v.Authorizations }).(OrderStatusAuthorizationsPatchArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
func (o OrderStatusPatchOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusPatch) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
func (o OrderStatusPatchOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusPatch) *string { return v.FailureTime }).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusPatchOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusPatch) *string { return v.FinalizeURL }).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in
// the current state.
func (o OrderStatusPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
func (o OrderStatusPatchOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusPatch) *string { return v.State }).(pulumi.StringPtrOutput)
}

// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
func (o OrderStatusPatchOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusPatch) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type OrderStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (OrderStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatusPatch)(nil)).Elem()
}

func (o OrderStatusPatchPtrOutput) ToOrderStatusPatchPtrOutput() OrderStatusPatchPtrOutput {
	return o
}

func (o OrderStatusPatchPtrOutput) ToOrderStatusPatchPtrOutputWithContext(ctx context.Context) OrderStatusPatchPtrOutput {
	return o
}

func (o OrderStatusPatchPtrOutput) Elem() OrderStatusPatchOutput {
	return o.ApplyT(func(v *OrderStatusPatch) OrderStatusPatch {
		if v != nil {
			return *v
		}
		var ret OrderStatusPatch
		return ret
	}).(OrderStatusPatchOutput)
}

// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
func (o OrderStatusPatchPtrOutput) Authorizations() OrderStatusAuthorizationsPatchArrayOutput {
	return o.ApplyT(func(v *OrderStatusPatch) []OrderStatusAuthorizationsPatch {
		if v == nil {
			return nil
		}
		return v.Authorizations
	}).(OrderStatusAuthorizationsPatchArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
func (o OrderStatusPatchPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
func (o OrderStatusPatchPtrOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.FailureTime
	}).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusPatchPtrOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.FinalizeURL
	}).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in
// the current state.
func (o OrderStatusPatchPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
func (o OrderStatusPatchPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
func (o OrderStatusPatchPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeTypeInput)(nil)).Elem(), ChallengeTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeTypeArrayInput)(nil)).Elem(), ChallengeTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeListTypeInput)(nil)).Elem(), ChallengeListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengePatchTypeInput)(nil)).Elem(), ChallengePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecInput)(nil)).Elem(), ChallengeSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecPtrInput)(nil)).Elem(), ChallengeSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefInput)(nil)).Elem(), ChallengeSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefPtrInput)(nil)).Elem(), ChallengeSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefPatchInput)(nil)).Elem(), ChallengeSpecIssuerRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefPatchPtrInput)(nil)).Elem(), ChallengeSpecIssuerRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecPatchInput)(nil)).Elem(), ChallengeSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecPatchPtrInput)(nil)).Elem(), ChallengeSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverInput)(nil)).Elem(), ChallengeSpecSolverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverPtrInput)(nil)).Elem(), ChallengeSpecSolverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Input)(nil)).Elem(), ChallengeSpecSolverDns01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDNSPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentityInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSManagedIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDNSPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePatchInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflarePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflarePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01PatchInput)(nil)).Elem(), ChallengeSpecSolverDns01PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01PatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136Input)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136PatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136PatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53Input)(nil)).Elem(), ChallengeSpecSolverDns01Route53Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53PatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53PatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPatchInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01Input)(nil)).Elem(), ChallengeSpecSolverHttp01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01PtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoutePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoutePatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHTTPRoutePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01PatchInput)(nil)).Elem(), ChallengeSpecSolverHttp01PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01PatchPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01PatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverPatchInput)(nil)).Elem(), ChallengeSpecSolverPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorInput)(nil)).Elem(), ChallengeSpecSolverSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorPatchInput)(nil)).Elem(), ChallengeSpecSolverSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorPatchPtrInput)(nil)).Elem(), ChallengeSpecSolverSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusInput)(nil)).Elem(), ChallengeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusPtrInput)(nil)).Elem(), ChallengeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusPatchInput)(nil)).Elem(), ChallengeStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusPatchPtrInput)(nil)).Elem(), ChallengeStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderTypeInput)(nil)).Elem(), OrderTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderTypeArrayInput)(nil)).Elem(), OrderTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderListTypeInput)(nil)).Elem(), OrderListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderPatchTypeInput)(nil)).Elem(), OrderPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecInput)(nil)).Elem(), OrderSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecPtrInput)(nil)).Elem(), OrderSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecIssuerRefInput)(nil)).Elem(), OrderSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecIssuerRefPtrInput)(nil)).Elem(), OrderSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecIssuerRefPatchInput)(nil)).Elem(), OrderSpecIssuerRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecIssuerRefPatchPtrInput)(nil)).Elem(), OrderSpecIssuerRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecPatchInput)(nil)).Elem(), OrderSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecPatchPtrInput)(nil)).Elem(), OrderSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusInput)(nil)).Elem(), OrderStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusPtrInput)(nil)).Elem(), OrderStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsInput)(nil)).Elem(), OrderStatusAuthorizationsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsArrayInput)(nil)).Elem(), OrderStatusAuthorizationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsChallengesInput)(nil)).Elem(), OrderStatusAuthorizationsChallengesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsChallengesArrayInput)(nil)).Elem(), OrderStatusAuthorizationsChallengesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsChallengesPatchInput)(nil)).Elem(), OrderStatusAuthorizationsChallengesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsChallengesPatchArrayInput)(nil)).Elem(), OrderStatusAuthorizationsChallengesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsPatchInput)(nil)).Elem(), OrderStatusAuthorizationsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsPatchArrayInput)(nil)).Elem(), OrderStatusAuthorizationsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusPatchInput)(nil)).Elem(), OrderStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusPatchPtrInput)(nil)).Elem(), OrderStatusPatchArgs{})
	pulumi.RegisterOutputType(ChallengeTypeOutput{})
	pulumi.RegisterOutputType(ChallengeTypeArrayOutput{})
	pulumi.RegisterOutputType(ChallengeListTypeOutput{})
	pulumi.RegisterOutputType(ChallengePatchTypeOutput{})
	pulumi.RegisterOutputType(ChallengeSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSManagedIdentityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSManagedIdentityPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflarePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflarePatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflarePatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01PatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01PatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136PatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136PatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIDSecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53PatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53PatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRouteOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRoutePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRouteParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHTTPRoutePatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplatePatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplatePatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplatePatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplatePatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferencePatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsPatchArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01PatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01PatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorPatchOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(ChallengeStatusOutput{})
	pulumi.RegisterOutputType(ChallengeStatusPtrOutput{})
	pulumi.RegisterOutputType(ChallengeStatusPatchOutput{})
	pulumi.RegisterOutputType(ChallengeStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(OrderTypeOutput{})
	pulumi.RegisterOutputType(OrderTypeArrayOutput{})
	pulumi.RegisterOutputType(OrderListTypeOutput{})
	pulumi.RegisterOutputType(OrderPatchTypeOutput{})
	pulumi.RegisterOutputType(OrderSpecOutput{})
	pulumi.RegisterOutputType(OrderSpecPtrOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefPatchOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefPatchPtrOutput{})
	pulumi.RegisterOutputType(OrderSpecPatchOutput{})
	pulumi.RegisterOutputType(OrderSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(OrderStatusOutput{})
	pulumi.RegisterOutputType(OrderStatusPtrOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsArrayOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesArrayOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesPatchOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesPatchArrayOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsPatchOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsPatchArrayOutput{})
	pulumi.RegisterOutputType(OrderStatusPatchOutput{})
	pulumi.RegisterOutputType(OrderStatusPatchPtrOutput{})
}
