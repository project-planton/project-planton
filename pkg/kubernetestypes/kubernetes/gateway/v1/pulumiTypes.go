// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRouteType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of GRPCRoute.
	Spec *GRPCRouteSpec `pulumi:"spec"`
	// Status defines the current state of GRPCRoute.
	Status *GRPCRouteStatus `pulumi:"status"`
}

type GRPCRouteMetadata struct {
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpec struct {
	// Hostnames defines a set of hostnames to match against the GRPC
	// Host header to select a GRPCRoute to process the request. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label MUST appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and GRPCRoute, there
	// MUST be at least one intersecting hostname for the GRPCRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and GRPCRoute have specified hostnames, any
	// GRPCRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// GRPCRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` MUST NOT be considered for a match.
	//
	// If both the Listener and GRPCRoute have specified hostnames, and none
	// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
	// the implementation. The implementation MUST raise an 'Accepted' Condition
	// with a status of `False` in the corresponding RouteParentStatus.
	//
	// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
	// Listener and that listener already has another Route (B) of the other
	// type attached and the intersection of the hostnames of A and B is
	// non-empty, then the implementation MUST accept exactly one of these two
	// routes, determined by the following criteria, in order:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// The rejected Route MUST raise an 'Accepted' condition with a status of
	// 'False' in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []GRPCRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules []GRPCRouteSpecRules `pulumi:"rules"`
}

// GRPCRouteSpecInput is an input type that accepts GRPCRouteSpecArgs and GRPCRouteSpecOutput values.
// You can construct a concrete instance of `GRPCRouteSpecInput` via:
//
//	GRPCRouteSpecArgs{...}
type GRPCRouteSpecInput interface {
	pulumi.Input

	ToGRPCRouteSpecOutput() GRPCRouteSpecOutput
	ToGRPCRouteSpecOutputWithContext(context.Context) GRPCRouteSpecOutput
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecArgs struct {
	// Hostnames defines a set of hostnames to match against the GRPC
	// Host header to select a GRPCRoute to process the request. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label MUST appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and GRPCRoute, there
	// MUST be at least one intersecting hostname for the GRPCRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and GRPCRoute have specified hostnames, any
	// GRPCRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// GRPCRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` MUST NOT be considered for a match.
	//
	// If both the Listener and GRPCRoute have specified hostnames, and none
	// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
	// the implementation. The implementation MUST raise an 'Accepted' Condition
	// with a status of `False` in the corresponding RouteParentStatus.
	//
	// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
	// Listener and that listener already has another Route (B) of the other
	// type attached and the intersection of the hostnames of A and B is
	// non-empty, then the implementation MUST accept exactly one of these two
	// routes, determined by the following criteria, in order:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// The rejected Route MUST raise an 'Accepted' condition with a status of
	// 'False' in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs GRPCRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules GRPCRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (GRPCRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpec)(nil)).Elem()
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecOutput() GRPCRouteSpecOutput {
	return i.ToGRPCRouteSpecOutputWithContext(context.Background())
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecOutputWithContext(ctx context.Context) GRPCRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecOutput)
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return i.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecOutput).ToGRPCRouteSpecPtrOutputWithContext(ctx)
}

// GRPCRouteSpecPtrInput is an input type that accepts GRPCRouteSpecArgs, GRPCRouteSpecPtr and GRPCRouteSpecPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecPtrInput` via:
//
//	        GRPCRouteSpecArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput
	ToGRPCRouteSpecPtrOutputWithContext(context.Context) GRPCRouteSpecPtrOutput
}

type grpcrouteSpecPtrType GRPCRouteSpecArgs

func GRPCRouteSpecPtr(v *GRPCRouteSpecArgs) GRPCRouteSpecPtrInput {
	return (*grpcrouteSpecPtrType)(v)
}

func (*grpcrouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpec)(nil)).Elem()
}

func (i *grpcrouteSpecPtrType) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return i.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecPtrType) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecPtrOutput)
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpec)(nil)).Elem()
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecOutput() GRPCRouteSpecOutput {
	return o
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecOutputWithContext(ctx context.Context) GRPCRouteSpecOutput {
	return o
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return o.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpec) *GRPCRouteSpec {
		return &v
	}).(GRPCRouteSpecPtrOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC
// Host header to select a GRPCRoute to process the request. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label MUST appear by itself as the first label.
//
// If a hostname is specified by both the Listener and GRPCRoute, there
// MUST be at least one intersecting hostname for the GRPCRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and GRPCRoute have specified hostnames, any
// GRPCRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// GRPCRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` MUST NOT be considered for a match.
//
// If both the Listener and GRPCRoute have specified hostnames, and none
// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
// the implementation. The implementation MUST raise an 'Accepted' Condition
// with a status of `False` in the corresponding RouteParentStatus.
//
// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
// Listener and that listener already has another Route (B) of the other
// type attached and the intersection of the hostnames of A and B is
// non-empty, then the implementation MUST accept exactly one of these two
// routes, determined by the following criteria, in order:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// The rejected Route MUST raise an 'Accepted' condition with a status of
// 'False' in the corresponding RouteParentStatus.
//
// Support: Core
func (o GRPCRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o GRPCRouteSpecOutput) ParentRefs() GRPCRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []GRPCRouteSpecParentRefs { return v.ParentRefs }).(GRPCRouteSpecParentRefsArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecOutput) Rules() GRPCRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []GRPCRouteSpecRules { return v.Rules }).(GRPCRouteSpecRulesArrayOutput)
}

type GRPCRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpec)(nil)).Elem()
}

func (o GRPCRouteSpecPtrOutput) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return o
}

func (o GRPCRouteSpecPtrOutput) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return o
}

func (o GRPCRouteSpecPtrOutput) Elem() GRPCRouteSpecOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) GRPCRouteSpec {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpec
		return ret
	}).(GRPCRouteSpecOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC
// Host header to select a GRPCRoute to process the request. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label MUST appear by itself as the first label.
//
// If a hostname is specified by both the Listener and GRPCRoute, there
// MUST be at least one intersecting hostname for the GRPCRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and GRPCRoute have specified hostnames, any
// GRPCRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// GRPCRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` MUST NOT be considered for a match.
//
// If both the Listener and GRPCRoute have specified hostnames, and none
// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
// the implementation. The implementation MUST raise an 'Accepted' Condition
// with a status of `False` in the corresponding RouteParentStatus.
//
// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
// Listener and that listener already has another Route (B) of the other
// type attached and the intersection of the hostnames of A and B is
// non-empty, then the implementation MUST accept exactly one of these two
// routes, determined by the following criteria, in order:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// The rejected Route MUST raise an 'Accepted' condition with a status of
// 'False' in the corresponding RouteParentStatus.
//
// Support: Core
func (o GRPCRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o GRPCRouteSpecPtrOutput) ParentRefs() GRPCRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []GRPCRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(GRPCRouteSpecParentRefsArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecPtrOutput) Rules() GRPCRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []GRPCRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(GRPCRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecParentRefs
func (val *GRPCRouteSpecParentRefs) Defaults() *GRPCRouteSpecParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteSpecParentRefsInput is an input type that accepts GRPCRouteSpecParentRefsArgs and GRPCRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsInput` via:
//
//	GRPCRouteSpecParentRefsArgs{...}
type GRPCRouteSpecParentRefsInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput
	ToGRPCRouteSpecParentRefsOutputWithContext(context.Context) GRPCRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecParentRefsArgs
func (val *GRPCRouteSpecParentRefsArgs) Defaults() *GRPCRouteSpecParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (GRPCRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsArgs) ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput {
	return i.ToGRPCRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsArgs) ToGRPCRouteSpecParentRefsOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsOutput)
}

// GRPCRouteSpecParentRefsArrayInput is an input type that accepts GRPCRouteSpecParentRefsArray and GRPCRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsArrayInput` via:
//
//	GRPCRouteSpecParentRefsArray{ GRPCRouteSpecParentRefsArgs{...} }
type GRPCRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput
	ToGRPCRouteSpecParentRefsArrayOutputWithContext(context.Context) GRPCRouteSpecParentRefsArrayOutput
}

type GRPCRouteSpecParentRefsArray []GRPCRouteSpecParentRefsInput

func (GRPCRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsArray) ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput {
	return i.ToGRPCRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsArray) ToGRPCRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsOutput) ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput {
	return o
}

func (o GRPCRouteSpecParentRefsOutput) ToGRPCRouteSpecParentRefsOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsArrayOutput) ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsArrayOutput) ToGRPCRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecParentRefs {
		return vs[0].([]GRPCRouteSpecParentRefs)[vs[1].(int)]
	}).(GRPCRouteSpecParentRefsOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive an `UNAVAILABLE` status.
	//
	// See the GRPCBackendRef definition for the rules about what makes a single
	// GRPCBackendRef invalid.
	//
	// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive an `UNAVAILABLE` status.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
	// Implementations may choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []GRPCRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// The effects of ordering of multiple behaviors are currently unspecified.
	// This can change in the future based on feedback during the alpha stage.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations that support
	//   GRPCRoute.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// If an implementation can not support a combination of filters, it must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []GRPCRouteSpecRulesFilters `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// gRPC requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, it MUST satisfy
	// EITHER of the two conditions:
	//
	// - service of foo.bar AND contains the header `version: 2`
	// - service of foo.bar.v2
	//
	// See the documentation for GRPCRouteMatch on how to specify multiple
	// match conditions to be ANDed together.
	//
	// If no matches are specified, the implementation MUST match every gRPC request.
	//
	// Proxy or Load Balancer routing configuration generated from GRPCRoutes
	// MUST prioritize rules based on the following criteria, continuing on
	// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
	// Precedence MUST be given to the rule with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	// * Characters in a matching service.
	// * Characters in a matching method.
	// * Header matches.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within the Route that has been given precedence,
	// matching precedence MUST be granted to the first matching rule meeting
	// the above criteria.
	Matches []GRPCRouteSpecRulesMatches `pulumi:"matches"`
}

// GRPCRouteSpecRulesInput is an input type that accepts GRPCRouteSpecRulesArgs and GRPCRouteSpecRulesOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesInput` via:
//
//	GRPCRouteSpecRulesArgs{...}
type GRPCRouteSpecRulesInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput
	ToGRPCRouteSpecRulesOutputWithContext(context.Context) GRPCRouteSpecRulesOutput
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive an `UNAVAILABLE` status.
	//
	// See the GRPCBackendRef definition for the rules about what makes a single
	// GRPCBackendRef invalid.
	//
	// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive an `UNAVAILABLE` status.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
	// Implementations may choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs GRPCRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// The effects of ordering of multiple behaviors are currently unspecified.
	// This can change in the future based on feedback during the alpha stage.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations that support
	//   GRPCRoute.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// If an implementation can not support a combination of filters, it must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters GRPCRouteSpecRulesFiltersArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// gRPC requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, it MUST satisfy
	// EITHER of the two conditions:
	//
	// - service of foo.bar AND contains the header `version: 2`
	// - service of foo.bar.v2
	//
	// See the documentation for GRPCRouteMatch on how to specify multiple
	// match conditions to be ANDed together.
	//
	// If no matches are specified, the implementation MUST match every gRPC request.
	//
	// Proxy or Load Balancer routing configuration generated from GRPCRoutes
	// MUST prioritize rules based on the following criteria, continuing on
	// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
	// Precedence MUST be given to the rule with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	// * Characters in a matching service.
	// * Characters in a matching method.
	// * Header matches.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within the Route that has been given precedence,
	// matching precedence MUST be granted to the first matching rule meeting
	// the above criteria.
	Matches GRPCRouteSpecRulesMatchesArrayInput `pulumi:"matches"`
}

func (GRPCRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRules)(nil)).Elem()
}

func (i GRPCRouteSpecRulesArgs) ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput {
	return i.ToGRPCRouteSpecRulesOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesArgs) ToGRPCRouteSpecRulesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesOutput)
}

// GRPCRouteSpecRulesArrayInput is an input type that accepts GRPCRouteSpecRulesArray and GRPCRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesArrayInput` via:
//
//	GRPCRouteSpecRulesArray{ GRPCRouteSpecRulesArgs{...} }
type GRPCRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput
	ToGRPCRouteSpecRulesArrayOutputWithContext(context.Context) GRPCRouteSpecRulesArrayOutput
}

type GRPCRouteSpecRulesArray []GRPCRouteSpecRulesInput

func (GRPCRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRules)(nil)).Elem()
}

func (i GRPCRouteSpecRulesArray) ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput {
	return i.ToGRPCRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesArray) ToGRPCRouteSpecRulesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesArrayOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRules)(nil)).Elem()
}

func (o GRPCRouteSpecRulesOutput) ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput {
	return o
}

func (o GRPCRouteSpecRulesOutput) ToGRPCRouteSpecRulesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive an `UNAVAILABLE` status.
//
// See the GRPCBackendRef definition for the rules about what makes a single
// GRPCBackendRef invalid.
//
// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive an `UNAVAILABLE` status.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
// Implementations may choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o GRPCRouteSpecRulesOutput) BackendRefs() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesBackendRefs { return v.BackendRefs }).(GRPCRouteSpecRulesBackendRefsArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// The effects of ordering of multiple behaviors are currently unspecified.
// This can change in the future based on feedback during the alpha stage.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations that support
//     GRPCRoute.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// If an implementation can not support a combination of filters, it must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o GRPCRouteSpecRulesOutput) Filters() GRPCRouteSpecRulesFiltersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesFilters { return v.Filters }).(GRPCRouteSpecRulesFiltersArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// gRPC requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, it MUST satisfy
// EITHER of the two conditions:
//
// - service of foo.bar AND contains the header `version: 2`
// - service of foo.bar.v2
//
// See the documentation for GRPCRouteMatch on how to specify multiple
// match conditions to be ANDed together.
//
// If no matches are specified, the implementation MUST match every gRPC request.
//
// Proxy or Load Balancer routing configuration generated from GRPCRoutes
// MUST prioritize rules based on the following criteria, continuing on
// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
// Precedence MUST be given to the rule with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
// * Characters in a matching service.
// * Characters in a matching method.
// * Header matches.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within the Route that has been given precedence,
// matching precedence MUST be granted to the first matching rule meeting
// the above criteria.
func (o GRPCRouteSpecRulesOutput) Matches() GRPCRouteSpecRulesMatchesArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesMatches { return v.Matches }).(GRPCRouteSpecRulesMatchesArrayOutput)
}

type GRPCRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRules)(nil)).Elem()
}

func (o GRPCRouteSpecRulesArrayOutput) ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesArrayOutput) ToGRPCRouteSpecRulesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRules {
		return vs[0].([]GRPCRouteSpecRules)[vs[1].(int)]
	}).(GRPCRouteSpecRulesOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefs struct {
	// Filters defined at this level MUST be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in GRPCRouteRule.)
	Filters []GRPCRouteSpecRulesBackendRefsFilters `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefs
func (val *GRPCRouteSpecRulesBackendRefs) Defaults() *GRPCRouteSpecRulesBackendRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	if tmp.Weight == nil {
		weight_ := 1
		tmp.Weight = &weight_
	}
	return &tmp
}

// GRPCRouteSpecRulesBackendRefsInput is an input type that accepts GRPCRouteSpecRulesBackendRefsArgs and GRPCRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsInput` via:
//
//	GRPCRouteSpecRulesBackendRefsArgs{...}
type GRPCRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput
	ToGRPCRouteSpecRulesBackendRefsOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsOutput
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsArgs struct {
	// Filters defined at this level MUST be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in GRPCRouteRule.)
	Filters GRPCRouteSpecRulesBackendRefsFiltersArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsArgs
func (val *GRPCRouteSpecRulesBackendRefsArgs) Defaults() *GRPCRouteSpecRulesBackendRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	if tmp.Weight == nil {
		tmp.Weight = pulumi.IntPtr(1)
	}
	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsArgs) ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsArgs) ToGRPCRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsOutput)
}

// GRPCRouteSpecRulesBackendRefsArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsArray and GRPCRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsArray{ GRPCRouteSpecRulesBackendRefsArgs{...} }
type GRPCRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput
	ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput
}

type GRPCRouteSpecRulesBackendRefsArray []GRPCRouteSpecRulesBackendRefsInput

func (GRPCRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsArray) ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsArray) ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsArrayOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsOutput) ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsOutput) ToGRPCRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsOutput {
	return o
}

// Filters defined at this level MUST be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in GRPCRouteRule.)
func (o GRPCRouteSpecRulesBackendRefsOutput) Filters() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) []GRPCRouteSpecRulesBackendRefsFilters { return v.Filters }).(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o GRPCRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefs {
		return vs[0].([]GRPCRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFilters struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// Support: Implementation-specific
	//
	// This filter can be used multiple times within the same rule.
	ExtensionRef *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFilters
func (val *GRPCRouteSpecRulesBackendRefsFilters) Defaults() *GRPCRouteSpecRulesBackendRefsFilters {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.RequestMirror = tmp.RequestMirror.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesBackendRefsFiltersInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersArgs and GRPCRouteSpecRulesBackendRefsFiltersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersArgs struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// Support: Implementation-specific
	//
	// This filter can be used multiple times within the same rule.
	ExtensionRef GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type pulumi.StringInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersArgs
func (val *GRPCRouteSpecRulesBackendRefsFiltersArgs) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArgs) ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArgs) ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersArray and GRPCRouteSpecRulesBackendRefsFiltersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersArray{ GRPCRouteSpecRulesBackendRefsFiltersArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersArray []GRPCRouteSpecRulesBackendRefsFiltersInput

func (GRPCRouteSpecRulesBackendRefsFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArray) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArray) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ExtensionRef() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		return v.ExtensionRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) RequestHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) RequestMirror() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		return v.RequestMirror
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ResponseHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations supporting GRPCRoute MUST support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` MUST be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) string { return v.Type }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFilters {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFilters)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput).ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs, GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtr and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs

func GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtr(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Name }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersExtensionRef
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirror struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.BackendRef = *tmp.BackendRef.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return &v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput).ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs, GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs

func GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFilters struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// Support: Implementation-specific
	//
	// This filter can be used multiple times within the same rule.
	ExtensionRef *GRPCRouteSpecRulesFiltersExtensionRef `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier *GRPCRouteSpecRulesFiltersRequestHeaderModifier `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror *GRPCRouteSpecRulesFiltersRequestMirror `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier *GRPCRouteSpecRulesFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFilters
func (val *GRPCRouteSpecRulesFilters) Defaults() *GRPCRouteSpecRulesFilters {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.RequestMirror = tmp.RequestMirror.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesFiltersInput is an input type that accepts GRPCRouteSpecRulesFiltersArgs and GRPCRouteSpecRulesFiltersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersInput` via:
//
//	GRPCRouteSpecRulesFiltersArgs{...}
type GRPCRouteSpecRulesFiltersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput
	ToGRPCRouteSpecRulesFiltersOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersArgs struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// Support: Implementation-specific
	//
	// This filter can be used multiple times within the same rule.
	ExtensionRef GRPCRouteSpecRulesFiltersExtensionRefPtrInput `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror GRPCRouteSpecRulesFiltersRequestMirrorPtrInput `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type pulumi.StringInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersArgs
func (val *GRPCRouteSpecRulesFiltersArgs) Defaults() *GRPCRouteSpecRulesFiltersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersArgs) ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput {
	return i.ToGRPCRouteSpecRulesFiltersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersArgs) ToGRPCRouteSpecRulesFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersOutput)
}

// GRPCRouteSpecRulesFiltersArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersArray and GRPCRouteSpecRulesFiltersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersArray{ GRPCRouteSpecRulesFiltersArgs{...} }
type GRPCRouteSpecRulesFiltersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput
	ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersArrayOutput
}

type GRPCRouteSpecRulesFiltersArray []GRPCRouteSpecRulesFiltersInput

func (GRPCRouteSpecRulesFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersArray) ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersArray) ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersOutput) ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersOutput) ToGRPCRouteSpecRulesFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersOutput {
	return o
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
func (o GRPCRouteSpecRulesFiltersOutput) ExtensionRef() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersExtensionRef { return v.ExtensionRef }).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersOutput) RequestHeaderModifier() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
func (o GRPCRouteSpecRulesFiltersOutput) RequestMirror() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersRequestMirror { return v.RequestMirror }).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
func (o GRPCRouteSpecRulesFiltersOutput) ResponseHeaderModifier() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations supporting GRPCRoute MUST support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` MUST be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesFiltersOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) string { return v.Type }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFilters {
		return vs[0].([]GRPCRouteSpecRulesFilters)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// GRPCRouteSpecRulesFiltersExtensionRefInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefArgs and GRPCRouteSpecRulesFiltersExtensionRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefInput` via:
//
//	GRPCRouteSpecRulesFiltersExtensionRefArgs{...}
type GRPCRouteSpecRulesFiltersExtensionRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefOutput)
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefOutput).ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersExtensionRefPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefArgs, GRPCRouteSpecRulesFiltersExtensionRefPtr and GRPCRouteSpecRulesFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput
}

type grpcrouteSpecRulesFiltersExtensionRefPtrType GRPCRouteSpecRulesFiltersExtensionRefArgs

func GRPCRouteSpecRulesFiltersExtensionRefPtr(v *GRPCRouteSpecRulesFiltersExtensionRefArgs) GRPCRouteSpecRulesFiltersExtensionRefPtrInput {
	return (*grpcrouteSpecRulesFiltersExtensionRefPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersExtensionRef) *GRPCRouteSpecRulesFiltersExtensionRef {
		return &v
	}).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) string { return v.Name }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Elem() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) GRPCRouteSpecRulesFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersExtensionRef
		return ret
	}).(GRPCRouteSpecRulesFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput).ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs, GRPCRouteSpecRulesFiltersRequestHeaderModifierPtr and GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
}

type grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs

func GRPCRouteSpecRulesFiltersRequestHeaderModifierPtr(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestHeaderModifier) *GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirror struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirror
func (val *GRPCRouteSpecRulesFiltersRequestMirror) Defaults() *GRPCRouteSpecRulesFiltersRequestMirror {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.BackendRef = *tmp.BackendRef.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesFiltersRequestMirrorInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorArgs and GRPCRouteSpecRulesFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorArgs struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorArgs
func (val *GRPCRouteSpecRulesFiltersRequestMirrorArgs) Defaults() *GRPCRouteSpecRulesFiltersRequestMirrorArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorArgs, GRPCRouteSpecRulesFiltersRequestMirrorPtr and GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorPtrType GRPCRouteSpecRulesFiltersRequestMirrorArgs

func GRPCRouteSpecRulesFiltersRequestMirrorPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorArgs) GRPCRouteSpecRulesFiltersRequestMirrorPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirror {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirror) GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirror) GRPCRouteSpecRulesFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirror
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return &v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
func (val *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) Defaults() *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs
func (val *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) Defaults() *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	return &tmp
}
func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs, GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtr and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs

func GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput).ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs, GRPCRouteSpecRulesFiltersResponseHeaderModifierPtr and GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
}

type grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs

func GRPCRouteSpecRulesFiltersResponseHeaderModifierPtr(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersResponseHeaderModifier) *GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersResponseHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatches struct {
	// Headers specifies gRPC request header matchers. Multiple match values are
	// ANDed together, meaning, a request MUST match all the specified headers
	// to select the route.
	Headers []GRPCRouteSpecRulesMatchesHeaders `pulumi:"headers"`
	// Method specifies a gRPC request service/method matcher. If this field is
	// not specified, all services and methods will match.
	Method *GRPCRouteSpecRulesMatchesMethod `pulumi:"method"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatches
func (val *GRPCRouteSpecRulesMatches) Defaults() *GRPCRouteSpecRulesMatches {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Method = tmp.Method.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesMatchesInput is an input type that accepts GRPCRouteSpecRulesMatchesArgs and GRPCRouteSpecRulesMatchesOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesInput` via:
//
//	GRPCRouteSpecRulesMatchesArgs{...}
type GRPCRouteSpecRulesMatchesInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput
	ToGRPCRouteSpecRulesMatchesOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesOutput
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesArgs struct {
	// Headers specifies gRPC request header matchers. Multiple match values are
	// ANDed together, meaning, a request MUST match all the specified headers
	// to select the route.
	Headers GRPCRouteSpecRulesMatchesHeadersArrayInput `pulumi:"headers"`
	// Method specifies a gRPC request service/method matcher. If this field is
	// not specified, all services and methods will match.
	Method GRPCRouteSpecRulesMatchesMethodPtrInput `pulumi:"method"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesArgs
func (val *GRPCRouteSpecRulesMatchesArgs) Defaults() *GRPCRouteSpecRulesMatchesArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesMatchesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesArgs) ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput {
	return i.ToGRPCRouteSpecRulesMatchesOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesArgs) ToGRPCRouteSpecRulesMatchesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesOutput)
}

// GRPCRouteSpecRulesMatchesArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesArray and GRPCRouteSpecRulesMatchesArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesArray{ GRPCRouteSpecRulesMatchesArgs{...} }
type GRPCRouteSpecRulesMatchesArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput
	ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesArrayOutput
}

type GRPCRouteSpecRulesMatchesArray []GRPCRouteSpecRulesMatchesInput

func (GRPCRouteSpecRulesMatchesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesArray) ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesArray) ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesArrayOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesOutput) ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesOutput) ToGRPCRouteSpecRulesMatchesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesOutput {
	return o
}

// Headers specifies gRPC request header matchers. Multiple match values are
// ANDed together, meaning, a request MUST match all the specified headers
// to select the route.
func (o GRPCRouteSpecRulesMatchesOutput) Headers() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatches) []GRPCRouteSpecRulesMatchesHeaders { return v.Headers }).(GRPCRouteSpecRulesMatchesHeadersArrayOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
func (o GRPCRouteSpecRulesMatchesOutput) Method() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatches) *GRPCRouteSpecRulesMatchesMethod { return v.Method }).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

type GRPCRouteSpecRulesMatchesArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatches {
		return vs[0].([]GRPCRouteSpecRulesMatches)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeaders struct {
	// Name is the name of the gRPC Header to be matched.
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type *string `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeaders
func (val *GRPCRouteSpecRulesMatchesHeaders) Defaults() *GRPCRouteSpecRulesMatchesHeaders {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "Exact"
		tmp.Type = &type_
	}
	return &tmp
}

// GRPCRouteSpecRulesMatchesHeadersInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersArgs and GRPCRouteSpecRulesMatchesHeadersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersArgs{...}
type GRPCRouteSpecRulesMatchesHeadersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput
	ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersOutput
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersArgs struct {
	// Name is the name of the gRPC Header to be matched.
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeadersArgs
func (val *GRPCRouteSpecRulesMatchesHeadersArgs) Defaults() *GRPCRouteSpecRulesMatchesHeadersArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("Exact")
	}
	return &tmp
}
func (GRPCRouteSpecRulesMatchesHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersArgs) ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersArgs) ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersOutput)
}

// GRPCRouteSpecRulesMatchesHeadersArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersArray and GRPCRouteSpecRulesMatchesHeadersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersArray{ GRPCRouteSpecRulesMatchesHeadersArgs{...} }
type GRPCRouteSpecRulesMatchesHeadersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput
	ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput
}

type GRPCRouteSpecRulesMatchesHeadersArray []GRPCRouteSpecRulesMatchesHeadersInput

func (GRPCRouteSpecRulesMatchesHeadersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersArray) ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersArray) ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersArrayOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersOutput) ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersOutput) ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersOutput {
	return o
}

// Name is the name of the gRPC Header to be matched.
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) string { return v.Name }).(pulumi.StringOutput)
}

// Type specifies how to match against the value of the header.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of the gRPC Header to be matched.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesMatchesHeadersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesHeadersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatchesHeaders {
		return vs[0].([]GRPCRouteSpecRulesMatchesHeaders)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesHeadersOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethod struct {
	// Value of the method to match against. If left empty or omitted, will
	// match all services.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Method *string `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will
	// match any service.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Service *string `pulumi:"service"`
	// Type specifies how to match against the service and/or method.
	// Support: Core (Exact with service and method specified)
	//
	// Support: Implementation-specific (Exact with method specified but no service specified)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethod
func (val *GRPCRouteSpecRulesMatchesMethod) Defaults() *GRPCRouteSpecRulesMatchesMethod {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "Exact"
		tmp.Type = &type_
	}
	return &tmp
}

// GRPCRouteSpecRulesMatchesMethodInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodArgs and GRPCRouteSpecRulesMatchesMethodOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodInput` via:
//
//	GRPCRouteSpecRulesMatchesMethodArgs{...}
type GRPCRouteSpecRulesMatchesMethodInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput
	ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodOutput
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodArgs struct {
	// Value of the method to match against. If left empty or omitted, will
	// match all services.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Method pulumi.StringPtrInput `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will
	// match any service.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Service pulumi.StringPtrInput `pulumi:"service"`
	// Type specifies how to match against the service and/or method.
	// Support: Core (Exact with service and method specified)
	//
	// Support: Implementation-specific (Exact with method specified but no service specified)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethodArgs
func (val *GRPCRouteSpecRulesMatchesMethodArgs) Defaults() *GRPCRouteSpecRulesMatchesMethodArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("Exact")
	}
	return &tmp
}
func (GRPCRouteSpecRulesMatchesMethodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodOutput)
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodOutput).ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesMatchesMethodPtrInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodArgs, GRPCRouteSpecRulesMatchesMethodPtr and GRPCRouteSpecRulesMatchesMethodPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodPtrInput` via:
//
//	        GRPCRouteSpecRulesMatchesMethodArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesMatchesMethodPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput
	ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput
}

type grpcrouteSpecRulesMatchesMethodPtrType GRPCRouteSpecRulesMatchesMethodArgs

func GRPCRouteSpecRulesMatchesMethodPtr(v *GRPCRouteSpecRulesMatchesMethodArgs) GRPCRouteSpecRulesMatchesMethodPtrInput {
	return (*grpcrouteSpecRulesMatchesMethodPtrType)(v)
}

func (*grpcrouteSpecRulesMatchesMethodPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (i *grpcrouteSpecRulesMatchesMethodPtrType) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesMatchesMethodPtrType) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesMatchesMethod) *GRPCRouteSpecRulesMatchesMethod {
		return &v
	}).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

// Value of the method to match against. If left empty or omitted, will
// match all services.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Method }).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will
// match any service.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Service }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method.
// Support: Core (Exact with service and method specified)
//
// Support: Implementation-specific (Exact with method specified but no service specified)
//
// Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesMatchesMethodPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Elem() GRPCRouteSpecRulesMatchesMethodOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) GRPCRouteSpecRulesMatchesMethod {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesMatchesMethod
		return ret
	}).(GRPCRouteSpecRulesMatchesMethodOutput)
}

// Value of the method to match against. If left empty or omitted, will
// match all services.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will
// match any service.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method.
// Support: Core (Exact with service and method specified)
//
// Support: Implementation-specific (Exact with method specified but no service specified)
//
// Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []GRPCRouteStatusParents `pulumi:"parents"`
}

// GRPCRouteStatusInput is an input type that accepts GRPCRouteStatusArgs and GRPCRouteStatusOutput values.
// You can construct a concrete instance of `GRPCRouteStatusInput` via:
//
//	GRPCRouteStatusArgs{...}
type GRPCRouteStatusInput interface {
	pulumi.Input

	ToGRPCRouteStatusOutput() GRPCRouteStatusOutput
	ToGRPCRouteStatusOutputWithContext(context.Context) GRPCRouteStatusOutput
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents GRPCRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (GRPCRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatus)(nil)).Elem()
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusOutput() GRPCRouteStatusOutput {
	return i.ToGRPCRouteStatusOutputWithContext(context.Background())
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusOutputWithContext(ctx context.Context) GRPCRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusOutput)
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return i.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusOutput).ToGRPCRouteStatusPtrOutputWithContext(ctx)
}

// GRPCRouteStatusPtrInput is an input type that accepts GRPCRouteStatusArgs, GRPCRouteStatusPtr and GRPCRouteStatusPtrOutput values.
// You can construct a concrete instance of `GRPCRouteStatusPtrInput` via:
//
//	        GRPCRouteStatusArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteStatusPtrInput interface {
	pulumi.Input

	ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput
	ToGRPCRouteStatusPtrOutputWithContext(context.Context) GRPCRouteStatusPtrOutput
}

type grpcrouteStatusPtrType GRPCRouteStatusArgs

func GRPCRouteStatusPtr(v *GRPCRouteStatusArgs) GRPCRouteStatusPtrInput {
	return (*grpcrouteStatusPtrType)(v)
}

func (*grpcrouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatus)(nil)).Elem()
}

func (i *grpcrouteStatusPtrType) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return i.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (i *grpcrouteStatusPtrType) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusPtrOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatus)(nil)).Elem()
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusOutput() GRPCRouteStatusOutput {
	return o
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusOutputWithContext(ctx context.Context) GRPCRouteStatusOutput {
	return o
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return o.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteStatus) *GRPCRouteStatus {
		return &v
	}).(GRPCRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o GRPCRouteStatusOutput) Parents() GRPCRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatus) []GRPCRouteStatusParents { return v.Parents }).(GRPCRouteStatusParentsArrayOutput)
}

type GRPCRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatus)(nil)).Elem()
}

func (o GRPCRouteStatusPtrOutput) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return o
}

func (o GRPCRouteStatusPtrOutput) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return o
}

func (o GRPCRouteStatusPtrOutput) Elem() GRPCRouteStatusOutput {
	return o.ApplyT(func(v *GRPCRouteStatus) GRPCRouteStatus {
		if v != nil {
			return *v
		}
		var ret GRPCRouteStatus
		return ret
	}).(GRPCRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o GRPCRouteStatusPtrOutput) Parents() GRPCRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *GRPCRouteStatus) []GRPCRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(GRPCRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []GRPCRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName string `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this
	// RouteParentStatus struct describes the status of.
	ParentRef GRPCRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParents
func (val *GRPCRouteStatusParents) Defaults() *GRPCRouteStatusParents {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.ParentRef = *tmp.ParentRef.Defaults()

	return &tmp
}

// GRPCRouteStatusParentsInput is an input type that accepts GRPCRouteStatusParentsArgs and GRPCRouteStatusParentsOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsInput` via:
//
//	GRPCRouteStatusParentsArgs{...}
type GRPCRouteStatusParentsInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput
	ToGRPCRouteStatusParentsOutputWithContext(context.Context) GRPCRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions GRPCRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this
	// RouteParentStatus struct describes the status of.
	ParentRef GRPCRouteStatusParentsParentRefInput `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParentsArgs
func (val *GRPCRouteStatusParentsArgs) Defaults() *GRPCRouteStatusParentsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParents)(nil)).Elem()
}

func (i GRPCRouteStatusParentsArgs) ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput {
	return i.ToGRPCRouteStatusParentsOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsArgs) ToGRPCRouteStatusParentsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsOutput)
}

// GRPCRouteStatusParentsArrayInput is an input type that accepts GRPCRouteStatusParentsArray and GRPCRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsArrayInput` via:
//
//	GRPCRouteStatusParentsArray{ GRPCRouteStatusParentsArgs{...} }
type GRPCRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput
	ToGRPCRouteStatusParentsArrayOutputWithContext(context.Context) GRPCRouteStatusParentsArrayOutput
}

type GRPCRouteStatusParentsArray []GRPCRouteStatusParentsInput

func (GRPCRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParents)(nil)).Elem()
}

func (i GRPCRouteStatusParentsArray) ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput {
	return i.ToGRPCRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsArray) ToGRPCRouteStatusParentsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParents)(nil)).Elem()
}

func (o GRPCRouteStatusParentsOutput) ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput {
	return o
}

func (o GRPCRouteStatusParentsOutput) ToGRPCRouteStatusParentsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o GRPCRouteStatusParentsOutput) Conditions() GRPCRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) []GRPCRouteStatusParentsConditions { return v.Conditions }).(GRPCRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o GRPCRouteStatusParentsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) string { return v.ControllerName }).(pulumi.StringOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
func (o GRPCRouteStatusParentsOutput) ParentRef() GRPCRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) GRPCRouteStatusParentsParentRef { return v.ParentRef }).(GRPCRouteStatusParentsParentRefOutput)
}

type GRPCRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParents)(nil)).Elem()
}

func (o GRPCRouteStatusParentsArrayOutput) ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsArrayOutput) ToGRPCRouteStatusParentsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParents {
		return vs[0].([]GRPCRouteStatusParents)[vs[1].(int)]
	}).(GRPCRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// GRPCRouteStatusParentsConditionsInput is an input type that accepts GRPCRouteStatusParentsConditionsArgs and GRPCRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsInput` via:
//
//	GRPCRouteStatusParentsConditionsArgs{...}
type GRPCRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput
	ToGRPCRouteStatusParentsConditionsOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (GRPCRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsArgs) ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput {
	return i.ToGRPCRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsArgs) ToGRPCRouteStatusParentsConditionsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsOutput)
}

// GRPCRouteStatusParentsConditionsArrayInput is an input type that accepts GRPCRouteStatusParentsConditionsArray and GRPCRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsArrayInput` via:
//
//	GRPCRouteStatusParentsConditionsArray{ GRPCRouteStatusParentsConditionsArgs{...} }
type GRPCRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput
	ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsArrayOutput
}

type GRPCRouteStatusParentsConditionsArray []GRPCRouteStatusParentsConditionsInput

func (GRPCRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsArray) ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput {
	return i.ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsArray) ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsOutput) ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsOutput) ToGRPCRouteStatusParentsConditionsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GRPCRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GRPCRouteStatusParentsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GRPCRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GRPCRouteStatusParentsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GRPCRouteStatusParentsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GRPCRouteStatusParentsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type GRPCRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParentsConditions {
		return vs[0].([]GRPCRouteStatusParentsConditions)[vs[1].(int)]
	}).(GRPCRouteStatusParentsConditionsOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParentsParentRef
func (val *GRPCRouteStatusParentsParentRef) Defaults() *GRPCRouteStatusParentsParentRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteStatusParentsParentRefInput is an input type that accepts GRPCRouteStatusParentsParentRefArgs and GRPCRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsParentRefInput` via:
//
//	GRPCRouteStatusParentsParentRefArgs{...}
type GRPCRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput
	ToGRPCRouteStatusParentsParentRefOutputWithContext(context.Context) GRPCRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParentsParentRefArgs
func (val *GRPCRouteStatusParentsParentRefArgs) Defaults() *GRPCRouteStatusParentsParentRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (GRPCRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput {
	return i.ToGRPCRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of Gateway.
	Spec GatewaySpec `pulumi:"spec"`
	// Status defines the current state of Gateway.
	Status *GatewayStatus `pulumi:"status"`
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of GatewayClass.
	Spec GatewayClassSpec `pulumi:"spec"`
	// Status defines the current state of GatewayClass.
	//
	// Implementations MUST populate status on all GatewayClass resources which
	// specify their controller name.
	Status *GatewayClassStatus `pulumi:"status"`
}

type GatewayClassMetadata struct {
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpec struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName string `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description *string `pulumi:"description"`
	// ParametersRef is a reference to a resource that contains the configuration
	// parameters corresponding to the GatewayClass. This is optional if the
	// controller does not require any additional configuration.
	//
	// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
	// or an implementation-specific custom resource. The resource can be
	// cluster-scoped or namespace-scoped.
	//
	// If the referent cannot be found, the GatewayClass's "InvalidParameters"
	// status condition will be true.
	//
	// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
	// the merging behavior is implementation specific.
	// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
	//
	// Support: Implementation-specific
	ParametersRef *GatewayClassSpecParametersRef `pulumi:"parametersRef"`
}

// GatewayClassSpecInput is an input type that accepts GatewayClassSpecArgs and GatewayClassSpecOutput values.
// You can construct a concrete instance of `GatewayClassSpecInput` via:
//
//	GatewayClassSpecArgs{...}
type GatewayClassSpecInput interface {
	pulumi.Input

	ToGatewayClassSpecOutput() GatewayClassSpecOutput
	ToGatewayClassSpecOutputWithContext(context.Context) GatewayClassSpecOutput
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecArgs struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// ParametersRef is a reference to a resource that contains the configuration
	// parameters corresponding to the GatewayClass. This is optional if the
	// controller does not require any additional configuration.
	//
	// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
	// or an implementation-specific custom resource. The resource can be
	// cluster-scoped or namespace-scoped.
	//
	// If the referent cannot be found, the GatewayClass's "InvalidParameters"
	// status condition will be true.
	//
	// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
	// the merging behavior is implementation specific.
	// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
	//
	// Support: Implementation-specific
	ParametersRef GatewayClassSpecParametersRefPtrInput `pulumi:"parametersRef"`
}

func (GatewayClassSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpec)(nil)).Elem()
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecOutput() GatewayClassSpecOutput {
	return i.ToGatewayClassSpecOutputWithContext(context.Background())
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecOutputWithContext(ctx context.Context) GatewayClassSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecOutput)
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return i.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecOutput).ToGatewayClassSpecPtrOutputWithContext(ctx)
}

// GatewayClassSpecPtrInput is an input type that accepts GatewayClassSpecArgs, GatewayClassSpecPtr and GatewayClassSpecPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecPtrInput` via:
//
//	        GatewayClassSpecArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput
	ToGatewayClassSpecPtrOutputWithContext(context.Context) GatewayClassSpecPtrOutput
}

type gatewayClassSpecPtrType GatewayClassSpecArgs

func GatewayClassSpecPtr(v *GatewayClassSpecArgs) GatewayClassSpecPtrInput {
	return (*gatewayClassSpecPtrType)(v)
}

func (*gatewayClassSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpec)(nil)).Elem()
}

func (i *gatewayClassSpecPtrType) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return i.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecPtrType) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpec)(nil)).Elem()
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecOutput() GatewayClassSpecOutput {
	return o
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecOutputWithContext(ctx context.Context) GatewayClassSpecOutput {
	return o
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return o.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpec) *GatewayClassSpec {
		return &v
	}).(GatewayClassSpecPtrOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassSpec) string { return v.ControllerName }).(pulumi.StringOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
func (o GatewayClassSpecOutput) ParametersRef() GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *GatewayClassSpecParametersRef { return v.ParametersRef }).(GatewayClassSpecParametersRefPtrOutput)
}

type GatewayClassSpecPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpec)(nil)).Elem()
}

func (o GatewayClassSpecPtrOutput) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return o
}

func (o GatewayClassSpecPtrOutput) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return o
}

func (o GatewayClassSpecPtrOutput) Elem() GatewayClassSpecOutput {
	return o.ApplyT(func(v *GatewayClassSpec) GatewayClassSpec {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpec
		return ret
	}).(GatewayClassSpecOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPtrOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *string {
		if v == nil {
			return nil
		}
		return &v.ControllerName
	}).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
func (o GatewayClassSpecPtrOutput) ParametersRef() GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *GatewayClassSpecParametersRef {
		if v == nil {
			return nil
		}
		return v.ParametersRef
	}).(GatewayClassSpecParametersRefPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRef struct {
	// Group is the group of the referent.
	Group string `pulumi:"group"`
	// Kind is kind of the referent.
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace *string `pulumi:"namespace"`
}

// GatewayClassSpecParametersRefInput is an input type that accepts GatewayClassSpecParametersRefArgs and GatewayClassSpecParametersRefOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefInput` via:
//
//	GatewayClassSpecParametersRefArgs{...}
type GatewayClassSpecParametersRefInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput
	ToGatewayClassSpecParametersRefOutputWithContext(context.Context) GatewayClassSpecParametersRefOutput
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewayClassSpecParametersRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRef)(nil)).Elem()
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput {
	return i.ToGatewayClassSpecParametersRefOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefOutput)
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return i.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefOutput).ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx)
}

// GatewayClassSpecParametersRefPtrInput is an input type that accepts GatewayClassSpecParametersRefArgs, GatewayClassSpecParametersRefPtr and GatewayClassSpecParametersRefPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPtrInput` via:
//
//	        GatewayClassSpecParametersRefArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecParametersRefPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput
	ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Context) GatewayClassSpecParametersRefPtrOutput
}

type gatewayClassSpecParametersRefPtrType GatewayClassSpecParametersRefArgs

func GatewayClassSpecParametersRefPtr(v *GatewayClassSpecParametersRefArgs) GatewayClassSpecParametersRefPtrInput {
	return (*gatewayClassSpecParametersRefPtrType)(v)
}

func (*gatewayClassSpecParametersRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRef)(nil)).Elem()
}

func (i *gatewayClassSpecParametersRefPtrType) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return i.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecParametersRefPtrType) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRef)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput {
	return o
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefOutput {
	return o
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return o.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecParametersRef) *GatewayClassSpecParametersRef {
		return &v
	}).(GatewayClassSpecParametersRefPtrOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewayClassSpecParametersRefPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRef)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPtrOutput) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPtrOutput) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPtrOutput) Elem() GatewayClassSpecParametersRefOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) GatewayClassSpecParametersRef {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecParametersRef
		return ret
	}).(GatewayClassSpecParametersRefOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatus struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions []GatewayClassStatusConditions `pulumi:"conditions"`
}

// GatewayClassStatusInput is an input type that accepts GatewayClassStatusArgs and GatewayClassStatusOutput values.
// You can construct a concrete instance of `GatewayClassStatusInput` via:
//
//	GatewayClassStatusArgs{...}
type GatewayClassStatusInput interface {
	pulumi.Input

	ToGatewayClassStatusOutput() GatewayClassStatusOutput
	ToGatewayClassStatusOutputWithContext(context.Context) GatewayClassStatusOutput
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusArgs struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions GatewayClassStatusConditionsArrayInput `pulumi:"conditions"`
}

func (GatewayClassStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatus)(nil)).Elem()
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusOutput() GatewayClassStatusOutput {
	return i.ToGatewayClassStatusOutputWithContext(context.Background())
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusOutputWithContext(ctx context.Context) GatewayClassStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusOutput)
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return i.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusOutput).ToGatewayClassStatusPtrOutputWithContext(ctx)
}

// GatewayClassStatusPtrInput is an input type that accepts GatewayClassStatusArgs, GatewayClassStatusPtr and GatewayClassStatusPtrOutput values.
// You can construct a concrete instance of `GatewayClassStatusPtrInput` via:
//
//	        GatewayClassStatusArgs{...}
//
//	or:
//
//	        nil
type GatewayClassStatusPtrInput interface {
	pulumi.Input

	ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput
	ToGatewayClassStatusPtrOutputWithContext(context.Context) GatewayClassStatusPtrOutput
}

type gatewayClassStatusPtrType GatewayClassStatusArgs

func GatewayClassStatusPtr(v *GatewayClassStatusArgs) GatewayClassStatusPtrInput {
	return (*gatewayClassStatusPtrType)(v)
}

func (*gatewayClassStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatus)(nil)).Elem()
}

func (i *gatewayClassStatusPtrType) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return i.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (i *gatewayClassStatusPtrType) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatus)(nil)).Elem()
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusOutput() GatewayClassStatusOutput {
	return o
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusOutputWithContext(ctx context.Context) GatewayClassStatusOutput {
	return o
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return o.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassStatus) *GatewayClassStatus {
		return &v
	}).(GatewayClassStatusPtrOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusOutput) Conditions() GatewayClassStatusConditionsArrayOutput {
	return o.ApplyT(func(v GatewayClassStatus) []GatewayClassStatusConditions { return v.Conditions }).(GatewayClassStatusConditionsArrayOutput)
}

type GatewayClassStatusPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatus)(nil)).Elem()
}

func (o GatewayClassStatusPtrOutput) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return o
}

func (o GatewayClassStatusPtrOutput) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return o
}

func (o GatewayClassStatusPtrOutput) Elem() GatewayClassStatusOutput {
	return o.ApplyT(func(v *GatewayClassStatus) GatewayClassStatus {
		if v != nil {
			return *v
		}
		var ret GatewayClassStatus
		return ret
	}).(GatewayClassStatusOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPtrOutput) Conditions() GatewayClassStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GatewayClassStatus) []GatewayClassStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayClassStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// GatewayClassStatusConditionsInput is an input type that accepts GatewayClassStatusConditionsArgs and GatewayClassStatusConditionsOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsInput` via:
//
//	GatewayClassStatusConditionsArgs{...}
type GatewayClassStatusConditionsInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput
	ToGatewayClassStatusConditionsOutputWithContext(context.Context) GatewayClassStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (GatewayClassStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditions)(nil)).Elem()
}

func (i GatewayClassStatusConditionsArgs) ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput {
	return i.ToGatewayClassStatusConditionsOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsArgs) ToGatewayClassStatusConditionsOutputWithContext(ctx context.Context) GatewayClassStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsOutput)
}

// GatewayClassStatusConditionsArrayInput is an input type that accepts GatewayClassStatusConditionsArray and GatewayClassStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsArrayInput` via:
//
//	GatewayClassStatusConditionsArray{ GatewayClassStatusConditionsArgs{...} }
type GatewayClassStatusConditionsArrayInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput
	ToGatewayClassStatusConditionsArrayOutputWithContext(context.Context) GatewayClassStatusConditionsArrayOutput
}

type GatewayClassStatusConditionsArray []GatewayClassStatusConditionsInput

func (GatewayClassStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditions)(nil)).Elem()
}

func (i GatewayClassStatusConditionsArray) ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput {
	return i.ToGatewayClassStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsArray) ToGatewayClassStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditions)(nil)).Elem()
}

func (o GatewayClassStatusConditionsOutput) ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput {
	return o
}

func (o GatewayClassStatusConditionsOutput) ToGatewayClassStatusConditionsOutputWithContext(ctx context.Context) GatewayClassStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayClassStatusConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayClassStatusConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayClassStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayClassStatusConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayClassStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayClassStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type GatewayClassStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditions)(nil)).Elem()
}

func (o GatewayClassStatusConditionsArrayOutput) ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsArrayOutput) ToGatewayClassStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsArrayOutput) Index(i pulumi.IntInput) GatewayClassStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassStatusConditions {
		return vs[0].([]GatewayClassStatusConditions)[vs[1].(int)]
	}).(GatewayClassStatusConditionsOutput)
}

type GatewayMetadata struct {
}

// Spec defines the desired state of Gateway.
type GatewaySpec struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses []interface{} `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName string `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners []GatewaySpecListeners `pulumi:"listeners"`
}

// GatewaySpecInput is an input type that accepts GatewaySpecArgs and GatewaySpecOutput values.
// You can construct a concrete instance of `GatewaySpecInput` via:
//
//	GatewaySpecArgs{...}
type GatewaySpecInput interface {
	pulumi.Input

	ToGatewaySpecOutput() GatewaySpecOutput
	ToGatewaySpecOutputWithContext(context.Context) GatewaySpecOutput
}

// Spec defines the desired state of Gateway.
type GatewaySpecArgs struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses pulumi.ArrayInput `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName pulumi.StringInput `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners GatewaySpecListenersArrayInput `pulumi:"listeners"`
}

func (GatewaySpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpec)(nil)).Elem()
}

func (i GatewaySpecArgs) ToGatewaySpecOutput() GatewaySpecOutput {
	return i.ToGatewaySpecOutputWithContext(context.Background())
}

func (i GatewaySpecArgs) ToGatewaySpecOutputWithContext(ctx context.Context) GatewaySpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecOutput)
}

func (i GatewaySpecArgs) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return i.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (i GatewaySpecArgs) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecOutput).ToGatewaySpecPtrOutputWithContext(ctx)
}

// GatewaySpecPtrInput is an input type that accepts GatewaySpecArgs, GatewaySpecPtr and GatewaySpecPtrOutput values.
// You can construct a concrete instance of `GatewaySpecPtrInput` via:
//
//	        GatewaySpecArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecPtrInput interface {
	pulumi.Input

	ToGatewaySpecPtrOutput() GatewaySpecPtrOutput
	ToGatewaySpecPtrOutputWithContext(context.Context) GatewaySpecPtrOutput
}

type gatewaySpecPtrType GatewaySpecArgs

func GatewaySpecPtr(v *GatewaySpecArgs) GatewaySpecPtrInput {
	return (*gatewaySpecPtrType)(v)
}

func (*gatewaySpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpec)(nil)).Elem()
}

func (i *gatewaySpecPtrType) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return i.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecPtrType) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecOutput struct{ *pulumi.OutputState }

func (GatewaySpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpec)(nil)).Elem()
}

func (o GatewaySpecOutput) ToGatewaySpecOutput() GatewaySpecOutput {
	return o
}

func (o GatewaySpecOutput) ToGatewaySpecOutputWithContext(ctx context.Context) GatewaySpecOutput {
	return o
}

func (o GatewaySpecOutput) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return o.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (o GatewaySpecOutput) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpec) *GatewaySpec {
		return &v
	}).(GatewaySpecPtrOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecOutput) Addresses() pulumi.ArrayOutput {
	return o.ApplyT(func(v GatewaySpec) []interface{} { return v.Addresses }).(pulumi.ArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecOutput) GatewayClassName() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpec) string { return v.GatewayClassName }).(pulumi.StringOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecOutput) Listeners() GatewaySpecListenersArrayOutput {
	return o.ApplyT(func(v GatewaySpec) []GatewaySpecListeners { return v.Listeners }).(GatewaySpecListenersArrayOutput)
}

type GatewaySpecPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpec)(nil)).Elem()
}

func (o GatewaySpecPtrOutput) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return o
}

func (o GatewaySpecPtrOutput) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return o
}

func (o GatewaySpecPtrOutput) Elem() GatewaySpecOutput {
	return o.ApplyT(func(v *GatewaySpec) GatewaySpec {
		if v != nil {
			return *v
		}
		var ret GatewaySpec
		return ret
	}).(GatewaySpecOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPtrOutput) Addresses() pulumi.ArrayOutput {
	return o.ApplyT(func(v *GatewaySpec) []interface{} {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(pulumi.ArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPtrOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpec) *string {
		if v == nil {
			return nil
		}
		return &v.GatewayClassName
	}).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPtrOutput) Listeners() GatewaySpecListenersArrayOutput {
	return o.ApplyT(func(v *GatewaySpec) []GatewaySpecListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewaySpecListenersArrayOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListeners struct {
	// AllowedRoutes defines the types of routes that MAY be attached to a
	// Listener and the trusted namespaces where those Route resources MAY be
	// present.
	//
	// Although a client request may match multiple route rules, only one rule
	// may ultimately receive the request. Matching precedence MUST be
	// determined in order of the following criteria:
	//
	// * The most specific match as defined by the Route type.
	// * The oldest Route based on creation timestamp. For example, a Route with
	//   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
	//   a Route with a creation timestamp of "2020-09-08 01:02:04".
	// * If everything else is equivalent, the Route appearing first in
	//   alphabetical order (namespace/name) should be given precedence. For
	//   example, foo/bar is given precedence over foo/baz.
	//
	// All valid rules within a Route attached to this Listener should be
	// implemented. Invalid Route rules can be ignored (sometimes that will mean
	// the full Route). If a Route rule transitions from valid to invalid,
	// support for that Route rule should be dropped to ensure consistency. For
	// example, even if a filter specified by a Route rule is invalid, the rest
	// of the rules within that Route should still be supported.
	//
	// Support: Core
	AllowedRoutes *GatewaySpecListenersAllowedRoutes `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol string `pulumi:"protocol"`
	// TLS is the TLS configuration for the Listener. This field is required if
	// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
	// if the Protocol field is "HTTP", "TCP", or "UDP".
	//
	// The association of SNIs to Certificate defined in GatewayTLSConfig is
	// defined based on the Hostname field for this listener.
	//
	// The GatewayClass MUST use the longest matching SNI out of all
	// available certificates for any TLS handshake.
	//
	// Support: Core
	Tls *GatewaySpecListenersTls `pulumi:"tls"`
}

// Defaults sets the appropriate defaults for GatewaySpecListeners
func (val *GatewaySpecListeners) Defaults() *GatewaySpecListeners {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AllowedRoutes = tmp.AllowedRoutes.Defaults()

	tmp.Tls = tmp.Tls.Defaults()

	return &tmp
}

// GatewaySpecListenersInput is an input type that accepts GatewaySpecListenersArgs and GatewaySpecListenersOutput values.
// You can construct a concrete instance of `GatewaySpecListenersInput` via:
//
//	GatewaySpecListenersArgs{...}
type GatewaySpecListenersInput interface {
	pulumi.Input

	ToGatewaySpecListenersOutput() GatewaySpecListenersOutput
	ToGatewaySpecListenersOutputWithContext(context.Context) GatewaySpecListenersOutput
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersArgs struct {
	// AllowedRoutes defines the types of routes that MAY be attached to a
	// Listener and the trusted namespaces where those Route resources MAY be
	// present.
	//
	// Although a client request may match multiple route rules, only one rule
	// may ultimately receive the request. Matching precedence MUST be
	// determined in order of the following criteria:
	//
	// * The most specific match as defined by the Route type.
	// * The oldest Route based on creation timestamp. For example, a Route with
	//   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
	//   a Route with a creation timestamp of "2020-09-08 01:02:04".
	// * If everything else is equivalent, the Route appearing first in
	//   alphabetical order (namespace/name) should be given precedence. For
	//   example, foo/bar is given precedence over foo/baz.
	//
	// All valid rules within a Route attached to this Listener should be
	// implemented. Invalid Route rules can be ignored (sometimes that will mean
	// the full Route). If a Route rule transitions from valid to invalid,
	// support for that Route rule should be dropped to ensure consistency. For
	// example, even if a filter specified by a Route rule is invalid, the rest
	// of the rules within that Route should still be supported.
	//
	// Support: Core
	AllowedRoutes GatewaySpecListenersAllowedRoutesPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port pulumi.IntInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// TLS is the TLS configuration for the Listener. This field is required if
	// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
	// if the Protocol field is "HTTP", "TCP", or "UDP".
	//
	// The association of SNIs to Certificate defined in GatewayTLSConfig is
	// defined based on the Hostname field for this listener.
	//
	// The GatewayClass MUST use the longest matching SNI out of all
	// available certificates for any TLS handshake.
	//
	// Support: Core
	Tls GatewaySpecListenersTlsPtrInput `pulumi:"tls"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersArgs
func (val *GatewaySpecListenersArgs) Defaults() *GatewaySpecListenersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GatewaySpecListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListeners)(nil)).Elem()
}

func (i GatewaySpecListenersArgs) ToGatewaySpecListenersOutput() GatewaySpecListenersOutput {
	return i.ToGatewaySpecListenersOutputWithContext(context.Background())
}

func (i GatewaySpecListenersArgs) ToGatewaySpecListenersOutputWithContext(ctx context.Context) GatewaySpecListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersOutput)
}

// GatewaySpecListenersArrayInput is an input type that accepts GatewaySpecListenersArray and GatewaySpecListenersArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersArrayInput` via:
//
//	GatewaySpecListenersArray{ GatewaySpecListenersArgs{...} }
type GatewaySpecListenersArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput
	ToGatewaySpecListenersArrayOutputWithContext(context.Context) GatewaySpecListenersArrayOutput
}

type GatewaySpecListenersArray []GatewaySpecListenersInput

func (GatewaySpecListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListeners)(nil)).Elem()
}

func (i GatewaySpecListenersArray) ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput {
	return i.ToGatewaySpecListenersArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersArray) ToGatewaySpecListenersArrayOutputWithContext(ctx context.Context) GatewaySpecListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersArrayOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListeners)(nil)).Elem()
}

func (o GatewaySpecListenersOutput) ToGatewaySpecListenersOutput() GatewaySpecListenersOutput {
	return o
}

func (o GatewaySpecListenersOutput) ToGatewaySpecListenersOutputWithContext(ctx context.Context) GatewaySpecListenersOutput {
	return o
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
func (o GatewaySpecListenersOutput) AllowedRoutes() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *GatewaySpecListenersAllowedRoutes { return v.AllowedRoutes }).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// Support: Core
func (o GatewaySpecListenersOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// Gateway.
//
// Support: Core
func (o GatewaySpecListenersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpecListeners) string { return v.Name }).(pulumi.StringOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
//
// Support: Core
func (o GatewaySpecListenersOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v GatewaySpecListeners) int { return v.Port }).(pulumi.IntOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
//
// Support: Core
func (o GatewaySpecListenersOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpecListeners) string { return v.Protocol }).(pulumi.StringOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
func (o GatewaySpecListenersOutput) Tls() GatewaySpecListenersTlsPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *GatewaySpecListenersTls { return v.Tls }).(GatewaySpecListenersTlsPtrOutput)
}

type GatewaySpecListenersArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListeners)(nil)).Elem()
}

func (o GatewaySpecListenersArrayOutput) ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput {
	return o
}

func (o GatewaySpecListenersArrayOutput) ToGatewaySpecListenersArrayOutputWithContext(ctx context.Context) GatewaySpecListenersArrayOutput {
	return o
}

func (o GatewaySpecListenersArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListeners {
		return vs[0].([]GatewaySpecListeners)[vs[1].(int)]
	}).(GatewaySpecListenersOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutes struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds []GatewaySpecListenersAllowedRoutesKinds `pulumi:"kinds"`
	// Namespaces indicates namespaces from which Routes may be attached to this
	// Listener. This is restricted to the namespace of this Gateway by default.
	//
	// Support: Core
	Namespaces *GatewaySpecListenersAllowedRoutesNamespaces `pulumi:"namespaces"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutes
func (val *GatewaySpecListenersAllowedRoutes) Defaults() *GatewaySpecListenersAllowedRoutes {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Namespaces = tmp.Namespaces.Defaults()

	return &tmp
}

// GatewaySpecListenersAllowedRoutesInput is an input type that accepts GatewaySpecListenersAllowedRoutesArgs and GatewaySpecListenersAllowedRoutesOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesInput` via:
//
//	GatewaySpecListenersAllowedRoutesArgs{...}
type GatewaySpecListenersAllowedRoutesInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput
	ToGatewaySpecListenersAllowedRoutesOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds GatewaySpecListenersAllowedRoutesKindsArrayInput `pulumi:"kinds"`
	// Namespaces indicates namespaces from which Routes may be attached to this
	// Listener. This is restricted to the namespace of this Gateway by default.
	//
	// Support: Core
	Namespaces GatewaySpecListenersAllowedRoutesNamespacesPtrInput `pulumi:"namespaces"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesArgs
func (val *GatewaySpecListenersAllowedRoutesArgs) Defaults() *GatewaySpecListenersAllowedRoutesArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GatewaySpecListenersAllowedRoutesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput {
	return i.ToGatewaySpecListenersAllowedRoutesOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesOutput)
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesOutput).ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesArgs, GatewaySpecListenersAllowedRoutesPtr and GatewaySpecListenersAllowedRoutesPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput
	ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPtrOutput
}

type gatewaySpecListenersAllowedRoutesPtrType GatewaySpecListenersAllowedRoutesArgs

func GatewaySpecListenersAllowedRoutesPtr(v *GatewaySpecListenersAllowedRoutesArgs) GatewaySpecListenersAllowedRoutesPtrInput {
	return (*gatewaySpecListenersAllowedRoutesPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesPtrType) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesPtrType) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutes {
		return &v
	}).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutes) []GatewaySpecListenersAllowedRoutesKinds { return v.Kinds }).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutesNamespaces {
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

type GatewaySpecListenersAllowedRoutesPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) Elem() GatewaySpecListenersAllowedRoutesOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) GatewaySpecListenersAllowedRoutes {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutes
		return ret
	}).(GatewaySpecListenersAllowedRoutesOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPtrOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) []GatewaySpecListenersAllowedRoutesKinds {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPtrOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutesNamespaces {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind string `pulumi:"kind"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesKinds
func (val *GatewaySpecListenersAllowedRoutesKinds) Defaults() *GatewaySpecListenersAllowedRoutesKinds {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	return &tmp
}

// GatewaySpecListenersAllowedRoutesKindsInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsArgs and GatewaySpecListenersAllowedRoutesKindsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsArgs{...}
type GatewaySpecListenersAllowedRoutesKindsInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput
	ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringInput `pulumi:"kind"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesKindsArgs
func (val *GatewaySpecListenersAllowedRoutesKindsArgs) Defaults() *GatewaySpecListenersAllowedRoutesKindsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	return &tmp
}
func (GatewaySpecListenersAllowedRoutesKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsArgs) ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsArgs) ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsOutput)
}

// GatewaySpecListenersAllowedRoutesKindsArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsArray and GatewaySpecListenersAllowedRoutesKindsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsArray{ GatewaySpecListenersAllowedRoutesKindsArgs{...} }
type GatewaySpecListenersAllowedRoutesKindsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput
	ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput
}

type GatewaySpecListenersAllowedRoutesKindsArray []GatewaySpecListenersAllowedRoutesKindsInput

func (GatewaySpecListenersAllowedRoutesKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsArray) ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsArray) ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsOutput) ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsOutput) ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsOutput {
	return o
}

// Group is the group of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKinds) string { return v.Kind }).(pulumi.StringOutput)
}

type GatewaySpecListenersAllowedRoutesKindsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesKinds {
		return vs[0].([]GatewaySpecListenersAllowedRoutesKinds)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesKindsOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespaces struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From *string `pulumi:"from"`
	// Selector must be specified when From is set to "Selector". In that case,
	// only Routes in Namespaces matching this Selector will be selected by this
	// Gateway. This field is ignored for other values of "From".
	//
	// Support: Core
	Selector *GatewaySpecListenersAllowedRoutesNamespacesSelector `pulumi:"selector"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesNamespaces
func (val *GatewaySpecListenersAllowedRoutesNamespaces) Defaults() *GatewaySpecListenersAllowedRoutesNamespaces {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.From == nil {
		from_ := "Same"
		tmp.From = &from_
	}
	return &tmp
}

// GatewaySpecListenersAllowedRoutesNamespacesInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesArgs and GatewaySpecListenersAllowedRoutesNamespacesOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From pulumi.StringPtrInput `pulumi:"from"`
	// Selector must be specified when From is set to "Selector". In that case,
	// only Routes in Namespaces matching this Selector will be selected by this
	// Gateway. This field is ignored for other values of "From".
	//
	// Support: Core
	Selector GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput `pulumi:"selector"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesNamespacesArgs
func (val *GatewaySpecListenersAllowedRoutesNamespacesArgs) Defaults() *GatewaySpecListenersAllowedRoutesNamespacesArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.From == nil {
		tmp.From = pulumi.StringPtr("Same")
	}
	return &tmp
}
func (GatewaySpecListenersAllowedRoutesNamespacesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesOutput).ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesArgs, GatewaySpecListenersAllowedRoutesNamespacesPtr and GatewaySpecListenersAllowedRoutesNamespacesPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesPtrType GatewaySpecListenersAllowedRoutesNamespacesArgs

func GatewaySpecListenersAllowedRoutesNamespacesPtr(v *GatewaySpecListenersAllowedRoutesNamespacesArgs) GatewaySpecListenersAllowedRoutesNamespacesPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespaces {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespaces) *string { return v.From }).(pulumi.StringPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) GatewaySpecListenersAllowedRoutesNamespaces {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespaces
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput).ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs, GatewaySpecListenersAllowedRoutesNamespacesSelectorPtr and GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs

func GatewaySpecListenersAllowedRoutesNamespacesSelectorPtr(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesSelector) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelector) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) GatewaySpecListenersAllowedRoutesNamespacesSelector {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesSelector
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{ GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...} }
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return vs[0].([]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchLabels struct {
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTls struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs []GatewaySpecListenersTlsCertificateRefs `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersTls
func (val *GatewaySpecListenersTls) Defaults() *GatewaySpecListenersTls {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Terminate"
		tmp.Mode = &mode_
	}
	return &tmp
}

// GatewaySpecListenersTlsInput is an input type that accepts GatewaySpecListenersTlsArgs and GatewaySpecListenersTlsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsInput` via:
//
//	GatewaySpecListenersTlsArgs{...}
type GatewaySpecListenersTlsInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput
	ToGatewaySpecListenersTlsOutputWithContext(context.Context) GatewaySpecListenersTlsOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs GatewaySpecListenersTlsCertificateRefsArrayInput `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersTlsArgs
func (val *GatewaySpecListenersTlsArgs) Defaults() *GatewaySpecListenersTlsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		tmp.Mode = pulumi.StringPtr("Terminate")
	}
	return &tmp
}
func (GatewaySpecListenersTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTls)(nil)).Elem()
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput {
	return i.ToGatewaySpecListenersTlsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsOutput)
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return i.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsOutput).ToGatewaySpecListenersTlsPtrOutputWithContext(ctx)
}

// GatewaySpecListenersTlsPtrInput is an input type that accepts GatewaySpecListenersTlsArgs, GatewaySpecListenersTlsPtr and GatewaySpecListenersTlsPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPtrInput` via:
//
//	        GatewaySpecListenersTlsArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersTlsPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput
	ToGatewaySpecListenersTlsPtrOutputWithContext(context.Context) GatewaySpecListenersTlsPtrOutput
}

type gatewaySpecListenersTlsPtrType GatewaySpecListenersTlsArgs

func GatewaySpecListenersTlsPtr(v *GatewaySpecListenersTlsArgs) GatewaySpecListenersTlsPtrInput {
	return (*gatewaySpecListenersTlsPtrType)(v)
}

func (*gatewaySpecListenersTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTls)(nil)).Elem()
}

func (i *gatewaySpecListenersTlsPtrType) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return i.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersTlsPtrType) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTls)(nil)).Elem()
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput {
	return o
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsOutput {
	return o
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return o.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersTls) *GatewaySpecListenersTls {
		return &v
	}).(GatewaySpecListenersTlsPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) []GatewaySpecListenersTlsCertificateRefs { return v.CertificateRefs }).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersTlsPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTls)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPtrOutput) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPtrOutput) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPtrOutput) Elem() GatewaySpecListenersTlsOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) GatewaySpecListenersTls {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersTls
		return ret
	}).(GatewaySpecListenersTlsOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPtrOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) []GatewaySpecListenersTlsCertificateRefs {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersTlsCertificateRefs
func (val *GatewaySpecListenersTlsCertificateRefs) Defaults() *GatewaySpecListenersTlsCertificateRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Secret"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GatewaySpecListenersTlsCertificateRefsInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsArgs and GatewaySpecListenersTlsCertificateRefsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsArgs{...}
type GatewaySpecListenersTlsCertificateRefsInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput
	ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

// Defaults sets the appropriate defaults for GatewaySpecListenersTlsCertificateRefsArgs
func (val *GatewaySpecListenersTlsCertificateRefsArgs) Defaults() *GatewaySpecListenersTlsCertificateRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Secret")
	}
	return &tmp
}
func (GatewaySpecListenersTlsCertificateRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsArgs) ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsArgs) ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsOutput)
}

// GatewaySpecListenersTlsCertificateRefsArrayInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsArray and GatewaySpecListenersTlsCertificateRefsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsArrayInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsArray{ GatewaySpecListenersTlsCertificateRefsArgs{...} }
type GatewaySpecListenersTlsCertificateRefsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput
	ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput
}

type GatewaySpecListenersTlsCertificateRefsArray []GatewaySpecListenersTlsCertificateRefsInput

func (GatewaySpecListenersTlsCertificateRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsArray) ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsArray) ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsOutput) ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsOutput) ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GatewaySpecListenersTlsCertificateRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o GatewaySpecListenersTlsCertificateRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewaySpecListenersTlsCertificateRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GatewaySpecListenersTlsCertificateRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersTlsCertificateRefsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersTlsCertificateRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersTlsCertificateRefs {
		return vs[0].([]GatewaySpecListenersTlsCertificateRefs)[vs[1].(int)]
	}).(GatewaySpecListenersTlsCertificateRefsOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
type GatewaySpecListenersTlsOptions struct {
}

// Status defines the current state of Gateway.
type GatewayStatus struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses []interface{} `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions []GatewayStatusConditions `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []GatewayStatusListeners `pulumi:"listeners"`
}

// GatewayStatusInput is an input type that accepts GatewayStatusArgs and GatewayStatusOutput values.
// You can construct a concrete instance of `GatewayStatusInput` via:
//
//	GatewayStatusArgs{...}
type GatewayStatusInput interface {
	pulumi.Input

	ToGatewayStatusOutput() GatewayStatusOutput
	ToGatewayStatusOutputWithContext(context.Context) GatewayStatusOutput
}

// Status defines the current state of Gateway.
type GatewayStatusArgs struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses pulumi.ArrayInput `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions GatewayStatusConditionsArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners GatewayStatusListenersArrayInput `pulumi:"listeners"`
}

func (GatewayStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatus)(nil)).Elem()
}

func (i GatewayStatusArgs) ToGatewayStatusOutput() GatewayStatusOutput {
	return i.ToGatewayStatusOutputWithContext(context.Background())
}

func (i GatewayStatusArgs) ToGatewayStatusOutputWithContext(ctx context.Context) GatewayStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusOutput)
}

func (i GatewayStatusArgs) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return i.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (i GatewayStatusArgs) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusOutput).ToGatewayStatusPtrOutputWithContext(ctx)
}

// GatewayStatusPtrInput is an input type that accepts GatewayStatusArgs, GatewayStatusPtr and GatewayStatusPtrOutput values.
// You can construct a concrete instance of `GatewayStatusPtrInput` via:
//
//	        GatewayStatusArgs{...}
//
//	or:
//
//	        nil
type GatewayStatusPtrInput interface {
	pulumi.Input

	ToGatewayStatusPtrOutput() GatewayStatusPtrOutput
	ToGatewayStatusPtrOutputWithContext(context.Context) GatewayStatusPtrOutput
}

type gatewayStatusPtrType GatewayStatusArgs

func GatewayStatusPtr(v *GatewayStatusArgs) GatewayStatusPtrInput {
	return (*gatewayStatusPtrType)(v)
}

func (*gatewayStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatus)(nil)).Elem()
}

func (i *gatewayStatusPtrType) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return i.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (i *gatewayStatusPtrType) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPtrOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusOutput struct{ *pulumi.OutputState }

func (GatewayStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatus)(nil)).Elem()
}

func (o GatewayStatusOutput) ToGatewayStatusOutput() GatewayStatusOutput {
	return o
}

func (o GatewayStatusOutput) ToGatewayStatusOutputWithContext(ctx context.Context) GatewayStatusOutput {
	return o
}

func (o GatewayStatusOutput) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return o.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (o GatewayStatusOutput) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayStatus) *GatewayStatus {
		return &v
	}).(GatewayStatusPtrOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusOutput) Addresses() pulumi.ArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []interface{} { return v.Addresses }).(pulumi.ArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusOutput) Conditions() GatewayStatusConditionsArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusConditions { return v.Conditions }).(GatewayStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusOutput) Listeners() GatewayStatusListenersArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusListeners { return v.Listeners }).(GatewayStatusListenersArrayOutput)
}

type GatewayStatusPtrOutput struct{ *pulumi.OutputState }

func (GatewayStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatus)(nil)).Elem()
}

func (o GatewayStatusPtrOutput) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return o
}

func (o GatewayStatusPtrOutput) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return o
}

func (o GatewayStatusPtrOutput) Elem() GatewayStatusOutput {
	return o.ApplyT(func(v *GatewayStatus) GatewayStatus {
		if v != nil {
			return *v
		}
		var ret GatewayStatus
		return ret
	}).(GatewayStatusOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPtrOutput) Addresses() pulumi.ArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []interface{} {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(pulumi.ArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPtrOutput) Conditions() GatewayStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPtrOutput) Listeners() GatewayStatusListenersArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewayStatusListenersArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// GatewayStatusConditionsInput is an input type that accepts GatewayStatusConditionsArgs and GatewayStatusConditionsOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsInput` via:
//
//	GatewayStatusConditionsArgs{...}
type GatewayStatusConditionsInput interface {
	pulumi.Input

	ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput
	ToGatewayStatusConditionsOutputWithContext(context.Context) GatewayStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (GatewayStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditions)(nil)).Elem()
}

func (i GatewayStatusConditionsArgs) ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput {
	return i.ToGatewayStatusConditionsOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsArgs) ToGatewayStatusConditionsOutputWithContext(ctx context.Context) GatewayStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsOutput)
}

// GatewayStatusConditionsArrayInput is an input type that accepts GatewayStatusConditionsArray and GatewayStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsArrayInput` via:
//
//	GatewayStatusConditionsArray{ GatewayStatusConditionsArgs{...} }
type GatewayStatusConditionsArrayInput interface {
	pulumi.Input

	ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput
	ToGatewayStatusConditionsArrayOutputWithContext(context.Context) GatewayStatusConditionsArrayOutput
}

type GatewayStatusConditionsArray []GatewayStatusConditionsInput

func (GatewayStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditions)(nil)).Elem()
}

func (i GatewayStatusConditionsArray) ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput {
	return i.ToGatewayStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsArray) ToGatewayStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditions)(nil)).Elem()
}

func (o GatewayStatusConditionsOutput) ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput {
	return o
}

func (o GatewayStatusConditionsOutput) ToGatewayStatusConditionsOutputWithContext(ctx context.Context) GatewayStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type GatewayStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditions)(nil)).Elem()
}

func (o GatewayStatusConditionsArrayOutput) ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput {
	return o
}

func (o GatewayStatusConditionsArrayOutput) ToGatewayStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsArrayOutput {
	return o
}

func (o GatewayStatusConditionsArrayOutput) Index(i pulumi.IntInput) GatewayStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusConditions {
		return vs[0].([]GatewayStatusConditions)[vs[1].(int)]
	}).(GatewayStatusConditionsOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListeners struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []GatewayStatusListenersConditions `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name string `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []GatewayStatusListenersSupportedKinds `pulumi:"supportedKinds"`
}

// GatewayStatusListenersInput is an input type that accepts GatewayStatusListenersArgs and GatewayStatusListenersOutput values.
// You can construct a concrete instance of `GatewayStatusListenersInput` via:
//
//	GatewayStatusListenersArgs{...}
type GatewayStatusListenersInput interface {
	pulumi.Input

	ToGatewayStatusListenersOutput() GatewayStatusListenersOutput
	ToGatewayStatusListenersOutputWithContext(context.Context) GatewayStatusListenersOutput
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions GatewayStatusListenersConditionsArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringInput `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds GatewayStatusListenersSupportedKindsArrayInput `pulumi:"supportedKinds"`
}

func (GatewayStatusListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListeners)(nil)).Elem()
}

func (i GatewayStatusListenersArgs) ToGatewayStatusListenersOutput() GatewayStatusListenersOutput {
	return i.ToGatewayStatusListenersOutputWithContext(context.Background())
}

func (i GatewayStatusListenersArgs) ToGatewayStatusListenersOutputWithContext(ctx context.Context) GatewayStatusListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersOutput)
}

// GatewayStatusListenersArrayInput is an input type that accepts GatewayStatusListenersArray and GatewayStatusListenersArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersArrayInput` via:
//
//	GatewayStatusListenersArray{ GatewayStatusListenersArgs{...} }
type GatewayStatusListenersArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput
	ToGatewayStatusListenersArrayOutputWithContext(context.Context) GatewayStatusListenersArrayOutput
}

type GatewayStatusListenersArray []GatewayStatusListenersInput

func (GatewayStatusListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListeners)(nil)).Elem()
}

func (i GatewayStatusListenersArray) ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput {
	return i.ToGatewayStatusListenersArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersArray) ToGatewayStatusListenersArrayOutputWithContext(ctx context.Context) GatewayStatusListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListeners)(nil)).Elem()
}

func (o GatewayStatusListenersOutput) ToGatewayStatusListenersOutput() GatewayStatusListenersOutput {
	return o
}

func (o GatewayStatusListenersOutput) ToGatewayStatusListenersOutputWithContext(ctx context.Context) GatewayStatusListenersOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o GatewayStatusListenersOutput) AttachedRoutes() pulumi.IntOutput {
	return o.ApplyT(func(v GatewayStatusListeners) int { return v.AttachedRoutes }).(pulumi.IntOutput)
}

// Conditions describe the current condition of this listener.
func (o GatewayStatusListenersOutput) Conditions() GatewayStatusListenersConditionsArrayOutput {
	return o.ApplyT(func(v GatewayStatusListeners) []GatewayStatusListenersConditions { return v.Conditions }).(GatewayStatusListenersConditionsArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o GatewayStatusListenersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListeners) string { return v.Name }).(pulumi.StringOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o GatewayStatusListenersOutput) SupportedKinds() GatewayStatusListenersSupportedKindsArrayOutput {
	return o.ApplyT(func(v GatewayStatusListeners) []GatewayStatusListenersSupportedKinds { return v.SupportedKinds }).(GatewayStatusListenersSupportedKindsArrayOutput)
}

type GatewayStatusListenersArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListeners)(nil)).Elem()
}

func (o GatewayStatusListenersArrayOutput) ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput {
	return o
}

func (o GatewayStatusListenersArrayOutput) ToGatewayStatusListenersArrayOutputWithContext(ctx context.Context) GatewayStatusListenersArrayOutput {
	return o
}

func (o GatewayStatusListenersArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListeners {
		return vs[0].([]GatewayStatusListeners)[vs[1].(int)]
	}).(GatewayStatusListenersOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// GatewayStatusListenersConditionsInput is an input type that accepts GatewayStatusListenersConditionsArgs and GatewayStatusListenersConditionsOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsInput` via:
//
//	GatewayStatusListenersConditionsArgs{...}
type GatewayStatusListenersConditionsInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput
	ToGatewayStatusListenersConditionsOutputWithContext(context.Context) GatewayStatusListenersConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (GatewayStatusListenersConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditions)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsArgs) ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput {
	return i.ToGatewayStatusListenersConditionsOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsArgs) ToGatewayStatusListenersConditionsOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsOutput)
}

// GatewayStatusListenersConditionsArrayInput is an input type that accepts GatewayStatusListenersConditionsArray and GatewayStatusListenersConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsArrayInput` via:
//
//	GatewayStatusListenersConditionsArray{ GatewayStatusListenersConditionsArgs{...} }
type GatewayStatusListenersConditionsArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput
	ToGatewayStatusListenersConditionsArrayOutputWithContext(context.Context) GatewayStatusListenersConditionsArrayOutput
}

type GatewayStatusListenersConditionsArray []GatewayStatusListenersConditionsInput

func (GatewayStatusListenersConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditions)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsArray) ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput {
	return i.ToGatewayStatusListenersConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsArray) ToGatewayStatusListenersConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditions)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsOutput) ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput {
	return o
}

func (o GatewayStatusListenersConditionsOutput) ToGatewayStatusListenersConditionsOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusListenersConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusListenersConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusListenersConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusListenersConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusListenersConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusListenersConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) string { return v.Type }).(pulumi.StringOutput)
}

type GatewayStatusListenersConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditions)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsArrayOutput) ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsArrayOutput) ToGatewayStatusListenersConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersConditions {
		return vs[0].([]GatewayStatusListenersConditions)[vs[1].(int)]
	}).(GatewayStatusListenersConditionsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind string `pulumi:"kind"`
}

// Defaults sets the appropriate defaults for GatewayStatusListenersSupportedKinds
func (val *GatewayStatusListenersSupportedKinds) Defaults() *GatewayStatusListenersSupportedKinds {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	return &tmp
}

// GatewayStatusListenersSupportedKindsInput is an input type that accepts GatewayStatusListenersSupportedKindsArgs and GatewayStatusListenersSupportedKindsOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsInput` via:
//
//	GatewayStatusListenersSupportedKindsArgs{...}
type GatewayStatusListenersSupportedKindsInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput
	ToGatewayStatusListenersSupportedKindsOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringInput `pulumi:"kind"`
}

// Defaults sets the appropriate defaults for GatewayStatusListenersSupportedKindsArgs
func (val *GatewayStatusListenersSupportedKindsArgs) Defaults() *GatewayStatusListenersSupportedKindsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	return &tmp
}
func (GatewayStatusListenersSupportedKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsArgs) ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput {
	return i.ToGatewayStatusListenersSupportedKindsOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsArgs) ToGatewayStatusListenersSupportedKindsOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsOutput)
}

// GatewayStatusListenersSupportedKindsArrayInput is an input type that accepts GatewayStatusListenersSupportedKindsArray and GatewayStatusListenersSupportedKindsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsArrayInput` via:
//
//	GatewayStatusListenersSupportedKindsArray{ GatewayStatusListenersSupportedKindsArgs{...} }
type GatewayStatusListenersSupportedKindsArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput
	ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsArrayOutput
}

type GatewayStatusListenersSupportedKindsArray []GatewayStatusListenersSupportedKindsInput

func (GatewayStatusListenersSupportedKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsArray) ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput {
	return i.ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsArray) ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsOutput) ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsOutput) ToGatewayStatusListenersSupportedKindsOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsOutput {
	return o
}

// Group is the group of the Route.
func (o GatewayStatusListenersSupportedKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewayStatusListenersSupportedKindsOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKinds) string { return v.Kind }).(pulumi.StringOutput)
}

type GatewayStatusListenersSupportedKindsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersSupportedKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersSupportedKinds {
		return vs[0].([]GatewayStatusListenersSupportedKinds)[vs[1].(int)]
	}).(GatewayStatusListenersSupportedKindsOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of HTTPRoute.
	Spec HTTPRouteSpec `pulumi:"spec"`
	// Status defines the current state of HTTPRoute.
	Status *HTTPRouteStatus `pulumi:"status"`
}

type HTTPRouteMetadata struct {
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpec struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []HTTPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules []HTTPRouteSpecRules `pulumi:"rules"`
}

// HTTPRouteSpecInput is an input type that accepts HTTPRouteSpecArgs and HTTPRouteSpecOutput values.
// You can construct a concrete instance of `HTTPRouteSpecInput` via:
//
//	HTTPRouteSpecArgs{...}
type HTTPRouteSpecInput interface {
	pulumi.Input

	ToHTTPRouteSpecOutput() HTTPRouteSpecOutput
	ToHTTPRouteSpecOutputWithContext(context.Context) HTTPRouteSpecOutput
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecArgs struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs HTTPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules HTTPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (HTTPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpec)(nil)).Elem()
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecOutput() HTTPRouteSpecOutput {
	return i.ToHTTPRouteSpecOutputWithContext(context.Background())
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecOutputWithContext(ctx context.Context) HTTPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecOutput)
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return i.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecOutput).ToHTTPRouteSpecPtrOutputWithContext(ctx)
}

// HTTPRouteSpecPtrInput is an input type that accepts HTTPRouteSpecArgs, HTTPRouteSpecPtr and HTTPRouteSpecPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPtrInput` via:
//
//	        HTTPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput
	ToHTTPRouteSpecPtrOutputWithContext(context.Context) HTTPRouteSpecPtrOutput
}

type httprouteSpecPtrType HTTPRouteSpecArgs

func HTTPRouteSpecPtr(v *HTTPRouteSpecArgs) HTTPRouteSpecPtrInput {
	return (*httprouteSpecPtrType)(v)
}

func (*httprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpec)(nil)).Elem()
}

func (i *httprouteSpecPtrType) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return i.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecPtrType) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpec)(nil)).Elem()
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecOutput() HTTPRouteSpecOutput {
	return o
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecOutputWithContext(ctx context.Context) HTTPRouteSpecOutput {
	return o
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return o.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpec) *HTTPRouteSpec {
		return &v
	}).(HTTPRouteSpecPtrOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecOutput) ParentRefs() HTTPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []HTTPRouteSpecParentRefs { return v.ParentRefs }).(HTTPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecOutput) Rules() HTTPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []HTTPRouteSpecRules { return v.Rules }).(HTTPRouteSpecRulesArrayOutput)
}

type HTTPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpec)(nil)).Elem()
}

func (o HTTPRouteSpecPtrOutput) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return o
}

func (o HTTPRouteSpecPtrOutput) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return o
}

func (o HTTPRouteSpecPtrOutput) Elem() HTTPRouteSpecOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) HTTPRouteSpec {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpec
		return ret
	}).(HTTPRouteSpecOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPtrOutput) ParentRefs() HTTPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []HTTPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(HTTPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPtrOutput) Rules() HTTPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []HTTPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(HTTPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecParentRefs
func (val *HTTPRouteSpecParentRefs) Defaults() *HTTPRouteSpecParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// HTTPRouteSpecParentRefsInput is an input type that accepts HTTPRouteSpecParentRefsArgs and HTTPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsInput` via:
//
//	HTTPRouteSpecParentRefsArgs{...}
type HTTPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput
	ToHTTPRouteSpecParentRefsOutputWithContext(context.Context) HTTPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecParentRefsArgs
func (val *HTTPRouteSpecParentRefsArgs) Defaults() *HTTPRouteSpecParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (HTTPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsArgs) ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput {
	return i.ToHTTPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsArgs) ToHTTPRouteSpecParentRefsOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsOutput)
}

// HTTPRouteSpecParentRefsArrayInput is an input type that accepts HTTPRouteSpecParentRefsArray and HTTPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsArrayInput` via:
//
//	HTTPRouteSpecParentRefsArray{ HTTPRouteSpecParentRefsArgs{...} }
type HTTPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput
	ToHTTPRouteSpecParentRefsArrayOutputWithContext(context.Context) HTTPRouteSpecParentRefsArrayOutput
}

type HTTPRouteSpecParentRefsArray []HTTPRouteSpecParentRefsInput

func (HTTPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsArray) ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput {
	return i.ToHTTPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsArray) ToHTTPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsOutput) ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput {
	return o
}

func (o HTTPRouteSpecParentRefsOutput) ToHTTPRouteSpecParentRefsOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsArrayOutput) ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsArrayOutput) ToHTTPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecParentRefs {
		return vs[0].([]HTTPRouteSpecParentRefs)[vs[1].(int)]
	}).(HTTPRouteSpecParentRefsOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []HTTPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []HTTPRouteSpecRulesFilters `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches []HTTPRouteSpecRulesMatches `pulumi:"matches"`
}

// HTTPRouteSpecRulesInput is an input type that accepts HTTPRouteSpecRulesArgs and HTTPRouteSpecRulesOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesInput` via:
//
//	HTTPRouteSpecRulesArgs{...}
type HTTPRouteSpecRulesInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput
	ToHTTPRouteSpecRulesOutputWithContext(context.Context) HTTPRouteSpecRulesOutput
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs HTTPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters HTTPRouteSpecRulesFiltersArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches HTTPRouteSpecRulesMatchesArrayInput `pulumi:"matches"`
}

func (HTTPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRules)(nil)).Elem()
}

func (i HTTPRouteSpecRulesArgs) ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput {
	return i.ToHTTPRouteSpecRulesOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesArgs) ToHTTPRouteSpecRulesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesOutput)
}

// HTTPRouteSpecRulesArrayInput is an input type that accepts HTTPRouteSpecRulesArray and HTTPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesArrayInput` via:
//
//	HTTPRouteSpecRulesArray{ HTTPRouteSpecRulesArgs{...} }
type HTTPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput
	ToHTTPRouteSpecRulesArrayOutputWithContext(context.Context) HTTPRouteSpecRulesArrayOutput
}

type HTTPRouteSpecRulesArray []HTTPRouteSpecRulesInput

func (HTTPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRules)(nil)).Elem()
}

func (i HTTPRouteSpecRulesArray) ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput {
	return i.ToHTTPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesArray) ToHTTPRouteSpecRulesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRules)(nil)).Elem()
}

func (o HTTPRouteSpecRulesOutput) ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput {
	return o
}

func (o HTTPRouteSpecRulesOutput) ToHTTPRouteSpecRulesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive a 500 status code.
//
// See the HTTPBackendRef definition for the rules about what makes a single
// HTTPBackendRef invalid.
//
// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive a 500 status code.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic must receive a 500. Implementations may
// choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o HTTPRouteSpecRulesOutput) BackendRefs() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesBackendRefs { return v.BackendRefs }).(HTTPRouteSpecRulesBackendRefsArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// Wherever possible, implementations SHOULD implement filters in the order
// they are specified.
//
// Implementations MAY choose to implement this ordering strictly, rejecting
// any combination or order of filters that can not be supported. If implementations
// choose a strict interpretation of filter ordering, they MUST clearly document
// that behavior.
//
// To reject an invalid combination or order of filters, implementations SHOULD
// consider the Route Rules with this configuration invalid. If all Route Rules
// in a Route are invalid, the entire Route would be considered invalid. If only
// a portion of Route Rules are invalid, implementations MUST set the
// "PartiallyInvalid" condition for the Route.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// All filters are expected to be compatible with each other except for the
// URLRewrite and RequestRedirect filters, which may not be combined. If an
// implementation can not support other combinations of filters, they must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o HTTPRouteSpecRulesOutput) Filters() HTTPRouteSpecRulesFiltersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesFilters { return v.Filters }).(HTTPRouteSpecRulesFiltersArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// HTTP requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, a request must satisfy
// EITHER of the two conditions:
//
// - path prefixed with `/foo` AND contains the header `version: v2`
// - path prefix of `/v2/foo`
//
// See the documentation for HTTPRouteMatch on how to specify multiple
// match conditions that should be ANDed together.
//
// If no matches are specified, the default is a prefix
// path match on "/", which has the effect of matching every
// HTTP request.
//
// Proxy or Load Balancer routing configuration generated from HTTPRoutes
// MUST prioritize matches based on the following criteria, continuing on
// ties. Across all rules specified on applicable Routes, precedence must be
// given to the match having:
//
// * "Exact" path match.
// * "Prefix" path match with largest number of characters.
// * Method match.
// * Largest number of header matches.
// * Largest number of query param matches.
//
// Note: The precedence of RegularExpression path matches are implementation-specific.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within an HTTPRoute, matching precedence MUST be granted
// to the FIRST matching rule (in list order) with a match meeting the above
// criteria.
//
// When no rules matching a request have been successfully attached to the
// parent a request is coming from, a HTTP 404 status code MUST be returned.
func (o HTTPRouteSpecRulesOutput) Matches() HTTPRouteSpecRulesMatchesArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesMatches { return v.Matches }).(HTTPRouteSpecRulesMatchesArrayOutput)
}

type HTTPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRules)(nil)).Elem()
}

func (o HTTPRouteSpecRulesArrayOutput) ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesArrayOutput) ToHTTPRouteSpecRulesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRules {
		return vs[0].([]HTTPRouteSpecRules)[vs[1].(int)]
	}).(HTTPRouteSpecRulesOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters []HTTPRouteSpecRulesBackendRefsFilters `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefs
func (val *HTTPRouteSpecRulesBackendRefs) Defaults() *HTTPRouteSpecRulesBackendRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	if tmp.Weight == nil {
		weight_ := 1
		tmp.Weight = &weight_
	}
	return &tmp
}

// HTTPRouteSpecRulesBackendRefsInput is an input type that accepts HTTPRouteSpecRulesBackendRefsArgs and HTTPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsInput` via:
//
//	HTTPRouteSpecRulesBackendRefsArgs{...}
type HTTPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput
	ToHTTPRouteSpecRulesBackendRefsOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsOutput
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsArgs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters HTTPRouteSpecRulesBackendRefsFiltersArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsArgs
func (val *HTTPRouteSpecRulesBackendRefsArgs) Defaults() *HTTPRouteSpecRulesBackendRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	if tmp.Weight == nil {
		tmp.Weight = pulumi.IntPtr(1)
	}
	return &tmp
}
func (HTTPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsArgs) ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsArgs) ToHTTPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsOutput)
}

// HTTPRouteSpecRulesBackendRefsArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsArray and HTTPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsArray{ HTTPRouteSpecRulesBackendRefsArgs{...} }
type HTTPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput
	ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput
}

type HTTPRouteSpecRulesBackendRefsArray []HTTPRouteSpecRulesBackendRefsInput

func (HTTPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsArray) ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsArray) ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsArrayOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsOutput) ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsOutput) ToHTTPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsOutput {
	return o
}

// Filters defined at this level should be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in HTTPRouteRule.)
func (o HTTPRouteSpecRulesBackendRefsOutput) Filters() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) []HTTPRouteSpecRulesBackendRefsFilters { return v.Filters }).(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o HTTPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefs {
		return vs[0].([]HTTPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFilters struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// This filter can be used multiple times within the same rule.
	//
	// Support: Implementation-specific
	ExtensionRef *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror `pulumi:"requestMirror"`
	// RequestRedirect defines a schema for a filter that responds to the
	// request with an HTTP redirection.
	//
	// Support: Core
	RequestRedirect *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect `pulumi:"requestRedirect"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type string `pulumi:"type"`
	// URLRewrite defines a schema for a filter that modifies a request during forwarding.
	//
	// Support: Extended
	UrlRewrite *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite `pulumi:"urlRewrite"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFilters
func (val *HTTPRouteSpecRulesBackendRefsFilters) Defaults() *HTTPRouteSpecRulesBackendRefsFilters {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.RequestMirror = tmp.RequestMirror.Defaults()

	tmp.RequestRedirect = tmp.RequestRedirect.Defaults()

	return &tmp
}

// HTTPRouteSpecRulesBackendRefsFiltersInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersArgs and HTTPRouteSpecRulesBackendRefsFiltersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersArgs struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// This filter can be used multiple times within the same rule.
	//
	// Support: Implementation-specific
	ExtensionRef HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput `pulumi:"requestMirror"`
	// RequestRedirect defines a schema for a filter that responds to the
	// request with an HTTP redirection.
	//
	// Support: Core
	RequestRedirect HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput `pulumi:"requestRedirect"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringInput `pulumi:"type"`
	// URLRewrite defines a schema for a filter that modifies a request during forwarding.
	//
	// Support: Extended
	UrlRewrite HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput `pulumi:"urlRewrite"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersArgs
func (val *HTTPRouteSpecRulesBackendRefsFiltersArgs) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (HTTPRouteSpecRulesBackendRefsFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArgs) ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArgs) ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersArray and HTTPRouteSpecRulesBackendRefsFiltersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersArray{ HTTPRouteSpecRulesBackendRefsFiltersArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersArray []HTTPRouteSpecRulesBackendRefsFiltersInput

func (HTTPRouteSpecRulesBackendRefsFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArray) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArray) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ExtensionRef() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestMirror() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestRedirect() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ResponseHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) string { return v.Type }).(pulumi.StringOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) UrlRewrite() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		return v.UrlRewrite
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFilters {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFilters)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput).ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs, HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtr and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs

func HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtr(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Name }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersExtensionRef
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirror struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirror
func (val *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.BackendRef = *tmp.BackendRef.Defaults()

	return &tmp
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
func (val *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirror
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return &v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
func (val *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	return &tmp
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
func (val *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	return &tmp
}
func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Path defines parameters used to modify the path of the incoming request.
	// The modified path is then used to construct the `Location` header. When
	// empty, the request path is used as-is.
	//
	// Support: Extended
	Path *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect
func (val *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.StatusCode == nil {
		statusCode_ := 302
		tmp.StatusCode = &statusCode_
	}
	return &tmp
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Path defines parameters used to modify the path of the incoming request.
	// The modified path is then used to construct the `Location` header. When
	// empty, the request path is used as-is.
	//
	// Support: Extended
	Path HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs
func (val *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) Defaults() *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.StatusCode == nil {
		tmp.StatusCode = pulumi.IntPtr(302)
	}
	return &tmp
}
func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) string { return v.Type }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput).ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs, HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs

func HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string `pulumi:"hostname"`
	// Path defines a path rewrite.
	//
	// Support: Extended
	Path *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath `pulumi:"path"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Path defines a path rewrite.
	//
	// Support: Extended
	Path HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) string { return v.Type }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFilters struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// This filter can be used multiple times within the same rule.
	//
	// Support: Implementation-specific
	ExtensionRef *HTTPRouteSpecRulesFiltersExtensionRef `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier *HTTPRouteSpecRulesFiltersRequestHeaderModifier `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror *HTTPRouteSpecRulesFiltersRequestMirror `pulumi:"requestMirror"`
	// RequestRedirect defines a schema for a filter that responds to the
	// request with an HTTP redirection.
	//
	// Support: Core
	RequestRedirect *HTTPRouteSpecRulesFiltersRequestRedirect `pulumi:"requestRedirect"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier *HTTPRouteSpecRulesFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type string `pulumi:"type"`
	// URLRewrite defines a schema for a filter that modifies a request during forwarding.
	//
	// Support: Extended
	UrlRewrite *HTTPRouteSpecRulesFiltersUrlRewrite `pulumi:"urlRewrite"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFilters
func (val *HTTPRouteSpecRulesFilters) Defaults() *HTTPRouteSpecRulesFilters {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.RequestMirror = tmp.RequestMirror.Defaults()

	tmp.RequestRedirect = tmp.RequestRedirect.Defaults()

	return &tmp
}

// HTTPRouteSpecRulesFiltersInput is an input type that accepts HTTPRouteSpecRulesFiltersArgs and HTTPRouteSpecRulesFiltersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersInput` via:
//
//	HTTPRouteSpecRulesFiltersArgs{...}
type HTTPRouteSpecRulesFiltersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput
	ToHTTPRouteSpecRulesFiltersOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersArgs struct {
	// ExtensionRef is an optional, implementation-specific extension to the
	// "filter" behavior.  For example, resource "myroutefilter" in group
	// "networking.example.net"). ExtensionRef MUST NOT be used for core and
	// extended filters.
	//
	// This filter can be used multiple times within the same rule.
	//
	// Support: Implementation-specific
	ExtensionRef HTTPRouteSpecRulesFiltersExtensionRefPtrInput `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request
	// headers.
	//
	// Support: Core
	RequestHeaderModifier HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests.
	// Requests are sent to the specified destination, but responses from
	// that destination are ignored.
	//
	// This filter can be used multiple times within the same rule. Note that
	// not all implementations will be able to support mirroring to multiple
	// backends.
	//
	// Support: Extended
	RequestMirror HTTPRouteSpecRulesFiltersRequestMirrorPtrInput `pulumi:"requestMirror"`
	// RequestRedirect defines a schema for a filter that responds to the
	// request with an HTTP redirection.
	//
	// Support: Core
	RequestRedirect HTTPRouteSpecRulesFiltersRequestRedirectPtrInput `pulumi:"requestRedirect"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response
	// headers.
	//
	// Support: Extended
	ResponseHeaderModifier HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringInput `pulumi:"type"`
	// URLRewrite defines a schema for a filter that modifies a request during forwarding.
	//
	// Support: Extended
	UrlRewrite HTTPRouteSpecRulesFiltersUrlRewritePtrInput `pulumi:"urlRewrite"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersArgs
func (val *HTTPRouteSpecRulesFiltersArgs) Defaults() *HTTPRouteSpecRulesFiltersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (HTTPRouteSpecRulesFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersArgs) ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput {
	return i.ToHTTPRouteSpecRulesFiltersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersArgs) ToHTTPRouteSpecRulesFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersOutput)
}

// HTTPRouteSpecRulesFiltersArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersArray and HTTPRouteSpecRulesFiltersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersArray{ HTTPRouteSpecRulesFiltersArgs{...} }
type HTTPRouteSpecRulesFiltersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput
	ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersArrayOutput
}

type HTTPRouteSpecRulesFiltersArray []HTTPRouteSpecRulesFiltersInput

func (HTTPRouteSpecRulesFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersArray) ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersArray) ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersOutput) ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersOutput) ToHTTPRouteSpecRulesFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersOutput {
	return o
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
func (o HTTPRouteSpecRulesFiltersOutput) ExtensionRef() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersExtensionRef { return v.ExtensionRef }).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersOutput) RequestHeaderModifier() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersOutput) RequestMirror() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestMirror { return v.RequestMirror }).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersOutput) RequestRedirect() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestRedirect { return v.RequestRedirect }).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersOutput) ResponseHeaderModifier() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) string { return v.Type }).(pulumi.StringOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersOutput) UrlRewrite() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersUrlRewrite { return v.UrlRewrite }).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

type HTTPRouteSpecRulesFiltersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFilters {
		return vs[0].([]HTTPRouteSpecRulesFilters)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// HTTPRouteSpecRulesFiltersExtensionRefInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefArgs and HTTPRouteSpecRulesFiltersExtensionRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefInput` via:
//
//	HTTPRouteSpecRulesFiltersExtensionRefArgs{...}
type HTTPRouteSpecRulesFiltersExtensionRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefOutput)
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefOutput).ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersExtensionRefPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefArgs, HTTPRouteSpecRulesFiltersExtensionRefPtr and HTTPRouteSpecRulesFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput
}

type httprouteSpecRulesFiltersExtensionRefPtrType HTTPRouteSpecRulesFiltersExtensionRefArgs

func HTTPRouteSpecRulesFiltersExtensionRefPtr(v *HTTPRouteSpecRulesFiltersExtensionRefArgs) HTTPRouteSpecRulesFiltersExtensionRefPtrInput {
	return (*httprouteSpecRulesFiltersExtensionRefPtrType)(v)
}

func (*httprouteSpecRulesFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersExtensionRef) *HTTPRouteSpecRulesFiltersExtensionRef {
		return &v
	}).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) string { return v.Name }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Elem() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) HTTPRouteSpecRulesFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersExtensionRef
		return ret
	}).(HTTPRouteSpecRulesFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput).ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs, HTTPRouteSpecRulesFiltersRequestHeaderModifierPtr and HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
}

type httprouteSpecRulesFiltersRequestHeaderModifierPtrType HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs

func HTTPRouteSpecRulesFiltersRequestHeaderModifierPtr(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput {
	return (*httprouteSpecRulesFiltersRequestHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestHeaderModifier) *HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirror struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef HTTPRouteSpecRulesFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirror
func (val *HTTPRouteSpecRulesFiltersRequestMirror) Defaults() *HTTPRouteSpecRulesFiltersRequestMirror {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.BackendRef = *tmp.BackendRef.Defaults()

	return &tmp
}

// HTTPRouteSpecRulesFiltersRequestMirrorInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorArgs and HTTPRouteSpecRulesFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorArgs struct {
	// BackendRef references a resource where mirrored requests are sent.
	//
	// Mirrored requests must be sent only to a single destination endpoint
	// within this BackendRef, irrespective of how many endpoints are present
	// within this BackendRef.
	//
	// If the referent cannot be found, this BackendRef is invalid and must be
	// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
	// condition on the Route status is set to `status: False` and not configure
	// this backend in the underlying implementation.
	//
	// If there is a cross-namespace reference to an *existing* object
	// that is not allowed by a ReferenceGrant, the controller must ensure the
	// "ResolvedRefs"  condition on the Route is set to `status: False`,
	// with the "RefNotPermitted" reason and not configure this backend in the
	// underlying implementation.
	//
	// In either error case, the Message of the `ResolvedRefs` Condition
	// should be used to provide more detail about the problem.
	//
	// Support: Extended for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	BackendRef HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorArgs
func (val *HTTPRouteSpecRulesFiltersRequestMirrorArgs) Defaults() *HTTPRouteSpecRulesFiltersRequestMirrorArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (HTTPRouteSpecRulesFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorArgs, HTTPRouteSpecRulesFiltersRequestMirrorPtr and HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorPtrType HTTPRouteSpecRulesFiltersRequestMirrorArgs

func HTTPRouteSpecRulesFiltersRequestMirrorPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorArgs) HTTPRouteSpecRulesFiltersRequestMirrorPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirror {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirror) HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirror) HTTPRouteSpecRulesFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirror
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return &v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorBackendRef
func (val *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) Defaults() *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	return &tmp
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs
func (val *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) Defaults() *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	return &tmp
}
func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs, HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtr and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs

func HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorBackendRef
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirect struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Path defines parameters used to modify the path of the incoming request.
	// The modified path is then used to construct the `Location` header. When
	// empty, the request path is used as-is.
	//
	// Support: Extended
	Path *HTTPRouteSpecRulesFiltersRequestRedirectPath `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestRedirect
func (val *HTTPRouteSpecRulesFiltersRequestRedirect) Defaults() *HTTPRouteSpecRulesFiltersRequestRedirect {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.StatusCode == nil {
		statusCode_ := 302
		tmp.StatusCode = &statusCode_
	}
	return &tmp
}

// HTTPRouteSpecRulesFiltersRequestRedirectInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectArgs and HTTPRouteSpecRulesFiltersRequestRedirectOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Path defines parameters used to modify the path of the incoming request.
	// The modified path is then used to construct the `Location` header. When
	// empty, the request path is used as-is.
	//
	// Support: Extended
	Path HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestRedirectArgs
func (val *HTTPRouteSpecRulesFiltersRequestRedirectArgs) Defaults() *HTTPRouteSpecRulesFiltersRequestRedirectArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.StatusCode == nil {
		tmp.StatusCode = pulumi.IntPtr(302)
	}
	return &tmp
}
func (HTTPRouteSpecRulesFiltersRequestRedirectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectArgs, HTTPRouteSpecRulesFiltersRequestRedirectPtr and HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPtrType HTTPRouteSpecRulesFiltersRequestRedirectArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectArgs) HTTPRouteSpecRulesFiltersRequestRedirectPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirect {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) HTTPRouteSpecRulesFiltersRequestRedirect {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirect
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathArgs and HTTPRouteSpecRulesFiltersRequestRedirectPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathArgs, HTTPRouteSpecRulesFiltersRequestRedirectPathPtr and HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPathPtrType HTTPRouteSpecRulesFiltersRequestRedirectPathArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPathPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPathPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPath) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) string { return v.Type }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) HTTPRouteSpecRulesFiltersRequestRedirectPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPath
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput).ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs, HTTPRouteSpecRulesFiltersResponseHeaderModifierPtr and HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
}

type httprouteSpecRulesFiltersResponseHeaderModifierPtrType HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs

func HTTPRouteSpecRulesFiltersResponseHeaderModifierPtr(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput {
	return (*httprouteSpecRulesFiltersResponseHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersResponseHeaderModifier) *HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersResponseHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewrite struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string `pulumi:"hostname"`
	// Path defines a path rewrite.
	//
	// Support: Extended
	Path *HTTPRouteSpecRulesFiltersUrlRewritePath `pulumi:"path"`
}

// HTTPRouteSpecRulesFiltersUrlRewriteInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewriteArgs and HTTPRouteSpecRulesFiltersUrlRewriteOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewriteInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewriteArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewriteInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput
	ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewriteArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Path defines a path rewrite.
	//
	// Support: Extended
	Path HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesFiltersUrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewriteOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewriteOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewriteArgs, HTTPRouteSpecRulesFiltersUrlRewritePtr and HTTPRouteSpecRulesFiltersUrlRewritePtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewriteArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePtrType HTTPRouteSpecRulesFiltersUrlRewriteArgs

func HTTPRouteSpecRulesFiltersUrlRewritePtr(v *HTTPRouteSpecRulesFiltersUrlRewriteArgs) HTTPRouteSpecRulesFiltersUrlRewritePtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewriteOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewrite {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewrite) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewritePath { return v.Path }).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) HTTPRouteSpecRulesFiltersUrlRewrite {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewrite
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewriteOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewritePath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePathInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathArgs and HTTPRouteSpecRulesFiltersUrlRewritePathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePathArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathArgs, HTTPRouteSpecRulesFiltersUrlRewritePathPtr and HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePathPtrType HTTPRouteSpecRulesFiltersUrlRewritePathArgs

func HTTPRouteSpecRulesFiltersUrlRewritePathPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePathArgs) HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePathPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePath) *HTTPRouteSpecRulesFiltersUrlRewritePath {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) string { return v.Type }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) HTTPRouteSpecRulesFiltersUrlRewritePath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePath
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatches struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers []HTTPRouteSpecRulesMatchesHeaders `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method *string `pulumi:"method"`
	// Path specifies a HTTP request path matcher. If this field is not
	// specified, a default prefix match on the "/" path is provided.
	Path *HTTPRouteSpecRulesMatchesPath `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams []HTTPRouteSpecRulesMatchesQueryParams `pulumi:"queryParams"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatches
func (val *HTTPRouteSpecRulesMatches) Defaults() *HTTPRouteSpecRulesMatches {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Path = tmp.Path.Defaults()

	return &tmp
}

// HTTPRouteSpecRulesMatchesInput is an input type that accepts HTTPRouteSpecRulesMatchesArgs and HTTPRouteSpecRulesMatchesOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesInput` via:
//
//	HTTPRouteSpecRulesMatchesArgs{...}
type HTTPRouteSpecRulesMatchesInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput
	ToHTTPRouteSpecRulesMatchesOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesOutput
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesArgs struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers HTTPRouteSpecRulesMatchesHeadersArrayInput `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method pulumi.StringPtrInput `pulumi:"method"`
	// Path specifies a HTTP request path matcher. If this field is not
	// specified, a default prefix match on the "/" path is provided.
	Path HTTPRouteSpecRulesMatchesPathPtrInput `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams HTTPRouteSpecRulesMatchesQueryParamsArrayInput `pulumi:"queryParams"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesArgs
func (val *HTTPRouteSpecRulesMatchesArgs) Defaults() *HTTPRouteSpecRulesMatchesArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (HTTPRouteSpecRulesMatchesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesArgs) ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput {
	return i.ToHTTPRouteSpecRulesMatchesOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesArgs) ToHTTPRouteSpecRulesMatchesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesOutput)
}

// HTTPRouteSpecRulesMatchesArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesArray and HTTPRouteSpecRulesMatchesArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesArray{ HTTPRouteSpecRulesMatchesArgs{...} }
type HTTPRouteSpecRulesMatchesArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput
	ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesArrayOutput
}

type HTTPRouteSpecRulesMatchesArray []HTTPRouteSpecRulesMatchesInput

func (HTTPRouteSpecRulesMatchesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesArray) ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesArray) ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesArrayOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesOutput) ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesOutput) ToHTTPRouteSpecRulesMatchesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesOutput {
	return o
}

// Headers specifies HTTP request header matchers. Multiple match values are
// ANDed together, meaning, a request must match all the specified headers
// to select the route.
func (o HTTPRouteSpecRulesMatchesOutput) Headers() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) []HTTPRouteSpecRulesMatchesHeaders { return v.Headers }).(HTTPRouteSpecRulesMatchesHeadersArrayOutput)
}

// Method specifies HTTP method matcher.
// When specified, this route will be matched only if the request has the
// specified method.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) *string { return v.Method }).(pulumi.StringPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
func (o HTTPRouteSpecRulesMatchesOutput) Path() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) *HTTPRouteSpecRulesMatchesPath { return v.Path }).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// QueryParams specifies HTTP query parameter matchers. Multiple match
// values are ANDed together, meaning, a request must match all the
// specified query parameters to select the route.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesOutput) QueryParams() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) []HTTPRouteSpecRulesMatchesQueryParams { return v.QueryParams }).(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput)
}

type HTTPRouteSpecRulesMatchesArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatches {
		return vs[0].([]HTTPRouteSpecRulesMatches)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeaders struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesHeaders
func (val *HTTPRouteSpecRulesMatchesHeaders) Defaults() *HTTPRouteSpecRulesMatchesHeaders {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "Exact"
		tmp.Type = &type_
	}
	return &tmp
}

// HTTPRouteSpecRulesMatchesHeadersInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersArgs and HTTPRouteSpecRulesMatchesHeadersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersArgs{...}
type HTTPRouteSpecRulesMatchesHeadersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput
	ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersOutput
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name pulumi.StringInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesHeadersArgs
func (val *HTTPRouteSpecRulesMatchesHeadersArgs) Defaults() *HTTPRouteSpecRulesMatchesHeadersArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("Exact")
	}
	return &tmp
}
func (HTTPRouteSpecRulesMatchesHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersArgs) ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersArgs) ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersOutput)
}

// HTTPRouteSpecRulesMatchesHeadersArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersArray and HTTPRouteSpecRulesMatchesHeadersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersArray{ HTTPRouteSpecRulesMatchesHeadersArgs{...} }
type HTTPRouteSpecRulesMatchesHeadersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput
	ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput
}

type HTTPRouteSpecRulesMatchesHeadersArray []HTTPRouteSpecRulesMatchesHeadersInput

func (HTTPRouteSpecRulesMatchesHeadersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersArray) ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersArray) ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersArrayOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersOutput) ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersOutput) ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
//
// When a header is repeated in an HTTP request, it is
// implementation-specific behavior as to how this is represented.
// Generally, proxies should follow the guidance from the RFC:
// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
// processing a repeated header, with special handling for "Set-Cookie".
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) string { return v.Name }).(pulumi.StringOutput)
}

// Type specifies how to match against the value of the header.
//
// Support: Core (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression HeaderMatchType has implementation-specific
// conformance, implementations can support POSIX, PCRE or any other dialects
// of regular expressions. Please read the implementation's documentation to
// determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesMatchesHeadersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesHeadersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesHeaders {
		return vs[0].([]HTTPRouteSpecRulesMatchesHeaders)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesHeadersOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPath struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value *string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesPath
func (val *HTTPRouteSpecRulesMatchesPath) Defaults() *HTTPRouteSpecRulesMatchesPath {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "PathPrefix"
		tmp.Type = &type_
	}
	if tmp.Value == nil {
		value_ := "/"
		tmp.Value = &value_
	}
	return &tmp
}

// HTTPRouteSpecRulesMatchesPathInput is an input type that accepts HTTPRouteSpecRulesMatchesPathArgs and HTTPRouteSpecRulesMatchesPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathInput` via:
//
//	HTTPRouteSpecRulesMatchesPathArgs{...}
type HTTPRouteSpecRulesMatchesPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput
	ToHTTPRouteSpecRulesMatchesPathOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathOutput
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathArgs struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesPathArgs
func (val *HTTPRouteSpecRulesMatchesPathArgs) Defaults() *HTTPRouteSpecRulesMatchesPathArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("PathPrefix")
	}
	if tmp.Value == nil {
		tmp.Value = pulumi.StringPtr("/")
	}
	return &tmp
}
func (HTTPRouteSpecRulesMatchesPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathOutput)
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathOutput).ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesMatchesPathPtrInput is an input type that accepts HTTPRouteSpecRulesMatchesPathArgs, HTTPRouteSpecRulesMatchesPathPtr and HTTPRouteSpecRulesMatchesPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPtrInput` via:
//
//	        HTTPRouteSpecRulesMatchesPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesMatchesPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput
	ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput
}

type httprouteSpecRulesMatchesPathPtrType HTTPRouteSpecRulesMatchesPathArgs

func HTTPRouteSpecRulesMatchesPathPtr(v *HTTPRouteSpecRulesMatchesPathArgs) HTTPRouteSpecRulesMatchesPathPtrInput {
	return (*httprouteSpecRulesMatchesPathPtrType)(v)
}

func (*httprouteSpecRulesMatchesPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (i *httprouteSpecRulesMatchesPathPtrType) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesMatchesPathPtrType) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesMatchesPath) *HTTPRouteSpecRulesMatchesPath {
		return &v
	}).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPath) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Elem() HTTPRouteSpecRulesMatchesPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) HTTPRouteSpecRulesMatchesPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesMatchesPath
		return ret
	}).(HTTPRouteSpecRulesMatchesPathOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParams struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name string `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesQueryParams
func (val *HTTPRouteSpecRulesMatchesQueryParams) Defaults() *HTTPRouteSpecRulesMatchesQueryParams {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "Exact"
		tmp.Type = &type_
	}
	return &tmp
}

// HTTPRouteSpecRulesMatchesQueryParamsInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsArgs and HTTPRouteSpecRulesMatchesQueryParamsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsArgs{...}
type HTTPRouteSpecRulesMatchesQueryParamsInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsArgs struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name pulumi.StringInput `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

// Defaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesQueryParamsArgs
func (val *HTTPRouteSpecRulesMatchesQueryParamsArgs) Defaults() *HTTPRouteSpecRulesMatchesQueryParamsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("Exact")
	}
	return &tmp
}
func (HTTPRouteSpecRulesMatchesQueryParamsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArgs) ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArgs) ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsOutput)
}

// HTTPRouteSpecRulesMatchesQueryParamsArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsArray and HTTPRouteSpecRulesMatchesQueryParamsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsArray{ HTTPRouteSpecRulesMatchesQueryParamsArgs{...} }
type HTTPRouteSpecRulesMatchesQueryParamsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput
}

type HTTPRouteSpecRulesMatchesQueryParamsArray []HTTPRouteSpecRulesMatchesQueryParamsInput

func (HTTPRouteSpecRulesMatchesQueryParamsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArray) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArray) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return o
}

// Name is the name of the HTTP query param to be matched. This must be an
// exact string match. (See
// https://tools.ietf.org/html/rfc7230#section-2.7.3).
//
// If multiple entries specify equivalent query param names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent query param name MUST be ignored.
//
// If a query param is repeated in an HTTP request, the behavior is
// purposely left undefined, since different data planes have different
// capabilities. However, it is *recommended* that implementations should
// match against the first value of the param if the data plane supports it,
// as this behavior is expected in other load balancing contexts outside of
// the Gateway API.
//
// Users SHOULD NOT route traffic based on repeated query params to guard
// themselves against potential differences in the implementations.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) string { return v.Name }).(pulumi.StringOutput)
}

// Type specifies how to match against the value of the query parameter.
//
// Support: Extended (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression QueryParamMatchType has Implementation-specific
// conformance, implementations can support POSIX, PCRE or any other
// dialects of regular expressions. Please read the implementation's
// documentation to determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP query param to be matched.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) string { return v.Value }).(pulumi.StringOutput)
}

type HTTPRouteSpecRulesMatchesQueryParamsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesQueryParams {
		return vs[0].([]HTTPRouteSpecRulesMatchesQueryParams)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesQueryParamsOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []HTTPRouteStatusParents `pulumi:"parents"`
}

// HTTPRouteStatusInput is an input type that accepts HTTPRouteStatusArgs and HTTPRouteStatusOutput values.
// You can construct a concrete instance of `HTTPRouteStatusInput` via:
//
//	HTTPRouteStatusArgs{...}
type HTTPRouteStatusInput interface {
	pulumi.Input

	ToHTTPRouteStatusOutput() HTTPRouteStatusOutput
	ToHTTPRouteStatusOutputWithContext(context.Context) HTTPRouteStatusOutput
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents HTTPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (HTTPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatus)(nil)).Elem()
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusOutput() HTTPRouteStatusOutput {
	return i.ToHTTPRouteStatusOutputWithContext(context.Background())
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusOutputWithContext(ctx context.Context) HTTPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusOutput)
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return i.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusOutput).ToHTTPRouteStatusPtrOutputWithContext(ctx)
}

// HTTPRouteStatusPtrInput is an input type that accepts HTTPRouteStatusArgs, HTTPRouteStatusPtr and HTTPRouteStatusPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPtrInput` via:
//
//	        HTTPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput
	ToHTTPRouteStatusPtrOutputWithContext(context.Context) HTTPRouteStatusPtrOutput
}

type httprouteStatusPtrType HTTPRouteStatusArgs

func HTTPRouteStatusPtr(v *HTTPRouteStatusArgs) HTTPRouteStatusPtrInput {
	return (*httprouteStatusPtrType)(v)
}

func (*httprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatus)(nil)).Elem()
}

func (i *httprouteStatusPtrType) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return i.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusPtrType) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPtrOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatus)(nil)).Elem()
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusOutput() HTTPRouteStatusOutput {
	return o
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusOutputWithContext(ctx context.Context) HTTPRouteStatusOutput {
	return o
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return o.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatus) *HTTPRouteStatus {
		return &v
	}).(HTTPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusOutput) Parents() HTTPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatus) []HTTPRouteStatusParents { return v.Parents }).(HTTPRouteStatusParentsArrayOutput)
}

type HTTPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatus)(nil)).Elem()
}

func (o HTTPRouteStatusPtrOutput) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return o
}

func (o HTTPRouteStatusPtrOutput) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return o
}

func (o HTTPRouteStatusPtrOutput) Elem() HTTPRouteStatusOutput {
	return o.ApplyT(func(v *HTTPRouteStatus) HTTPRouteStatus {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatus
		return ret
	}).(HTTPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPtrOutput) Parents() HTTPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *HTTPRouteStatus) []HTTPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(HTTPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []HTTPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName string `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this
	// RouteParentStatus struct describes the status of.
	ParentRef HTTPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for HTTPRouteStatusParents
func (val *HTTPRouteStatusParents) Defaults() *HTTPRouteStatusParents {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.ParentRef = *tmp.ParentRef.Defaults()

	return &tmp
}

// HTTPRouteStatusParentsInput is an input type that accepts HTTPRouteStatusParentsArgs and HTTPRouteStatusParentsOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsInput` via:
//
//	HTTPRouteStatusParentsArgs{...}
type HTTPRouteStatusParentsInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput
	ToHTTPRouteStatusParentsOutputWithContext(context.Context) HTTPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions HTTPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this
	// RouteParentStatus struct describes the status of.
	ParentRef HTTPRouteStatusParentsParentRefInput `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for HTTPRouteStatusParentsArgs
func (val *HTTPRouteStatusParentsArgs) Defaults() *HTTPRouteStatusParentsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (HTTPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParents)(nil)).Elem()
}

func (i HTTPRouteStatusParentsArgs) ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput {
	return i.ToHTTPRouteStatusParentsOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsArgs) ToHTTPRouteStatusParentsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsOutput)
}

// HTTPRouteStatusParentsArrayInput is an input type that accepts HTTPRouteStatusParentsArray and HTTPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsArrayInput` via:
//
//	HTTPRouteStatusParentsArray{ HTTPRouteStatusParentsArgs{...} }
type HTTPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput
	ToHTTPRouteStatusParentsArrayOutputWithContext(context.Context) HTTPRouteStatusParentsArrayOutput
}

type HTTPRouteStatusParentsArray []HTTPRouteStatusParentsInput

func (HTTPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParents)(nil)).Elem()
}

func (i HTTPRouteStatusParentsArray) ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput {
	return i.ToHTTPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsArray) ToHTTPRouteStatusParentsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParents)(nil)).Elem()
}

func (o HTTPRouteStatusParentsOutput) ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput {
	return o
}

func (o HTTPRouteStatusParentsOutput) ToHTTPRouteStatusParentsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o HTTPRouteStatusParentsOutput) Conditions() HTTPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) []HTTPRouteStatusParentsConditions { return v.Conditions }).(HTTPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o HTTPRouteStatusParentsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) string { return v.ControllerName }).(pulumi.StringOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
func (o HTTPRouteStatusParentsOutput) ParentRef() HTTPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) HTTPRouteStatusParentsParentRef { return v.ParentRef }).(HTTPRouteStatusParentsParentRefOutput)
}

type HTTPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParents)(nil)).Elem()
}

func (o HTTPRouteStatusParentsArrayOutput) ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsArrayOutput) ToHTTPRouteStatusParentsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParents {
		return vs[0].([]HTTPRouteStatusParents)[vs[1].(int)]
	}).(HTTPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// HTTPRouteStatusParentsConditionsInput is an input type that accepts HTTPRouteStatusParentsConditionsArgs and HTTPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsInput` via:
//
//	HTTPRouteStatusParentsConditionsArgs{...}
type HTTPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput
	ToHTTPRouteStatusParentsConditionsOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (HTTPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsArgs) ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput {
	return i.ToHTTPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsArgs) ToHTTPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsOutput)
}

// HTTPRouteStatusParentsConditionsArrayInput is an input type that accepts HTTPRouteStatusParentsConditionsArray and HTTPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsArrayInput` via:
//
//	HTTPRouteStatusParentsConditionsArray{ HTTPRouteStatusParentsConditionsArgs{...} }
type HTTPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput
	ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsArrayOutput
}

type HTTPRouteStatusParentsConditionsArray []HTTPRouteStatusParentsConditionsInput

func (HTTPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsArray) ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput {
	return i.ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsArray) ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsOutput) ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsOutput) ToHTTPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o HTTPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o HTTPRouteStatusParentsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o HTTPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o HTTPRouteStatusParentsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o HTTPRouteStatusParentsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o HTTPRouteStatusParentsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type HTTPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsConditions {
		return vs[0].([]HTTPRouteStatusParentsConditions)[vs[1].(int)]
	}).(HTTPRouteStatusParentsConditionsOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for HTTPRouteStatusParentsParentRef
func (val *HTTPRouteStatusParentsParentRef) Defaults() *HTTPRouteStatusParentsParentRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// HTTPRouteStatusParentsParentRefInput is an input type that accepts HTTPRouteStatusParentsParentRefArgs and HTTPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefInput` via:
//
//	HTTPRouteStatusParentsParentRefArgs{...}
type HTTPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput
	ToHTTPRouteStatusParentsParentRefOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for HTTPRouteStatusParentsParentRefArgs
func (val *HTTPRouteStatusParentsParentRefArgs) Defaults() *HTTPRouteStatusParentsParentRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (HTTPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput {
	return i.ToHTTPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecInput)(nil)).Elem(), GRPCRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecPtrInput)(nil)).Elem(), GRPCRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsInput)(nil)).Elem(), GRPCRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsArrayInput)(nil)).Elem(), GRPCRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesInput)(nil)).Elem(), GRPCRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesArrayInput)(nil)).Elem(), GRPCRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPtrInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusInput)(nil)).Elem(), GRPCRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusPtrInput)(nil)).Elem(), GRPCRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsInput)(nil)).Elem(), GRPCRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsArrayInput)(nil)).Elem(), GRPCRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsArrayInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsParentRefInput)(nil)).Elem(), GRPCRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecInput)(nil)).Elem(), GatewayClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPtrInput)(nil)).Elem(), GatewayClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefInput)(nil)).Elem(), GatewayClassSpecParametersRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPtrInput)(nil)).Elem(), GatewayClassSpecParametersRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusInput)(nil)).Elem(), GatewayClassStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPtrInput)(nil)).Elem(), GatewayClassStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsInput)(nil)).Elem(), GatewayClassStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsArrayInput)(nil)).Elem(), GatewayClassStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecInput)(nil)).Elem(), GatewaySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPtrInput)(nil)).Elem(), GatewaySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersInput)(nil)).Elem(), GatewaySpecListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersArrayInput)(nil)).Elem(), GatewaySpecListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsInput)(nil)).Elem(), GatewaySpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPtrInput)(nil)).Elem(), GatewaySpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsArrayInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusInput)(nil)).Elem(), GatewayStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPtrInput)(nil)).Elem(), GatewayStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsInput)(nil)).Elem(), GatewayStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsArrayInput)(nil)).Elem(), GatewayStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersInput)(nil)).Elem(), GatewayStatusListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersArrayInput)(nil)).Elem(), GatewayStatusListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsInput)(nil)).Elem(), GatewayStatusListenersConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsArrayInput)(nil)).Elem(), GatewayStatusListenersConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsArrayInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecInput)(nil)).Elem(), HTTPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPtrInput)(nil)).Elem(), HTTPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsInput)(nil)).Elem(), HTTPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsArrayInput)(nil)).Elem(), HTTPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesInput)(nil)).Elem(), HTTPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesArrayInput)(nil)).Elem(), HTTPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewriteInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusInput)(nil)).Elem(), HTTPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPtrInput)(nil)).Elem(), HTTPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsInput)(nil)).Elem(), HTTPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsArrayInput)(nil)).Elem(), HTTPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterOutputType(GRPCRouteSpecOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecOutput{})
	pulumi.RegisterOutputType(GatewaySpecPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusOutput{})
	pulumi.RegisterOutputType(GatewayStatusPtrOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewriteOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefOutput{})
}
