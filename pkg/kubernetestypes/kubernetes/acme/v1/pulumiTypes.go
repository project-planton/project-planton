// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeType struct {
	ApiVersion *string           `pulumi:"apiVersion"`
	Kind       *string           `pulumi:"kind"`
	Metadata   metav1.ObjectMeta `pulumi:"metadata"`
	Spec       ChallengeSpec     `pulumi:"spec"`
	Status     *ChallengeStatus  `pulumi:"status"`
}

type ChallengeMetadata struct {
}

type ChallengeSpec struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL string `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName string `pulumi:"dnsName"`
	// References a properly configured ACME-type Issuer which should
	// be used to create this Challenge.
	// If the Issuer does not exist, processing will be retried.
	// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
	// Challenge will be marked as failed.
	IssuerRef ChallengeSpecIssuerRef `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key string `pulumi:"key"`
	// Contains the domain solving configuration that should be used to
	// solve this challenge resource.
	Solver ChallengeSpecSolver `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token string `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type string `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url string `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// ChallengeSpecInput is an input type that accepts ChallengeSpecArgs and ChallengeSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecInput` via:
//
//	ChallengeSpecArgs{...}
type ChallengeSpecInput interface {
	pulumi.Input

	ToChallengeSpecOutput() ChallengeSpecOutput
	ToChallengeSpecOutputWithContext(context.Context) ChallengeSpecOutput
}

type ChallengeSpecArgs struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL pulumi.StringInput `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName pulumi.StringInput `pulumi:"dnsName"`
	// References a properly configured ACME-type Issuer which should
	// be used to create this Challenge.
	// If the Issuer does not exist, processing will be retried.
	// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
	// Challenge will be marked as failed.
	IssuerRef ChallengeSpecIssuerRefInput `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key pulumi.StringInput `pulumi:"key"`
	// Contains the domain solving configuration that should be used to
	// solve this challenge resource.
	Solver ChallengeSpecSolverInput `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token pulumi.StringInput `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type pulumi.StringInput `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url pulumi.StringInput `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (ChallengeSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (i ChallengeSpecArgs) ToChallengeSpecOutput() ChallengeSpecOutput {
	return i.ToChallengeSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput)
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput).ToChallengeSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecPtrInput is an input type that accepts ChallengeSpecArgs, ChallengeSpecPtr and ChallengeSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecPtrInput` via:
//
//	        ChallengeSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput
	ToChallengeSpecPtrOutputWithContext(context.Context) ChallengeSpecPtrOutput
}

type challengeSpecPtrType ChallengeSpecArgs

func ChallengeSpecPtr(v *ChallengeSpecArgs) ChallengeSpecPtrInput {
	return (*challengeSpecPtrType)(v)
}

func (*challengeSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPtrOutput)
}

type ChallengeSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecOutput) ToChallengeSpecOutput() ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpec) *ChallengeSpec {
		return &v
	}).(ChallengeSpecPtrOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecOutput) AuthorizationURL() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.AuthorizationURL }).(pulumi.StringOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.DnsName }).(pulumi.StringOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
func (o ChallengeSpecOutput) IssuerRef() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v ChallengeSpec) ChallengeSpecIssuerRef { return v.IssuerRef }).(ChallengeSpecIssuerRefOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Key }).(pulumi.StringOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
func (o ChallengeSpecOutput) Solver() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v ChallengeSpec) ChallengeSpecSolver { return v.Solver }).(ChallengeSpecSolverOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Token }).(pulumi.StringOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Type }).(pulumi.StringOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Url }).(pulumi.StringOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type ChallengeSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) Elem() ChallengeSpecOutput {
	return o.ApplyT(func(v *ChallengeSpec) ChallengeSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpec
		return ret
	}).(ChallengeSpecOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecPtrOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.AuthorizationURL
	}).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecPtrOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.DnsName
	}).(pulumi.StringPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
func (o ChallengeSpecPtrOutput) IssuerRef() ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecIssuerRef {
		if v == nil {
			return nil
		}
		return &v.IssuerRef
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
func (o ChallengeSpecPtrOutput) Solver() ChallengeSpecSolverPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecSolver {
		if v == nil {
			return nil
		}
		return &v.Solver
	}).(ChallengeSpecSolverPtrOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecPtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Token
	}).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Url
	}).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecPtrOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *bool {
		if v == nil {
			return nil
		}
		return v.Wildcard
	}).(pulumi.BoolPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name string `pulumi:"name"`
}

// ChallengeSpecIssuerRefInput is an input type that accepts ChallengeSpecIssuerRefArgs and ChallengeSpecIssuerRefOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefInput` via:
//
//	ChallengeSpecIssuerRefArgs{...}
type ChallengeSpecIssuerRefInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput
	ToChallengeSpecIssuerRefOutputWithContext(context.Context) ChallengeSpecIssuerRefOutput
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return i.ToChallengeSpecIssuerRefOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput)
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput).ToChallengeSpecIssuerRefPtrOutputWithContext(ctx)
}

// ChallengeSpecIssuerRefPtrInput is an input type that accepts ChallengeSpecIssuerRefArgs, ChallengeSpecIssuerRefPtr and ChallengeSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefPtrInput` via:
//
//	        ChallengeSpecIssuerRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput
	ToChallengeSpecIssuerRefPtrOutputWithContext(context.Context) ChallengeSpecIssuerRefPtrOutput
}

type challengeSpecIssuerRefPtrType ChallengeSpecIssuerRefArgs

func ChallengeSpecIssuerRefPtr(v *ChallengeSpecIssuerRefArgs) ChallengeSpecIssuerRefPtrInput {
	return (*challengeSpecIssuerRefPtrType)(v)
}

func (*challengeSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecIssuerRef) *ChallengeSpecIssuerRef {
		return &v
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) Elem() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) ChallengeSpecIssuerRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecIssuerRef
		return ret
	}).(ChallengeSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolver struct {
	// Configures cert-manager to attempt to complete authorizations by
	// performing the DNS01 challenge flow.
	Dns01 *ChallengeSpecSolverDns01 `pulumi:"dns01"`
	// Configures cert-manager to attempt to complete authorizations by
	// performing the HTTP01 challenge flow.
	// It is not possible to obtain certificates for wildcard domain names
	// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	Http01 *ChallengeSpecSolverHttp01 `pulumi:"http01"`
	// Selector selects a set of DNSNames on the Certificate resource that
	// should be solved using this challenge solver.
	// If not specified, the solver will be treated as the 'default' solver
	// with the lowest priority, i.e. if any other solver has a more specific
	// match, it will be used instead.
	Selector *ChallengeSpecSolverSelector `pulumi:"selector"`
}

// ChallengeSpecSolverInput is an input type that accepts ChallengeSpecSolverArgs and ChallengeSpecSolverOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverInput` via:
//
//	ChallengeSpecSolverArgs{...}
type ChallengeSpecSolverInput interface {
	pulumi.Input

	ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput
	ToChallengeSpecSolverOutputWithContext(context.Context) ChallengeSpecSolverOutput
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverArgs struct {
	// Configures cert-manager to attempt to complete authorizations by
	// performing the DNS01 challenge flow.
	Dns01 ChallengeSpecSolverDns01PtrInput `pulumi:"dns01"`
	// Configures cert-manager to attempt to complete authorizations by
	// performing the HTTP01 challenge flow.
	// It is not possible to obtain certificates for wildcard domain names
	// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	Http01 ChallengeSpecSolverHttp01PtrInput `pulumi:"http01"`
	// Selector selects a set of DNSNames on the Certificate resource that
	// should be solved using this challenge solver.
	// If not specified, the solver will be treated as the 'default' solver
	// with the lowest priority, i.e. if any other solver has a more specific
	// match, it will be used instead.
	Selector ChallengeSpecSolverSelectorPtrInput `pulumi:"selector"`
}

func (ChallengeSpecSolverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return i.ToChallengeSpecSolverOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput)
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput).ToChallengeSpecSolverPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverPtrInput is an input type that accepts ChallengeSpecSolverArgs, ChallengeSpecSolverPtr and ChallengeSpecSolverPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverPtrInput` via:
//
//	        ChallengeSpecSolverArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput
	ToChallengeSpecSolverPtrOutputWithContext(context.Context) ChallengeSpecSolverPtrOutput
}

type challengeSpecSolverPtrType ChallengeSpecSolverArgs

func ChallengeSpecSolverPtr(v *ChallengeSpecSolverArgs) ChallengeSpecSolverPtrInput {
	return (*challengeSpecSolverPtrType)(v)
}

func (*challengeSpecSolverPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolver) *ChallengeSpecSolver {
		return &v
	}).(ChallengeSpecSolverPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
func (o ChallengeSpecSolverOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverDns01 { return v.Dns01 }).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
func (o ChallengeSpecSolverOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverHttp01 { return v.Http01 }).(ChallengeSpecSolverHttp01PtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
func (o ChallengeSpecSolverOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverSelector { return v.Selector }).(ChallengeSpecSolverSelectorPtrOutput)
}

type ChallengeSpecSolverPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) Elem() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) ChallengeSpecSolver {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolver
		return ret
	}).(ChallengeSpecSolverOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
func (o ChallengeSpecSolverPtrOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverDns01 {
		if v == nil {
			return nil
		}
		return v.Dns01
	}).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
func (o ChallengeSpecSolverPtrOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverHttp01 {
		if v == nil {
			return nil
		}
		return v.Http01
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
func (o ChallengeSpecSolverPtrOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01 struct {
	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
	// DNS01 challenge records.
	AcmeDNS *ChallengeSpecSolverDns01AcmeDns `pulumi:"acmeDNS"`
	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	Akamai *ChallengeSpecSolverDns01Akamai `pulumi:"akamai"`
	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	AzureDNS *ChallengeSpecSolverDns01AzureDns `pulumi:"azureDNS"`
	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	CloudDNS *ChallengeSpecSolverDns01CloudDns `pulumi:"cloudDNS"`
	// Use the Cloudflare API to manage DNS01 challenge records.
	Cloudflare *ChallengeSpecSolverDns01Cloudflare `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy *string `pulumi:"cnameStrategy"`
	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	Digitalocean *ChallengeSpecSolverDns01Digitalocean `pulumi:"digitalocean"`
	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
	// to manage DNS01 challenge records.
	Rfc2136 *ChallengeSpecSolverDns01Rfc2136 `pulumi:"rfc2136"`
	// Use the AWS Route53 API to manage DNS01 challenge records.
	Route53 *ChallengeSpecSolverDns01Route53 `pulumi:"route53"`
	// Configure an external webhook based DNS01 challenge solver to manage
	// DNS01 challenge records.
	Webhook *ChallengeSpecSolverDns01Webhook `pulumi:"webhook"`
}

// ChallengeSpecSolverDns01Input is an input type that accepts ChallengeSpecSolverDns01Args and ChallengeSpecSolverDns01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Input` via:
//
//	ChallengeSpecSolverDns01Args{...}
type ChallengeSpecSolverDns01Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output
	ToChallengeSpecSolverDns01OutputWithContext(context.Context) ChallengeSpecSolverDns01Output
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Args struct {
	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
	// DNS01 challenge records.
	AcmeDNS ChallengeSpecSolverDns01AcmeDnsPtrInput `pulumi:"acmeDNS"`
	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	Akamai ChallengeSpecSolverDns01AkamaiPtrInput `pulumi:"akamai"`
	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	AzureDNS ChallengeSpecSolverDns01AzureDnsPtrInput `pulumi:"azureDNS"`
	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	CloudDNS ChallengeSpecSolverDns01CloudDnsPtrInput `pulumi:"cloudDNS"`
	// Use the Cloudflare API to manage DNS01 challenge records.
	Cloudflare ChallengeSpecSolverDns01CloudflarePtrInput `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy pulumi.StringPtrInput `pulumi:"cnameStrategy"`
	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	Digitalocean ChallengeSpecSolverDns01DigitaloceanPtrInput `pulumi:"digitalocean"`
	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
	// to manage DNS01 challenge records.
	Rfc2136 ChallengeSpecSolverDns01Rfc2136PtrInput `pulumi:"rfc2136"`
	// Use the AWS Route53 API to manage DNS01 challenge records.
	Route53 ChallengeSpecSolverDns01Route53PtrInput `pulumi:"route53"`
	// Configure an external webhook based DNS01 challenge solver to manage
	// DNS01 challenge records.
	Webhook ChallengeSpecSolverDns01WebhookPtrInput `pulumi:"webhook"`
}

func (ChallengeSpecSolverDns01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return i.ToChallengeSpecSolverDns01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output)
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output).ToChallengeSpecSolverDns01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01PtrInput is an input type that accepts ChallengeSpecSolverDns01Args, ChallengeSpecSolverDns01Ptr and ChallengeSpecSolverDns01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01PtrInput` via:
//
//	        ChallengeSpecSolverDns01Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput
	ToChallengeSpecSolverDns01PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01PtrOutput
}

type challengeSpecSolverDns01PtrType ChallengeSpecSolverDns01Args

func ChallengeSpecSolverDns01Ptr(v *ChallengeSpecSolverDns01Args) ChallengeSpecSolverDns01PtrInput {
	return (*challengeSpecSolverDns01PtrType)(v)
}

func (*challengeSpecSolverDns01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01 {
		return &v
	}).(ChallengeSpecSolverDns01PtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) AcmeDNS() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDns { return v.AcmeDNS }).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai { return v.Akamai }).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) AzureDNS() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDns { return v.AzureDNS }).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) CloudDNS() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDns { return v.CloudDNS }).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare { return v.Cloudflare }).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01Output) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *string { return v.CnameStrategy }).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean { return v.Digitalocean }).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 { return v.Rfc2136 }).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 { return v.Route53 }).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook { return v.Webhook }).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

type ChallengeSpecSolverDns01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) Elem() ChallengeSpecSolverDns01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) ChallengeSpecSolverDns01 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01
		return ret
	}).(ChallengeSpecSolverDns01Output)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) AcmeDNS() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDns {
		if v == nil {
			return nil
		}
		return v.AcmeDNS
	}).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) AzureDNS() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDns {
		if v == nil {
			return nil
		}
		return v.AzureDNS
	}).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) CloudDNS() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDns {
		if v == nil {
			return nil
		}
		return v.CloudDNS
	}).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare {
		if v == nil {
			return nil
		}
		return v.Cloudflare
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01PtrOutput) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *string {
		if v == nil {
			return nil
		}
		return v.CnameStrategy
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean {
		if v == nil {
			return nil
		}
		return v.Digitalocean
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 {
		if v == nil {
			return nil
		}
		return v.Rfc2136
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 {
		if v == nil {
			return nil
		}
		return v.Route53
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook {
		if v == nil {
			return nil
		}
		return v.Webhook
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDns struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccountSecretRef ChallengeSpecSolverDns01AcmeDnsAccountSecretRef `pulumi:"accountSecretRef"`
	Host             string                                          `pulumi:"host"`
}

// ChallengeSpecSolverDns01AcmeDnsInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsArgs and ChallengeSpecSolverDns01AcmeDnsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsInput` via:
//
//	ChallengeSpecSolverDns01AcmeDnsArgs{...}
type ChallengeSpecSolverDns01AcmeDnsInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsOutput() ChallengeSpecSolverDns01AcmeDnsOutput
	ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsOutput
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDnsArgs struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccountSecretRef ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput `pulumi:"accountSecretRef"`
	Host             pulumi.StringInput                                   `pulumi:"host"`
}

func (ChallengeSpecSolverDns01AcmeDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsOutput() ChallengeSpecSolverDns01AcmeDnsOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsOutput)
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsOutput).ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDnsPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsArgs, ChallengeSpecSolverDns01AcmeDnsPtr and ChallengeSpecSolverDns01AcmeDnsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDnsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDnsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput
	ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput
}

type challengeSpecSolverDns01AcmeDnsPtrType ChallengeSpecSolverDns01AcmeDnsArgs

func ChallengeSpecSolverDns01AcmeDnsPtr(v *ChallengeSpecSolverDns01AcmeDnsArgs) ChallengeSpecSolverDns01AcmeDnsPtrInput {
	return (*challengeSpecSolverDns01AcmeDnsPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDnsPtrType) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDnsPtrType) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDnsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsOutput() ChallengeSpecSolverDns01AcmeDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDns) *ChallengeSpecSolverDns01AcmeDns {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AcmeDnsOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDns) ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput)
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDns) string { return v.Host }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AcmeDnsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDnsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDns) ChallengeSpecSolverDns01AcmeDns {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDns
		return ret
	}).(ChallengeSpecSolverDns01AcmeDnsOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDns) *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		if v == nil {
			return nil
		}
		return &v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDns) *string {
		if v == nil {
			return nil
		}
		return &v.Host
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs and ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput
	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput).ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs, ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtr and ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs

func ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtr(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDnsAccountSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Akamai struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccessTokenSecretRef ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef `pulumi:"accessTokenSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRef `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain string                                             `pulumi:"serviceConsumerDomain"`
}

// ChallengeSpecSolverDns01AkamaiInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs and ChallengeSpecSolverDns01AkamaiOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiInput` via:
//
//	ChallengeSpecSolverDns01AkamaiArgs{...}
type ChallengeSpecSolverDns01AkamaiInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput
	ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiOutput
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiArgs struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccessTokenSecretRef ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput `pulumi:"accessTokenSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput `pulumi:"clientSecretSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain pulumi.StringInput                                      `pulumi:"serviceConsumerDomain"`
}

func (ChallengeSpecSolverDns01AkamaiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return i.ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput)
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput).ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs, ChallengeSpecSolverDns01AkamaiPtr and ChallengeSpecSolverDns01AkamaiPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput
	ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput
}

type challengeSpecSolverDns01AkamaiPtrType ChallengeSpecSolverDns01AkamaiArgs

func ChallengeSpecSolverDns01AkamaiPtr(v *ChallengeSpecSolverDns01AkamaiArgs) ChallengeSpecSolverDns01AkamaiPtrInput {
	return (*challengeSpecSolverDns01AkamaiPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01Akamai {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ServiceConsumerDomain() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) string { return v.ServiceConsumerDomain }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01Akamai {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Akamai
		return ret
	}).(ChallengeSpecSolverDns01AkamaiOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return &v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceConsumerDomain
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDns struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID *string `pulumi:"clientID"`
	// Auth: Azure Service Principal:
	// A reference to a Secret containing the password associated with the Service Principal.
	// If set, ClientID and TenantID must also be set.
	ClientSecretSecretRef *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment *string `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName *string `pulumi:"hostedZoneName"`
	// Auth: Azure Workload Identity or Azure Managed Service Identity:
	// Settings to enable Azure Workload Identity or Azure Managed Service Identity
	// If set, ClientID, ClientSecret and TenantID must not be set.
	ManagedIdentity *ChallengeSpecSolverDns01AzureDnsManagedIdentity `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID string `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID *string `pulumi:"tenantID"`
}

// ChallengeSpecSolverDns01AzureDnsInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsArgs and ChallengeSpecSolverDns01AzureDnsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsInput` via:
//
//	ChallengeSpecSolverDns01AzureDnsArgs{...}
type ChallengeSpecSolverDns01AzureDnsInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsOutput() ChallengeSpecSolverDns01AzureDnsOutput
	ToChallengeSpecSolverDns01AzureDnsOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsOutput
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDnsArgs struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// Auth: Azure Service Principal:
	// A reference to a Secret containing the password associated with the Service Principal.
	// If set, ClientID and TenantID must also be set.
	ClientSecretSecretRef ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment pulumi.StringPtrInput `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName pulumi.StringPtrInput `pulumi:"hostedZoneName"`
	// Auth: Azure Workload Identity or Azure Managed Service Identity:
	// Settings to enable Azure Workload Identity or Azure Managed Service Identity
	// If set, ClientID, ClientSecret and TenantID must not be set.
	ManagedIdentity ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID pulumi.StringInput `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID pulumi.StringPtrInput `pulumi:"tenantID"`
}

func (ChallengeSpecSolverDns01AzureDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsOutput() ChallengeSpecSolverDns01AzureDnsOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsOutput)
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsOutput).ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDnsPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsArgs, ChallengeSpecSolverDns01AzureDnsPtr and ChallengeSpecSolverDns01AzureDnsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDnsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDnsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput
	ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput
}

type challengeSpecSolverDns01AzureDnsPtrType ChallengeSpecSolverDns01AzureDnsArgs

func ChallengeSpecSolverDns01AzureDnsPtr(v *ChallengeSpecSolverDns01AzureDnsArgs) ChallengeSpecSolverDns01AzureDnsPtrInput {
	return (*challengeSpecSolverDns01AzureDnsPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDnsPtrType) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDnsPtrType) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDnsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsOutput() ChallengeSpecSolverDns01AzureDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDns {
		return &v
	}).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDnsOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.Environment }).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDnsOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDnsOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) string { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDnsOutput) SubscriptionID() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) string { return v.SubscriptionID }).(pulumi.StringOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.TenantID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDnsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) Elem() ChallengeSpecSolverDns01AzureDnsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) ChallengeSpecSolverDns01AzureDns {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDns
		return ret
	}).(ChallengeSpecSolverDns01AzureDnsOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.Environment
	}).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		if v == nil {
			return nil
		}
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceGroupName
	}).(pulumi.StringPtrOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return &v.SubscriptionID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.TenantID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs and ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs, ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtr and ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDnsManagedIdentity struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID *string `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID *string `pulumi:"resourceID"`
}

// ChallengeSpecSolverDns01AzureDnsManagedIdentityInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs and ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsManagedIdentityInput` via:
//
//	ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{...}
type ChallengeSpecSolverDns01AzureDnsManagedIdentityInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput
	ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID pulumi.StringPtrInput `pulumi:"resourceID"`
}

func (ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput)
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput).ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs, ChallengeSpecSolverDns01AzureDnsManagedIdentityPtr and ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput
	ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput
}

type challengeSpecSolverDns01AzureDnsManagedIdentityPtrType ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs

func ChallengeSpecSolverDns01AzureDnsManagedIdentityPtr(v *ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput {
	return (*challengeSpecSolverDns01AzureDnsManagedIdentityPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDnsManagedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDnsManagedIdentityPtrType) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDnsManagedIdentityPtrType) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDnsManagedIdentity) *ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		return &v
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string { return v.ResourceID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) Elem() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsManagedIdentity) ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDnsManagedIdentity
		return ret
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.ResourceID
	}).(pulumi.StringPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDns struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName *string `pulumi:"hostedZoneName"`
	Project        string  `pulumi:"project"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ServiceAccountSecretRef *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef `pulumi:"serviceAccountSecretRef"`
}

// ChallengeSpecSolverDns01CloudDnsInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsArgs and ChallengeSpecSolverDns01CloudDnsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsInput` via:
//
//	ChallengeSpecSolverDns01CloudDnsArgs{...}
type ChallengeSpecSolverDns01CloudDnsInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsOutput() ChallengeSpecSolverDns01CloudDnsOutput
	ToChallengeSpecSolverDns01CloudDnsOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsOutput
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDnsArgs struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName pulumi.StringPtrInput `pulumi:"hostedZoneName"`
	Project        pulumi.StringInput    `pulumi:"project"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ServiceAccountSecretRef ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput `pulumi:"serviceAccountSecretRef"`
}

func (ChallengeSpecSolverDns01CloudDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsOutput() ChallengeSpecSolverDns01CloudDnsOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsOutput)
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsOutput).ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDnsPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsArgs, ChallengeSpecSolverDns01CloudDnsPtr and ChallengeSpecSolverDns01CloudDnsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDnsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDnsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput
	ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput
}

type challengeSpecSolverDns01CloudDnsPtrType ChallengeSpecSolverDns01CloudDnsArgs

func ChallengeSpecSolverDns01CloudDnsPtr(v *ChallengeSpecSolverDns01CloudDnsArgs) ChallengeSpecSolverDns01CloudDnsPtrInput {
	return (*challengeSpecSolverDns01CloudDnsPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDnsPtrType) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDnsPtrType) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDnsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsOutput() ChallengeSpecSolverDns01CloudDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDns) *ChallengeSpecSolverDns01CloudDns {
		return &v
	}).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDnsOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDns) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDns) string { return v.Project }).(pulumi.StringOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01CloudDnsOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDns) *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01CloudDnsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) Elem() ChallengeSpecSolverDns01CloudDnsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) ChallengeSpecSolverDns01CloudDns {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDns
		return ret
	}).(ChallengeSpecSolverDns01CloudDnsOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) *string {
		if v == nil {
			return nil
		}
		return &v.Project
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		if v == nil {
			return nil
		}
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs and ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput
	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput).ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs, ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtr and ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs

func ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtr(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Cloudflare struct {
	// API key to use to authenticate with Cloudflare.
	// Note: using an API token to authenticate is now the recommended method
	// as it allows greater control of permissions.
	ApiKeySecretRef *ChallengeSpecSolverDns01CloudflareApiKeySecretRef `pulumi:"apiKeySecretRef"`
	// API token used to authenticate with Cloudflare.
	ApiTokenSecretRef *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email *string `pulumi:"email"`
}

// ChallengeSpecSolverDns01CloudflareInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs and ChallengeSpecSolverDns01CloudflareOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareInput` via:
//
//	ChallengeSpecSolverDns01CloudflareArgs{...}
type ChallengeSpecSolverDns01CloudflareInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput
	ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareOutput
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareArgs struct {
	// API key to use to authenticate with Cloudflare.
	// Note: using an API token to authenticate is now the recommended method
	// as it allows greater control of permissions.
	ApiKeySecretRef ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput `pulumi:"apiKeySecretRef"`
	// API token used to authenticate with Cloudflare.
	ApiTokenSecretRef ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email pulumi.StringPtrInput `pulumi:"email"`
}

func (ChallengeSpecSolverDns01CloudflareArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return i.ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput)
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput).ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflarePtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs, ChallengeSpecSolverDns01CloudflarePtr and ChallengeSpecSolverDns01CloudflarePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflarePtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflarePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput
	ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput
}

type challengeSpecSolverDns01CloudflarePtrType ChallengeSpecSolverDns01CloudflareArgs

func ChallengeSpecSolverDns01CloudflarePtr(v *ChallengeSpecSolverDns01CloudflareArgs) ChallengeSpecSolverDns01CloudflarePtrInput {
	return (*challengeSpecSolverDns01CloudflarePtrType)(v)
}

func (*challengeSpecSolverDns01CloudflarePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01Cloudflare {
		return &v
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
func (o ChallengeSpecSolverDns01CloudflareOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
func (o ChallengeSpecSolverDns01CloudflareOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflareOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *string { return v.Email }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflarePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflarePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Elem() ChallengeSpecSolverDns01CloudflareOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) ChallengeSpecSolverDns01Cloudflare {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Cloudflare
		return ret
	}).(ChallengeSpecSolverDns01CloudflareOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v == nil {
			return nil
		}
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *string {
		if v == nil {
			return nil
		}
		return v.Email
	}).(pulumi.StringPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs and ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs, ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr and ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiKeySecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs, ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Digitalocean struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRef `pulumi:"tokenSecretRef"`
}

// ChallengeSpecSolverDns01DigitaloceanInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs and ChallengeSpecSolverDns01DigitaloceanOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanArgs{...}
type ChallengeSpecSolverDns01DigitaloceanInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput
	ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanOutput
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanArgs struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput `pulumi:"tokenSecretRef"`
}

func (ChallengeSpecSolverDns01DigitaloceanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput).ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs, ChallengeSpecSolverDns01DigitaloceanPtr and ChallengeSpecSolverDns01DigitaloceanPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput
}

type challengeSpecSolverDns01DigitaloceanPtrType ChallengeSpecSolverDns01DigitaloceanArgs

func ChallengeSpecSolverDns01DigitaloceanPtr(v *ChallengeSpecSolverDns01DigitaloceanArgs) ChallengeSpecSolverDns01DigitaloceanPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01Digitalocean {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01DigitaloceanOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

type ChallengeSpecSolverDns01DigitaloceanPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01Digitalocean {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Digitalocean
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput).ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs, ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs

func ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01DigitaloceanTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136 struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver string `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm *string `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName *string `pulumi:"tsigKeyName"`
	// The name of the secret containing the TSIG value.
	// If ``tsigKeyName`` is defined, this field is required.
	TsigSecretSecretRef *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef `pulumi:"tsigSecretSecretRef"`
}

// ChallengeSpecSolverDns01Rfc2136Input is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args and ChallengeSpecSolverDns01Rfc2136Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136Input` via:
//
//	ChallengeSpecSolverDns01Rfc2136Args{...}
type ChallengeSpecSolverDns01Rfc2136Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output
	ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136Output
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Args struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver pulumi.StringInput `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm pulumi.StringPtrInput `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName pulumi.StringPtrInput `pulumi:"tsigKeyName"`
	// The name of the secret containing the TSIG value.
	// If ``tsigKeyName`` is defined, this field is required.
	TsigSecretSecretRef ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput `pulumi:"tsigSecretSecretRef"`
}

func (ChallengeSpecSolverDns01Rfc2136Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return i.ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output)
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output).ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136PtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args, ChallengeSpecSolverDns01Rfc2136Ptr and ChallengeSpecSolverDns01Rfc2136PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136PtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput
	ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput
}

type challengeSpecSolverDns01Rfc2136PtrType ChallengeSpecSolverDns01Rfc2136Args

func ChallengeSpecSolverDns01Rfc2136Ptr(v *ChallengeSpecSolverDns01Rfc2136Args) ChallengeSpecSolverDns01Rfc2136PtrInput {
	return (*challengeSpecSolverDns01Rfc2136PtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136 {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) Nameserver() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) string { return v.Nameserver }).(pulumi.StringOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigAlgorithm }).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigKeyName }).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) ChallengeSpecSolverDns01Rfc2136 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136Output)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return &v.Nameserver
	}).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigAlgorithm
	}).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigKeyName
	}).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput).ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs, ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs

func ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53 struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID *string `pulumi:"accessKeyID"`
	// The SecretAccessKey is used for authentication. If set, pull the AWS
	// access key ID from a key within a Kubernetes Secret.
	// Cannot be set when AccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyIDSecretRef *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef `pulumi:"accessKeyIDSecretRef"`
	// Auth configures how cert-manager authenticates.
	Auth *ChallengeSpecSolverDns01Route53Auth `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID *string `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region string `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role *string `pulumi:"role"`
	// The SecretAccessKey is used for authentication.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	SecretAccessKeySecretRef *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef `pulumi:"secretAccessKeySecretRef"`
}

// ChallengeSpecSolverDns01Route53Input is an input type that accepts ChallengeSpecSolverDns01Route53Args and ChallengeSpecSolverDns01Route53Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53Input` via:
//
//	ChallengeSpecSolverDns01Route53Args{...}
type ChallengeSpecSolverDns01Route53Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output
	ToChallengeSpecSolverDns01Route53OutputWithContext(context.Context) ChallengeSpecSolverDns01Route53Output
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Args struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID pulumi.StringPtrInput `pulumi:"accessKeyID"`
	// The SecretAccessKey is used for authentication. If set, pull the AWS
	// access key ID from a key within a Kubernetes Secret.
	// Cannot be set when AccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyIDSecretRef ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput `pulumi:"accessKeyIDSecretRef"`
	// Auth configures how cert-manager authenticates.
	Auth ChallengeSpecSolverDns01Route53AuthPtrInput `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID pulumi.StringPtrInput `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region pulumi.StringInput `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role pulumi.StringPtrInput `pulumi:"role"`
	// The SecretAccessKey is used for authentication.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	SecretAccessKeySecretRef ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput `pulumi:"secretAccessKeySecretRef"`
}

func (ChallengeSpecSolverDns01Route53Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return i.ToChallengeSpecSolverDns01Route53OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output)
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output).ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53PtrInput is an input type that accepts ChallengeSpecSolverDns01Route53Args, ChallengeSpecSolverDns01Route53Ptr and ChallengeSpecSolverDns01Route53PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53PtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput
	ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53PtrOutput
}

type challengeSpecSolverDns01Route53PtrType ChallengeSpecSolverDns01Route53Args

func ChallengeSpecSolverDns01Route53Ptr(v *ChallengeSpecSolverDns01Route53Args) ChallengeSpecSolverDns01Route53PtrInput {
	return (*challengeSpecSolverDns01Route53PtrType)(v)
}

func (*challengeSpecSolverDns01Route53PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53 {
		return &v
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.AccessKeyID }).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// Auth configures how cert-manager authenticates.
func (o ChallengeSpecSolverDns01Route53Output) Auth() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53Auth { return v.Auth }).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53Output) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.HostedZoneID }).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53Output) Region() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) string { return v.Region }).(pulumi.StringOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53Output) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.Role }).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Route53PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) Elem() ChallengeSpecSolverDns01Route53Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) ChallengeSpecSolverDns01Route53 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53
		return ret
	}).(ChallengeSpecSolverDns01Route53Output)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.AccessKeyID
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		if v == nil {
			return nil
		}
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// Auth configures how cert-manager authenticates.
func (o ChallengeSpecSolverDns01Route53PtrOutput) Auth() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53Auth {
		if v == nil {
			return nil
		}
		return v.Auth
	}).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53PtrOutput) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneID
	}).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53PtrOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return &v.Region
	}).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53PtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v == nil {
			return nil
		}
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs and ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput` via:
//
//	ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{...}
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput).ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs, ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtr and ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput
}

type challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs

func ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtr(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef
		return ret
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53Auth struct {
	// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
	// by passing a bound ServiceAccount token.
	Kubernetes ChallengeSpecSolverDns01Route53AuthKubernetes `pulumi:"kubernetes"`
}

// ChallengeSpecSolverDns01Route53AuthInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthArgs and ChallengeSpecSolverDns01Route53AuthOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthArgs{...}
type ChallengeSpecSolverDns01Route53AuthInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput
	ToChallengeSpecSolverDns01Route53AuthOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthOutput
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthArgs struct {
	// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
	// by passing a bound ServiceAccount token.
	Kubernetes ChallengeSpecSolverDns01Route53AuthKubernetesInput `pulumi:"kubernetes"`
}

func (ChallengeSpecSolverDns01Route53AuthArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthOutput).ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthArgs, ChallengeSpecSolverDns01Route53AuthPtr and ChallengeSpecSolverDns01Route53AuthPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput
	ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput
}

type challengeSpecSolverDns01Route53AuthPtrType ChallengeSpecSolverDns01Route53AuthArgs

func ChallengeSpecSolverDns01Route53AuthPtr(v *ChallengeSpecSolverDns01Route53AuthArgs) ChallengeSpecSolverDns01Route53AuthPtrInput {
	return (*challengeSpecSolverDns01Route53AuthPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthPtrType) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthPtrType) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53Auth {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
func (o ChallengeSpecSolverDns01Route53AuthOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Auth) ChallengeSpecSolverDns01Route53AuthKubernetes {
		return v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

type ChallengeSpecSolverDns01Route53AuthPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Auth) ChallengeSpecSolverDns01Route53Auth {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53Auth
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		if v == nil {
			return nil
		}
		return &v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetes struct {
	// A reference to a service account that will be used to request a bound
	// token (also known as "projected token"). To use this field, you must
	// configure an RBAC rule to let cert-manager request a token.
	ServiceAccountRef ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef `pulumi:"serviceAccountRef"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesArgs and ChallengeSpecSolverDns01Route53AuthKubernetesOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesArgs struct {
	// A reference to a service account that will be used to request a bound
	// token (also known as "projected token"). To use this field, you must
	// configure an RBAC rule to let cert-manager request a token.
	ServiceAccountRef ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput `pulumi:"serviceAccountRef"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesArgs, ChallengeSpecSolverDns01Route53AuthKubernetesPtr and ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesPtrType ChallengeSpecSolverDns01Route53AuthKubernetesArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetes) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		return v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetes) ChallengeSpecSolverDns01Route53AuthKubernetes {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetes
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		if v == nil {
			return nil
		}
		return &v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences []string `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences pulumi.StringArrayInput `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs, ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtr and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) []string { return v.Audiences }).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) []string {
		if v == nil {
			return nil
		}
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput` via:
//
//	ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput).ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs, ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
}

type challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs

func ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef
		return ret
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01Webhook struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config map[string]interface{} `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName string `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName string `pulumi:"solverName"`
}

// ChallengeSpecSolverDns01WebhookInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs and ChallengeSpecSolverDns01WebhookOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookInput` via:
//
//	ChallengeSpecSolverDns01WebhookArgs{...}
type ChallengeSpecSolverDns01WebhookInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput
	ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookOutput
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookArgs struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config pulumi.MapInput `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName pulumi.StringInput `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName pulumi.StringInput `pulumi:"solverName"`
}

func (ChallengeSpecSolverDns01WebhookArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return i.ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput)
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput).ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01WebhookPtrInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs, ChallengeSpecSolverDns01WebhookPtr and ChallengeSpecSolverDns01WebhookPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookPtrInput` via:
//
//	        ChallengeSpecSolverDns01WebhookArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01WebhookPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput
	ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookPtrOutput
}

type challengeSpecSolverDns01WebhookPtrType ChallengeSpecSolverDns01WebhookArgs

func ChallengeSpecSolverDns01WebhookPtr(v *ChallengeSpecSolverDns01WebhookArgs) ChallengeSpecSolverDns01WebhookPtrInput {
	return (*challengeSpecSolverDns01WebhookPtrType)(v)
}

func (*challengeSpecSolverDns01WebhookPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Webhook) *ChallengeSpecSolverDns01Webhook {
		return &v
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookOutput) GroupName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) string { return v.GroupName }).(pulumi.StringOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookOutput) SolverName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) string { return v.SolverName }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01WebhookPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) Elem() ChallengeSpecSolverDns01WebhookOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) ChallengeSpecSolverDns01Webhook {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Webhook
		return ret
	}).(ChallengeSpecSolverDns01WebhookOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return &v.GroupName
	}).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return &v.SolverName
	}).(pulumi.StringPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01 struct {
	// The Gateway API is a sig-network community API that models service networking
	// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
	// create HTTPRoutes with the specified labels in the same namespace as the challenge.
	// This solver is experimental, and fields / behaviour may change in the future.
	GatewayHTTPRoute *ChallengeSpecSolverHttp01GatewayHttproute `pulumi:"gatewayHTTPRoute"`
	// The ingress based HTTP01 challenge solver will solve challenges by
	// creating or modifying Ingress resources in order to route requests for
	// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
	// provisioned by cert-manager for each Challenge to be completed.
	Ingress *ChallengeSpecSolverHttp01Ingress `pulumi:"ingress"`
}

// ChallengeSpecSolverHttp01Input is an input type that accepts ChallengeSpecSolverHttp01Args and ChallengeSpecSolverHttp01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01Input` via:
//
//	ChallengeSpecSolverHttp01Args{...}
type ChallengeSpecSolverHttp01Input interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output
	ToChallengeSpecSolverHttp01OutputWithContext(context.Context) ChallengeSpecSolverHttp01Output
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Args struct {
	// The Gateway API is a sig-network community API that models service networking
	// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
	// create HTTPRoutes with the specified labels in the same namespace as the challenge.
	// This solver is experimental, and fields / behaviour may change in the future.
	GatewayHTTPRoute ChallengeSpecSolverHttp01GatewayHttproutePtrInput `pulumi:"gatewayHTTPRoute"`
	// The ingress based HTTP01 challenge solver will solve challenges by
	// creating or modifying Ingress resources in order to route requests for
	// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
	// provisioned by cert-manager for each Challenge to be completed.
	Ingress ChallengeSpecSolverHttp01IngressPtrInput `pulumi:"ingress"`
}

func (ChallengeSpecSolverHttp01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return i.ToChallengeSpecSolverHttp01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output)
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output).ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01PtrInput is an input type that accepts ChallengeSpecSolverHttp01Args, ChallengeSpecSolverHttp01Ptr and ChallengeSpecSolverHttp01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01PtrInput` via:
//
//	        ChallengeSpecSolverHttp01Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput
	ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01PtrOutput
}

type challengeSpecSolverHttp01PtrType ChallengeSpecSolverHttp01Args

func ChallengeSpecSolverHttp01Ptr(v *ChallengeSpecSolverHttp01Args) ChallengeSpecSolverHttp01PtrInput {
	return (*challengeSpecSolverHttp01PtrType)(v)
}

func (*challengeSpecSolverHttp01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01 {
		return &v
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
func (o ChallengeSpecSolverHttp01Output) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01GatewayHttproute {
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
func (o ChallengeSpecSolverHttp01Output) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress { return v.Ingress }).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

type ChallengeSpecSolverHttp01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) Elem() ChallengeSpecSolverHttp01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) ChallengeSpecSolverHttp01 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01
		return ret
	}).(ChallengeSpecSolverHttp01Output)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
func (o ChallengeSpecSolverHttp01PtrOutput) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01GatewayHttproute {
		if v == nil {
			return nil
		}
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
func (o ChallengeSpecSolverHttp01PtrOutput) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress {
		if v == nil {
			return nil
		}
		return v.Ingress
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHttproute struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels map[string]string `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs []ChallengeSpecSolverHttp01GatewayHttprouteParentRefs `pulumi:"parentRefs"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01GatewayHttprouteInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteArgs and ChallengeSpecSolverHttp01GatewayHttprouteOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttprouteInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttprouteArgs{...}
type ChallengeSpecSolverHttp01GatewayHttprouteInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttprouteOutput() ChallengeSpecSolverHttp01GatewayHttprouteOutput
	ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttprouteOutput
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHttprouteArgs struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput `pulumi:"parentRefs"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01GatewayHttprouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttprouteOutput() ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteOutput).ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteArgs, ChallengeSpecSolverHttp01GatewayHttproutePtr and ChallengeSpecSolverHttp01GatewayHttproutePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttprouteArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePtrType ChallengeSpecSolverHttp01GatewayHttprouteArgs

func ChallengeSpecSolverHttp01GatewayHttproutePtr(v *ChallengeSpecSolverHttp01GatewayHttprouteArgs) ChallengeSpecSolverHttp01GatewayHttproutePtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHttprouteOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttprouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttprouteOutput() ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproute) *ChallengeSpecSolverHttp01GatewayHttproute {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) []ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) ChallengeSpecSolverHttp01GatewayHttproute {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproute
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttprouteOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) []ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
type ChallengeSpecSolverHttp01GatewayHttprouteLabels struct {
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01GatewayHttprouteParentRefs
func (val *ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) Defaults() *ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs and ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput
	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs
func (val *ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) Defaults() *ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray and ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray{ ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray []ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput

func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// <gateway:experimental:description>
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
// </gateway:experimental:description>
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// <gateway:experimental:description>
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
// </gateway:experimental:description>
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01Ingress struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class *string `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName *string `pulumi:"ingressClassName"`
	// Optional ingress template used to configure the ACME challenge solver
	// ingress used for HTTP01 challenges.
	IngressTemplate *ChallengeSpecSolverHttp01IngressIngressTemplate `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name *string `pulumi:"name"`
	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	PodTemplate *ChallengeSpecSolverHttp01IngressPodTemplate `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01IngressInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs and ChallengeSpecSolverHttp01IngressOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressInput` via:
//
//	ChallengeSpecSolverHttp01IngressArgs{...}
type ChallengeSpecSolverHttp01IngressInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput
	ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressOutput
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressArgs struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class pulumi.StringPtrInput `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName pulumi.StringPtrInput `pulumi:"ingressClassName"`
	// Optional ingress template used to configure the ACME challenge solver
	// ingress used for HTTP01 challenges.
	IngressTemplate ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	PodTemplate ChallengeSpecSolverHttp01IngressPodTemplatePtrInput `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01IngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return i.ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput)
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput).ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs, ChallengeSpecSolverHttp01IngressPtr and ChallengeSpecSolverHttp01IngressPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput
	ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPtrOutput
}

type challengeSpecSolverHttp01IngressPtrType ChallengeSpecSolverHttp01IngressArgs

func ChallengeSpecSolverHttp01IngressPtr(v *ChallengeSpecSolverHttp01IngressArgs) ChallengeSpecSolverHttp01IngressPtrInput {
	return (*challengeSpecSolverHttp01IngressPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01Ingress {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Class }).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.IngressClassName }).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) Elem() ChallengeSpecSolverHttp01IngressOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) ChallengeSpecSolverHttp01Ingress {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01Ingress
		return ret
	}).(ChallengeSpecSolverHttp01IngressOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Class
	}).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.IngressClassName
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v == nil {
			return nil
		}
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplate struct {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata `pulumi:"metadata"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs and ChallengeSpecSolverHttp01IngressIngressTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplateArgs struct {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput `pulumi:"metadata"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput).ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs, ChallengeSpecSolverHttp01IngressIngressTemplatePtr and ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplatePtrType ChallengeSpecSolverHttp01IngressIngressTemplateArgs

func ChallengeSpecSolverHttp01IngressIngressTemplatePtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplate
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadata struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotations struct {
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabels struct {
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplate struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01IngressPodTemplateMetadata `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	Spec *ChallengeSpecSolverHttp01IngressPodTemplateSpec `pulumi:"spec"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs and ChallengeSpecSolverHttp01IngressPodTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplateArgs struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	Spec ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput `pulumi:"spec"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput).ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs, ChallengeSpecSolverHttp01IngressPodTemplatePtr and ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplatePtrType ChallengeSpecSolverHttp01IngressPodTemplateArgs

func ChallengeSpecSolverHttp01IngressPodTemplatePtr(v *ChallengeSpecSolverHttp01IngressPodTemplateArgs) ChallengeSpecSolverHttp01IngressPodTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) ChallengeSpecSolverHttp01IngressPodTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplate
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadata struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotations struct {
}

// Labels that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabels struct {
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpec struct {
	// If specified, the pod's scheduling constraints
	Affinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName *string `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations `pulumi:"tolerations"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs struct {
	// If specified, the pod's scheduling constraints
	Affinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector pulumi.StringMapInput `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName pulumi.StringPtrInput `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput `pulumi:"tolerations"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string { return v.NodeSelector }).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.PriorityClassName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpec
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		if v == nil {
			return nil
		}
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.PriorityClassName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		if v == nil {
			return nil
		}
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity `pulumi:"podAntiAffinity"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput `pulumi:"podAntiAffinity"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A node selector term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Preference() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return v.Preference
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms `pulumi:"nodeSelectorTerms"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput `pulumi:"nodeSelectorTerms"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchLabels struct {
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchLabels struct {
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchLabels struct {
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchLabels struct {
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
	Name *string `pulumi:"name"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets
func (val *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets) Defaults() *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Name == nil {
		name_ := ""
		tmp.Name = &name_
	}
	return &tmp
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs
func (val *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) Defaults() *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Name == nil {
		tmp.Name = pulumi.StringPtr("")
	}
	return &tmp
}
func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return o
}

// Name of the referent.
// This field is effectively required, but due to backwards compatibility is
// allowed to be empty. Instances of this type with an empty value here are
// almost certainly wrong.
// TODO: Add other useful fields. apiVersion, kind, uid?
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
type ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelector struct {
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects.
// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys.
// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value.
// Valid operators are Exists and Equal. Defaults to Equal.
// Exists is equivalent to wildcard for value, so that a pod can
// tolerate all taints of a particular category.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be
// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
// it is not set, which means tolerate the taint forever (do not evict). Zero and
// negative values will be treated as 0 (evict immediately) by the system.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *int { return v.TolerationSeconds }).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to.
// If the operator is Exists, the value should be empty, otherwise just a regular string.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelector struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames []string `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones []string `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverSelectorInput is an input type that accepts ChallengeSpecSolverSelectorArgs and ChallengeSpecSolverSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorInput` via:
//
//	ChallengeSpecSolverSelectorArgs{...}
type ChallengeSpecSolverSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput
	ToChallengeSpecSolverSelectorOutputWithContext(context.Context) ChallengeSpecSolverSelectorOutput
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorArgs struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones pulumi.StringArrayInput `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return i.ToChallengeSpecSolverSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput)
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput).ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverSelectorPtrInput is an input type that accepts ChallengeSpecSolverSelectorArgs, ChallengeSpecSolverSelectorPtr and ChallengeSpecSolverSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorPtrInput` via:
//
//	        ChallengeSpecSolverSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput
	ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverSelectorPtrOutput
}

type challengeSpecSolverSelectorPtrType ChallengeSpecSolverSelectorArgs

func ChallengeSpecSolverSelectorPtr(v *ChallengeSpecSolverSelectorArgs) ChallengeSpecSolverSelectorPtrInput {
	return (*challengeSpecSolverSelectorPtrType)(v)
}

func (*challengeSpecSolverSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverSelector) *ChallengeSpecSolverSelector {
		return &v
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsZones }).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) Elem() ChallengeSpecSolverSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) ChallengeSpecSolverSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverSelector
		return ret
	}).(ChallengeSpecSolverSelectorOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsZones
	}).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
type ChallengeSpecSolverSelectorMatchLabels struct {
}

type ChallengeStatus struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented *bool `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing *bool `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason *string `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State *string `pulumi:"state"`
}

// ChallengeStatusInput is an input type that accepts ChallengeStatusArgs and ChallengeStatusOutput values.
// You can construct a concrete instance of `ChallengeStatusInput` via:
//
//	ChallengeStatusArgs{...}
type ChallengeStatusInput interface {
	pulumi.Input

	ToChallengeStatusOutput() ChallengeStatusOutput
	ToChallengeStatusOutputWithContext(context.Context) ChallengeStatusOutput
}

type ChallengeStatusArgs struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented pulumi.BoolPtrInput `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing pulumi.BoolPtrInput `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (ChallengeStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (i ChallengeStatusArgs) ToChallengeStatusOutput() ChallengeStatusOutput {
	return i.ToChallengeStatusOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput)
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput).ToChallengeStatusPtrOutputWithContext(ctx)
}

// ChallengeStatusPtrInput is an input type that accepts ChallengeStatusArgs, ChallengeStatusPtr and ChallengeStatusPtrOutput values.
// You can construct a concrete instance of `ChallengeStatusPtrInput` via:
//
//	        ChallengeStatusArgs{...}
//
//	or:
//
//	        nil
type ChallengeStatusPtrInput interface {
	pulumi.Input

	ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput
	ToChallengeStatusPtrOutputWithContext(context.Context) ChallengeStatusPtrOutput
}

type challengeStatusPtrType ChallengeStatusArgs

func ChallengeStatusPtr(v *ChallengeStatusArgs) ChallengeStatusPtrInput {
	return (*challengeStatusPtrType)(v)
}

func (*challengeStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPtrOutput)
}

type ChallengeStatusOutput struct{ *pulumi.OutputState }

func (ChallengeStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusOutput) ToChallengeStatusOutput() ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeStatus) *ChallengeStatus {
		return &v
	}).(ChallengeStatusPtrOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Presented }).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Processing }).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

type ChallengeStatusPtrOutput struct{ *pulumi.OutputState }

func (ChallengeStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) Elem() ChallengeStatusOutput {
	return o.ApplyT(func(v *ChallengeStatus) ChallengeStatus {
		if v != nil {
			return *v
		}
		var ret ChallengeStatus
		return ret
	}).(ChallengeStatusOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusPtrOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Presented
	}).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusPtrOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Processing
	}).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderType struct {
	ApiVersion *string           `pulumi:"apiVersion"`
	Kind       *string           `pulumi:"kind"`
	Metadata   metav1.ObjectMeta `pulumi:"metadata"`
	Spec       OrderSpec         `pulumi:"spec"`
	Status     *OrderStatus      `pulumi:"status"`
}

type OrderMetadata struct {
}

type OrderSpec struct {
	// CommonName is the common name as specified on the DER encoded CSR.
	// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
	// This field must match the corresponding field on the DER encoded CSR.
	CommonName *string `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	DnsNames []string `pulumi:"dnsNames"`
	// Duration is the duration for the not after date for the requested certificate.
	// this is set on order creation as pe the ACME spec.
	Duration *string `pulumi:"duration"`
	// IPAddresses is a list of IP addresses that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	IpAddresses []string `pulumi:"ipAddresses"`
	// IssuerRef references a properly configured ACME-type Issuer which should
	// be used to create this Order.
	// If the Issuer does not exist, processing will be retried.
	// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
	// Order will be marked as failed.
	IssuerRef OrderSpecIssuerRef `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding.
	// This will be used when finalizing the order.
	// This field must be set on the order.
	Request string `pulumi:"request"`
}

// OrderSpecInput is an input type that accepts OrderSpecArgs and OrderSpecOutput values.
// You can construct a concrete instance of `OrderSpecInput` via:
//
//	OrderSpecArgs{...}
type OrderSpecInput interface {
	pulumi.Input

	ToOrderSpecOutput() OrderSpecOutput
	ToOrderSpecOutputWithContext(context.Context) OrderSpecOutput
}

type OrderSpecArgs struct {
	// CommonName is the common name as specified on the DER encoded CSR.
	// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
	// This field must match the corresponding field on the DER encoded CSR.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// Duration is the duration for the not after date for the requested certificate.
	// this is set on order creation as pe the ACME spec.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// IPAddresses is a list of IP addresses that should be included as part of the Order
	// validation process.
	// This field must match the corresponding field on the DER encoded CSR.
	IpAddresses pulumi.StringArrayInput `pulumi:"ipAddresses"`
	// IssuerRef references a properly configured ACME-type Issuer which should
	// be used to create this Order.
	// If the Issuer does not exist, processing will be retried.
	// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
	// Order will be marked as failed.
	IssuerRef OrderSpecIssuerRefInput `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding.
	// This will be used when finalizing the order.
	// This field must be set on the order.
	Request pulumi.StringInput `pulumi:"request"`
}

func (OrderSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpec)(nil)).Elem()
}

func (i OrderSpecArgs) ToOrderSpecOutput() OrderSpecOutput {
	return i.ToOrderSpecOutputWithContext(context.Background())
}

func (i OrderSpecArgs) ToOrderSpecOutputWithContext(ctx context.Context) OrderSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecOutput)
}

func (i OrderSpecArgs) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return i.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (i OrderSpecArgs) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecOutput).ToOrderSpecPtrOutputWithContext(ctx)
}

// OrderSpecPtrInput is an input type that accepts OrderSpecArgs, OrderSpecPtr and OrderSpecPtrOutput values.
// You can construct a concrete instance of `OrderSpecPtrInput` via:
//
//	        OrderSpecArgs{...}
//
//	or:
//
//	        nil
type OrderSpecPtrInput interface {
	pulumi.Input

	ToOrderSpecPtrOutput() OrderSpecPtrOutput
	ToOrderSpecPtrOutputWithContext(context.Context) OrderSpecPtrOutput
}

type orderSpecPtrType OrderSpecArgs

func OrderSpecPtr(v *OrderSpecArgs) OrderSpecPtrInput {
	return (*orderSpecPtrType)(v)
}

func (*orderSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpec)(nil)).Elem()
}

func (i *orderSpecPtrType) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return i.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (i *orderSpecPtrType) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecPtrOutput)
}

type OrderSpecOutput struct{ *pulumi.OutputState }

func (OrderSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpec)(nil)).Elem()
}

func (o OrderSpecOutput) ToOrderSpecOutput() OrderSpecOutput {
	return o
}

func (o OrderSpecOutput) ToOrderSpecOutputWithContext(ctx context.Context) OrderSpecOutput {
	return o
}

func (o OrderSpecOutput) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return o.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (o OrderSpecOutput) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderSpec) *OrderSpec {
		return &v
	}).(OrderSpecPtrOutput)
}

// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpec) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpec) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
func (o OrderSpecOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpec) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) IpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpec) []string { return v.IpAddresses }).(pulumi.StringArrayOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
func (o OrderSpecOutput) IssuerRef() OrderSpecIssuerRefOutput {
	return o.ApplyT(func(v OrderSpec) OrderSpecIssuerRef { return v.IssuerRef }).(OrderSpecIssuerRefOutput)
}

// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
func (o OrderSpecOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v OrderSpec) string { return v.Request }).(pulumi.StringOutput)
}

type OrderSpecPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpec)(nil)).Elem()
}

func (o OrderSpecPtrOutput) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return o
}

func (o OrderSpecPtrOutput) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return o
}

func (o OrderSpecPtrOutput) Elem() OrderSpecOutput {
	return o.ApplyT(func(v *OrderSpec) OrderSpec {
		if v != nil {
			return *v
		}
		var ret OrderSpec
		return ret
	}).(OrderSpecOutput)
}

// CommonName is the common name as specified on the DER encoded CSR.
// If specified, this value must also be present in `dnsNames` or `ipAddresses`.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return v.CommonName
	}).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpec) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// Duration is the duration for the not after date for the requested certificate.
// this is set on order creation as pe the ACME spec.
func (o OrderSpecPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// IPAddresses is a list of IP addresses that should be included as part of the Order
// validation process.
// This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) IpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpAddresses
	}).(pulumi.StringArrayOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
func (o OrderSpecPtrOutput) IssuerRef() OrderSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *OrderSpecIssuerRef {
		if v == nil {
			return nil
		}
		return &v.IssuerRef
	}).(OrderSpecIssuerRefPtrOutput)
}

// Certificate signing request bytes in DER encoding.
// This will be used when finalizing the order.
// This field must be set on the order.
func (o OrderSpecPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Request
	}).(pulumi.StringPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name string `pulumi:"name"`
}

// OrderSpecIssuerRefInput is an input type that accepts OrderSpecIssuerRefArgs and OrderSpecIssuerRefOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefInput` via:
//
//	OrderSpecIssuerRefArgs{...}
type OrderSpecIssuerRefInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput
	ToOrderSpecIssuerRefOutputWithContext(context.Context) OrderSpecIssuerRefOutput
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringInput `pulumi:"name"`
}

func (OrderSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRef)(nil)).Elem()
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput {
	return i.ToOrderSpecIssuerRefOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefOutputWithContext(ctx context.Context) OrderSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefOutput)
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return i.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefOutput).ToOrderSpecIssuerRefPtrOutputWithContext(ctx)
}

// OrderSpecIssuerRefPtrInput is an input type that accepts OrderSpecIssuerRefArgs, OrderSpecIssuerRefPtr and OrderSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefPtrInput` via:
//
//	        OrderSpecIssuerRefArgs{...}
//
//	or:
//
//	        nil
type OrderSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput
	ToOrderSpecIssuerRefPtrOutputWithContext(context.Context) OrderSpecIssuerRefPtrOutput
}

type orderSpecIssuerRefPtrType OrderSpecIssuerRefArgs

func OrderSpecIssuerRefPtr(v *OrderSpecIssuerRefArgs) OrderSpecIssuerRefPtrInput {
	return (*orderSpecIssuerRefPtrType)(v)
}

func (*orderSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRef)(nil)).Elem()
}

func (i *orderSpecIssuerRefPtrType) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return i.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *orderSpecIssuerRefPtrType) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should
// be used to create this Order.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Order will be marked as failed.
type OrderSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRef)(nil)).Elem()
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput {
	return o
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefOutputWithContext(ctx context.Context) OrderSpecIssuerRefOutput {
	return o
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return o.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderSpecIssuerRef) *OrderSpecIssuerRef {
		return &v
	}).(OrderSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) string { return v.Name }).(pulumi.StringOutput)
}

type OrderSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRef)(nil)).Elem()
}

func (o OrderSpecIssuerRefPtrOutput) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPtrOutput) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPtrOutput) Elem() OrderSpecIssuerRefOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) OrderSpecIssuerRef {
		if v != nil {
			return *v
		}
		var ret OrderSpecIssuerRef
		return ret
	}).(OrderSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type OrderStatus struct {
	// Authorizations contains data returned from the ACME server on what
	// authorizations must be completed in order to validate the DNS names
	// specified on the Order.
	Authorizations []OrderStatusAuthorizations `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order.
	// This field will be populated after the order has been successfully
	// finalized with the ACME server, and the order has transitioned to the
	// 'valid' state.
	Certificate *string `pulumi:"certificate"`
	// FailureTime stores the time that this order failed.
	// This is used to influence garbage collection and back-off.
	FailureTime *string `pulumi:"failureTime"`
	// FinalizeURL of the Order.
	// This is used to obtain certificates for this order once it has been completed.
	FinalizeURL *string `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in
	// the current state.
	Reason *string `pulumi:"reason"`
	// State contains the current state of this Order resource.
	// States 'success' and 'expired' are 'final'
	State *string `pulumi:"state"`
	// URL of the Order.
	// This will initially be empty when the resource is first created.
	// The Order controller will populate this field when the Order is first processed.
	// This field will be immutable after it is initially set.
	Url *string `pulumi:"url"`
}

// OrderStatusInput is an input type that accepts OrderStatusArgs and OrderStatusOutput values.
// You can construct a concrete instance of `OrderStatusInput` via:
//
//	OrderStatusArgs{...}
type OrderStatusInput interface {
	pulumi.Input

	ToOrderStatusOutput() OrderStatusOutput
	ToOrderStatusOutputWithContext(context.Context) OrderStatusOutput
}

type OrderStatusArgs struct {
	// Authorizations contains data returned from the ACME server on what
	// authorizations must be completed in order to validate the DNS names
	// specified on the Order.
	Authorizations OrderStatusAuthorizationsArrayInput `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order.
	// This field will be populated after the order has been successfully
	// finalized with the ACME server, and the order has transitioned to the
	// 'valid' state.
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// FailureTime stores the time that this order failed.
	// This is used to influence garbage collection and back-off.
	FailureTime pulumi.StringPtrInput `pulumi:"failureTime"`
	// FinalizeURL of the Order.
	// This is used to obtain certificates for this order once it has been completed.
	FinalizeURL pulumi.StringPtrInput `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in
	// the current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// State contains the current state of this Order resource.
	// States 'success' and 'expired' are 'final'
	State pulumi.StringPtrInput `pulumi:"state"`
	// URL of the Order.
	// This will initially be empty when the resource is first created.
	// The Order controller will populate this field when the Order is first processed.
	// This field will be immutable after it is initially set.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (OrderStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatus)(nil)).Elem()
}

func (i OrderStatusArgs) ToOrderStatusOutput() OrderStatusOutput {
	return i.ToOrderStatusOutputWithContext(context.Background())
}

func (i OrderStatusArgs) ToOrderStatusOutputWithContext(ctx context.Context) OrderStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusOutput)
}

func (i OrderStatusArgs) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return i.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (i OrderStatusArgs) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusOutput).ToOrderStatusPtrOutputWithContext(ctx)
}

// OrderStatusPtrInput is an input type that accepts OrderStatusArgs, OrderStatusPtr and OrderStatusPtrOutput values.
// You can construct a concrete instance of `OrderStatusPtrInput` via:
//
//	        OrderStatusArgs{...}
//
//	or:
//
//	        nil
type OrderStatusPtrInput interface {
	pulumi.Input

	ToOrderStatusPtrOutput() OrderStatusPtrOutput
	ToOrderStatusPtrOutputWithContext(context.Context) OrderStatusPtrOutput
}

type orderStatusPtrType OrderStatusArgs

func OrderStatusPtr(v *OrderStatusArgs) OrderStatusPtrInput {
	return (*orderStatusPtrType)(v)
}

func (*orderStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatus)(nil)).Elem()
}

func (i *orderStatusPtrType) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return i.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (i *orderStatusPtrType) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusPtrOutput)
}

type OrderStatusOutput struct{ *pulumi.OutputState }

func (OrderStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatus)(nil)).Elem()
}

func (o OrderStatusOutput) ToOrderStatusOutput() OrderStatusOutput {
	return o
}

func (o OrderStatusOutput) ToOrderStatusOutputWithContext(ctx context.Context) OrderStatusOutput {
	return o
}

func (o OrderStatusOutput) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return o.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (o OrderStatusOutput) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OrderStatus) *OrderStatus {
		return &v
	}).(OrderStatusPtrOutput)
}

// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
func (o OrderStatusOutput) Authorizations() OrderStatusAuthorizationsArrayOutput {
	return o.ApplyT(func(v OrderStatus) []OrderStatusAuthorizations { return v.Authorizations }).(OrderStatusAuthorizationsArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
func (o OrderStatusOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
func (o OrderStatusOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.FailureTime }).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.FinalizeURL }).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in
// the current state.
func (o OrderStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
func (o OrderStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
func (o OrderStatusOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type OrderStatusPtrOutput struct{ *pulumi.OutputState }

func (OrderStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatus)(nil)).Elem()
}

func (o OrderStatusPtrOutput) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return o
}

func (o OrderStatusPtrOutput) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return o
}

func (o OrderStatusPtrOutput) Elem() OrderStatusOutput {
	return o.ApplyT(func(v *OrderStatus) OrderStatus {
		if v != nil {
			return *v
		}
		var ret OrderStatus
		return ret
	}).(OrderStatusOutput)
}

// Authorizations contains data returned from the ACME server on what
// authorizations must be completed in order to validate the DNS names
// specified on the Order.
func (o OrderStatusPtrOutput) Authorizations() OrderStatusAuthorizationsArrayOutput {
	return o.ApplyT(func(v *OrderStatus) []OrderStatusAuthorizations {
		if v == nil {
			return nil
		}
		return v.Authorizations
	}).(OrderStatusAuthorizationsArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order.
// This field will be populated after the order has been successfully
// finalized with the ACME server, and the order has transitioned to the
// 'valid' state.
func (o OrderStatusPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed.
// This is used to influence garbage collection and back-off.
func (o OrderStatusPtrOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.FailureTime
	}).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order.
// This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusPtrOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.FinalizeURL
	}).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in
// the current state.
func (o OrderStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource.
// States 'success' and 'expired' are 'final'
func (o OrderStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// URL of the Order.
// This will initially be empty when the resource is first created.
// The Order controller will populate this field when the Order is first processed.
// This field will be immutable after it is initially set.
func (o OrderStatusPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizations struct {
	// Challenges specifies the challenge types offered by the ACME server.
	// One of these challenge types will be selected when validating the DNS
	// name and an appropriate Challenge resource will be created to perform
	// the ACME challenge process.
	Challenges []OrderStatusAuthorizationsChallenges `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier *string `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first
	// fetched from the ACME server.
	// If an Authorization is already 'valid', the Order controller will not
	// create a Challenge resource for the authorization. This will occur when
	// working with an ACME server that enables 'authz reuse' (such as Let's
	// Encrypt's production endpoint).
	// If not set and 'identifier' is set, the state is assumed to be pending
	// and a Challenge will be created.
	InitialState *string `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url string `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name.
	// If this is true, the identifier will be the *non-wildcard* version of
	// the DNS name.
	// For example, if '*.example.com' is the DNS name being validated, this
	// field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// OrderStatusAuthorizationsInput is an input type that accepts OrderStatusAuthorizationsArgs and OrderStatusAuthorizationsOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsInput` via:
//
//	OrderStatusAuthorizationsArgs{...}
type OrderStatusAuthorizationsInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput
	ToOrderStatusAuthorizationsOutputWithContext(context.Context) OrderStatusAuthorizationsOutput
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsArgs struct {
	// Challenges specifies the challenge types offered by the ACME server.
	// One of these challenge types will be selected when validating the DNS
	// name and an appropriate Challenge resource will be created to perform
	// the ACME challenge process.
	Challenges OrderStatusAuthorizationsChallengesArrayInput `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first
	// fetched from the ACME server.
	// If an Authorization is already 'valid', the Order controller will not
	// create a Challenge resource for the authorization. This will occur when
	// working with an ACME server that enables 'authz reuse' (such as Let's
	// Encrypt's production endpoint).
	// If not set and 'identifier' is set, the state is assumed to be pending
	// and a Challenge will be created.
	InitialState pulumi.StringPtrInput `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url pulumi.StringInput `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name.
	// If this is true, the identifier will be the *non-wildcard* version of
	// the DNS name.
	// For example, if '*.example.com' is the DNS name being validated, this
	// field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (OrderStatusAuthorizationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizations)(nil)).Elem()
}

func (i OrderStatusAuthorizationsArgs) ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput {
	return i.ToOrderStatusAuthorizationsOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsArgs) ToOrderStatusAuthorizationsOutputWithContext(ctx context.Context) OrderStatusAuthorizationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsOutput)
}

// OrderStatusAuthorizationsArrayInput is an input type that accepts OrderStatusAuthorizationsArray and OrderStatusAuthorizationsArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsArrayInput` via:
//
//	OrderStatusAuthorizationsArray{ OrderStatusAuthorizationsArgs{...} }
type OrderStatusAuthorizationsArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput
	ToOrderStatusAuthorizationsArrayOutputWithContext(context.Context) OrderStatusAuthorizationsArrayOutput
}

type OrderStatusAuthorizationsArray []OrderStatusAuthorizationsInput

func (OrderStatusAuthorizationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizations)(nil)).Elem()
}

func (i OrderStatusAuthorizationsArray) ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput {
	return i.ToOrderStatusAuthorizationsArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsArray) ToOrderStatusAuthorizationsArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsArrayOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an
// authorization that must be completed in order validate a DNS name on an ACME
// Order resource.
type OrderStatusAuthorizationsOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizations)(nil)).Elem()
}

func (o OrderStatusAuthorizationsOutput) ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput {
	return o
}

func (o OrderStatusAuthorizationsOutput) ToOrderStatusAuthorizationsOutputWithContext(ctx context.Context) OrderStatusAuthorizationsOutput {
	return o
}

// Challenges specifies the challenge types offered by the ACME server.
// One of these challenge types will be selected when validating the DNS
// name and an appropriate Challenge resource will be created to perform
// the ACME challenge process.
func (o OrderStatusAuthorizationsOutput) Challenges() OrderStatusAuthorizationsChallengesArrayOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) []OrderStatusAuthorizationsChallenges { return v.Challenges }).(OrderStatusAuthorizationsChallengesArrayOutput)
}

// Identifier is the DNS name to be validated as part of this authorization
func (o OrderStatusAuthorizationsOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

// InitialState is the initial state of the ACME authorization when first
// fetched from the ACME server.
// If an Authorization is already 'valid', the Order controller will not
// create a Challenge resource for the authorization. This will occur when
// working with an ACME server that enables 'authz reuse' (such as Let's
// Encrypt's production endpoint).
// If not set and 'identifier' is set, the state is assumed to be pending
// and a Challenge will be created.
func (o OrderStatusAuthorizationsOutput) InitialState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.InitialState }).(pulumi.StringPtrOutput)
}

// URL is the URL of the Authorization that must be completed
func (o OrderStatusAuthorizationsOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) string { return v.Url }).(pulumi.StringOutput)
}

// Wildcard will be true if this authorization is for a wildcard DNS name.
// If this is true, the identifier will be the *non-wildcard* version of
// the DNS name.
// For example, if '*.example.com' is the DNS name being validated, this
// field will be 'true' and the 'identifier' field will be 'example.com'.
func (o OrderStatusAuthorizationsOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type OrderStatusAuthorizationsArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizations)(nil)).Elem()
}

func (o OrderStatusAuthorizationsArrayOutput) ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsArrayOutput) ToOrderStatusAuthorizationsArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizations {
		return vs[0].([]OrderStatusAuthorizations)[vs[1].(int)]
	}).(OrderStatusAuthorizationsOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallenges struct {
	// Token is the token that must be presented for this challenge.
	// This is used to compute the 'key' that must also be presented.
	Token string `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
	// 'tls-sni-01', etc.
	// This is the raw value retrieved from the ACME server.
	// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
	// will be ignored.
	Type string `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional
	// metadata about the Challenge from the ACME server.
	Url string `pulumi:"url"`
}

// OrderStatusAuthorizationsChallengesInput is an input type that accepts OrderStatusAuthorizationsChallengesArgs and OrderStatusAuthorizationsChallengesOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesInput` via:
//
//	OrderStatusAuthorizationsChallengesArgs{...}
type OrderStatusAuthorizationsChallengesInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput
	ToOrderStatusAuthorizationsChallengesOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesOutput
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesArgs struct {
	// Token is the token that must be presented for this challenge.
	// This is used to compute the 'key' that must also be presented.
	Token pulumi.StringInput `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
	// 'tls-sni-01', etc.
	// This is the raw value retrieved from the ACME server.
	// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
	// will be ignored.
	Type pulumi.StringInput `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional
	// metadata about the Challenge from the ACME server.
	Url pulumi.StringInput `pulumi:"url"`
}

func (OrderStatusAuthorizationsChallengesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesArgs) ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput {
	return i.ToOrderStatusAuthorizationsChallengesOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesArgs) ToOrderStatusAuthorizationsChallengesOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesOutput)
}

// OrderStatusAuthorizationsChallengesArrayInput is an input type that accepts OrderStatusAuthorizationsChallengesArray and OrderStatusAuthorizationsChallengesArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesArrayInput` via:
//
//	OrderStatusAuthorizationsChallengesArray{ OrderStatusAuthorizationsChallengesArgs{...} }
type OrderStatusAuthorizationsChallengesArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput
	ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesArrayOutput
}

type OrderStatusAuthorizationsChallengesArray []OrderStatusAuthorizationsChallengesInput

func (OrderStatusAuthorizationsChallengesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesArray) ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput {
	return i.ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesArray) ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesArrayOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order.
// An appropriate Challenge resource can be created to perform the ACME
// challenge process.
type OrderStatusAuthorizationsChallengesOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesOutput) ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesOutput) ToOrderStatusAuthorizationsChallengesOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesOutput {
	return o
}

// Token is the token that must be presented for this challenge.
// This is used to compute the 'key' that must also be presented.
func (o OrderStatusAuthorizationsChallengesOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) string { return v.Token }).(pulumi.StringOutput)
}

// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01',
// 'tls-sni-01', etc.
// This is the raw value retrieved from the ACME server.
// Only 'http-01' and 'dns-01' are supported by cert-manager, other values
// will be ignored.
func (o OrderStatusAuthorizationsChallengesOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) string { return v.Type }).(pulumi.StringOutput)
}

// URL is the URL of this challenge. It can be used to retrieve additional
// metadata about the Challenge from the ACME server.
func (o OrderStatusAuthorizationsChallengesOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) string { return v.Url }).(pulumi.StringOutput)
}

type OrderStatusAuthorizationsChallengesArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsChallengesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizationsChallenges {
		return vs[0].([]OrderStatusAuthorizationsChallenges)[vs[1].(int)]
	}).(OrderStatusAuthorizationsChallengesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecInput)(nil)).Elem(), ChallengeSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecPtrInput)(nil)).Elem(), ChallengeSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefInput)(nil)).Elem(), ChallengeSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefPtrInput)(nil)).Elem(), ChallengeSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverInput)(nil)).Elem(), ChallengeSpecSolverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverPtrInput)(nil)).Elem(), ChallengeSpecSolverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Input)(nil)).Elem(), ChallengeSpecSolverDns01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentityInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136Input)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53Input)(nil)).Elem(), ChallengeSpecSolverDns01Route53Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01Input)(nil)).Elem(), ChallengeSpecSolverHttp01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01PtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorInput)(nil)).Elem(), ChallengeSpecSolverSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusInput)(nil)).Elem(), ChallengeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusPtrInput)(nil)).Elem(), ChallengeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecInput)(nil)).Elem(), OrderSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecPtrInput)(nil)).Elem(), OrderSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecIssuerRefInput)(nil)).Elem(), OrderSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderSpecIssuerRefPtrInput)(nil)).Elem(), OrderSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusInput)(nil)).Elem(), OrderStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusPtrInput)(nil)).Elem(), OrderStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsInput)(nil)).Elem(), OrderStatusAuthorizationsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsArrayInput)(nil)).Elem(), OrderStatusAuthorizationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsChallengesInput)(nil)).Elem(), OrderStatusAuthorizationsChallengesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OrderStatusAuthorizationsChallengesArrayInput)(nil)).Elem(), OrderStatusAuthorizationsChallengesArray{})
	pulumi.RegisterOutputType(ChallengeSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflarePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttprouteOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeStatusOutput{})
	pulumi.RegisterOutputType(ChallengeStatusPtrOutput{})
	pulumi.RegisterOutputType(OrderSpecOutput{})
	pulumi.RegisterOutputType(OrderSpecPtrOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(OrderStatusOutput{})
	pulumi.RegisterOutputType(OrderStatusPtrOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsArrayOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesArrayOutput{})
}
